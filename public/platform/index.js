(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var Backbone = require('backbone'),
		_ = require('underscore'),
    jquery = require('jquery'),
    router = require('./router.js');

Backbone.$ = window.$ = jquery;

var AppStart = function() {
  Backbone.AppRouter = new router();
  Backbone.history.start({ pushState: true, root: '/' });
}

Backbone.middle = _.extend({
	goTo: function(url) {
  	Backbone.AppRouter.navigate(url, {trigger: true});
	},
	goToPrev: function() {
		Backbone.AppRouter.previous();
	},
	goToExt: function(url) {
		window.location = url;
	}
}, Backbone.Events);

Backbone.middle.on({
	"goTo": Backbone.middle.goTo,
	"goToPrevious": Backbone.middle.goToPrev,
	"goToExt": Backbone.middle.goToExt
});

AppStart();
},{"./router.js":31,"backbone":19,"jquery":25,"underscore":30}],2:[function(require,module,exports){
/**
 * Bootstrap Modal wrapper for use with Backbone.
 *
 * Takes care of instantiation, manages multiple modals,
 * adds several options and removes the element from the DOM when closed
 *
 * @author Charles Davison <charlie@powmedia.co.uk>
 *
 * Events:
 * shown: Fired when the modal has finished animating in
 * hidden: Fired when the modal has finished animating out
 * cancel: The user dismissed the modal
 * ok: The user clicked OK
 */

var Backbone = require('backbone'),
    _ = require('underscore'),
    $ = require('jquery');

(function($, _, Backbone) {

  //Set custom template settings
  var _interpolateBackup = _.templateSettings;
  _.templateSettings = {
    interpolate: /\{\{(.+?)\}\}/g,
    evaluate: /<%([\s\S]+?)%>/g
  };

  var template = _.template('\
    <div class="modal-dialog"><div class="modal-content">\
    <% if (title) { %>\
      <div class="modal-header">\
        <% if (allowCancel) { %>\
          <a class="close">&times;</a>\
        <% } %>\
        <h4>{{title}}</h4>\
      </div>\
    <% } %>\
    <div class="modal-body">{{content}}</div>\
    <% if (showFooter) { %>\
      <div class="modal-footer">\
        <% if (allowCancel) { %>\
          <% if (cancelText) { %>\
            <a href="#" class="btn cancel">{{cancelText}}</a>\
          <% } %>\
        <% } %>\
        <a href="#" class="btn ok btn-primary">{{okText}}</a>\
      </div>\
    <% } %>\
    </div></div>\
  ');

  //Reset to users' template settings
  _.templateSettings = _interpolateBackup;


  var Modal = Backbone.View.extend({

    className: 'modal',

    events: {
      'click .close': function(event) {
        event.preventDefault();

        this.trigger('cancel');

        if (this.options.content && this.options.content.trigger) {
          this.options.content.trigger('cancel', this);
        }
      },
      'click .cancel': function(event) {
        event.preventDefault();

        this.trigger('cancel');

        if (this.options.content && this.options.content.trigger) {
          this.options.content.trigger('cancel', this);
        }
      },
      'click .ok': function(event) {
        event.preventDefault();

        this.trigger('ok');

        if (this.options.content && this.options.content.trigger) {
          this.options.content.trigger('ok', this);
        }

        if (this.options.okCloses) {
          this.close();
        }
      },
      'keypress': function(event) {
        if (this.options.enterTriggersOk && event.which == 13) {
          event.preventDefault();

          this.trigger('ok');

          if (this.options.content && this.options.content.trigger) {
            this.options.content.trigger('ok', this);
          }

          if (this.options.okCloses) {
            this.close();
          }
        }
      }
    },

    /**
     * Creates an instance of a Bootstrap Modal
     *
     * @see http://twitter.github.com/bootstrap/javascript.html#modals
     *
     * @param {Object} options
     * @param {String|View} [options.content]     Modal content. Default: none
     * @param {String} [options.title]            Title. Default: none
     * @param {String} [options.okText]           Text for the OK button. Default: 'OK'
     * @param {String} [options.cancelText]       Text for the cancel button. Default: 'Cancel'. If passed a falsey value, the button will be removed
     * @param {Boolean} [options.allowCancel      Whether the modal can be closed, other than by pressing OK. Default: true
     * @param {Boolean} [options.escape]          Whether the 'esc' key can dismiss the modal. Default: true, but false if options.cancellable is true
     * @param {Boolean} [options.animate]         Whether to animate in/out. Default: false
     * @param {Function} [options.template]       Compiled underscore template to override the default one
     * @param {Boolean} [options.enterTriggersOk] Whether the 'enter' key will trigger OK. Default: false
     */
    initialize: function(options) {
      this.options = _.extend({
        title: null,
        okText: 'OK',
        focusOk: true,
        okCloses: true,
        cancelText: 'Cancel',
        showFooter: true,
        allowCancel: true,
        escape: true,
        animate: false,
        template: template,
        enterTriggersOk: false
      }, options);
    },

    /**
     * Creates the DOM element
     *
     * @api private
     */
    render: function() {
      var $el = this.$el,
          options = this.options,
          content = options.content;

      //Create the modal container
      $el.html(options.template(options));

      var $content = this.$content = $el.find('.modal-body')

      //Insert the main content if it's a view
      if (content && content.$el) {
        content.render();
        $el.find('.modal-body').html(content.$el);
      }

      if (options.animate) $el.addClass('fade');

      this.isRendered = true;

      return this;
    },

    /**
     * Renders and shows the modal
     *
     * @param {Function} [cb]     Optional callback that runs only when OK is pressed.
     */
    open: function(cb) {
      if (!this.isRendered) this.render();

      var self = this,
          $el = this.$el;

      //Create it
      $el.modal(_.extend({
        keyboard: this.options.allowCancel,
        backdrop: this.options.allowCancel ? true : 'static'
      }, this.options.modalOptions));

      //Focus OK button
      $el.one('shown.bs.modal', function() {
        if (self.options.focusOk) {
          $el.find('.btn.ok').focus();
        }

        if (self.options.content && self.options.content.trigger) {
          self.options.content.trigger('shown', self);
        }

        self.trigger('shown');
      });

      //Adjust the modal and backdrop z-index; for dealing with multiple modals
      var numModals = Modal.count,
          $backdrop = $('.modal-backdrop:eq('+numModals+')'),
          backdropIndex = parseInt($backdrop.css('z-index'),10),
          elIndex = parseInt($backdrop.css('z-index'), 10);

      $backdrop.css('z-index', backdropIndex + numModals);
      this.$el.css('z-index', elIndex + numModals);

      if (this.options.allowCancel) {
        $backdrop.one('click', function() {
          if (self.options.content && self.options.content.trigger) {
            self.options.content.trigger('cancel', self);
          }

          self.trigger('cancel');
        });

        $(document).one('keyup.dismiss.modal', function (e) {
          e.which == 27 && self.trigger('cancel');

          if (self.options.content && self.options.content.trigger) {
            e.which == 27 && self.options.content.trigger('shown', self);
          }
        });
      }

      this.on('cancel', function() {
        self.close();
      });

      Modal.count++;

      //Run callback on OK if provided
      if (cb) {
        self.on('ok', cb);
      }

      return this;
    },

    /**
     * Closes the modal
     */
    close: function() {
      var self = this,
          $el = this.$el;

      //Check if the modal should stay open
      if (this._preventClose) {
        this._preventClose = false;
        return;
      }

      $el.one('hidden.bs.modal', function onHidden(e) {
        // Ignore events propagated from interior objects, like bootstrap tooltips
        if(e.target !== e.currentTarget){
          return $el.one('hidden', onHidden);
        }
        self.remove();

        if (self.options.content && self.options.content.trigger) {
          self.options.content.trigger('hidden', self);
        }

        self.trigger('hidden');
      });

      $el.modal('hide');

      Modal.count--;
    },

    /**
     * Stop the modal from closing.
     * Can be called from within a 'close' or 'ok' event listener.
     */
    preventClose: function() {
      this._preventClose = true;
    }
  }, {
    //STATICS

    //The number of modals on display
    count: 0
  });


  //EXPORTS
  //CommonJS
  if (typeof require == 'function' && typeof module !== 'undefined' && exports) {
    module.exports = Modal;
  }

  //AMD / RequireJS
  if (typeof define === 'function' && define.amd) {
    return define(function() {
      Backbone.BootstrapModal = Modal;
    })
  }

  //Regular; add to Backbone.Bootstrap.Modal
  else {
    Backbone.BootstrapModal = Modal;
  }

})(jQuery, _, Backbone);

},{"backbone":19,"jquery":25,"underscore":30}],3:[function(require,module,exports){
/*
  backgrid-paginator
  http://github.com/wyuenho/backgrid

  Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
  Licensed under the MIT @license.
*/
(function (root, factory) {

  // CommonJS
  if (typeof exports == "object") {
    module.exports = factory(require("underscore"),
                             require("backbone"),
                             require("backgrid"),
                             require("backbone.paginator"));
  }
  // AMD. Register as an anonymous module.
  else if (typeof define === 'function' && define.amd) {
    define(['underscore', 'backbone', 'backgrid', 'backbone.paginator'], factory);
  }
  // Browser
  else {
    factory(root._, root.Backbone, root.Backgrid);
  }

}(this, function (_, Backbone, Backgrid) {

  "use strict";

  /**
     PageHandle is a class that renders the actual page handles and reacts to
     click events for pagination.

     This class acts in two modes - control or discrete page handle modes. If
     one of the `is*` flags is `true`, an instance of this class is under
     control page handle mode. Setting a `pageIndex` to an instance of this
     class under control mode has no effect and the correct page index will
     always be inferred from the `is*` flag. Only one of the `is*` flags should
     be set to `true` at a time. For example, an instance of this class cannot
     simultaneously be a rewind control and a fast forward control. A `label`
     and a `title` function or a string are required to be passed to the
     constuctor under this mode. If a `title` function is provided, it __MUST__
     accept a hash parameter `data`, which contains a key `label`. Its result
     will be used to render the generated anchor's title attribute.

     If all of the `is*` flags is set to `false`, which is the default, an
     instance of this class will be in discrete page handle mode. An instance
     under this mode requires the `pageIndex` to be passed from the constructor
     as an option and it __MUST__ be a 0-based index of the list of page numbers
     to render. The constuctor will normalize the base to the same base the
     underlying PageableCollection collection instance uses. A `label` is not
     required under this mode, which will default to the equivalent 1-based page
     index calculated from `pageIndex` and the underlying PageableCollection
     instance. A provided `label` will still be honored however. The `title`
     parameter is also not required under this mode, in which case the default
     `title` function will be used. You are encouraged to provide your own
     `title` function however if you wish to localize the title strings.

     If this page handle represents the current page, an `active` class will be
     placed on the root list element.

     If this page handle is at the border of the list of pages, a `disabled`
     class will be placed on the root list element.

     Only page handles that are neither `active` nor `disabled` will respond to
     click events and triggers pagination.

     @class Backgrid.Extension.PageHandle
  */
  var PageHandle = Backgrid.Extension.PageHandle = Backbone.View.extend({

    /** @property */
    tagName: "li",

    /** @property */
    events: {
      "click a": "changePage"
    },

    /**
       @property {string|function(Object.<string, string>): string} title
       The title to use for the `title` attribute of the generated page handle
       anchor elements. It can be a string or a function that takes a `data`
       parameter, which contains a mandatory `label` key which provides the
       label value to be displayed.
    */
    title: function (data) {
      return 'Page ' + data.label;
    },

    /**
       @property {boolean} isRewind Whether this handle represents a rewind
       control
    */
    isRewind: false,

    /**
       @property {boolean} isBack Whether this handle represents a back
       control
    */
    isBack: false,

    /**
       @property {boolean} isForward Whether this handle represents a forward
       control
    */
    isForward: false,

    /**
       @property {boolean} isFastForward Whether this handle represents a fast
       forward control
    */
    isFastForward: false,

    /**
       Initializer.

       @param {Object} options
       @param {Backbone.Collection} options.collection
       @param {number} pageIndex 0-based index of the page number this handle
       handles. This parameter will be normalized to the base the underlying
       PageableCollection uses.
       @param {string} [options.label] If provided it is used to render the
       anchor text, otherwise the normalized pageIndex will be used
       instead. Required if any of the `is*` flags is set to `true`.
       @param {string} [options.title]
       @param {boolean} [options.isRewind=false]
       @param {boolean} [options.isBack=false]
       @param {boolean} [options.isForward=false]
       @param {boolean} [options.isFastForward=false]
    */
    initialize: function (options) {
      var collection = this.collection;
      var state = collection.state;
      var currentPage = state.currentPage;
      var firstPage = state.firstPage;
      var lastPage = state.lastPage;

      _.extend(this, _.pick(options,
                            ["isRewind", "isBack", "isForward", "isFastForward"]));

      var pageIndex;
      if (this.isRewind) pageIndex = firstPage;
      else if (this.isBack) pageIndex = Math.max(firstPage, currentPage - 1);
      else if (this.isForward) pageIndex = Math.min(lastPage, currentPage + 1);
      else if (this.isFastForward) pageIndex = lastPage;
      else {
        pageIndex = +options.pageIndex;
        pageIndex = (firstPage ? pageIndex + 1 : pageIndex);
      }
      this.pageIndex = pageIndex;

      this.label = (options.label || (firstPage ? pageIndex : pageIndex + 1)) + '';
      var title = options.title || this.title;
      this.title = _.isFunction(title) ? title({label: this.label}) : title;
    },

    /**
       Renders a clickable anchor element under a list item.
    */
    render: function () {
      this.$el.empty();
      var anchor = document.createElement("a");
      anchor.href = '#';
      if (this.title) anchor.title = this.title;
      anchor.innerHTML = this.label;
      this.el.appendChild(anchor);

      var collection = this.collection;
      var state = collection.state;
      var currentPage = state.currentPage;
      var pageIndex = this.pageIndex;

      if (this.isRewind && currentPage == state.firstPage ||
         this.isBack && !collection.hasPreviousPage() ||
         this.isForward && !collection.hasNextPage() ||
         this.isFastForward && (currentPage == state.lastPage || state.totalPages < 1)) {
        this.$el.addClass("disabled");
      }
      else if (!(this.isRewind ||
                 this.isBack ||
                 this.isForward ||
                 this.isFastForward) &&
               state.currentPage == pageIndex) {
        this.$el.addClass("active");
      }

      this.delegateEvents();
      return this;
    },

    /**
       jQuery click event handler. Goes to the page this PageHandle instance
       represents. No-op if this page handle is currently active or disabled.
    */
    changePage: function (e) {
      e.preventDefault();
      var $el = this.$el, col = this.collection;
      if (!$el.hasClass("active") && !$el.hasClass("disabled")) {
        if (this.isRewind) col.getFirstPage();
        else if (this.isBack) col.getPreviousPage();
        else if (this.isForward) col.getNextPage();
        else if (this.isFastForward) col.getLastPage();
        else col.getPage(this.pageIndex, {reset: true});
      }
      return this;
    }

  });

  /**
     Paginator is a Backgrid extension that renders a series of configurable
     pagination handles. This extension is best used for splitting a large data
     set across multiple pages. If the number of pages is larger then a
     threshold, which is set to 10 by default, the page handles are rendered
     within a sliding window, plus the rewind, back, forward and fast forward
     control handles. The individual control handles can be turned off.

     @class Backgrid.Extension.Paginator
  */
  var Paginator = Backgrid.Extension.Paginator = Backbone.View.extend({

    /** @property */
    className: "backgrid-paginator",

    /** @property */
    windowSize: 10,

    /**
       @property {number} slideScale the number used by #slideHowMuch to scale
       `windowSize` to yield the number of pages to slide. For example, the
       default windowSize(10) * slideScale(0.5) yields 5, which means the window
       will slide forward 5 pages as soon as you've reached page 6. The smaller
       the scale factor the less pages to slide, and vice versa.

       Also See:

       - #slideMaybe
       - #slideHowMuch
    */
    slideScale: 0.5,

    /**
       @property {Object.<string, Object.<string, string>>} controls You can
       disable specific control handles by setting the keys in question to
       null. The defaults will be merged with your controls object, with your
       changes taking precedent.
    */
    controls: {
      rewind: {
        label: "《",
        title: "First"
      },
      back: {
        label: "〈",
        title: "Previous"
      },
      forward: {
        label: "〉",
        title: "Next"
      },
      fastForward: {
        label: "》",
        title: "Last"
      }
    },

    /** @property */
    renderIndexedPageHandles: true,

    /**
       @property {Backgrid.Extension.PageHandle} pageHandle. The PageHandle
       class to use for rendering individual handles
    */
    pageHandle: PageHandle,

    /** @property */
    goBackFirstOnSort: true,

    /**
       Initializer.

       @param {Object} options
       @param {Backbone.Collection} options.collection
       @param {boolean} [options.controls]
       @param {boolean} [options.pageHandle=Backgrid.Extension.PageHandle]
       @param {boolean} [options.goBackFirstOnSort=true]
    */
    initialize: function (options) {
      var self = this;
      self.controls = _.defaults(options.controls || {}, self.controls,
                                 Paginator.prototype.controls);

      _.extend(self, _.pick(options || {}, "windowSize", "pageHandle",
                            "slideScale", "goBackFirstOnSort",
                            "renderIndexedPageHandles"));

      var col = self.collection;
      self.listenTo(col, "add", self.render);
      self.listenTo(col, "remove", self.render);
      self.listenTo(col, "reset", self.render);
      self.listenTo(col, "backgrid:sorted", function () {
        if (self.goBackFirstOnSort) col.getFirstPage({reset: true});
      });
    },

    /**
      Decides whether the window should slide. This method should return 1 if
      sliding should occur and 0 otherwise. The default is sliding should occur
      if half of the pages in a window has been reached.

      __Note__: All the parameters have been normalized to be 0-based.

      @param {number} firstPage
      @param {number} lastPage
      @param {number} currentPage
      @param {number} windowSize
      @param {number} slideScale

      @return {0|1}
     */
    slideMaybe: function (firstPage, lastPage, currentPage, windowSize, slideScale) {
      return Math.round(currentPage % windowSize / windowSize);
    },

    /**
      Decides how many pages to slide when sliding should occur. The default
      simply scales the `windowSize` to arrive at a fraction of the `windowSize`
      to increment.

      __Note__: All the parameters have been normalized to be 0-based.

      @param {number} firstPage
      @param {number} lastPage
      @param {number} currentPage
      @param {number} windowSize
      @param {number} slideScale

      @return {number}
     */
    slideThisMuch: function (firstPage, lastPage, currentPage, windowSize, slideScale) {
      return ~~(windowSize * slideScale);
    },

    _calculateWindow: function () {
      var collection = this.collection;
      var state = collection.state;

      // convert all indices to 0-based here
      var firstPage = state.firstPage;
      var lastPage = +state.lastPage;
      lastPage = Math.max(0, firstPage ? lastPage - 1 : lastPage);
      var currentPage = Math.max(state.currentPage, state.firstPage);
      currentPage = firstPage ? currentPage - 1 : currentPage;
      var windowSize = this.windowSize;
      var slideScale = this.slideScale;
      var windowStart = Math.floor(currentPage / windowSize) * windowSize;
      if (currentPage <= lastPage - this.slideThisMuch()) {
        windowStart += (this.slideMaybe(firstPage, lastPage, currentPage, windowSize, slideScale) *
                        this.slideThisMuch(firstPage, lastPage, currentPage, windowSize, slideScale));
      }
      var windowEnd = Math.min(lastPage + 1, windowStart + windowSize);
      return [windowStart, windowEnd];
    },

    /**
       Creates a list of page handle objects for rendering.

       @return {Array.<Object>} an array of page handle objects hashes
    */
    makeHandles: function () {

      var handles = [];
      var collection = this.collection;

      var window = this._calculateWindow();
      var winStart = window[0], winEnd = window[1];

      if (this.renderIndexedPageHandles) {
        for (var i = winStart; i < winEnd; i++) {
          handles.push(new this.pageHandle({
            collection: collection,
            pageIndex: i
          }));
        }
      }

      var controls = this.controls;
      _.each(["back", "rewind", "forward", "fastForward"], function (key) {
        var value = controls[key];
        if (value) {
          var handleCtorOpts = {
            collection: collection,
            title: value.title,
            label: value.label
          };
          handleCtorOpts["is" + key.slice(0, 1).toUpperCase() + key.slice(1)] = true;
          var handle = new this.pageHandle(handleCtorOpts);
          if (key == "rewind" || key == "back") handles.unshift(handle);
          else handles.push(handle);
        }
      }, this);

      return handles;
    },

    /**
       Render the paginator handles inside an unordered list.
    */
    render: function () {
      this.$el.empty();

      if (this.handles) {
        for (var i = 0, l = this.handles.length; i < l; i++) {
          this.handles[i].remove();
        }
      }

      var handles = this.handles = this.makeHandles();

      var ul = document.createElement("ul");
      for (var i = 0; i < handles.length; i++) {
        ul.appendChild(handles[i].render().el);
      }

      this.el.appendChild(ul);

      return this;
    }

  });

}));

},{"backbone":19,"backbone.paginator":17,"backgrid":23,"underscore":30}],4:[function(require,module,exports){
var Backbone = require('backbone'),
    _ = require('underscore');

/** 
 * Include this template file after backbone-forms.amd.js to override the default templates
 * 
 * 'data-*' attributes control where elements are placed
 */
;(function(Form) {
  
  /**
   * Bootstrap 3 templates
   */
  Form.template = _.template('\
    <form class="form-horizontal" role="form" data-fieldsets></form>\
  ');


  Form.Fieldset.template = _.template('\
    <fieldset data-fields>\
      <% if (legend) { %>\
        <legend><%= legend %></legend>\
      <% } %>\
    </fieldset>\
  ');


  Form.Field.template = _.template('\
    <div class="form-group field-<%= key %>">\
      <div class="details">\
        <label class="control-label" for="<%= editorId %>"><%= title %></label>\
        <p class="help-block"><%= help %></p>\
      </div>\
      <div class="field">\
        <span data-editor></span>\
        <p class="help-block" data-error></p>\
      </div>\
    </div>\
  ');


  Form.NestedField.template = _.template('\
    <div class="field-<%= key %> nested-item">\
      <div class="input-xlarge">\
        <% if (key == "phones"){ %>\
          <label><%= title %></label>\
        <% } %>\
        <span data-editor></span>\
        <div class="help-inline" data-error></div>\
      </div>\
      <div class="help-block"><%= help %></div>\
    </div>\
  ');

  Form.editors.Base.prototype.className = 'form-control';
  Form.editors.Object.prototype.className = '';

  Form.Field.errorClassName = 'has-error';


  if (Form.editors.List) {

    Form.editors.List.template = _.template('\
      <div class="bbf-list">\
        <ul class="unstyled clearfix" data-items></ul>\
        <button type="button" class="btn bbf-add" data-action="add">+ добавить</button>\
      </div>\
    ');


    Form.editors.List.Item.template = _.template('\
      <li class="clearfix">\
        <div class="pull-left" data-editor></div>\
        <button type="button" class="btn bbf-del" data-action="remove">&times;</button>\
      </li>\
    ');
    

    Form.editors.List.Object.template = Form.editors.List.NestedModel.template = _.template('\
      <div class="bbf-list-modal"><%= summary %></div>\
    ');

  }


})(Backbone.Form);

},{"backbone":19,"underscore":30}],5:[function(require,module,exports){
/*!
 * Bootstrap v3.3.2 (http://getbootstrap.com)
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

/*!
 * Generated using the Bootstrap Customizer (http://getbootstrap.com/customize/?id=1ef4f007c3c16131e388)
 * Config saved to config.json and https://gist.github.com/1ef4f007c3c16131e388
 */

var $ = jQuery = require('jquery');

if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery')
}
+function ($) {
  'use strict';
  var version = $.fn.jquery.split(' ')[0].split('.')
  if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1)) {
    throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher')
  }
}(jQuery);

/* ========================================================================
 * Bootstrap: modal.js v3.3.2
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options        = options
    this.$body          = $(document.body)
    this.$element       = $(element)
    this.$backdrop      =
    this.isShown        = null
    this.scrollbarWidth = 0

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.3.2'

  Modal.TRANSITION_DURATION = 300
  Modal.BACKDROP_TRANSITION_DURATION = 150

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.setScrollbar()
    this.$body.addClass('modal-open')

    this.escape()
    this.resize()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      if (that.options.backdrop) that.adjustBackdrop()
      that.adjustDialog()

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element
        .addClass('in')
        .attr('aria-hidden', false)

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$element.find('.modal-dialog') // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.escape()
    this.resize()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .attr('aria-hidden', true)
      .off('click.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(Modal.TRANSITION_DURATION) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal')
    }
  }

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this))
    } else {
      $(window).off('resize.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$body.removeClass('modal-open')
      that.resetAdjustments()
      that.resetScrollbar()
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
        .prependTo(this.$element)
        .on('click.dismiss.bs.modal', $.proxy(function (e) {
          if (e.target !== e.currentTarget) return
          this.options.backdrop == 'static'
            ? this.$element[0].focus.call(this.$element[0])
            : this.hide.call(this)
        }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  // these following methods are used to handle overflowing modals

  Modal.prototype.handleUpdate = function () {
    if (this.options.backdrop) this.adjustBackdrop()
    this.adjustDialog()
  }

  Modal.prototype.adjustBackdrop = function () {
    this.$backdrop
      .css('height', 0)
      .css('height', this.$element[0].scrollHeight)
  }

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight

    this.$element.css({
      paddingLeft:  !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    })
  }

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    })
  }

  Modal.prototype.checkScrollbar = function () {
    this.bodyIsOverflowing = document.body.scrollHeight > document.documentElement.clientHeight
    this.scrollbarWidth = this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    if (this.bodyIsOverflowing) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', '')
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

},{"jquery":25}],6:[function(require,module,exports){
/*globals jQuery, define, exports, require, window, document, postMessage */
(function (factory) {
	"use strict";
	if (typeof define === 'function' && define.amd) {
		define(['jquery'], factory);
	}
	else if(typeof exports === 'object') {
		factory(require('jquery'));
	}
	else {
		factory(jQuery);
	}
}(function ($, undefined) {
	"use strict";
/*!
 * jsTree 3.0.9
 * http://jstree.com/
 *
 * Copyright (c) 2014 Ivan Bozhanov (http://vakata.com)
 *
 * Licensed same as jquery - under the terms of the MIT License
 *   http://www.opensource.org/licenses/mit-license.php
 */
/*!
 * if using jslint please allow for the jQuery global and use following options: 
 * jslint: browser: true, ass: true, bitwise: true, continue: true, nomen: true, plusplus: true, regexp: true, unparam: true, todo: true, white: true
 */

	// prevent another load? maybe there is a better way?
	if($.jstree) {
		return;
	}

	/**
	 * ### jsTree core functionality
	 */

	// internal variables
	var instance_counter = 0,
		ccp_node = false,
		ccp_mode = false,
		ccp_inst = false,
		themes_loaded = [],
		src = $('script:last').attr('src'),
		_d = document, _node = _d.createElement('LI'), _temp1, _temp2;

	_node.setAttribute('role', 'treeitem');
	_temp1 = _d.createElement('I');
	_temp1.className = 'jstree-icon jstree-ocl';
	_temp1.setAttribute('role', 'presentation');
	_node.appendChild(_temp1);
	_temp1 = _d.createElement('A');
	_temp1.className = 'jstree-anchor';
	_temp1.setAttribute('href','#');
	_temp1.setAttribute('tabindex','-1');
	_temp2 = _d.createElement('I');
	_temp2.className = 'jstree-icon jstree-themeicon';
	_temp2.setAttribute('role', 'presentation');
	_temp1.appendChild(_temp2);
	_node.appendChild(_temp1);
	_temp1 = _temp2 = null;


	/**
	 * holds all jstree related functions and variables, including the actual class and methods to create, access and manipulate instances.
	 * @name $.jstree
	 */
	$.jstree = {
		/** 
		 * specifies the jstree version in use
		 * @name $.jstree.version
		 */
		version : '3.0.9',
		/**
		 * holds all the default options used when creating new instances
		 * @name $.jstree.defaults
		 */
		defaults : {
			/**
			 * configure which plugins will be active on an instance. Should be an array of strings, where each element is a plugin name. The default is `[]`
			 * @name $.jstree.defaults.plugins
			 */
			plugins : []
		},
		/**
		 * stores all loaded jstree plugins (used internally)
		 * @name $.jstree.plugins
		 */
		plugins : {},
		path : src && src.indexOf('/') !== -1 ? src.replace(/\/[^\/]+$/,'') : '',
		idregex : /[\\:&!^|()\[\]<>@*'+~#";.,=\- \/${}%?`]/g
	};
	/**
	 * creates a jstree instance
	 * @name $.jstree.create(el [, options])
	 * @param {DOMElement|jQuery|String} el the element to create the instance on, can be jQuery extended or a selector
	 * @param {Object} options options for this instance (extends `$.jstree.defaults`)
	 * @return {jsTree} the new instance
	 */
	$.jstree.create = function (el, options) {
		var tmp = new $.jstree.core(++instance_counter),
			opt = options;
		options = $.extend(true, {}, $.jstree.defaults, options);
		if(opt && opt.plugins) {
			options.plugins = opt.plugins;
		}
		$.each(options.plugins, function (i, k) {
			if(i !== 'core') {
				tmp = tmp.plugin(k, options[k]);
			}
		});
		tmp.init(el, options);
		return tmp;
	};
	/**
	 * remove all traces of jstree from the DOM and destroy all instances
	 * @name $.jstree.destroy()
	 */
	$.jstree.destroy = function () {
		$('.jstree:jstree').jstree('destroy');
		$(document).off('.jstree');
	};
	/**
	 * the jstree class constructor, used only internally
	 * @private
	 * @name $.jstree.core(id)
	 * @param {Number} id this instance's index
	 */
	$.jstree.core = function (id) {
		this._id = id;
		this._cnt = 0;
		this._wrk = null;
		this._data = {
			core : {
				themes : {
					name : false,
					dots : false,
					icons : false
				},
				selected : [],
				last_error : {},
				working : false,
				worker_queue : [],
				focused : null
			}
		};
	};
	/**
	 * get a reference to an existing instance
	 *
	 * __Examples__
	 *
	 *	// provided a container with an ID of "tree", and a nested node with an ID of "branch"
	 *	// all of there will return the same instance
	 *	$.jstree.reference('tree');
	 *	$.jstree.reference('#tree');
	 *	$.jstree.reference($('#tree'));
	 *	$.jstree.reference(document.getElementByID('tree'));
	 *	$.jstree.reference('branch');
	 *	$.jstree.reference('#branch');
	 *	$.jstree.reference($('#branch'));
	 *	$.jstree.reference(document.getElementByID('branch'));
	 *
	 * @name $.jstree.reference(needle)
	 * @param {DOMElement|jQuery|String} needle
	 * @return {jsTree|null} the instance or `null` if not found
	 */
	$.jstree.reference = function (needle) {
		var tmp = null,
			obj = null;
		if(needle && needle.id) { needle = needle.id; }

		if(!obj || !obj.length) {
			try { obj = $(needle); } catch (ignore) { }
		}
		if(!obj || !obj.length) {
			try { obj = $('#' + needle.replace($.jstree.idregex,'\\$&')); } catch (ignore) { }
		}
		if(obj && obj.length && (obj = obj.closest('.jstree')).length && (obj = obj.data('jstree'))) {
			tmp = obj;
		}
		else {
			$('.jstree').each(function () {
				var inst = $(this).data('jstree');
				if(inst && inst._model.data[needle]) {
					tmp = inst;
					return false;
				}
			});
		}
		return tmp;
	};
	/**
	 * Create an instance, get an instance or invoke a command on a instance. 
	 * 
	 * If there is no instance associated with the current node a new one is created and `arg` is used to extend `$.jstree.defaults` for this new instance. There would be no return value (chaining is not broken).
	 * 
	 * If there is an existing instance and `arg` is a string the command specified by `arg` is executed on the instance, with any additional arguments passed to the function. If the function returns a value it will be returned (chaining could break depending on function).
	 * 
	 * If there is an existing instance and `arg` is not a string the instance itself is returned (similar to `$.jstree.reference`).
	 * 
	 * In any other case - nothing is returned and chaining is not broken.
	 *
	 * __Examples__
	 *
	 *	$('#tree1').jstree(); // creates an instance
	 *	$('#tree2').jstree({ plugins : [] }); // create an instance with some options
	 *	$('#tree1').jstree('open_node', '#branch_1'); // call a method on an existing instance, passing additional arguments
	 *	$('#tree2').jstree(); // get an existing instance (or create an instance)
	 *	$('#tree2').jstree(true); // get an existing instance (will not create new instance)
	 *	$('#branch_1').jstree().select_node('#branch_1'); // get an instance (using a nested element and call a method)
	 *
	 * @name $().jstree([arg])
	 * @param {String|Object} arg
	 * @return {Mixed}
	 */
	$.fn.jstree = function (arg) {
		// check for string argument
		var is_method	= (typeof arg === 'string'),
			args		= Array.prototype.slice.call(arguments, 1),
			result		= null;
		if(arg === true && !this.length) { return false; }
		this.each(function () {
			// get the instance (if there is one) and method (if it exists)
			var instance = $.jstree.reference(this),
				method = is_method && instance ? instance[arg] : null;
			// if calling a method, and method is available - execute on the instance
			result = is_method && method ?
				method.apply(instance, args) :
				null;
			// if there is no instance and no method is being called - create one
			if(!instance && !is_method && (arg === undefined || $.isPlainObject(arg))) {
				$(this).data('jstree', new $.jstree.create(this, arg));
			}
			// if there is an instance and no method is called - return the instance
			if( (instance && !is_method) || arg === true ) {
				result = instance || false;
			}
			// if there was a method call which returned a result - break and return the value
			if(result !== null && result !== undefined) {
				return false;
			}
		});
		// if there was a method call with a valid return value - return that, otherwise continue the chain
		return result !== null && result !== undefined ?
			result : this;
	};
	/**
	 * used to find elements containing an instance
	 *
	 * __Examples__
	 *
	 *	$('div:jstree').each(function () {
	 *		$(this).jstree('destroy');
	 *	});
	 *
	 * @name $(':jstree')
	 * @return {jQuery}
	 */
	$.expr[':'].jstree = $.expr.createPseudo(function(search) {
		return function(a) {
			return $(a).hasClass('jstree') &&
				$(a).data('jstree') !== undefined;
		};
	});

	/**
	 * stores all defaults for the core
	 * @name $.jstree.defaults.core
	 */
	$.jstree.defaults.core = {
		/**
		 * data configuration
		 * 
		 * If left as `false` the HTML inside the jstree container element is used to populate the tree (that should be an unordered list with list items).
		 *
		 * You can also pass in a HTML string or a JSON array here.
		 * 
		 * It is possible to pass in a standard jQuery-like AJAX config and jstree will automatically determine if the response is JSON or HTML and use that to populate the tree. 
		 * In addition to the standard jQuery ajax options here you can suppy functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node is being loaded, the return value of those functions will be used.
		 * 
		 * The last option is to specify a function, that function will receive the node being loaded as argument and a second param which is a function which should be called with the result.
		 *
		 * __Examples__
		 *
		 *	// AJAX
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : {
		 *				'url' : '/get/children/',
		 *				'data' : function (node) {
		 *					return { 'id' : node.id };
		 *				}
		 *			}
		 *		});
		 *
		 *	// direct data
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : [
		 *				'Simple root node',
		 *				{
		 *					'id' : 'node_2',
		 *					'text' : 'Root node with options',
		 *					'state' : { 'opened' : true, 'selected' : true },
		 *					'children' : [ { 'text' : 'Child 1' }, 'Child 2']
		 *				}
		 *			]
		 *		});
		 *	
		 *	// function
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'data' : function (obj, callback) {
		 *				callback.call(this, ['Root 1', 'Root 2']);
		 *			}
		 *		});
		 * 
		 * @name $.jstree.defaults.core.data
		 */
		data			: false,
		/**
		 * configure the various strings used throughout the tree
		 *
		 * You can use an object where the key is the string you need to replace and the value is your replacement.
		 * Another option is to specify a function which will be called with an argument of the needed string and should return the replacement.
		 * If left as `false` no replacement is made.
		 *
		 * __Examples__
		 *
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'strings' : {
		 *				'Loading ...' : 'Please wait ...'
		 *			}
		 *		}
		 *	});
		 *
		 * @name $.jstree.defaults.core.strings
		 */
		strings			: false,
		/**
		 * determines what happens when a user tries to modify the structure of the tree
		 * If left as `false` all operations like create, rename, delete, move or copy are prevented.
		 * You can set this to `true` to allow all interactions or use a function to have better control.
		 *
		 * __Examples__
		 *
		 *	$('#tree').jstree({
		 *		'core' : {
		 *			'check_callback' : function (operation, node, node_parent, node_position, more) {
		 *				// operation can be 'create_node', 'rename_node', 'delete_node', 'move_node' or 'copy_node'
		 *				// in case of 'rename_node' node_position is filled with the new node name
		 *				return operation === 'rename_node' ? true : false;
		 *			}
		 *		}
		 *	});
		 * 
		 * @name $.jstree.defaults.core.check_callback
		 */
		check_callback	: false,
		/**
		 * a callback called with a single object parameter in the instance's scope when something goes wrong (operation prevented, ajax failed, etc)
		 * @name $.jstree.defaults.core.error
		 */
		error			: $.noop,
		/**
		 * the open / close animation duration in milliseconds - set this to `false` to disable the animation (default is `200`)
		 * @name $.jstree.defaults.core.animation
		 */
		animation		: 200,
		/**
		 * a boolean indicating if multiple nodes can be selected
		 * @name $.jstree.defaults.core.multiple
		 */
		multiple		: true,
		/**
		 * theme configuration object
		 * @name $.jstree.defaults.core.themes
		 */
		themes			: {
			/**
			 * the name of the theme to use (if left as `false` the default theme is used)
			 * @name $.jstree.defaults.core.themes.name
			 */
			name			: false,
			/**
			 * the URL of the theme's CSS file, leave this as `false` if you have manually included the theme CSS (recommended). You can set this to `true` too which will try to autoload the theme.
			 * @name $.jstree.defaults.core.themes.url
			 */
			url				: false,
			/**
			 * the location of all jstree themes - only used if `url` is set to `true`
			 * @name $.jstree.defaults.core.themes.dir
			 */
			dir				: false,
			/**
			 * a boolean indicating if connecting dots are shown
			 * @name $.jstree.defaults.core.themes.dots
			 */
			dots			: true,
			/**
			 * a boolean indicating if node icons are shown
			 * @name $.jstree.defaults.core.themes.icons
			 */
			icons			: true,
			/**
			 * a boolean indicating if the tree background is striped
			 * @name $.jstree.defaults.core.themes.stripes
			 */
			stripes			: false,
			/**
			 * a string (or boolean `false`) specifying the theme variant to use (if the theme supports variants)
			 * @name $.jstree.defaults.core.themes.variant
			 */
			variant			: false,
			/**
			 * a boolean specifying if a reponsive version of the theme should kick in on smaller screens (if the theme supports it). Defaults to `false`.
			 * @name $.jstree.defaults.core.themes.responsive
			 */
			responsive		: false
		},
		/**
		 * if left as `true` all parents of all selected nodes will be opened once the tree loads (so that all selected nodes are visible to the user)
		 * @name $.jstree.defaults.core.expand_selected_onload
		 */
		expand_selected_onload : true,
		/**
		 * if left as `true` web workers will be used to parse incoming JSON data where possible, so that the UI will not be blocked by large requests. Workers are however about 30% slower. Defaults to `true`
		 * @name $.jstree.defaults.core.worker
		 */
		worker : true,
		/**
		 * Force node text to plain text (and escape HTML). Defaults to `false`
		 * @name $.jstree.defaults.core.force_text
		 */
		force_text : false,
		/**
		 * Should the node should be toggled if the text is double clicked . Defaults to `true`
		 * @name $.jstree.defaults.core.dblclick_toggle
		 */
		dblclick_toggle : true
	};
	$.jstree.core.prototype = {
		/**
		 * used to decorate an instance with a plugin. Used internally.
		 * @private
		 * @name plugin(deco [, opts])
		 * @param  {String} deco the plugin to decorate with
		 * @param  {Object} opts options for the plugin
		 * @return {jsTree}
		 */
		plugin : function (deco, opts) {
			var Child = $.jstree.plugins[deco];
			if(Child) {
				this._data[deco] = {};
				Child.prototype = this;
				return new Child(opts, this);
			}
			return this;
		},
		/**
		 * used to decorate an instance with a plugin. Used internally.
		 * @private
		 * @name init(el, optons)
		 * @param {DOMElement|jQuery|String} el the element we are transforming
		 * @param {Object} options options for this instance
		 * @trigger init.jstree, loading.jstree, loaded.jstree, ready.jstree, changed.jstree
		 */
		init : function (el, options) {
			this._model = {
				data : {
					'#' : {
						id : '#',
						parent : null,
						parents : [],
						children : [],
						children_d : [],
						state : { loaded : false }
					}
				},
				changed : [],
				force_full_redraw : false,
				redraw_timeout : false,
				default_state : {
					loaded : true,
					opened : false,
					selected : false,
					disabled : false
				}
			};

			this.element = $(el).addClass('jstree jstree-' + this._id);
			this.settings = options;

			this._data.core.ready = false;
			this._data.core.loaded = false;
			this._data.core.rtl = (this.element.css("direction") === "rtl");
			this.element[this._data.core.rtl ? 'addClass' : 'removeClass']("jstree-rtl");
			this.element.attr('role','tree');
			if(this.settings.core.multiple) {
				this.element.attr('aria-multiselectable', true);
			}
			if(!this.element.attr('tabindex')) {
				this.element.attr('tabindex','0');
			}

			this.bind();
			/**
			 * triggered after all events are bound
			 * @event
			 * @name init.jstree
			 */
			this.trigger("init");

			this._data.core.original_container_html = this.element.find(" > ul > li").clone(true);
			this._data.core.original_container_html
				.find("li").addBack()
				.contents().filter(function() {
					return this.nodeType === 3 && (!this.nodeValue || /^\s+$/.test(this.nodeValue));
				})
				.remove();
			this.element.html("<"+"ul class='jstree-container-ul jstree-children' role='group'><"+"li id='j"+this._id+"_loading' class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='tree-item'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
			this.element.attr('aria-activedescendant','j' + this._id + '_loading');
			this._data.core.li_height = this.get_container_ul().children("li").first().height() || 24;
			/**
			 * triggered after the loading text is shown and before loading starts
			 * @event
			 * @name loading.jstree
			 */
			this.trigger("loading");
			this.load_node('#');
		},
		/**
		 * destroy an instance
		 * @name destroy()
		 * @param  {Boolean} keep_html if not set to `true` the container will be emptied, otherwise the current DOM elements will be kept intact
		 */
		destroy : function (keep_html) {
			if(this._wrk) {
				try {
					window.URL.revokeObjectURL(this._wrk);
					this._wrk = null;
				}
				catch (ignore) { }
			}
			if(!keep_html) { this.element.empty(); }
			this.teardown();
		},
		/**
		 * part of the destroying of an instance. Used internally.
		 * @private
		 * @name teardown()
		 */
		teardown : function () {
			this.unbind();
			this.element
				.removeClass('jstree')
				.removeData('jstree')
				.find("[class^='jstree']")
					.addBack()
					.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
			this.element = null;
		},
		/**
		 * bind all events. Used internally.
		 * @private
		 * @name bind()
		 */
		bind : function () {
			var word = '',
				tout = null,
				was_click = 0;
			this.element
				.on("dblclick.jstree", function () {
						if(document.selection && document.selection.empty) {
							document.selection.empty();
						}
						else {
							if(window.getSelection) {
								var sel = window.getSelection();
								try {
									sel.removeAllRanges();
									sel.collapse();
								} catch (ignore) { }
							}
						}
					})
				.on("mousedown.jstree", $.proxy(function (e) {
						if(e.target === this.element[0]) {
							e.preventDefault(); // prevent losing focus when clicking scroll arrows (FF, Chrome)
							was_click = +(new Date()); // ie does not allow to prevent losing focus
						}
					}, this))
				.on("mousedown.jstree", ".jstree-ocl", function (e) {
						e.preventDefault(); // prevent any node inside from losing focus when clicking the open/close icon
					})
				.on("click.jstree", ".jstree-ocl", $.proxy(function (e) {
						this.toggle_node(e.target);
					}, this))
				.on("dblclick.jstree", ".jstree-anchor", $.proxy(function (e) {
						if(this.settings.core.dblclick_toggle) {
							this.toggle_node(e.target);
						}
					}, this))
				.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
						e.preventDefault();
						if(e.currentTarget !== document.activeElement) { $(e.currentTarget).focus(); }
						this.activate_node(e.currentTarget, e);
					}, this))
				.on('keydown.jstree', '.jstree-anchor', $.proxy(function (e) {
						if(e.target.tagName === "INPUT") { return true; }
						var o = null;
						if(this._data.core.rtl) {
							if(e.which === 37) { e.which = 39; }
							else if(e.which === 39) { e.which = 37; }
						}
						switch(e.which) {
							case 32: // aria defines space only with Ctrl
								if(e.ctrlKey) {
									e.type = "click";
									$(e.currentTarget).trigger(e);
								}
								break;
							case 13: // enter
								e.type = "click";
								$(e.currentTarget).trigger(e);
								break;
							case 37: // right
								e.preventDefault();
								if(this.is_open(e.currentTarget)) {
									this.close_node(e.currentTarget);
								}
								else {
									o = this.get_parent(e.currentTarget);
									if(o && o.id !== '#') { this.get_node(o, true).children('.jstree-anchor').focus(); }
								}
								break;
							case 38: // up
								e.preventDefault();
								o = this.get_prev_dom(e.currentTarget);
								if(o && o.length) { o.children('.jstree-anchor').focus(); }
								break;
							case 39: // left
								e.preventDefault();
								if(this.is_closed(e.currentTarget)) {
									this.open_node(e.currentTarget, function (o) { this.get_node(o, true).children('.jstree-anchor').focus(); });
								}
								else if (this.is_open(e.currentTarget)) {
									o = this.get_node(e.currentTarget, true).children('.jstree-children')[0];
									if(o) { $(this._firstChild(o)).children('.jstree-anchor').focus(); }
								}
								break;
							case 40: // down
								e.preventDefault();
								o = this.get_next_dom(e.currentTarget);
								if(o && o.length) { o.children('.jstree-anchor').focus(); }
								break;
							case 106: // aria defines * on numpad as open_all - not very common
								this.open_all();
								break;
							case 36: // home
								e.preventDefault();
								o = this._firstChild(this.get_container_ul()[0]);
								if(o) { $(o).children('.jstree-anchor').filter(':visible').focus(); }
								break;
							case 35: // end
								e.preventDefault();
								this.element.find('.jstree-anchor').filter(':visible').last().focus();
								break;
							/*
							// delete
							case 46:
								e.preventDefault();
								o = this.get_node(e.currentTarget);
								if(o && o.id && o.id !== '#') {
									o = this.is_selected(o) ? this.get_selected() : o;
									this.delete_node(o);
								}
								break;
							// f2
							case 113:
								e.preventDefault();
								o = this.get_node(e.currentTarget);
								if(o && o.id && o.id !== '#') {
									// this.edit(o);
								}
								break;
							default:
								// console.log(e.which);
								break;
							*/
						}
					}, this))
				.on("load_node.jstree", $.proxy(function (e, data) {
						if(data.status) {
							if(data.node.id === '#' && !this._data.core.loaded) {
								this._data.core.loaded = true;
								if(this._firstChild(this.get_container_ul()[0])) {
									this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
								}
								/**
								 * triggered after the root node is loaded for the first time
								 * @event
								 * @name loaded.jstree
								 */
								this.trigger("loaded");
							}
							if(!this._data.core.ready) {
								setTimeout($.proxy(function() {
									if(!this.get_container_ul().find('.jstree-loading').length) {
										this._data.core.ready = true;
										if(this._data.core.selected.length) {
											if(this.settings.core.expand_selected_onload) {
												var tmp = [], i, j;
												for(i = 0, j = this._data.core.selected.length; i < j; i++) {
													tmp = tmp.concat(this._model.data[this._data.core.selected[i]].parents);
												}
												tmp = $.vakata.array_unique(tmp);
												for(i = 0, j = tmp.length; i < j; i++) {
													this.open_node(tmp[i], false, 0);
												}
											}
											this.trigger('changed', { 'action' : 'ready', 'selected' : this._data.core.selected });
										}
										/**
										 * triggered after all nodes are finished loading
										 * @event
										 * @name ready.jstree
										 */
										this.trigger("ready");
									}
								}, this), 0);
							}
						}
					}, this))
				// quick searching when the tree is focused
				.on('keypress.jstree', $.proxy(function (e) {
						if(e.target.tagName === "INPUT") { return true; }
						if(tout) { clearTimeout(tout); }
						tout = setTimeout(function () {
							word = '';
						}, 500);

						var chr = String.fromCharCode(e.which).toLowerCase(),
							col = this.element.find('.jstree-anchor').filter(':visible'),
							ind = col.index(document.activeElement) || 0,
							end = false;
						word += chr;

						// match for whole word from current node down (including the current node)
						if(word.length > 1) {
							col.slice(ind).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().indexOf(word) === 0) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }

							// match for whole word from the beginning of the tree
							col.slice(0, ind).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().indexOf(word) === 0) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }
						}
						// list nodes that start with that letter (only if word consists of a single char)
						if(new RegExp('^' + chr + '+$').test(word)) {
							// search for the next node starting with that letter
							col.slice(ind + 1).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().charAt(0) === chr) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }

							// search from the beginning
							col.slice(0, ind + 1).each($.proxy(function (i, v) {
								if($(v).text().toLowerCase().charAt(0) === chr) {
									$(v).focus();
									end = true;
									return false;
								}
							}, this));
							if(end) { return; }
						}
					}, this))
				// THEME RELATED
				.on("init.jstree", $.proxy(function () {
						var s = this.settings.core.themes;
						this._data.core.themes.dots			= s.dots;
						this._data.core.themes.stripes		= s.stripes;
						this._data.core.themes.icons		= s.icons;
						this.set_theme(s.name || "default", s.url);
						this.set_theme_variant(s.variant);
					}, this))
				.on("loading.jstree", $.proxy(function () {
						this[ this._data.core.themes.dots ? "show_dots" : "hide_dots" ]();
						this[ this._data.core.themes.icons ? "show_icons" : "hide_icons" ]();
						this[ this._data.core.themes.stripes ? "show_stripes" : "hide_stripes" ]();
					}, this))
				.on('blur.jstree', '.jstree-anchor', $.proxy(function (e) {
						this._data.core.focused = null;
						$(e.currentTarget).filter('.jstree-hovered').mouseleave();
						this.element.attr('tabindex', '0');
					}, this))
				.on('focus.jstree', '.jstree-anchor', $.proxy(function (e) {
						var tmp = this.get_node(e.currentTarget);
						if(tmp && tmp.id) {
							this._data.core.focused = tmp.id;
						}
						this.element.find('.jstree-hovered').not(e.currentTarget).mouseleave();
						$(e.currentTarget).mouseenter();
						this.element.attr('tabindex', '-1');
					}, this))
				.on('focus.jstree', $.proxy(function () {
						if(+(new Date()) - was_click > 500 && !this._data.core.focused) {
							was_click = 0;
							this.get_node(this.element.attr('aria-activedescendant'), true).find('> .jstree-anchor').focus();
						}
					}, this))
				.on('mouseenter.jstree', '.jstree-anchor', $.proxy(function (e) {
						this.hover_node(e.currentTarget);
					}, this))
				.on('mouseleave.jstree', '.jstree-anchor', $.proxy(function (e) {
						this.dehover_node(e.currentTarget);
					}, this));
		},
		/**
		 * part of the destroying of an instance. Used internally.
		 * @private
		 * @name unbind()
		 */
		unbind : function () {
			this.element.off('.jstree');
			$(document).off('.jstree-' + this._id);
		},
		/**
		 * trigger an event. Used internally.
		 * @private
		 * @name trigger(ev [, data])
		 * @param  {String} ev the name of the event to trigger
		 * @param  {Object} data additional data to pass with the event
		 */
		trigger : function (ev, data) {
			if(!data) {
				data = {};
			}
			data.instance = this;
			this.element.triggerHandler(ev.replace('.jstree','') + '.jstree', data);
		},
		/**
		 * returns the jQuery extended instance container
		 * @name get_container()
		 * @return {jQuery}
		 */
		get_container : function () {
			return this.element;
		},
		/**
		 * returns the jQuery extended main UL node inside the instance container. Used internally.
		 * @private
		 * @name get_container_ul()
		 * @return {jQuery}
		 */
		get_container_ul : function () {
			return this.element.children(".jstree-children").first();
		},
		/**
		 * gets string replacements (localization). Used internally.
		 * @private
		 * @name get_string(key)
		 * @param  {String} key
		 * @return {String}
		 */
		get_string : function (key) {
			var a = this.settings.core.strings;
			if($.isFunction(a)) { return a.call(this, key); }
			if(a && a[key]) { return a[key]; }
			return key;
		},
		/**
		 * gets the first child of a DOM node. Used internally.
		 * @private
		 * @name _firstChild(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_firstChild : function (dom) {
			dom = dom ? dom.firstChild : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.nextSibling;
			}
			return dom;
		},
		/**
		 * gets the next sibling of a DOM node. Used internally.
		 * @private
		 * @name _nextSibling(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_nextSibling : function (dom) {
			dom = dom ? dom.nextSibling : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.nextSibling;
			}
			return dom;
		},
		/**
		 * gets the previous sibling of a DOM node. Used internally.
		 * @private
		 * @name _previousSibling(dom)
		 * @param  {DOMElement} dom
		 * @return {DOMElement}
		 */
		_previousSibling : function (dom) {
			dom = dom ? dom.previousSibling : null;
			while(dom !== null && dom.nodeType !== 1) {
				dom = dom.previousSibling;
			}
			return dom;
		},
		/**
		 * get the JSON representation of a node (or the actual jQuery extended DOM node) by using any input (child DOM element, ID string, selector, etc)
		 * @name get_node(obj [, as_dom])
		 * @param  {mixed} obj
		 * @param  {Boolean} as_dom
		 * @return {Object|jQuery}
		 */
		get_node : function (obj, as_dom) {
			if(obj && obj.id) {
				obj = obj.id;
			}
			var dom;
			try {
				if(this._model.data[obj]) {
					obj = this._model.data[obj];
				}
				else if(typeof obj === "string" && this._model.data[obj.replace(/^#/, '')]) {
					obj = this._model.data[obj.replace(/^#/, '')];
				}
				else if(typeof obj === "string" && (dom = $('#' + obj.replace($.jstree.idregex,'\\$&'), this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
					obj = this._model.data[dom.closest('.jstree-node').attr('id')];
				}
				else if((dom = $(obj, this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
					obj = this._model.data[dom.closest('.jstree-node').attr('id')];
				}
				else if((dom = $(obj, this.element)).length && dom.hasClass('jstree')) {
					obj = this._model.data['#'];
				}
				else {
					return false;
				}

				if(as_dom) {
					obj = obj.id === '#' ? this.element : $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
				}
				return obj;
			} catch (ex) { return false; }
		},
		/**
		 * get the path to a node, either consisting of node texts, or of node IDs, optionally glued together (otherwise an array)
		 * @name get_path(obj [, glue, ids])
		 * @param  {mixed} obj the node
		 * @param  {String} glue if you want the path as a string - pass the glue here (for example '/'), if a falsy value is supplied here, an array is returned
		 * @param  {Boolean} ids if set to true build the path using ID, otherwise node text is used
		 * @return {mixed}
		 */
		get_path : function (obj, glue, ids) {
			obj = obj.parents ? obj : this.get_node(obj);
			if(!obj || obj.id === '#' || !obj.parents) {
				return false;
			}
			var i, j, p = [];
			p.push(ids ? obj.id : obj.text);
			for(i = 0, j = obj.parents.length; i < j; i++) {
				p.push(ids ? obj.parents[i] : this.get_text(obj.parents[i]));
			}
			p = p.reverse().slice(1);
			return glue ? p.join(glue) : p;
		},
		/**
		 * get the next visible node that is below the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
		 * @name get_next_dom(obj [, strict])
		 * @param  {mixed} obj
		 * @param  {Boolean} strict
		 * @return {jQuery}
		 */
		get_next_dom : function (obj, strict) {
			var tmp;
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				tmp = this._firstChild(this.get_container_ul()[0]);
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._nextSibling(tmp);
				}
				return tmp ? $(tmp) : false;
			}
			if(!obj || !obj.length) {
				return false;
			}
			if(strict) {
				tmp = obj[0];
				do {
					tmp = this._nextSibling(tmp);
				} while (tmp && tmp.offsetHeight === 0);
				return tmp ? $(tmp) : false;
			}
			if(obj.hasClass("jstree-open")) {
				tmp = this._firstChild(obj.children('.jstree-children')[0]);
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._nextSibling(tmp);
				}
				if(tmp !== null) {
					return $(tmp);
				}
			}
			tmp = obj[0];
			do {
				tmp = this._nextSibling(tmp);
			} while (tmp && tmp.offsetHeight === 0);
			if(tmp !== null) {
				return $(tmp);
			}
			return obj.parentsUntil(".jstree",".jstree-node").next(".jstree-node:visible").first();
		},
		/**
		 * get the previous visible node that is above the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
		 * @name get_prev_dom(obj [, strict])
		 * @param  {mixed} obj
		 * @param  {Boolean} strict
		 * @return {jQuery}
		 */
		get_prev_dom : function (obj, strict) {
			var tmp;
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				tmp = this.get_container_ul()[0].lastChild;
				while (tmp && tmp.offsetHeight === 0) {
					tmp = this._previousSibling(tmp);
				}
				return tmp ? $(tmp) : false;
			}
			if(!obj || !obj.length) {
				return false;
			}
			if(strict) {
				tmp = obj[0];
				do {
					tmp = this._previousSibling(tmp);
				} while (tmp && tmp.offsetHeight === 0);
				return tmp ? $(tmp) : false;
			}
			tmp = obj[0];
			do {
				tmp = this._previousSibling(tmp);
			} while (tmp && tmp.offsetHeight === 0);
			if(tmp !== null) {
				obj = $(tmp);
				while(obj.hasClass("jstree-open")) {
					obj = obj.children(".jstree-children").first().children(".jstree-node:visible:last");
				}
				return obj;
			}
			tmp = obj[0].parentNode.parentNode;
			return tmp && tmp.className && tmp.className.indexOf('jstree-node') !== -1 ? $(tmp) : false;
		},
		/**
		 * get the parent ID of a node
		 * @name get_parent(obj)
		 * @param  {mixed} obj
		 * @return {String}
		 */
		get_parent : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			return obj.parent;
		},
		/**
		 * get a jQuery collection of all the children of a node (node must be rendered)
		 * @name get_children_dom(obj)
		 * @param  {mixed} obj
		 * @return {jQuery}
		 */
		get_children_dom : function (obj) {
			obj = this.get_node(obj, true);
			if(obj[0] === this.element[0]) {
				return this.get_container_ul().children(".jstree-node");
			}
			if(!obj || !obj.length) {
				return false;
			}
			return obj.children(".jstree-children").children(".jstree-node");
		},
		/**
		 * checks if a node has children
		 * @name is_parent(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_parent : function (obj) {
			obj = this.get_node(obj);
			return obj && (obj.state.loaded === false || obj.children.length > 0);
		},
		/**
		 * checks if a node is loaded (its children are available)
		 * @name is_loaded(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_loaded : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state.loaded;
		},
		/**
		 * check if a node is currently loading (fetching children)
		 * @name is_loading(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_loading : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state && obj.state.loading;
		},
		/**
		 * check if a node is opened
		 * @name is_open(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_open : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state.opened;
		},
		/**
		 * check if a node is in a closed state
		 * @name is_closed(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_closed : function (obj) {
			obj = this.get_node(obj);
			return obj && this.is_parent(obj) && !obj.state.opened;
		},
		/**
		 * check if a node has no children
		 * @name is_leaf(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_leaf : function (obj) {
			return !this.is_parent(obj);
		},
		/**
		 * loads a node (fetches its children using the `core.data` setting). Multiple nodes can be passed to by using an array.
		 * @name load_node(obj [, callback])
		 * @param  {mixed} obj
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives two arguments - the node and a boolean status
		 * @return {Boolean}
		 * @trigger load_node.jstree
		 */
		load_node : function (obj, callback) {
			var k, l, i, j, c;
			if($.isArray(obj)) {
				this._load_nodes(obj.slice(), callback);
				return true;
			}
			obj = this.get_node(obj);
			if(!obj) {
				if(callback) { callback.call(this, obj, false); }
				return false;
			}
			// if(obj.state.loading) { } // the node is already loading - just wait for it to load and invoke callback? but if called implicitly it should be loaded again?
			if(obj.state.loaded) {
				obj.state.loaded = false;
				for(k = 0, l = obj.children_d.length; k < l; k++) {
					for(i = 0, j = obj.parents.length; i < j; i++) {
						this._model.data[obj.parents[i]].children_d = $.vakata.array_remove_item(this._model.data[obj.parents[i]].children_d, obj.children_d[k]);
					}
					if(this._model.data[obj.children_d[k]].state.selected) {
						c = true;
						this._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.children_d[k]);
					}
					delete this._model.data[obj.children_d[k]];
				}
				obj.children = [];
				obj.children_d = [];
				if(c) {
					this.trigger('changed', { 'action' : 'load_node', 'node' : obj, 'selected' : this._data.core.selected });
				}
			}
			obj.state.loading = true;
			this.get_node(obj, true).addClass("jstree-loading").attr('aria-busy',true);
			this._load_node(obj, $.proxy(function (status) {
				obj = this._model.data[obj.id];
				obj.state.loading = false;
				obj.state.loaded = status;
				var dom = this.get_node(obj, true);
				if(obj.state.loaded && !obj.children.length && dom && dom.length && !dom.hasClass('jstree-leaf')) {
					dom.removeClass('jstree-closed jstree-open').addClass('jstree-leaf');
				}
				dom.removeClass("jstree-loading").attr('aria-busy',false);
				/**
				 * triggered after a node is loaded
				 * @event
				 * @name load_node.jstree
				 * @param {Object} node the node that was loading
				 * @param {Boolean} status was the node loaded successfully
				 */
				this.trigger('load_node', { "node" : obj, "status" : status });
				if(callback) {
					callback.call(this, obj, status);
				}
			}, this));
			return true;
		},
		/**
		 * load an array of nodes (will also load unavailable nodes as soon as the appear in the structure). Used internally.
		 * @private
		 * @name _load_nodes(nodes [, callback])
		 * @param  {array} nodes
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - the array passed to _load_nodes
		 */
		_load_nodes : function (nodes, callback, is_callback) {
			var r = true,
				c = function () { this._load_nodes(nodes, callback, true); },
				m = this._model.data, i, j;
			for(i = 0, j = nodes.length; i < j; i++) {
				if(m[nodes[i]] && (!m[nodes[i]].state.loaded || !is_callback)) {
					if(!this.is_loading(nodes[i])) {
						this.load_node(nodes[i], c);
					}
					r = false;
				}
			}
			if(r) {
				if(callback && !callback.done) {
					callback.call(this, nodes);
					callback.done = true;
				}
			}
		},
		/**
		 * loads all unloaded nodes
		 * @name load_all([obj, callback])
		 * @param {mixed} obj the node to load recursively, omit to load all nodes in the tree
		 * @param {function} callback a function to be executed once loading all the nodes is complete,
		 * @trigger load_all.jstree
		 */
		load_all : function (obj, callback) {
			if(!obj) { obj = '#'; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var to_load = [],
				m = this._model.data,
				c = m[obj.id].children_d,
				i, j;
			if(obj.state && !obj.state.loaded) {
				to_load.push(obj.id);
			}
			for(i = 0, j = c.length; i < j; i++) {
				if(m[c[i]] && m[c[i]].state && !m[c[i]].state.loaded) {
					to_load.push(c[i]);
				}
			}
			if(to_load.length) {
				this._load_nodes(to_load, function () {
					this.load_all(obj, callback);
				});
			}
			else {
				/**
				 * triggered after a load_all call completes
				 * @event
				 * @name load_all.jstree
				 * @param {Object} node the recursively loaded node
				 */
				if(callback) { callback.call(this, obj); }
				this.trigger('load_all', { "node" : obj });
			}
		},
		/**
		 * handles the actual loading of a node. Used only internally.
		 * @private
		 * @name _load_node(obj [, callback])
		 * @param  {mixed} obj
		 * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - a boolean status
		 * @return {Boolean}
		 */
		_load_node : function (obj, callback) {
			var s = this.settings.core.data, t;
			// use original HTML
			if(!s) {
				if(obj.id === '#') {
					return this._append_html_data(obj, this._data.core.original_container_html.clone(true), function (status) {
						callback.call(this, status);
					});
				}
				else {
					return callback.call(this, false);
				}
				// return callback.call(this, obj.id === '#' ? this._append_html_data(obj, this._data.core.original_container_html.clone(true)) : false);
			}
			if($.isFunction(s)) {
				return s.call(this, obj, $.proxy(function (d) {
					if(d === false) {
						callback.call(this, false);
					}
					this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(d) : d, function (status) {
						callback.call(this, status);
					});
					// return d === false ? callback.call(this, false) : callback.call(this, this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(d) : d));
				}, this));
			}
			if(typeof s === 'object') {
				if(s.url) {
					s = $.extend(true, {}, s);
					if($.isFunction(s.url)) {
						s.url = s.url.call(this, obj);
					}
					if($.isFunction(s.data)) {
						s.data = s.data.call(this, obj);
					}
					return $.ajax(s)
						.done($.proxy(function (d,t,x) {
								var type = x.getResponseHeader('Content-Type');
								if(type.indexOf('json') !== -1 || typeof d === "object") {
									return this._append_json_data(obj, d, function (status) { callback.call(this, status); });
									//return callback.call(this, this._append_json_data(obj, d));
								}
								if(type.indexOf('html') !== -1 || typeof d === "string") {
									return this._append_html_data(obj, $(d), function (status) { callback.call(this, status); });
									// return callback.call(this, this._append_html_data(obj, $(d)));
								}
								this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : x }) };
								this.settings.core.error.call(this, this._data.core.last_error);
								return callback.call(this, false);
							}, this))
						.fail($.proxy(function (f) {
								callback.call(this, false);
								this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'core', 'id' : 'core_04', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id, 'xhr' : f }) };
								this.settings.core.error.call(this, this._data.core.last_error);
							}, this));
				}
				t = ($.isArray(s) || $.isPlainObject(s)) ? JSON.parse(JSON.stringify(s)) : s;
				if(obj.id === '#') {
					return this._append_json_data(obj, t, function (status) {
						callback.call(this, status);
					});
				}
				else {
					this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_05', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
					this.settings.core.error.call(this, this._data.core.last_error);
					return callback.call(this, false);
				}
				//return callback.call(this, (obj.id === "#" ? this._append_json_data(obj, t) : false) );
			}
			if(typeof s === 'string') {
				if(obj.id === '#') {
					return this._append_html_data(obj, $(s), function (status) {
						callback.call(this, status);
					});
				}
				else {
					this._data.core.last_error = { 'error' : 'nodata', 'plugin' : 'core', 'id' : 'core_06', 'reason' : 'Could not load node', 'data' : JSON.stringify({ 'id' : obj.id }) };
					this.settings.core.error.call(this, this._data.core.last_error);
					return callback.call(this, false);
				}
				//return callback.call(this, (obj.id === "#" ? this._append_html_data(obj, $(s)) : false) );
			}
			return callback.call(this, false);
		},
		/**
		 * adds a node to the list of nodes to redraw. Used only internally.
		 * @private
		 * @name _node_changed(obj [, callback])
		 * @param  {mixed} obj
		 */
		_node_changed : function (obj) {
			obj = this.get_node(obj);
			if(obj) {
				this._model.changed.push(obj.id);
			}
		},
		/**
		 * appends HTML content to the tree. Used internally.
		 * @private
		 * @name _append_html_data(obj, data)
		 * @param  {mixed} obj the node to append to
		 * @param  {String} data the HTML string to parse and append
		 * @trigger model.jstree, changed.jstree
		 */
		_append_html_data : function (dom, data, cb) {
			dom = this.get_node(dom);
			dom.children = [];
			dom.children_d = [];
			var dat = data.is('ul') ? data.children() : data,
				par = dom.id,
				chd = [],
				dpc = [],
				m = this._model.data,
				p = m[par],
				s = this._data.core.selected.length,
				tmp, i, j;
			dat.each($.proxy(function (i, v) {
				tmp = this._parse_model_from_html($(v), par, p.parents.concat());
				if(tmp) {
					chd.push(tmp);
					dpc.push(tmp);
					if(m[tmp].children_d.length) {
						dpc = dpc.concat(m[tmp].children_d);
					}
				}
			}, this));
			p.children = chd;
			p.children_d = dpc;
			for(i = 0, j = p.parents.length; i < j; i++) {
				m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
			}
			/**
			 * triggered when new data is inserted to the tree model
			 * @event
			 * @name model.jstree
			 * @param {Array} nodes an array of node IDs
			 * @param {String} parent the parent ID of the nodes
			 */
			this.trigger('model', { "nodes" : dpc, 'parent' : par });
			if(par !== '#') {
				this._node_changed(par);
				this.redraw();
			}
			else {
				this.get_container_ul().children('.jstree-initial-node').remove();
				this.redraw(true);
			}
			if(this._data.core.selected.length !== s) {
				this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
			}
			cb.call(this, true);
		},
		/**
		 * appends JSON content to the tree. Used internally.
		 * @private
		 * @name _append_json_data(obj, data)
		 * @param  {mixed} obj the node to append to
		 * @param  {String} data the JSON object to parse and append
		 * @param  {Boolean} force_processing internal param - do not set
		 * @trigger model.jstree, changed.jstree
		 */
		_append_json_data : function (dom, data, cb, force_processing) {
			dom = this.get_node(dom);
			dom.children = [];
			dom.children_d = [];
			// *%$@!!!
			if(data.d) {
				data = data.d;
				if(typeof data === "string") {
					data = JSON.parse(data);
				}
			}
			if(!$.isArray(data)) { data = [data]; }
			var w = null,
				args = {
					'df'	: this._model.default_state,
					'dat'	: data,
					'par'	: dom.id,
					'm'		: this._model.data,
					't_id'	: this._id,
					't_cnt'	: this._cnt,
					'sel'	: this._data.core.selected
				},
				func = function (data, undefined) {
					if(data.data) { data = data.data; }
					var dat = data.dat,
						par = data.par,
						chd = [],
						dpc = [],
						add = [],
						df = data.df,
						t_id = data.t_id,
						t_cnt = data.t_cnt,
						m = data.m,
						p = m[par],
						sel = data.sel,
						tmp, i, j, rslt,
						parse_flat = function (d, p, ps) {
							if(!ps) { ps = []; }
							else { ps = ps.concat(); }
							if(p) { ps.unshift(p); }
							var tid = d.id.toString(),
								i, j, c, e,
								tmp = {
									id			: tid,
									text		: d.text || '',
									icon		: d.icon !== undefined ? d.icon : true,
									parent		: p,
									parents		: ps,
									children	: d.children || [],
									children_d	: d.children_d || [],
									data		: d.data,
									state		: { },
									li_attr		: { id : false },
									a_attr		: { href : '#' },
									original	: false
								};
							for(i in df) {
								if(df.hasOwnProperty(i)) {
									tmp.state[i] = df[i];
								}
							}
							if(d && d.data && d.data.jstree && d.data.jstree.icon) {
								tmp.icon = d.data.jstree.icon;
							}
							if(d && d.data) {
								tmp.data = d.data;
								if(d.data.jstree) {
									for(i in d.data.jstree) {
										if(d.data.jstree.hasOwnProperty(i)) {
											tmp.state[i] = d.data.jstree[i];
										}
									}
								}
							}
							if(d && typeof d.state === 'object') {
								for (i in d.state) {
									if(d.state.hasOwnProperty(i)) {
										tmp.state[i] = d.state[i];
									}
								}
							}
							if(d && typeof d.li_attr === 'object') {
								for (i in d.li_attr) {
									if(d.li_attr.hasOwnProperty(i)) {
										tmp.li_attr[i] = d.li_attr[i];
									}
								}
							}
							if(!tmp.li_attr.id) {
								tmp.li_attr.id = tid;
							}
							if(d && typeof d.a_attr === 'object') {
								for (i in d.a_attr) {
									if(d.a_attr.hasOwnProperty(i)) {
										tmp.a_attr[i] = d.a_attr[i];
									}
								}
							}
							if(d && d.children && d.children === true) {
								tmp.state.loaded = false;
								tmp.children = [];
								tmp.children_d = [];
							}
							m[tmp.id] = tmp;
							for(i = 0, j = tmp.children.length; i < j; i++) {
								c = parse_flat(m[tmp.children[i]], tmp.id, ps);
								e = m[c];
								tmp.children_d.push(c);
								if(e.children_d.length) {
									tmp.children_d = tmp.children_d.concat(e.children_d);
								}
							}
							delete d.data;
							delete d.children;
							m[tmp.id].original = d;
							if(tmp.state.selected) {
								add.push(tmp.id);
							}
							return tmp.id;
						},
						parse_nest = function (d, p, ps) {
							if(!ps) { ps = []; }
							else { ps = ps.concat(); }
							if(p) { ps.unshift(p); }
							var tid = false, i, j, c, e, tmp;
							do {
								tid = 'j' + t_id + '_' + (++t_cnt);
							} while(m[tid]);

							tmp = {
								id			: false,
								text		: typeof d === 'string' ? d : '',
								icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
								parent		: p,
								parents		: ps,
								children	: [],
								children_d	: [],
								data		: null,
								state		: { },
								li_attr		: { id : false },
								a_attr		: { href : '#' },
								original	: false
							};
							for(i in df) {
								if(df.hasOwnProperty(i)) {
									tmp.state[i] = df[i];
								}
							}
							if(d && d.id) { tmp.id = d.id.toString(); }
							if(d && d.text) { tmp.text = d.text; }
							if(d && d.data && d.data.jstree && d.data.jstree.icon) {
								tmp.icon = d.data.jstree.icon;
							}
							if(d && d.data) {
								tmp.data = d.data;
								if(d.data.jstree) {
									for(i in d.data.jstree) {
										if(d.data.jstree.hasOwnProperty(i)) {
											tmp.state[i] = d.data.jstree[i];
										}
									}
								}
							}
							if(d && typeof d.state === 'object') {
								for (i in d.state) {
									if(d.state.hasOwnProperty(i)) {
										tmp.state[i] = d.state[i];
									}
								}
							}
							if(d && typeof d.li_attr === 'object') {
								for (i in d.li_attr) {
									if(d.li_attr.hasOwnProperty(i)) {
										tmp.li_attr[i] = d.li_attr[i];
									}
								}
							}
							if(tmp.li_attr.id && !tmp.id) {
								tmp.id = tmp.li_attr.id.toString();
							}
							if(!tmp.id) {
								tmp.id = tid;
							}
							if(!tmp.li_attr.id) {
								tmp.li_attr.id = tmp.id;
							}
							if(d && typeof d.a_attr === 'object') {
								for (i in d.a_attr) {
									if(d.a_attr.hasOwnProperty(i)) {
										tmp.a_attr[i] = d.a_attr[i];
									}
								}
							}
							if(d && d.children && d.children.length) {
								for(i = 0, j = d.children.length; i < j; i++) {
									c = parse_nest(d.children[i], tmp.id, ps);
									e = m[c];
									tmp.children.push(c);
									if(e.children_d.length) {
										tmp.children_d = tmp.children_d.concat(e.children_d);
									}
								}
								tmp.children_d = tmp.children_d.concat(tmp.children);
							}
							if(d && d.children && d.children === true) {
								tmp.state.loaded = false;
								tmp.children = [];
								tmp.children_d = [];
							}
							delete d.data;
							delete d.children;
							tmp.original = d;
							m[tmp.id] = tmp;
							if(tmp.state.selected) {
								add.push(tmp.id);
							}
							return tmp.id;
						};

					if(dat.length && dat[0].id !== undefined && dat[0].parent !== undefined) {
						// Flat JSON support (for easy import from DB):
						// 1) convert to object (foreach)
						for(i = 0, j = dat.length; i < j; i++) {
							if(!dat[i].children) {
								dat[i].children = [];
							}
							m[dat[i].id.toString()] = dat[i];
						}
						// 2) populate children (foreach)
						for(i = 0, j = dat.length; i < j; i++) {
							m[dat[i].parent.toString()].children.push(dat[i].id.toString());
							// populate parent.children_d
							p.children_d.push(dat[i].id.toString());
						}
						// 3) normalize && populate parents and children_d with recursion
						for(i = 0, j = p.children.length; i < j; i++) {
							tmp = parse_flat(m[p.children[i]], par, p.parents.concat());
							dpc.push(tmp);
							if(m[tmp].children_d.length) {
								dpc = dpc.concat(m[tmp].children_d);
							}
						}
						for(i = 0, j = p.parents.length; i < j; i++) {
							m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
						}
						// ?) three_state selection - p.state.selected && t - (if three_state foreach(dat => ch) -> foreach(parents) if(parent.selected) child.selected = true;
						rslt = {
							'cnt' : t_cnt,
							'mod' : m,
							'sel' : sel,
							'par' : par,
							'dpc' : dpc,
							'add' : add
						};
					}
					else {
						for(i = 0, j = dat.length; i < j; i++) {
							tmp = parse_nest(dat[i], par, p.parents.concat());
							if(tmp) {
								chd.push(tmp);
								dpc.push(tmp);
								if(m[tmp].children_d.length) {
									dpc = dpc.concat(m[tmp].children_d);
								}
							}
						}
						p.children = chd;
						p.children_d = dpc;
						for(i = 0, j = p.parents.length; i < j; i++) {
							m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
						}
						rslt = {
							'cnt' : t_cnt,
							'mod' : m,
							'sel' : sel,
							'par' : par,
							'dpc' : dpc,
							'add' : add
						};
					}
					if(typeof window === 'undefined' || typeof window.document === 'undefined') {
						postMessage(rslt);
					}
					else {
						return rslt;
					}
				},
				rslt = function (rslt, worker) {
					this._cnt = rslt.cnt;
					this._model.data = rslt.mod; // breaks the reference in load_node - careful

					if(worker) {
						var i, j, a = rslt.add, r = rslt.sel, s = this._data.core.selected.slice(), m = this._model.data;
						// if selection was changed while calculating in worker
						if(r.length !== s.length || $.vakata.array_unique(r.concat(s)).length !== r.length) {
							// deselect nodes that are no longer selected
							for(i = 0, j = r.length; i < j; i++) {
								if($.inArray(r[i], a) === -1 && $.inArray(r[i], s) === -1) {
									m[r[i]].state.selected = false;
								}
							}
							// select nodes that were selected in the mean time
							for(i = 0, j = s.length; i < j; i++) {
								if($.inArray(s[i], r) === -1) {
									m[s[i]].state.selected = true;
								}
							}
						}
					}
					if(rslt.add.length) {
						this._data.core.selected = this._data.core.selected.concat(rslt.add);
					}

					this.trigger('model', { "nodes" : rslt.dpc, 'parent' : rslt.par });

					if(rslt.par !== '#') {
						this._node_changed(rslt.par);
						this.redraw();
					}
					else {
						// this.get_container_ul().children('.jstree-initial-node').remove();
						this.redraw(true);
					}
					if(rslt.add.length) {
						this.trigger('changed', { 'action' : 'model', 'selected' : this._data.core.selected });
					}
					cb.call(this, true);
				};
			if(this.settings.core.worker && window.Blob && window.URL && window.Worker) {
				try {
					if(this._wrk === null) {
						this._wrk = window.URL.createObjectURL(
							new window.Blob(
								['self.onmessage = ' + func.toString()],
								{type:"text/javascript"}
							)
						);
					}
					if(!this._data.core.working || force_processing) {
						this._data.core.working = true;
						w = new window.Worker(this._wrk);
						w.onmessage = $.proxy(function (e) {
							rslt.call(this, e.data, true);
							try { w.terminate(); w = null; } catch(ignore) { }
							if(this._data.core.worker_queue.length) {
								this._append_json_data.apply(this, this._data.core.worker_queue.shift());
							}
							else {
								this._data.core.working = false;
							}
						}, this);
						if(!args.par) {
							if(this._data.core.worker_queue.length) {
								this._append_json_data.apply(this, this._data.core.worker_queue.shift());
							}
							else {
								this._data.core.working = false;
							}
						}
						else {
							w.postMessage(args);
						}
					}
					else {
						this._data.core.worker_queue.push([dom, data, cb, true]);
					}
				}
				catch(e) {
					rslt.call(this, func(args), false);
					if(this._data.core.worker_queue.length) {
						this._append_json_data.apply(this, this._data.core.worker_queue.shift());
					}
					else {
						this._data.core.working = false;
					}
				}
			}
			else {
				rslt.call(this, func(args), false);
			}
		},
		/**
		 * parses a node from a jQuery object and appends them to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_html(d [, p, ps])
		 * @param  {jQuery} d the jQuery object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_html : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = [].concat(ps); }
			if(p) { ps.unshift(p); }
			var c, e, m = this._model.data,
				data = {
					id			: false,
					text		: false,
					icon		: true,
					parent		: p,
					parents		: ps,
					children	: [],
					children_d	: [],
					data		: null,
					state		: { },
					li_attr		: { id : false },
					a_attr		: { href : '#' },
					original	: false
				}, i, tmp, tid;
			for(i in this._model.default_state) {
				if(this._model.default_state.hasOwnProperty(i)) {
					data.state[i] = this._model.default_state[i];
				}
			}
			tmp = $.vakata.attributes(d, true);
			$.each(tmp, function (i, v) {
				v = $.trim(v);
				if(!v.length) { return true; }
				data.li_attr[i] = v;
				if(i === 'id') {
					data.id = v.toString();
				}
			});
			tmp = d.children('a').first();
			if(tmp.length) {
				tmp = $.vakata.attributes(tmp, true);
				$.each(tmp, function (i, v) {
					v = $.trim(v);
					if(v.length) {
						data.a_attr[i] = v;
					}
				});
			}
			tmp = d.children("a").first().length ? d.children("a").first().clone() : d.clone();
			tmp.children("ins, i, ul").remove();
			tmp = tmp.html();
			tmp = $('<div />').html(tmp);
			data.text = this.settings.core.force_text ? tmp.text() : tmp.html();
			tmp = d.data();
			data.data = tmp ? $.extend(true, {}, tmp) : null;
			data.state.opened = d.hasClass('jstree-open');
			data.state.selected = d.children('a').hasClass('jstree-clicked');
			data.state.disabled = d.children('a').hasClass('jstree-disabled');
			if(data.data && data.data.jstree) {
				for(i in data.data.jstree) {
					if(data.data.jstree.hasOwnProperty(i)) {
						data.state[i] = data.data.jstree[i];
					}
				}
			}
			tmp = d.children("a").children(".jstree-themeicon");
			if(tmp.length) {
				data.icon = tmp.hasClass('jstree-themeicon-hidden') ? false : tmp.attr('rel');
			}
			if(data.state.icon) {
				data.icon = data.state.icon;
			}
			tmp = d.children("ul").children("li");
			do {
				tid = 'j' + this._id + '_' + (++this._cnt);
			} while(m[tid]);
			data.id = data.li_attr.id ? data.li_attr.id.toString() : tid;
			if(tmp.length) {
				tmp.each($.proxy(function (i, v) {
					c = this._parse_model_from_html($(v), data.id, ps);
					e = this._model.data[c];
					data.children.push(c);
					if(e.children_d.length) {
						data.children_d = data.children_d.concat(e.children_d);
					}
				}, this));
				data.children_d = data.children_d.concat(data.children);
			}
			else {
				if(d.hasClass('jstree-closed')) {
					data.state.loaded = false;
				}
			}
			if(data.li_attr['class']) {
				data.li_attr['class'] = data.li_attr['class'].replace('jstree-closed','').replace('jstree-open','');
			}
			if(data.a_attr['class']) {
				data.a_attr['class'] = data.a_attr['class'].replace('jstree-clicked','').replace('jstree-disabled','');
			}
			m[data.id] = data;
			if(data.state.selected) {
				this._data.core.selected.push(data.id);
			}
			return data.id;
		},
		/**
		 * parses a node from a JSON object (used when dealing with flat data, which has no nesting of children, but has id and parent properties) and appends it to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_flat_json(d [, p, ps])
		 * @param  {Object} d the JSON object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_flat_json : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = ps.concat(); }
			if(p) { ps.unshift(p); }
			var tid = d.id.toString(),
				m = this._model.data,
				df = this._model.default_state,
				i, j, c, e,
				tmp = {
					id			: tid,
					text		: d.text || '',
					icon		: d.icon !== undefined ? d.icon : true,
					parent		: p,
					parents		: ps,
					children	: d.children || [],
					children_d	: d.children_d || [],
					data		: d.data,
					state		: { },
					li_attr		: { id : false },
					a_attr		: { href : '#' },
					original	: false
				};
			for(i in df) {
				if(df.hasOwnProperty(i)) {
					tmp.state[i] = df[i];
				}
			}
			if(d && d.data && d.data.jstree && d.data.jstree.icon) {
				tmp.icon = d.data.jstree.icon;
			}
			if(d && d.data) {
				tmp.data = d.data;
				if(d.data.jstree) {
					for(i in d.data.jstree) {
						if(d.data.jstree.hasOwnProperty(i)) {
							tmp.state[i] = d.data.jstree[i];
						}
					}
				}
			}
			if(d && typeof d.state === 'object') {
				for (i in d.state) {
					if(d.state.hasOwnProperty(i)) {
						tmp.state[i] = d.state[i];
					}
				}
			}
			if(d && typeof d.li_attr === 'object') {
				for (i in d.li_attr) {
					if(d.li_attr.hasOwnProperty(i)) {
						tmp.li_attr[i] = d.li_attr[i];
					}
				}
			}
			if(!tmp.li_attr.id) {
				tmp.li_attr.id = tid;
			}
			if(d && typeof d.a_attr === 'object') {
				for (i in d.a_attr) {
					if(d.a_attr.hasOwnProperty(i)) {
						tmp.a_attr[i] = d.a_attr[i];
					}
				}
			}
			if(d && d.children && d.children === true) {
				tmp.state.loaded = false;
				tmp.children = [];
				tmp.children_d = [];
			}
			m[tmp.id] = tmp;
			for(i = 0, j = tmp.children.length; i < j; i++) {
				c = this._parse_model_from_flat_json(m[tmp.children[i]], tmp.id, ps);
				e = m[c];
				tmp.children_d.push(c);
				if(e.children_d.length) {
					tmp.children_d = tmp.children_d.concat(e.children_d);
				}
			}
			delete d.data;
			delete d.children;
			m[tmp.id].original = d;
			if(tmp.state.selected) {
				this._data.core.selected.push(tmp.id);
			}
			return tmp.id;
		},
		/**
		 * parses a node from a JSON object and appends it to the in memory tree model. Used internally.
		 * @private
		 * @name _parse_model_from_json(d [, p, ps])
		 * @param  {Object} d the JSON object to parse
		 * @param  {String} p the parent ID
		 * @param  {Array} ps list of all parents
		 * @return {String} the ID of the object added to the model
		 */
		_parse_model_from_json : function (d, p, ps) {
			if(!ps) { ps = []; }
			else { ps = ps.concat(); }
			if(p) { ps.unshift(p); }
			var tid = false, i, j, c, e, m = this._model.data, df = this._model.default_state, tmp;
			do {
				tid = 'j' + this._id + '_' + (++this._cnt);
			} while(m[tid]);

			tmp = {
				id			: false,
				text		: typeof d === 'string' ? d : '',
				icon		: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
				parent		: p,
				parents		: ps,
				children	: [],
				children_d	: [],
				data		: null,
				state		: { },
				li_attr		: { id : false },
				a_attr		: { href : '#' },
				original	: false
			};
			for(i in df) {
				if(df.hasOwnProperty(i)) {
					tmp.state[i] = df[i];
				}
			}
			if(d && d.id) { tmp.id = d.id.toString(); }
			if(d && d.text) { tmp.text = d.text; }
			if(d && d.data && d.data.jstree && d.data.jstree.icon) {
				tmp.icon = d.data.jstree.icon;
			}
			if(d && d.data) {
				tmp.data = d.data;
				if(d.data.jstree) {
					for(i in d.data.jstree) {
						if(d.data.jstree.hasOwnProperty(i)) {
							tmp.state[i] = d.data.jstree[i];
						}
					}
				}
			}
			if(d && typeof d.state === 'object') {
				for (i in d.state) {
					if(d.state.hasOwnProperty(i)) {
						tmp.state[i] = d.state[i];
					}
				}
			}
			if(d && typeof d.li_attr === 'object') {
				for (i in d.li_attr) {
					if(d.li_attr.hasOwnProperty(i)) {
						tmp.li_attr[i] = d.li_attr[i];
					}
				}
			}
			if(tmp.li_attr.id && !tmp.id) {
				tmp.id = tmp.li_attr.id.toString();
			}
			if(!tmp.id) {
				tmp.id = tid;
			}
			if(!tmp.li_attr.id) {
				tmp.li_attr.id = tmp.id;
			}
			if(d && typeof d.a_attr === 'object') {
				for (i in d.a_attr) {
					if(d.a_attr.hasOwnProperty(i)) {
						tmp.a_attr[i] = d.a_attr[i];
					}
				}
			}
			if(d && d.children && d.children.length) {
				for(i = 0, j = d.children.length; i < j; i++) {
					c = this._parse_model_from_json(d.children[i], tmp.id, ps);
					e = m[c];
					tmp.children.push(c);
					if(e.children_d.length) {
						tmp.children_d = tmp.children_d.concat(e.children_d);
					}
				}
				tmp.children_d = tmp.children_d.concat(tmp.children);
			}
			if(d && d.children && d.children === true) {
				tmp.state.loaded = false;
				tmp.children = [];
				tmp.children_d = [];
			}
			delete d.data;
			delete d.children;
			tmp.original = d;
			m[tmp.id] = tmp;
			if(tmp.state.selected) {
				this._data.core.selected.push(tmp.id);
			}
			return tmp.id;
		},
		/**
		 * redraws all nodes that need to be redrawn. Used internally.
		 * @private
		 * @name _redraw()
		 * @trigger redraw.jstree
		 */
		_redraw : function () {
			var nodes = this._model.force_full_redraw ? this._model.data['#'].children.concat([]) : this._model.changed.concat([]),
				f = document.createElement('UL'), tmp, i, j, fe = this._data.core.focused;
			for(i = 0, j = nodes.length; i < j; i++) {
				tmp = this.redraw_node(nodes[i], true, this._model.force_full_redraw);
				if(tmp && this._model.force_full_redraw) {
					f.appendChild(tmp);
				}
			}
			if(this._model.force_full_redraw) {
				f.className = this.get_container_ul()[0].className;
				f.setAttribute('role','group');
				this.element.empty().append(f);
				//this.get_container_ul()[0].appendChild(f);
			}
			if(fe !== null) {
				tmp = this.get_node(fe, true);
				if(tmp && tmp.length && tmp.children('.jstree-anchor')[0] !== document.activeElement) {
					tmp.children('.jstree-anchor').focus();
				}
				else {
					this._data.core.focused = null;
				}
			}
			this._model.force_full_redraw = false;
			this._model.changed = [];
			/**
			 * triggered after nodes are redrawn
			 * @event
			 * @name redraw.jstree
			 * @param {array} nodes the redrawn nodes
			 */
			this.trigger('redraw', { "nodes" : nodes });
		},
		/**
		 * redraws all nodes that need to be redrawn or optionally - the whole tree
		 * @name redraw([full])
		 * @param {Boolean} full if set to `true` all nodes are redrawn.
		 */
		redraw : function (full) {
			if(full) {
				this._model.force_full_redraw = true;
			}
			//if(this._model.redraw_timeout) {
			//	clearTimeout(this._model.redraw_timeout);
			//}
			//this._model.redraw_timeout = setTimeout($.proxy(this._redraw, this),0);
			this._redraw();
		},
		/**
		 * redraws a single node's children. Used internally.
		 * @private
		 * @name draw_children(node)
		 * @param {mixed} node the node whose children will be redrawn
		 */
		draw_children : function (node) {
			var obj = this.get_node(node),
				i = false,
				j = false,
				k = false,
				d = document;
			if(!obj) { return false; }
			if(obj.id === '#') { return this.redraw(true); }
			node = this.get_node(node, true);
			if(!node || !node.length) { return false; } // TODO: quick toggle

			node.children('.jstree-children').remove();
			node = node[0];
			if(obj.children.length && obj.state.loaded) {
				k = d.createElement('UL');
				k.setAttribute('role', 'group');
				k.className = 'jstree-children';
				for(i = 0, j = obj.children.length; i < j; i++) {
					k.appendChild(this.redraw_node(obj.children[i], true, true));
				}
				node.appendChild(k);
			}
		},
		/**
		 * redraws a single node. Used internally.
		 * @private
		 * @name redraw_node(node, deep, is_callback, force_render)
		 * @param {mixed} node the node to redraw
		 * @param {Boolean} deep should child nodes be redrawn too
		 * @param {Boolean} is_callback is this a recursion call
		 * @param {Boolean} force_render should children of closed parents be drawn anyway
		 */
		redraw_node : function (node, deep, is_callback, force_render) {
			var obj = this.get_node(node),
				par = false,
				ind = false,
				old = false,
				i = false,
				j = false,
				k = false,
				c = '',
				d = document,
				m = this._model.data,
				f = false,
				s = false,
				tmp = null,
				t = 0,
				l = 0;
			if(!obj) { return false; }
			if(obj.id === '#') {  return this.redraw(true); }
			deep = deep || obj.children.length === 0;
			node = !document.querySelector ? document.getElementById(obj.id) : this.element[0].querySelector('#' + ("0123456789".indexOf(obj.id[0]) !== -1 ? '\\3' + obj.id[0] + ' ' + obj.id.substr(1).replace($.jstree.idregex,'\\$&') : obj.id.replace($.jstree.idregex,'\\$&')) ); //, this.element);
			if(!node) {
				deep = true;
				//node = d.createElement('LI');
				if(!is_callback) {
					par = obj.parent !== '#' ? $('#' + obj.parent.replace($.jstree.idregex,'\\$&'), this.element)[0] : null;
					if(par !== null && (!par || !m[obj.parent].state.opened)) {
						return false;
					}
					ind = $.inArray(obj.id, par === null ? m['#'].children : m[obj.parent].children);
				}
			}
			else {
				node = $(node);
				if(!is_callback) {
					par = node.parent().parent()[0];
					if(par === this.element[0]) {
						par = null;
					}
					ind = node.index();
				}
				// m[obj.id].data = node.data(); // use only node's data, no need to touch jquery storage
				if(!deep && obj.children.length && !node.children('.jstree-children').length) {
					deep = true;
				}
				if(!deep) {
					old = node.children('.jstree-children')[0];
				}
				f = node.children('.jstree-anchor')[0] === document.activeElement;
				node.remove();
				//node = d.createElement('LI');
				//node = node[0];
			}
			node = _node.cloneNode(true);
			// node is DOM, deep is boolean

			c = 'jstree-node ';
			for(i in obj.li_attr) {
				if(obj.li_attr.hasOwnProperty(i)) {
					if(i === 'id') { continue; }
					if(i !== 'class') {
						node.setAttribute(i, obj.li_attr[i]);
					}
					else {
						c += obj.li_attr[i];
					}
				}
			}
			if(!obj.a_attr.id) {
				obj.a_attr.id = obj.id + '_anchor';
			}
			node.setAttribute('aria-selected', !!obj.state.selected);
			node.setAttribute('aria-level', obj.parents.length);
			node.setAttribute('aria-labelledby', obj.a_attr.id);
			if(obj.state.disabled) {
				node.setAttribute('aria-disabled', true);
			}

			if(obj.state.loaded && !obj.children.length) {
				c += ' jstree-leaf';
			}
			else {
				c += obj.state.opened && obj.state.loaded ? ' jstree-open' : ' jstree-closed';
				node.setAttribute('aria-expanded', (obj.state.opened && obj.state.loaded) );
			}
			if(obj.parent !== null && m[obj.parent].children[m[obj.parent].children.length - 1] === obj.id) {
				c += ' jstree-last';
			}
			node.id = obj.id;
			node.className = c;
			c = ( obj.state.selected ? ' jstree-clicked' : '') + ( obj.state.disabled ? ' jstree-disabled' : '');
			for(j in obj.a_attr) {
				if(obj.a_attr.hasOwnProperty(j)) {
					if(j === 'href' && obj.a_attr[j] === '#') { continue; }
					if(j !== 'class') {
						node.childNodes[1].setAttribute(j, obj.a_attr[j]);
					}
					else {
						c += ' ' + obj.a_attr[j];
					}
				}
			}
			if(c.length) {
				node.childNodes[1].className = 'jstree-anchor ' + c;
			}
			if((obj.icon && obj.icon !== true) || obj.icon === false) {
				if(obj.icon === false) {
					node.childNodes[1].childNodes[0].className += ' jstree-themeicon-hidden';
				}
				else if(obj.icon.indexOf('/') === -1 && obj.icon.indexOf('.') === -1) {
					node.childNodes[1].childNodes[0].className += ' ' + obj.icon + ' jstree-themeicon-custom';
				}
				else {
					node.childNodes[1].childNodes[0].style.backgroundImage = 'url('+obj.icon+')';
					node.childNodes[1].childNodes[0].style.backgroundPosition = 'center center';
					node.childNodes[1].childNodes[0].style.backgroundSize = 'auto';
					node.childNodes[1].childNodes[0].className += ' jstree-themeicon-custom';
				}
			}

			if(this.settings.core.force_text) {
				node.childNodes[1].appendChild(d.createTextNode(obj.text));
			}
			else {
				node.childNodes[1].innerHTML += obj.text;
			}


			if(deep && obj.children.length && (obj.state.opened || force_render) && obj.state.loaded) {
				k = d.createElement('UL');
				k.setAttribute('role', 'group');
				k.className = 'jstree-children';
				for(i = 0, j = obj.children.length; i < j; i++) {
					k.appendChild(this.redraw_node(obj.children[i], deep, true));
				}
				node.appendChild(k);
			}
			if(old) {
				node.appendChild(old);
			}
			if(!is_callback) {
				// append back using par / ind
				if(!par) {
					par = this.element[0];
				}
				for(i = 0, j = par.childNodes.length; i < j; i++) {
					if(par.childNodes[i] && par.childNodes[i].className && par.childNodes[i].className.indexOf('jstree-children') !== -1) {
						tmp = par.childNodes[i];
						break;
					}
				}
				if(!tmp) {
					tmp = d.createElement('UL');
					tmp.setAttribute('role', 'group');
					tmp.className = 'jstree-children';
					par.appendChild(tmp);
				}
				par = tmp;

				if(ind < par.childNodes.length) {
					par.insertBefore(node, par.childNodes[ind]);
				}
				else {
					par.appendChild(node);
				}
				if(f) {
					t = this.element[0].scrollTop;
					l = this.element[0].scrollLeft;
					node.childNodes[1].focus();
					this.element[0].scrollTop = t;
					this.element[0].scrollLeft = l;
				}
			}
			if(obj.state.opened && !obj.state.loaded) {
				obj.state.opened = false;
				setTimeout($.proxy(function () {
					this.open_node(obj.id, false, 0);
				}, this), 0);
			}
			return node;
		},
		/**
		 * opens a node, revaling its children. If the node is not loaded it will be loaded and opened once ready.
		 * @name open_node(obj [, callback, animation])
		 * @param {mixed} obj the node to open
		 * @param {Function} callback a function to execute once the node is opened
		 * @param {Number} animation the animation duration in milliseconds when opening the node (overrides the `core.animation` setting). Use `false` for no animation.
		 * @trigger open_node.jstree, after_open.jstree, before_open.jstree
		 */
		open_node : function (obj, callback, animation) {
			var t1, t2, d, t;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.open_node(obj[t1], callback, animation);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			animation = animation === undefined ? this.settings.core.animation : animation;
			if(!this.is_closed(obj)) {
				if(callback) {
					callback.call(this, obj, false);
				}
				return false;
			}
			if(!this.is_loaded(obj)) {
				if(this.is_loading(obj)) {
					return setTimeout($.proxy(function () {
						this.open_node(obj, callback, animation);
					}, this), 500);
				}
				this.load_node(obj, function (o, ok) {
					return ok ? this.open_node(o, callback, animation) : (callback ? callback.call(this, o, false) : false);
				});
			}
			else {
				d = this.get_node(obj, true);
				t = this;
				if(d.length) {
					if(animation && d.children(".jstree-children").length) {
						d.children(".jstree-children").stop(true, true);
					}
					if(obj.children.length && !this._firstChild(d.children('.jstree-children')[0])) {
						this.draw_children(obj);
						//d = this.get_node(obj, true);
					}
					if(!animation) {
						this.trigger('before_open', { "node" : obj });
						d[0].className = d[0].className.replace('jstree-closed', 'jstree-open');
						d[0].setAttribute("aria-expanded", true);
					}
					else {
						this.trigger('before_open', { "node" : obj });
						d
							.children(".jstree-children").css("display","none").end()
							.removeClass("jstree-closed").addClass("jstree-open").attr("aria-expanded", true)
							.children(".jstree-children").stop(true, true)
								.slideDown(animation, function () {
									this.style.display = "";
									t.trigger("after_open", { "node" : obj });
								});
					}
				}
				obj.state.opened = true;
				if(callback) {
					callback.call(this, obj, true);
				}
				if(!d.length) {
					/**
					 * triggered when a node is about to be opened (if the node is supposed to be in the DOM, it will be, but it won't be visible yet)
					 * @event
					 * @name before_open.jstree
					 * @param {Object} node the opened node
					 */
					this.trigger('before_open', { "node" : obj });
				}
				/**
				 * triggered when a node is opened (if there is an animation it will not be completed yet)
				 * @event
				 * @name open_node.jstree
				 * @param {Object} node the opened node
				 */
				this.trigger('open_node', { "node" : obj });
				if(!animation || !d.length) {
					/**
					 * triggered when a node is opened and the animation is complete
					 * @event
					 * @name after_open.jstree
					 * @param {Object} node the opened node
					 */
					this.trigger("after_open", { "node" : obj });
				}
			}
		},
		/**
		 * opens every parent of a node (node should be loaded)
		 * @name _open_to(obj)
		 * @param {mixed} obj the node to reveal
		 * @private
		 */
		_open_to : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			var i, j, p = obj.parents;
			for(i = 0, j = p.length; i < j; i+=1) {
				if(i !== '#') {
					this.open_node(p[i], false, 0);
				}
			}
			return $('#' + obj.id.replace($.jstree.idregex,'\\$&'), this.element);
		},
		/**
		 * closes a node, hiding its children
		 * @name close_node(obj [, animation])
		 * @param {mixed} obj the node to close
		 * @param {Number} animation the animation duration in milliseconds when closing the node (overrides the `core.animation` setting). Use `false` for no animation.
		 * @trigger close_node.jstree, after_close.jstree
		 */
		close_node : function (obj, animation) {
			var t1, t2, t, d;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.close_node(obj[t1], animation);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			if(this.is_closed(obj)) {
				return false;
			}
			animation = animation === undefined ? this.settings.core.animation : animation;
			t = this;
			d = this.get_node(obj, true);
			if(d.length) {
				if(!animation) {
					d[0].className = d[0].className.replace('jstree-open', 'jstree-closed');
					d.attr("aria-expanded", false).children('.jstree-children').remove();
				}
				else {
					d
						.children(".jstree-children").attr("style","display:block !important").end()
						.removeClass("jstree-open").addClass("jstree-closed").attr("aria-expanded", false)
						.children(".jstree-children").stop(true, true).slideUp(animation, function () {
							this.style.display = "";
							d.children('.jstree-children').remove();
							t.trigger("after_close", { "node" : obj });
						});
				}
			}
			obj.state.opened = false;
			/**
			 * triggered when a node is closed (if there is an animation it will not be complete yet)
			 * @event
			 * @name close_node.jstree
			 * @param {Object} node the closed node
			 */
			this.trigger('close_node',{ "node" : obj });
			if(!animation || !d.length) {
				/**
				 * triggered when a node is closed and the animation is complete
				 * @event
				 * @name after_close.jstree
				 * @param {Object} node the closed node
				 */
				this.trigger("after_close", { "node" : obj });
			}
		},
		/**
		 * toggles a node - closing it if it is open, opening it if it is closed
		 * @name toggle_node(obj)
		 * @param {mixed} obj the node to toggle
		 */
		toggle_node : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.toggle_node(obj[t1]);
				}
				return true;
			}
			if(this.is_closed(obj)) {
				return this.open_node(obj);
			}
			if(this.is_open(obj)) {
				return this.close_node(obj);
			}
		},
		/**
		 * opens all nodes within a node (or the tree), revaling their children. If the node is not loaded it will be loaded and opened once ready.
		 * @name open_all([obj, animation, original_obj])
		 * @param {mixed} obj the node to open recursively, omit to open all nodes in the tree
		 * @param {Number} animation the animation duration in milliseconds when opening the nodes, the default is no animation
		 * @param {jQuery} reference to the node that started the process (internal use)
		 * @trigger open_all.jstree
		 */
		open_all : function (obj, animation, original_obj) {
			if(!obj) { obj = '#'; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var dom = obj.id === '#' ? this.get_container_ul() : this.get_node(obj, true), i, j, _this;
			if(!dom.length) {
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					if(this.is_closed(this._model.data[obj.children_d[i]])) {
						this._model.data[obj.children_d[i]].state.opened = true;
					}
				}
				return this.trigger('open_all', { "node" : obj });
			}
			original_obj = original_obj || dom;
			_this = this;
			dom = this.is_closed(obj) ? dom.find('.jstree-closed').addBack() : dom.find('.jstree-closed');
			dom.each(function () {
				_this.open_node(
					this,
					function(node, status) { if(status && this.is_parent(node)) { this.open_all(node, animation, original_obj); } },
					animation || 0
				);
			});
			if(original_obj.find('.jstree-closed').length === 0) {
				/**
				 * triggered when an `open_all` call completes
				 * @event
				 * @name open_all.jstree
				 * @param {Object} node the opened node
				 */
				this.trigger('open_all', { "node" : this.get_node(original_obj) });
			}
		},
		/**
		 * closes all nodes within a node (or the tree), revaling their children
		 * @name close_all([obj, animation])
		 * @param {mixed} obj the node to close recursively, omit to close all nodes in the tree
		 * @param {Number} animation the animation duration in milliseconds when closing the nodes, the default is no animation
		 * @trigger close_all.jstree
		 */
		close_all : function (obj, animation) {
			if(!obj) { obj = '#'; }
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var dom = obj.id === '#' ? this.get_container_ul() : this.get_node(obj, true),
				_this = this, i, j;
			if(!dom.length) {
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					this._model.data[obj.children_d[i]].state.opened = false;
				}
				return this.trigger('close_all', { "node" : obj });
			}
			dom = this.is_open(obj) ? dom.find('.jstree-open').addBack() : dom.find('.jstree-open');
			$(dom.get().reverse()).each(function () { _this.close_node(this, animation || 0); });
			/**
			 * triggered when an `close_all` call completes
			 * @event
			 * @name close_all.jstree
			 * @param {Object} node the closed node
			 */
			this.trigger('close_all', { "node" : obj });
		},
		/**
		 * checks if a node is disabled (not selectable)
		 * @name is_disabled(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		is_disabled : function (obj) {
			obj = this.get_node(obj);
			return obj && obj.state && obj.state.disabled;
		},
		/**
		 * enables a node - so that it can be selected
		 * @name enable_node(obj)
		 * @param {mixed} obj the node to enable
		 * @trigger enable_node.jstree
		 */
		enable_node : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.enable_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			obj.state.disabled = false;
			this.get_node(obj,true).children('.jstree-anchor').removeClass('jstree-disabled').attr('aria-disabled', false);
			/**
			 * triggered when an node is enabled
			 * @event
			 * @name enable_node.jstree
			 * @param {Object} node the enabled node
			 */
			this.trigger('enable_node', { 'node' : obj });
		},
		/**
		 * disables a node - so that it can not be selected
		 * @name disable_node(obj)
		 * @param {mixed} obj the node to disable
		 * @trigger disable_node.jstree
		 */
		disable_node : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.disable_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			obj.state.disabled = true;
			this.get_node(obj,true).children('.jstree-anchor').addClass('jstree-disabled').attr('aria-disabled', true);
			/**
			 * triggered when an node is disabled
			 * @event
			 * @name disable_node.jstree
			 * @param {Object} node the disabled node
			 */
			this.trigger('disable_node', { 'node' : obj });
		},
		/**
		 * called when a node is selected by the user. Used internally.
		 * @private
		 * @name activate_node(obj, e)
		 * @param {mixed} obj the node
		 * @param {Object} e the related event
		 * @trigger activate_node.jstree, changed.jstree
		 */
		activate_node : function (obj, e) {
			if(this.is_disabled(obj)) {
				return false;
			}

			// ensure last_clicked is still in the DOM, make it fresh (maybe it was moved?) and make sure it is still selected, if not - make last_clicked the last selected node
			this._data.core.last_clicked = this._data.core.last_clicked && this._data.core.last_clicked.id !== undefined ? this.get_node(this._data.core.last_clicked.id) : null;
			if(this._data.core.last_clicked && !this._data.core.last_clicked.state.selected) { this._data.core.last_clicked = null; }
			if(!this._data.core.last_clicked && this._data.core.selected.length) { this._data.core.last_clicked = this.get_node(this._data.core.selected[this._data.core.selected.length - 1]); }

			if(!this.settings.core.multiple || (!e.metaKey && !e.ctrlKey && !e.shiftKey) || (e.shiftKey && (!this._data.core.last_clicked || !this.get_parent(obj) || this.get_parent(obj) !== this._data.core.last_clicked.parent ) )) {
				if(!this.settings.core.multiple && (e.metaKey || e.ctrlKey || e.shiftKey) && this.is_selected(obj)) {
					this.deselect_node(obj, false, e);
				}
				else {
					this.deselect_all(true);
					this.select_node(obj, false, false, e);
					this._data.core.last_clicked = this.get_node(obj);
				}
			}
			else {
				if(e.shiftKey) {
					var o = this.get_node(obj).id,
						l = this._data.core.last_clicked.id,
						p = this.get_node(this._data.core.last_clicked.parent).children,
						c = false,
						i, j;
					for(i = 0, j = p.length; i < j; i += 1) {
						// separate IFs work whem o and l are the same
						if(p[i] === o) {
							c = !c;
						}
						if(p[i] === l) {
							c = !c;
						}
						if(c || p[i] === o || p[i] === l) {
							this.select_node(p[i], true, false, e);
						}
						else {
							this.deselect_node(p[i], true, e);
						}
					}
					this.trigger('changed', { 'action' : 'select_node', 'node' : this.get_node(obj), 'selected' : this._data.core.selected, 'event' : e });
				}
				else {
					if(!this.is_selected(obj)) {
						this.select_node(obj, false, false, e);
					}
					else {
						this.deselect_node(obj, false, e);
					}
				}
			}
			/**
			 * triggered when an node is clicked or intercated with by the user
			 * @event
			 * @name activate_node.jstree
			 * @param {Object} node
			 */
			this.trigger('activate_node', { 'node' : this.get_node(obj) });
		},
		/**
		 * applies the hover state on a node, called when a node is hovered by the user. Used internally.
		 * @private
		 * @name hover_node(obj)
		 * @param {mixed} obj
		 * @trigger hover_node.jstree
		 */
		hover_node : function (obj) {
			obj = this.get_node(obj, true);
			if(!obj || !obj.length || obj.children('.jstree-hovered').length) {
				return false;
			}
			var o = this.element.find('.jstree-hovered'), t = this.element;
			if(o && o.length) { this.dehover_node(o); }

			obj.children('.jstree-anchor').addClass('jstree-hovered');
			/**
			 * triggered when an node is hovered
			 * @event
			 * @name hover_node.jstree
			 * @param {Object} node
			 */
			this.trigger('hover_node', { 'node' : this.get_node(obj) });
			setTimeout(function () { t.attr('aria-activedescendant', obj[0].id); }, 0);
		},
		/**
		 * removes the hover state from a nodecalled when a node is no longer hovered by the user. Used internally.
		 * @private
		 * @name dehover_node(obj)
		 * @param {mixed} obj
		 * @trigger dehover_node.jstree
		 */
		dehover_node : function (obj) {
			obj = this.get_node(obj, true);
			if(!obj || !obj.length || !obj.children('.jstree-hovered').length) {
				return false;
			}
			obj.children('.jstree-anchor').removeClass('jstree-hovered');
			/**
			 * triggered when an node is no longer hovered
			 * @event
			 * @name dehover_node.jstree
			 * @param {Object} node
			 */
			this.trigger('dehover_node', { 'node' : this.get_node(obj) });
		},
		/**
		 * select a node
		 * @name select_node(obj [, supress_event, prevent_open])
		 * @param {mixed} obj an array can be used to select multiple nodes
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @param {Boolean} prevent_open if set to `true` parents of the selected node won't be opened
		 * @trigger select_node.jstree, changed.jstree
		 */
		select_node : function (obj, supress_event, prevent_open, e) {
			var dom, t1, t2, th;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.select_node(obj[t1], supress_event, prevent_open, e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			dom = this.get_node(obj, true);
			if(!obj.state.selected) {
				obj.state.selected = true;
				this._data.core.selected.push(obj.id);
				if(!prevent_open) {
					dom = this._open_to(obj);
				}
				if(dom && dom.length) {
					dom.attr('aria-selected', true).children('.jstree-anchor').addClass('jstree-clicked');
				}
				/**
				 * triggered when an node is selected
				 * @event
				 * @name select_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this select_node
				 */
				this.trigger('select_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				if(!supress_event) {
					/**
					 * triggered when selection changes
					 * @event
					 * @name changed.jstree
					 * @param {Object} node
					 * @param {Object} action the action that caused the selection to change
					 * @param {Array} selected the current selection
					 * @param {Object} event the event (if any) that triggered this changed event
					 */
					this.trigger('changed', { 'action' : 'select_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				}
			}
		},
		/**
		 * deselect a node
		 * @name deselect_node(obj [, supress_event])
		 * @param {mixed} obj an array can be used to deselect multiple nodes
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger deselect_node.jstree, changed.jstree
		 */
		deselect_node : function (obj, supress_event, e) {
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.deselect_node(obj[t1], supress_event, e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			dom = this.get_node(obj, true);
			if(obj.state.selected) {
				obj.state.selected = false;
				this._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.id);
				if(dom.length) {
					dom.attr('aria-selected', false).children('.jstree-anchor').removeClass('jstree-clicked');
				}
				/**
				 * triggered when an node is deselected
				 * @event
				 * @name deselect_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this deselect_node
				 */
				this.trigger('deselect_node', { 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				if(!supress_event) {
					this.trigger('changed', { 'action' : 'deselect_node', 'node' : obj, 'selected' : this._data.core.selected, 'event' : e });
				}
			}
		},
		/**
		 * select all nodes in the tree
		 * @name select_all([supress_event])
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger select_all.jstree, changed.jstree
		 */
		select_all : function (supress_event) {
			var tmp = this._data.core.selected.concat([]), i, j;
			this._data.core.selected = this._model.data['#'].children_d.concat();
			for(i = 0, j = this._data.core.selected.length; i < j; i++) {
				if(this._model.data[this._data.core.selected[i]]) {
					this._model.data[this._data.core.selected[i]].state.selected = true;
				}
			}
			this.redraw(true);
			/**
			 * triggered when all nodes are selected
			 * @event
			 * @name select_all.jstree
			 * @param {Array} selected the current selection
			 */
			this.trigger('select_all', { 'selected' : this._data.core.selected });
			if(!supress_event) {
				this.trigger('changed', { 'action' : 'select_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
			}
		},
		/**
		 * deselect all selected nodes
		 * @name deselect_all([supress_event])
		 * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
		 * @trigger deselect_all.jstree, changed.jstree
		 */
		deselect_all : function (supress_event) {
			var tmp = this._data.core.selected.concat([]), i, j;
			for(i = 0, j = this._data.core.selected.length; i < j; i++) {
				if(this._model.data[this._data.core.selected[i]]) {
					this._model.data[this._data.core.selected[i]].state.selected = false;
				}
			}
			this._data.core.selected = [];
			this.element.find('.jstree-clicked').removeClass('jstree-clicked').parent().attr('aria-selected', false);
			/**
			 * triggered when all nodes are deselected
			 * @event
			 * @name deselect_all.jstree
			 * @param {Object} node the previous selection
			 * @param {Array} selected the current selection
			 */
			this.trigger('deselect_all', { 'selected' : this._data.core.selected, 'node' : tmp });
			if(!supress_event) {
				this.trigger('changed', { 'action' : 'deselect_all', 'selected' : this._data.core.selected, 'old_selection' : tmp });
			}
		},
		/**
		 * checks if a node is selected
		 * @name is_selected(obj)
		 * @param  {mixed}  obj
		 * @return {Boolean}
		 */
		is_selected : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			return obj.state.selected;
		},
		/**
		 * get an array of all selected nodes
		 * @name get_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_selected : function (full) {
			return full ? $.map(this._data.core.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.core.selected.slice();
		},
		/**
		 * get an array of all top level selected nodes (ignoring children of selected nodes)
		 * @name get_top_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_top_selected : function (full) {
			var tmp = this.get_selected(true),
				obj = {}, i, j, k, l;
			for(i = 0, j = tmp.length; i < j; i++) {
				obj[tmp[i].id] = tmp[i];
			}
			for(i = 0, j = tmp.length; i < j; i++) {
				for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
					if(obj[tmp[i].children_d[k]]) {
						delete obj[tmp[i].children_d[k]];
					}
				}
			}
			tmp = [];
			for(i in obj) {
				if(obj.hasOwnProperty(i)) {
					tmp.push(i);
				}
			}
			return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
		},
		/**
		 * get an array of all bottom level selected nodes (ignoring selected parents)
		 * @name get_bottom_selected([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 */
		get_bottom_selected : function (full) {
			var tmp = this.get_selected(true),
				obj = [], i, j;
			for(i = 0, j = tmp.length; i < j; i++) {
				if(!tmp[i].children.length) {
					obj.push(tmp[i].id);
				}
			}
			return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
		},
		/**
		 * gets the current state of the tree so that it can be restored later with `set_state(state)`. Used internally.
		 * @name get_state()
		 * @private
		 * @return {Object}
		 */
		get_state : function () {
			var state	= {
				'core' : {
					'open' : [],
					'scroll' : {
						'left' : this.element.scrollLeft(),
						'top' : this.element.scrollTop()
					},
					/*!
					'themes' : {
						'name' : this.get_theme(),
						'icons' : this._data.core.themes.icons,
						'dots' : this._data.core.themes.dots
					},
					*/
					'selected' : []
				}
			}, i;
			for(i in this._model.data) {
				if(this._model.data.hasOwnProperty(i)) {
					if(i !== '#') {
						if(this._model.data[i].state.opened) {
							state.core.open.push(i);
						}
						if(this._model.data[i].state.selected) {
							state.core.selected.push(i);
						}
					}
				}
			}
			return state;
		},
		/**
		 * sets the state of the tree. Used internally.
		 * @name set_state(state [, callback])
		 * @private
		 * @param {Object} state the state to restore
		 * @param {Function} callback an optional function to execute once the state is restored.
		 * @trigger set_state.jstree
		 */
		set_state : function (state, callback) {
			if(state) {
				if(state.core) {
					var res, n, t, _this;
					if(state.core.open) {
						if(!$.isArray(state.core.open)) {
							delete state.core.open;
							this.set_state(state, callback);
							return false;
						}
						res = true;
						n = false;
						t = this;
						$.each(state.core.open.concat([]), function (i, v) {
							n = t.get_node(v);
							if(n) {
								if(t.is_loaded(v)) {
									if(t.is_closed(v)) {
										t.open_node(v, false, 0);
									}
									if(state && state.core && state.core.open) {
										$.vakata.array_remove_item(state.core.open, v);
									}
								}
								else {
									if(!t.is_loading(v)) {
										t.open_node(v, $.proxy(function (o, s) {
											if(!s && state && state.core && state.core.open) {
												$.vakata.array_remove_item(state.core.open, o.id);
											}
											this.set_state(state, callback);
										}, t), 0);
									}
									// there will be some async activity - so wait for it
									res = false;
								}
							}
						});
						if(res) {
							delete state.core.open;
							this.set_state(state, callback);
						}
						return false;
					}
					if(state.core.scroll) {
						if(state.core.scroll && state.core.scroll.left !== undefined) {
							this.element.scrollLeft(state.core.scroll.left);
						}
						if(state.core.scroll && state.core.scroll.top !== undefined) {
							this.element.scrollTop(state.core.scroll.top);
						}
						delete state.core.scroll;
						this.set_state(state, callback);
						return false;
					}
					/*!
					if(state.core.themes) {
						if(state.core.themes.name) {
							this.set_theme(state.core.themes.name);
						}
						if(typeof state.core.themes.dots !== 'undefined') {
							this[ state.core.themes.dots ? "show_dots" : "hide_dots" ]();
						}
						if(typeof state.core.themes.icons !== 'undefined') {
							this[ state.core.themes.icons ? "show_icons" : "hide_icons" ]();
						}
						delete state.core.themes;
						delete state.core.open;
						this.set_state(state, callback);
						return false;
					}
					*/
					if(state.core.selected) {
						_this = this;
						this.deselect_all();
						$.each(state.core.selected, function (i, v) {
							_this.select_node(v);
						});
						delete state.core.selected;
						this.set_state(state, callback);
						return false;
					}
					if($.isEmptyObject(state.core)) {
						delete state.core;
						this.set_state(state, callback);
						return false;
					}
				}
				if($.isEmptyObject(state)) {
					state = null;
					if(callback) { callback.call(this); }
					/**
					 * triggered when a `set_state` call completes
					 * @event
					 * @name set_state.jstree
					 */
					this.trigger('set_state');
					return false;
				}
				return true;
			}
			return false;
		},
		/**
		 * refreshes the tree - all nodes are reloaded with calls to `load_node`.
		 * @name refresh()
		 * @param {Boolean} skip_loading an option to skip showing the loading indicator
		 * @param {Mixed} forget_state if set to `true` state will not be reapplied, if set to a function (receiving the current state as argument) the result of that function will be used as state
		 * @trigger refresh.jstree
		 */
		refresh : function (skip_loading, forget_state) {
			this._data.core.state = forget_state === true ? {} : this.get_state();
			if(forget_state && $.isFunction(forget_state)) { this._data.core.state = forget_state.call(this, this._data.core.state); }
			this._cnt = 0;
			this._model.data = {
				'#' : {
					id : '#',
					parent : null,
					parents : [],
					children : [],
					children_d : [],
					state : { loaded : false }
				}
			};
			var c = this.get_container_ul()[0].className;
			if(!skip_loading) {
				this.element.html("<"+"ul class='"+c+"' role='group'><"+"li class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='treeitem' id='j"+this._id+"_loading'><i class='jstree-icon jstree-ocl'></i><"+"a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
				this.element.attr('aria-activedescendant','j'+this._id+'_loading');
			}
			this.load_node('#', function (o, s) {
				if(s) {
					this.get_container_ul()[0].className = c;
					if(this._firstChild(this.get_container_ul()[0])) {
						this.element.attr('aria-activedescendant',this._firstChild(this.get_container_ul()[0]).id);
					}
					this.set_state($.extend(true, {}, this._data.core.state), function () {
						/**
						 * triggered when a `refresh` call completes
						 * @event
						 * @name refresh.jstree
						 */
						this.trigger('refresh');
					});
				}
				this._data.core.state = null;
			});
		},
		/**
		 * refreshes a node in the tree (reload its children) all opened nodes inside that node are reloaded with calls to `load_node`.
		 * @name refresh_node(obj)
		 * @param  {mixed} obj the node
		 * @trigger refresh_node.jstree
		 */
		refresh_node : function (obj) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			var opened = [], to_load = [], s = this._data.core.selected.concat([]);
			to_load.push(obj.id);
			if(obj.state.opened === true) { opened.push(obj.id); }
			this.get_node(obj, true).find('.jstree-open').each(function() { opened.push(this.id); });
			this._load_nodes(to_load, $.proxy(function (nodes) {
				this.open_node(opened, false, 0);
				this.select_node(this._data.core.selected);
				/**
				 * triggered when a node is refreshed
				 * @event
				 * @name refresh_node.jstree
				 * @param {Object} node - the refreshed node
				 * @param {Array} nodes - an array of the IDs of the nodes that were reloaded
				 */
				this.trigger('refresh_node', { 'node' : obj, 'nodes' : nodes });
			}, this));
		},
		/**
		 * set (change) the ID of a node
		 * @name set_id(obj, id)
		 * @param  {mixed} obj the node
		 * @param  {String} id the new ID
		 * @return {Boolean}
		 */
		set_id : function (obj, id) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			var i, j, m = this._model.data;
			id = id.toString();
			// update parents (replace current ID with new one in children and children_d)
			m[obj.parent].children[$.inArray(obj.id, m[obj.parent].children)] = id;
			for(i = 0, j = obj.parents.length; i < j; i++) {
				m[obj.parents[i]].children_d[$.inArray(obj.id, m[obj.parents[i]].children_d)] = id;
			}
			// update children (replace current ID with new one in parent and parents)
			for(i = 0, j = obj.children.length; i < j; i++) {
				m[obj.children[i]].parent = id;
			}
			for(i = 0, j = obj.children_d.length; i < j; i++) {
				m[obj.children_d[i]].parents[$.inArray(obj.id, m[obj.children_d[i]].parents)] = id;
			}
			i = $.inArray(obj.id, this._data.core.selected);
			if(i !== -1) { this._data.core.selected[i] = id; }
			// update model and obj itself (obj.id, this._model.data[KEY])
			i = this.get_node(obj.id, true);
			if(i) {
				i.attr('id', id);
			}
			delete m[obj.id];
			obj.id = id;
			m[id] = obj;
			return true;
		},
		/**
		 * get the text value of a node
		 * @name get_text(obj)
		 * @param  {mixed} obj the node
		 * @return {String}
		 */
		get_text : function (obj) {
			obj = this.get_node(obj);
			return (!obj || obj.id === '#') ? false : obj.text;
		},
		/**
		 * set the text value of a node. Used internally, please use `rename_node(obj, val)`.
		 * @private
		 * @name set_text(obj, val)
		 * @param  {mixed} obj the node, you can pass an array to set the text on multiple nodes
		 * @param  {String} val the new text value
		 * @return {Boolean}
		 * @trigger set_text.jstree
		 */
		set_text : function (obj, val) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_text(obj[t1], val);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			obj.text = val;
			if(this.get_node(obj, true).length) {
				this.redraw_node(obj.id);
			}
			/**
			 * triggered when a node text value is changed
			 * @event
			 * @name set_text.jstree
			 * @param {Object} obj
			 * @param {String} text the new value
			 */
			this.trigger('set_text',{ "obj" : obj, "text" : val });
			return true;
		},
		/**
		 * gets a JSON representation of a node (or the whole tree)
		 * @name get_json([obj, options])
		 * @param  {mixed} obj
		 * @param  {Object} options
		 * @param  {Boolean} options.no_state do not return state information
		 * @param  {Boolean} options.no_id do not return ID
		 * @param  {Boolean} options.no_children do not include children
		 * @param  {Boolean} options.no_data do not include node data
		 * @param  {Boolean} options.flat return flat JSON instead of nested
		 * @return {Object}
		 */
		get_json : function (obj, options, flat) {
			obj = this.get_node(obj || '#');
			if(!obj) { return false; }
			if(options && options.flat && !flat) { flat = []; }
			var tmp = {
				'id' : obj.id,
				'text' : obj.text,
				'icon' : this.get_icon(obj),
				'li_attr' : $.extend(true, {}, obj.li_attr),
				'a_attr' : $.extend(true, {}, obj.a_attr),
				'state' : {},
				'data' : options && options.no_data ? false : $.extend(true, {}, obj.data)
				//( this.get_node(obj, true).length ? this.get_node(obj, true).data() : obj.data ),
			}, i, j;
			if(options && options.flat) {
				tmp.parent = obj.parent;
			}
			else {
				tmp.children = [];
			}
			if(!options || !options.no_state) {
				for(i in obj.state) {
					if(obj.state.hasOwnProperty(i)) {
						tmp.state[i] = obj.state[i];
					}
				}
			}
			if(options && options.no_id) {
				delete tmp.id;
				if(tmp.li_attr && tmp.li_attr.id) {
					delete tmp.li_attr.id;
				}
				if(tmp.a_attr && tmp.a_attr.id) {
					delete tmp.a_attr.id;
				}
			}
			if(options && options.flat && obj.id !== '#') {
				flat.push(tmp);
			}
			if(!options || !options.no_children) {
				for(i = 0, j = obj.children.length; i < j; i++) {
					if(options && options.flat) {
						this.get_json(obj.children[i], options, flat);
					}
					else {
						tmp.children.push(this.get_json(obj.children[i], options));
					}
				}
			}
			return options && options.flat ? flat : (obj.id === '#' ? tmp.children : tmp);
		},
		/**
		 * create a new node (do not confuse with load_node)
		 * @name create_node([obj, node, pos, callback, is_loaded])
		 * @param  {mixed}   par       the parent node (to create a root node use either "#" (string) or `null`)
		 * @param  {mixed}   node      the data for the new node (a valid JSON object, or a simple string with the name)
		 * @param  {mixed}   pos       the index at which to insert the node, "first" and "last" are also supported, default is "last"
		 * @param  {Function} callback a function to be called once the node is created
		 * @param  {Boolean} is_loaded internal argument indicating if the parent node was succesfully loaded
		 * @return {String}            the ID of the newly create node
		 * @trigger model.jstree, create_node.jstree
		 */
		create_node : function (par, node, pos, callback, is_loaded) {
			if(par === null) { par = "#"; }
			par = this.get_node(par);
			if(!par) { return false; }
			pos = pos === undefined ? "last" : pos;
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.create_node(par, node, pos, callback, true); });
			}
			if(!node) { node = { "text" : this.get_string('New node') }; }
			if(typeof node === "string") { node = { "text" : node }; }
			if(node.text === undefined) { node.text = this.get_string('New node'); }
			var tmp, dpc, i, j;

			if(par.id === '#') {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					tmp = this.get_node(par.parent);
					pos = $.inArray(par.id, tmp.children);
					par = tmp;
					break;
				case "after" :
					tmp = this.get_node(par.parent);
					pos = $.inArray(par.id, tmp.children) + 1;
					par = tmp;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > par.children.length) { pos = par.children.length; }
			if(!node.id) { node.id = true; }
			if(!this.check("create_node", node, par, pos)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(node.id === true) { delete node.id; }
			node = this._parse_model_from_json(node, par.id, par.parents.concat());
			if(!node) { return false; }
			tmp = this.get_node(node);
			dpc = [];
			dpc.push(node);
			dpc = dpc.concat(tmp.children_d);
			this.trigger('model', { "nodes" : dpc, "parent" : par.id });

			par.children_d = par.children_d.concat(dpc);
			for(i = 0, j = par.parents.length; i < j; i++) {
				this._model.data[par.parents[i]].children_d = this._model.data[par.parents[i]].children_d.concat(dpc);
			}
			node = tmp;
			tmp = [];
			for(i = 0, j = par.children.length; i < j; i++) {
				tmp[i >= pos ? i+1 : i] = par.children[i];
			}
			tmp[pos] = node.id;
			par.children = tmp;

			this.redraw_node(par, true);
			if(callback) { callback.call(this, this.get_node(node)); }
			/**
			 * triggered when a node is created
			 * @event
			 * @name create_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the new node among the parent's children
			 */
			this.trigger('create_node', { "node" : this.get_node(node), "parent" : par.id, "position" : pos });
			return node.id;
		},
		/**
		 * set the text value of a node
		 * @name rename_node(obj, val)
		 * @param  {mixed} obj the node, you can pass an array to rename multiple nodes to the same name
		 * @param  {String} val the new text value
		 * @return {Boolean}
		 * @trigger rename_node.jstree
		 */
		rename_node : function (obj, val) {
			var t1, t2, old;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.rename_node(obj[t1], val);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			old = obj.text;
			if(!this.check("rename_node", obj, this.get_parent(obj), val)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			this.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))
			/**
			 * triggered when a node is renamed
			 * @event
			 * @name rename_node.jstree
			 * @param {Object} node
			 * @param {String} text the new value
			 * @param {String} old the old value
			 */
			this.trigger('rename_node', { "node" : obj, "text" : val, "old" : old });
			return true;
		},
		/**
		 * remove a node
		 * @name delete_node(obj)
		 * @param  {mixed} obj the node, you can pass an array to delete multiple nodes
		 * @return {Boolean}
		 * @trigger delete_node.jstree, changed.jstree
		 */
		delete_node : function (obj) {
			var t1, t2, par, pos, tmp, i, j, k, l, c;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.delete_node(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			par = this.get_node(obj.parent);
			pos = $.inArray(obj.id, par.children);
			c = false;
			if(!this.check("delete_node", obj, par, pos)) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(pos !== -1) {
				par.children = $.vakata.array_remove(par.children, pos);
			}
			tmp = obj.children_d.concat([]);
			tmp.push(obj.id);
			for(k = 0, l = tmp.length; k < l; k++) {
				for(i = 0, j = obj.parents.length; i < j; i++) {
					pos = $.inArray(tmp[k], this._model.data[obj.parents[i]].children_d);
					if(pos !== -1) {
						this._model.data[obj.parents[i]].children_d = $.vakata.array_remove(this._model.data[obj.parents[i]].children_d, pos);
					}
				}
				if(this._model.data[tmp[k]].state.selected) {
					c = true;
					pos = $.inArray(tmp[k], this._data.core.selected);
					if(pos !== -1) {
						this._data.core.selected = $.vakata.array_remove(this._data.core.selected, pos);
					}
				}
			}
			/**
			 * triggered when a node is deleted
			 * @event
			 * @name delete_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 */
			this.trigger('delete_node', { "node" : obj, "parent" : par.id });
			if(c) {
				this.trigger('changed', { 'action' : 'delete_node', 'node' : obj, 'selected' : this._data.core.selected, 'parent' : par.id });
			}
			for(k = 0, l = tmp.length; k < l; k++) {
				delete this._model.data[tmp[k]];
			}
			this.redraw_node(par, true);
			return true;
		},
		/**
		 * check if an operation is premitted on the tree. Used internally.
		 * @private
		 * @name check(chk, obj, par, pos)
		 * @param  {String} chk the operation to check, can be "create_node", "rename_node", "delete_node", "copy_node" or "move_node"
		 * @param  {mixed} obj the node
		 * @param  {mixed} par the parent
		 * @param  {mixed} pos the position to insert at, or if "rename_node" - the new name
		 * @param  {mixed} more some various additional information, for example if a "move_node" operations is triggered by DND this will be the hovered node
		 * @return {Boolean}
		 */
		check : function (chk, obj, par, pos, more) {
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			var tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,
				chc = this.settings.core.check_callback;
			if(chk === "move_node" || chk === "copy_node") {
				if((!more || !more.is_multi) && (obj.id === par.id || $.inArray(obj.id, par.children) === pos || $.inArray(par.id, obj.children_d) !== -1)) {
					this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_01', 'reason' : 'Moving parent inside child', 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					return false;
				}
			}
			if(tmp && tmp.data) { tmp = tmp.data; }
			if(tmp && tmp.functions && (tmp.functions[chk] === false || tmp.functions[chk] === true)) {
				if(tmp.functions[chk] === false) {
					this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_02', 'reason' : 'Node data prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
				}
				return tmp.functions[chk];
			}
			if(chc === false || ($.isFunction(chc) && chc.call(this, chk, obj, par, pos, more) === false) || (chc && chc[chk] === false)) {
				this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_03', 'reason' : 'User config for core.check_callback prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
				return false;
			}
			return true;
		},
		/**
		 * get the last error
		 * @name last_error()
		 * @return {Object}
		 */
		last_error : function () {
			return this._data.core.last_error;
		},
		/**
		 * move a node to a new parent
		 * @name move_node(obj, par [, pos, callback, is_loaded])
		 * @param  {mixed} obj the node to move, pass an array to move multiple nodes
		 * @param  {mixed} par the new parent
		 * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
		 * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
		 * @param  {Boolean} internal parameter indicating if the parent node has been loaded
		 * @param  {Boolean} internal parameter indicating if the tree should be redrawn
		 * @trigger move_node.jstree
		 */
		move_node : function (obj, par, pos, callback, is_loaded, skip_redraw) {
			var t1, t2, old_par, old_pos, new_par, old_ins, is_multi, dpc, tmp, i, j, k, l, p;

			par = this.get_node(par);
			pos = pos === undefined ? 0 : pos;
			if(!par) { return false; }
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.move_node(obj, par, pos, callback, true); });
			}

			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					if(this.move_node(obj[t1], par, pos, callback, is_loaded, true)) {
						par = obj[t1];
						pos = "after";
					}
				}
				this.redraw();
				return true;
			}
			obj = obj && obj.id ? obj : this.get_node(obj);

			if(!obj || obj.id === '#') { return false; }

			old_par = (obj.parent || '#').toString();
			new_par = (!pos.toString().match(/^(before|after)$/) || par.id === '#') ? par : this.get_node(par.parent);
			old_ins = obj.instance ? obj.instance : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
			is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);
			old_pos = old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1;
			if(is_multi) {
				if(this.copy_node(obj, par, pos, callback, is_loaded)) {
					if(old_ins) { old_ins.delete_node(obj); }
					return true;
				}
				return false;
			}
			//var m = this._model.data;
			if(par.id === '#') {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					pos = $.inArray(par.id, new_par.children);
					break;
				case "after" :
					pos = $.inArray(par.id, new_par.children) + 1;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = new_par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > new_par.children.length) { pos = new_par.children.length; }
			if(!this.check("move_node", obj, new_par, pos, { 'core' : true, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			if(obj.parent === new_par.id) {
				dpc = new_par.children.concat();
				tmp = $.inArray(obj.id, dpc);
				if(tmp !== -1) {
					dpc = $.vakata.array_remove(dpc, tmp);
					if(pos > tmp) { pos--; }
				}
				tmp = [];
				for(i = 0, j = dpc.length; i < j; i++) {
					tmp[i >= pos ? i+1 : i] = dpc[i];
				}
				tmp[pos] = obj.id;
				new_par.children = tmp;
				this._node_changed(new_par.id);
				this.redraw(new_par.id === '#');
			}
			else {
				// clean old parent and up
				tmp = obj.children_d.concat();
				tmp.push(obj.id);
				for(i = 0, j = obj.parents.length; i < j; i++) {
					dpc = [];
					p = old_ins._model.data[obj.parents[i]].children_d;
					for(k = 0, l = p.length; k < l; k++) {
						if($.inArray(p[k], tmp) === -1) {
							dpc.push(p[k]);
						}
					}
					old_ins._model.data[obj.parents[i]].children_d = dpc;
				}
				old_ins._model.data[old_par].children = $.vakata.array_remove_item(old_ins._model.data[old_par].children, obj.id);

				// insert into new parent and up
				for(i = 0, j = new_par.parents.length; i < j; i++) {
					this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(tmp);
				}
				dpc = [];
				for(i = 0, j = new_par.children.length; i < j; i++) {
					dpc[i >= pos ? i+1 : i] = new_par.children[i];
				}
				dpc[pos] = obj.id;
				new_par.children = dpc;
				new_par.children_d.push(obj.id);
				new_par.children_d = new_par.children_d.concat(obj.children_d);

				// update object
				obj.parent = new_par.id;
				tmp = new_par.parents.concat();
				tmp.unshift(new_par.id);
				p = obj.parents.length;
				obj.parents = tmp;

				// update object children
				tmp = tmp.concat();
				for(i = 0, j = obj.children_d.length; i < j; i++) {
					this._model.data[obj.children_d[i]].parents = this._model.data[obj.children_d[i]].parents.slice(0,p*-1);
					Array.prototype.push.apply(this._model.data[obj.children_d[i]].parents, tmp);
				}

				if(old_par === '#' || new_par.id === '#') {
					this._model.force_full_redraw = true;
				}
				if(!this._model.force_full_redraw) {
					this._node_changed(old_par);
					this._node_changed(new_par.id);
				}
				if(!skip_redraw) {
					this.redraw();
				}
			}
			if(callback) { callback.call(this, obj, new_par, pos); }
			/**
			 * triggered when a node is moved
			 * @event
			 * @name move_node.jstree
			 * @param {Object} node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the node among the parent's children
			 * @param {String} old_parent the old parent of the node
			 * @param {Number} old_position the old position of the node
			 * @param {Boolean} is_multi do the node and new parent belong to different instances
			 * @param {jsTree} old_instance the instance the node came from
			 * @param {jsTree} new_instance the instance of the new parent
			 */
			this.trigger('move_node', { "node" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_pos, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
			return true;
		},
		/**
		 * copy a node to a new parent
		 * @name copy_node(obj, par [, pos, callback, is_loaded])
		 * @param  {mixed} obj the node to copy, pass an array to copy multiple nodes
		 * @param  {mixed} par the new parent
		 * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
		 * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
		 * @param  {Boolean} internal parameter indicating if the parent node has been loaded
		 * @param  {Boolean} internal parameter indicating if the tree should be redrawn
		 * @trigger model.jstree copy_node.jstree
		 */
		copy_node : function (obj, par, pos, callback, is_loaded, skip_redraw) {
			var t1, t2, dpc, tmp, i, j, node, old_par, new_par, old_ins, is_multi;

			par = this.get_node(par);
			pos = pos === undefined ? 0 : pos;
			if(!par) { return false; }
			if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
				return this.load_node(par, function () { this.copy_node(obj, par, pos, callback, true); });
			}

			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					tmp = this.copy_node(obj[t1], par, pos, callback, is_loaded, true);
					if(tmp) {
						par = tmp;
						pos = "after";
					}
				}
				this.redraw();
				return true;
			}
			obj = obj && obj.id ? obj : this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }

			old_par = (obj.parent || '#').toString();
			new_par = (!pos.toString().match(/^(before|after)$/) || par.id === '#') ? par : this.get_node(par.parent);
			old_ins = obj.instance ? obj.instance : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
			is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);
			if(par.id === '#') {
				if(pos === "before") { pos = "first"; }
				if(pos === "after") { pos = "last"; }
			}
			switch(pos) {
				case "before":
					pos = $.inArray(par.id, new_par.children);
					break;
				case "after" :
					pos = $.inArray(par.id, new_par.children) + 1;
					break;
				case "inside":
				case "first":
					pos = 0;
					break;
				case "last":
					pos = new_par.children.length;
					break;
				default:
					if(!pos) { pos = 0; }
					break;
			}
			if(pos > new_par.children.length) { pos = new_par.children.length; }
			if(!this.check("copy_node", obj, new_par, pos, { 'core' : true, 'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id) })) {
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			node = old_ins ? old_ins.get_json(obj, { no_id : true, no_data : true, no_state : true }) : obj;
			if(!node) { return false; }
			if(node.id === true) { delete node.id; }
			node = this._parse_model_from_json(node, new_par.id, new_par.parents.concat());
			if(!node) { return false; }
			tmp = this.get_node(node);
			if(obj && obj.state && obj.state.loaded === false) { tmp.state.loaded = false; }
			dpc = [];
			dpc.push(node);
			dpc = dpc.concat(tmp.children_d);
			this.trigger('model', { "nodes" : dpc, "parent" : new_par.id });

			// insert into new parent and up
			for(i = 0, j = new_par.parents.length; i < j; i++) {
				this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(dpc);
			}
			dpc = [];
			for(i = 0, j = new_par.children.length; i < j; i++) {
				dpc[i >= pos ? i+1 : i] = new_par.children[i];
			}
			dpc[pos] = tmp.id;
			new_par.children = dpc;
			new_par.children_d.push(tmp.id);
			new_par.children_d = new_par.children_d.concat(tmp.children_d);

			if(new_par.id === '#') {
				this._model.force_full_redraw = true;
			}
			if(!this._model.force_full_redraw) {
				this._node_changed(new_par.id);
			}
			if(!skip_redraw) {
				this.redraw(new_par.id === '#');
			}
			if(callback) { callback.call(this, tmp, new_par, pos); }
			/**
			 * triggered when a node is copied
			 * @event
			 * @name copy_node.jstree
			 * @param {Object} node the copied node
			 * @param {Object} original the original node
			 * @param {String} parent the parent's ID
			 * @param {Number} position the position of the node among the parent's children
			 * @param {String} old_parent the old parent of the node
			 * @param {Number} old_position the position of the original node
			 * @param {Boolean} is_multi do the node and new parent belong to different instances
			 * @param {jsTree} old_instance the instance the node came from
			 * @param {jsTree} new_instance the instance of the new parent
			 */
			this.trigger('copy_node', { "node" : tmp, "original" : obj, "parent" : new_par.id, "position" : pos, "old_parent" : old_par, "old_position" : old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1,'is_multi' : (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign' : (!old_ins || !old_ins._id), 'old_instance' : old_ins, 'new_instance' : this });
			return tmp.id;
		},
		/**
		 * cut a node (a later call to `paste(obj)` would move the node)
		 * @name cut(obj)
		 * @param  {mixed} obj multiple objects can be passed using an array
		 * @trigger cut.jstree
		 */
		cut : function (obj) {
			if(!obj) { obj = this._data.core.selected.concat(); }
			if(!$.isArray(obj)) { obj = [obj]; }
			if(!obj.length) { return false; }
			var tmp = [], o, t1, t2;
			for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
				o = this.get_node(obj[t1]);
				if(o && o.id && o.id !== '#') { tmp.push(o); }
			}
			if(!tmp.length) { return false; }
			ccp_node = tmp;
			ccp_inst = this;
			ccp_mode = 'move_node';
			/**
			 * triggered when nodes are added to the buffer for moving
			 * @event
			 * @name cut.jstree
			 * @param {Array} node
			 */
			this.trigger('cut', { "node" : obj });
		},
		/**
		 * copy a node (a later call to `paste(obj)` would copy the node)
		 * @name copy(obj)
		 * @param  {mixed} obj multiple objects can be passed using an array
		 * @trigger copy.jstre
		 */
		copy : function (obj) {
			if(!obj) { obj = this._data.core.selected.concat(); }
			if(!$.isArray(obj)) { obj = [obj]; }
			if(!obj.length) { return false; }
			var tmp = [], o, t1, t2;
			for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
				o = this.get_node(obj[t1]);
				if(o && o.id && o.id !== '#') { tmp.push(o); }
			}
			if(!tmp.length) { return false; }
			ccp_node = tmp;
			ccp_inst = this;
			ccp_mode = 'copy_node';
			/**
			 * triggered when nodes are added to the buffer for copying
			 * @event
			 * @name copy.jstree
			 * @param {Array} node
			 */
			this.trigger('copy', { "node" : obj });
		},
		/**
		 * get the current buffer (any nodes that are waiting for a paste operation)
		 * @name get_buffer()
		 * @return {Object} an object consisting of `mode` ("copy_node" or "move_node"), `node` (an array of objects) and `inst` (the instance)
		 */
		get_buffer : function () {
			return { 'mode' : ccp_mode, 'node' : ccp_node, 'inst' : ccp_inst };
		},
		/**
		 * check if there is something in the buffer to paste
		 * @name can_paste()
		 * @return {Boolean}
		 */
		can_paste : function () {
			return ccp_mode !== false && ccp_node !== false; // && ccp_inst._model.data[ccp_node];
		},
		/**
		 * copy or move the previously cut or copied nodes to a new parent
		 * @name paste(obj [, pos])
		 * @param  {mixed} obj the new parent
		 * @param  {mixed} pos the position to insert at (besides integer, "first" and "last" are supported), defaults to integer `0`
		 * @trigger paste.jstree
		 */
		paste : function (obj, pos) {
			obj = this.get_node(obj);
			if(!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) { return false; }
			if(this[ccp_mode](ccp_node, obj, pos)) {
				/**
				 * triggered when paste is invoked
				 * @event
				 * @name paste.jstree
				 * @param {String} parent the ID of the receiving node
				 * @param {Array} node the nodes in the buffer
				 * @param {String} mode the performed operation - "copy_node" or "move_node"
				 */
				this.trigger('paste', { "parent" : obj.id, "node" : ccp_node, "mode" : ccp_mode });
			}
			ccp_node = false;
			ccp_mode = false;
			ccp_inst = false;
		},
		/**
		 * clear the buffer of previously copied or cut nodes
		 * @name clear_buffer()
		 * @trigger clear_buffer.jstree
		 */
		clear_buffer : function () {
			ccp_node = false;
			ccp_mode = false;
			ccp_inst = false;
			/**
			 * triggered when the copy / cut buffer is cleared
			 * @event
			 * @name clear_buffer.jstree
			 */
			this.trigger('clear_buffer');
		},
		/**
		 * put a node in edit mode (input field to rename the node)
		 * @name edit(obj [, default_text])
		 * @param  {mixed} obj
		 * @param  {String} default_text the text to populate the input with (if omitted the node text value is used)
		 */
		edit : function (obj, default_text) {
			obj = this.get_node(obj);
			if(!obj) { return false; }
			if(this.settings.core.check_callback === false) {
				this._data.core.last_error = { 'error' : 'check', 'plugin' : 'core', 'id' : 'core_07', 'reason' : 'Could not edit node because of check_callback' };
				this.settings.core.error.call(this, this._data.core.last_error);
				return false;
			}
			default_text = typeof default_text === 'string' ? default_text : obj.text;
			this.set_text(obj, "");
			obj = this._open_to(obj);

			var rtl = this._data.core.rtl,
				w  = this.element.width(),
				a  = obj.children('.jstree-anchor'),
				s  = $('<span>'),
				/*!
				oi = obj.children("i:visible"),
				ai = a.children("i:visible"),
				w1 = oi.width() * oi.length,
				w2 = ai.width() * ai.length,
				*/
				t  = default_text,
				h1 = $("<"+"div />", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body"),
				h2 = $("<"+"input />", {
						"value" : t,
						"class" : "jstree-rename-input",
						// "size" : t.length,
						"css" : {
							"padding" : "0",
							"border" : "1px solid silver",
							"box-sizing" : "border-box",
							"display" : "inline-block",
							"height" : (this._data.core.li_height) + "px",
							"lineHeight" : (this._data.core.li_height) + "px",
							"width" : "150px" // will be set a bit further down
						},
						"blur" : $.proxy(function () {
							var i = s.children(".jstree-rename-input"),
								v = i.val();
							if(v === "") { v = t; }
							h1.remove();
							s.replaceWith(a);
							s.remove();
							this.set_text(obj, t);
							if(this.rename_node(obj, $('<div></div>').text(v)[this.settings.core.force_text ? 'text' : 'html']()) === false) {
								this.set_text(obj, t); // move this up? and fix #483
							}
						}, this),
						"keydown" : function (event) {
							var key = event.which;
							if(key === 27) {
								this.value = t;
							}
							if(key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40 || key === 32) {
								event.stopImmediatePropagation();
							}
							if(key === 27 || key === 13) {
								event.preventDefault();
								this.blur();
							}
						},
						"click" : function (e) { e.stopImmediatePropagation(); },
						"mousedown" : function (e) { e.stopImmediatePropagation(); },
						"keyup" : function (event) {
							h2.width(Math.min(h1.text("pW" + this.value).width(),w));
						},
						"keypress" : function(event) {
							if(event.which === 13) { return false; }
						}
					}),
				fn = {
						fontFamily		: a.css('fontFamily')		|| '',
						fontSize		: a.css('fontSize')			|| '',
						fontWeight		: a.css('fontWeight')		|| '',
						fontStyle		: a.css('fontStyle')		|| '',
						fontStretch		: a.css('fontStretch')		|| '',
						fontVariant		: a.css('fontVariant')		|| '',
						letterSpacing	: a.css('letterSpacing')	|| '',
						wordSpacing		: a.css('wordSpacing')		|| ''
				};
			s.attr('class', a.attr('class')).append(a.contents().clone()).append(h2);
			a.replaceWith(s);
			h1.css(fn);
			h2.css(fn).width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
		},


		/**
		 * changes the theme
		 * @name set_theme(theme_name [, theme_url])
		 * @param {String} theme_name the name of the new theme to apply
		 * @param {mixed} theme_url  the location of the CSS file for this theme. Omit or set to `false` if you manually included the file. Set to `true` to autoload from the `core.themes.dir` directory.
		 * @trigger set_theme.jstree
		 */
		set_theme : function (theme_name, theme_url) {
			if(!theme_name) { return false; }
			if(theme_url === true) {
				var dir = this.settings.core.themes.dir;
				if(!dir) { dir = $.jstree.path + '/themes'; }
				theme_url = dir + '/' + theme_name + '/style.css';
			}
			if(theme_url && $.inArray(theme_url, themes_loaded) === -1) {
				$('head').append('<'+'link rel="stylesheet" href="' + theme_url + '" type="text/css" />');
				themes_loaded.push(theme_url);
			}
			if(this._data.core.themes.name) {
				this.element.removeClass('jstree-' + this._data.core.themes.name);
			}
			this._data.core.themes.name = theme_name;
			this.element.addClass('jstree-' + theme_name);
			this.element[this.settings.core.themes.responsive ? 'addClass' : 'removeClass' ]('jstree-' + theme_name + '-responsive');
			/**
			 * triggered when a theme is set
			 * @event
			 * @name set_theme.jstree
			 * @param {String} theme the new theme
			 */
			this.trigger('set_theme', { 'theme' : theme_name });
		},
		/**
		 * gets the name of the currently applied theme name
		 * @name get_theme()
		 * @return {String}
		 */
		get_theme : function () { return this._data.core.themes.name; },
		/**
		 * changes the theme variant (if the theme has variants)
		 * @name set_theme_variant(variant_name)
		 * @param {String|Boolean} variant_name the variant to apply (if `false` is used the current variant is removed)
		 */
		set_theme_variant : function (variant_name) {
			if(this._data.core.themes.variant) {
				this.element.removeClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
			}
			this._data.core.themes.variant = variant_name;
			if(variant_name) {
				this.element.addClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
			}
		},
		/**
		 * gets the name of the currently applied theme variant
		 * @name get_theme()
		 * @return {String}
		 */
		get_theme_variant : function () { return this._data.core.themes.variant; },
		/**
		 * shows a striped background on the container (if the theme supports it)
		 * @name show_stripes()
		 */
		show_stripes : function () { this._data.core.themes.stripes = true; this.get_container_ul().addClass("jstree-striped"); },
		/**
		 * hides the striped background on the container
		 * @name hide_stripes()
		 */
		hide_stripes : function () { this._data.core.themes.stripes = false; this.get_container_ul().removeClass("jstree-striped"); },
		/**
		 * toggles the striped background on the container
		 * @name toggle_stripes()
		 */
		toggle_stripes : function () { if(this._data.core.themes.stripes) { this.hide_stripes(); } else { this.show_stripes(); } },
		/**
		 * shows the connecting dots (if the theme supports it)
		 * @name show_dots()
		 */
		show_dots : function () { this._data.core.themes.dots = true; this.get_container_ul().removeClass("jstree-no-dots"); },
		/**
		 * hides the connecting dots
		 * @name hide_dots()
		 */
		hide_dots : function () { this._data.core.themes.dots = false; this.get_container_ul().addClass("jstree-no-dots"); },
		/**
		 * toggles the connecting dots
		 * @name toggle_dots()
		 */
		toggle_dots : function () { if(this._data.core.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
		/**
		 * show the node icons
		 * @name show_icons()
		 */
		show_icons : function () { this._data.core.themes.icons = true; this.get_container_ul().removeClass("jstree-no-icons"); },
		/**
		 * hide the node icons
		 * @name hide_icons()
		 */
		hide_icons : function () { this._data.core.themes.icons = false; this.get_container_ul().addClass("jstree-no-icons"); },
		/**
		 * toggle the node icons
		 * @name toggle_icons()
		 */
		toggle_icons : function () { if(this._data.core.themes.icons) { this.hide_icons(); } else { this.show_icons(); } },
		/**
		 * set the node icon for a node
		 * @name set_icon(obj, icon)
		 * @param {mixed} obj
		 * @param {String} icon the new icon - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
		 */
		set_icon : function (obj, icon) {
			var t1, t2, dom, old;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_icon(obj[t1], icon);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			old = obj.icon;
			obj.icon = icon;
			dom = this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon");
			if(icon === false) {
				this.hide_icon(obj);
			}
			else if(icon === true) {
				dom.removeClass('jstree-themeicon-custom ' + old).css("background","").removeAttr("rel");
				if(old === false) { this.show_icon(obj); }
			}
			else if(icon.indexOf("/") === -1 && icon.indexOf(".") === -1) {
				dom.removeClass(old).css("background","");
				dom.addClass(icon + ' jstree-themeicon-custom').attr("rel",icon);
				if(old === false) { this.show_icon(obj); }
			}
			else {
				dom.removeClass(old).css("background","");
				dom.addClass('jstree-themeicon-custom').css("background", "url('" + icon + "') center center no-repeat").attr("rel",icon);
				if(old === false) { this.show_icon(obj); }
			}
			return true;
		},
		/**
		 * get the node icon for a node
		 * @name get_icon(obj)
		 * @param {mixed} obj
		 * @return {String}
		 */
		get_icon : function (obj) {
			obj = this.get_node(obj);
			return (!obj || obj.id === '#') ? false : obj.icon;
		},
		/**
		 * hide the icon on an individual node
		 * @name hide_icon(obj)
		 * @param {mixed} obj
		 */
		hide_icon : function (obj) {
			var t1, t2;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.hide_icon(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj === '#') { return false; }
			obj.icon = false;
			this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon").addClass('jstree-themeicon-hidden');
			return true;
		},
		/**
		 * show the icon on an individual node
		 * @name show_icon(obj)
		 * @param {mixed} obj
		 */
		show_icon : function (obj) {
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.show_icon(obj[t1]);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj === '#') { return false; }
			dom = this.get_node(obj, true);
			obj.icon = dom.length ? dom.children(".jstree-anchor").children(".jstree-themeicon").attr('rel') : true;
			if(!obj.icon) { obj.icon = true; }
			dom.children(".jstree-anchor").children(".jstree-themeicon").removeClass('jstree-themeicon-hidden');
			return true;
		}
	};

	// helpers
	$.vakata = {};
	// collect attributes
	$.vakata.attributes = function(node, with_values) {
		node = $(node)[0];
		var attr = with_values ? {} : [];
		if(node && node.attributes) {
			$.each(node.attributes, function (i, v) {
				if($.inArray(v.name.toLowerCase(),['style','contenteditable','hasfocus','tabindex']) !== -1) { return; }
				if(v.value !== null && $.trim(v.value) !== '') {
					if(with_values) { attr[v.name] = v.value; }
					else { attr.push(v.name); }
				}
			});
		}
		return attr;
	};
	$.vakata.array_unique = function(array) {
		var a = [], i, j, l;
		for(i = 0, l = array.length; i < l; i++) {
			for(j = 0; j <= i; j++) {
				if(array[i] === array[j]) {
					break;
				}
			}
			if(j === i) { a.push(array[i]); }
		}
		return a;
	};
	// remove item from array
	$.vakata.array_remove = function(array, from, to) {
		var rest = array.slice((to || from) + 1 || array.length);
		array.length = from < 0 ? array.length + from : from;
		array.push.apply(array, rest);
		return array;
	};
	// remove item from array
	$.vakata.array_remove_item = function(array, item) {
		var tmp = $.inArray(item, array);
		return tmp !== -1 ? $.vakata.array_remove(array, tmp) : array;
	};


/**
 * ### Checkbox plugin
 *
 * This plugin renders checkbox icons in front of each node, making multiple selection much easier. 
 * It also supports tri-state behavior, meaning that if a node has a few of its children checked it will be rendered as undetermined, and state will be propagated up.
 */

	var _i = document.createElement('I');
	_i.className = 'jstree-icon jstree-checkbox';
	_i.setAttribute('role', 'presentation');
	/**
	 * stores all defaults for the checkbox plugin
	 * @name $.jstree.defaults.checkbox
	 * @plugin checkbox
	 */
	$.jstree.defaults.checkbox = {
		/**
		 * a boolean indicating if checkboxes should be visible (can be changed at a later time using `show_checkboxes()` and `hide_checkboxes`). Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.visible
		 * @plugin checkbox
		 */
		visible				: true,
		/**
		 * a boolean indicating if checkboxes should cascade down and have an undetermined state. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.three_state
		 * @plugin checkbox
		 */
		three_state			: true,
		/**
		 * a boolean indicating if clicking anywhere on the node should act as clicking on the checkbox. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.whole_node
		 * @plugin checkbox
		 */
		whole_node			: true,
		/**
		 * a boolean indicating if the selected style of a node should be kept, or removed. Defaults to `true`.
		 * @name $.jstree.defaults.checkbox.keep_selected_style
		 * @plugin checkbox
		 */
		keep_selected_style	: true,
		/**
		 * This setting controls how cascading and undetermined nodes are applied. 
		 * If 'up' is in the string - cascading up is enabled, if 'down' is in the string - cascading down is enabled, if 'undetermined' is in the string - undetermined nodes will be used. 
		 * If `three_state` is set to `true` this setting is automatically set to 'up+down+undetermined'. Defaults to ''.
		 * @name $.jstree.defaults.checkbox.cascade
		 * @plugin checkbox
		 */
		cascade				: '',
		/**
		 * This setting controls if checkbox are bound to the general tree selection or to an internal array maintained by the checkbox plugin. Defaults to `true`, only set to `false` if you know exactly what you are doing. 
		 * @name $.jstree.defaults.checkbox.tie_selection
		 * @plugin checkbox
		 */
		tie_selection		: true
	};
	$.jstree.plugins.checkbox = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			this._data.checkbox.uto = false;
			this._data.checkbox.selected = [];
			if(this.settings.checkbox.three_state) {
				this.settings.checkbox.cascade = 'up+down+undetermined';
			}
			this.element
				.on("init.jstree", $.proxy(function () {
						this._data.checkbox.visible = this.settings.checkbox.visible;
						if(!this.settings.checkbox.keep_selected_style) {
							this.element.addClass('jstree-checkbox-no-clicked');
						}
						if(this.settings.checkbox.tie_selection) {
							this.element.addClass('jstree-checkbox-selection');
						}
					}, this))
				.on("loading.jstree", $.proxy(function () {
						this[ this._data.checkbox.visible ? 'show_checkboxes' : 'hide_checkboxes' ]();
					}, this));
			if(this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
				this.element
					.on('changed.jstree uncheck_node.jstree check_node.jstree uncheck_all.jstree check_all.jstree move_node.jstree copy_node.jstree redraw.jstree open_node.jstree', $.proxy(function () {
							// only if undetermined is in setting
							if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
							this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
						}, this));
			}
			if(!this.settings.checkbox.tie_selection) {
				this.element
					.on('model.jstree', $.proxy(function (e, data) {
						var m = this._model.data,
							p = m[data.parent],
							dpc = data.nodes,
							i, j;
						for(i = 0, j = dpc.length; i < j; i++) {
							m[dpc[i]].state.checked = (m[dpc[i]].original && m[dpc[i]].original.state && m[dpc[i]].original.state.checked);
							if(m[dpc[i]].state.checked) {
								this._data.checkbox.selected.push(dpc[i]);
							}
						}
					}, this));
			}
			if(this.settings.checkbox.cascade.indexOf('up') !== -1 || this.settings.checkbox.cascade.indexOf('down') !== -1) {
				this.element
					.on('model.jstree', $.proxy(function (e, data) {
							var m = this._model.data,
								p = m[data.parent],
								dpc = data.nodes,
								chd = [],
								c, i, j, k, l, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;

							if(s.indexOf('down') !== -1) {
								// apply down
								if(p.state[ t ? 'selected' : 'checked' ]) {
									for(i = 0, j = dpc.length; i < j; i++) {
										m[dpc[i]].state[ t ? 'selected' : 'checked' ] = true;
									}
									this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(dpc);
								}
								else {
									for(i = 0, j = dpc.length; i < j; i++) {
										if(m[dpc[i]].state[ t ? 'selected' : 'checked' ]) {
											for(k = 0, l = m[dpc[i]].children_d.length; k < l; k++) {
												m[m[dpc[i]].children_d[k]].state[ t ? 'selected' : 'checked' ] = true;
											}
											this._data[ t ? 'core' : 'checkbox' ].selected = this._data[ t ? 'core' : 'checkbox' ].selected.concat(m[dpc[i]].children_d);
										}
									}
								}
							}

							if(s.indexOf('up') !== -1) {
								// apply up
								for(i = 0, j = p.children_d.length; i < j; i++) {
									if(!m[p.children_d[i]].children.length) {
										chd.push(m[p.children_d[i]].parent);
									}
								}
								chd = $.vakata.array_unique(chd);
								for(k = 0, l = chd.length; k < l; k++) {
									p = m[chd[k]];
									while(p && p.id !== '#') {
										c = 0;
										for(i = 0, j = p.children.length; i < j; i++) {
											c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
										}
										if(c === j) {
											p.state[ t ? 'selected' : 'checked' ] = true;
											this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
											tmp = this.get_node(p, true);
											if(tmp && tmp.length) {
												tmp.attr('aria-selected', true).children('.jstree-anchor').addClass( t ? 'jstree-clicked' : 'jstree-checked');
											}
										}
										else {
											break;
										}
										p = this.get_node(p.parent);
									}
								}
							}

							this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected);
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'select_node.jstree' : 'check_node.jstree', $.proxy(function (e, data) {
							var obj = data.node,
								m = this._model.data,
								par = this.get_node(obj.parent),
								dom = this.get_node(obj, true),
								i, j, c, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;

							// apply down
							if(s.indexOf('down') !== -1) {
								this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected.concat(obj.children_d));
								for(i = 0, j = obj.children_d.length; i < j; i++) {
									tmp = m[obj.children_d[i]];
									tmp.state[ t ? 'selected' : 'checked' ] = true;
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
								}
							}

							// apply up
							if(s.indexOf('up') !== -1) {
								while(par && par.id !== '#') {
									c = 0;
									for(i = 0, j = par.children.length; i < j; i++) {
										c += m[par.children[i]].state[ t ? 'selected' : 'checked' ];
									}
									if(c === j) {
										par.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(par.id);
										tmp = this.get_node(par, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
									par = this.get_node(par.parent);
								}
							}

							// apply down (process .children separately?)
							if(s.indexOf('down') !== -1 && dom.length) {
								dom.find('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', true);
							}
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'deselect_all.jstree' : 'uncheck_all.jstree', $.proxy(function (e, data) {
							var obj = this.get_node('#'),
								m = this._model.data,
								i, j, tmp;
							for(i = 0, j = obj.children_d.length; i < j; i++) {
								tmp = m[obj.children_d[i]];
								if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
									tmp.original.state.undetermined = false;
								}
							}
						}, this))
					.on(this.settings.checkbox.tie_selection ? 'deselect_node.jstree' : 'uncheck_node.jstree', $.proxy(function (e, data) {
							var obj = data.node,
								dom = this.get_node(obj, true),
								i, j, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;
							if(obj && obj.original && obj.original.state && obj.original.state.undetermined) {
								obj.original.state.undetermined = false;
							}

							// apply down
							if(s.indexOf('down') !== -1) {
								for(i = 0, j = obj.children_d.length; i < j; i++) {
									tmp = this._model.data[obj.children_d[i]];
									tmp.state[ t ? 'selected' : 'checked' ] = false;
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
								}
							}

							// apply up
							if(s.indexOf('up') !== -1) {
								for(i = 0, j = obj.parents.length; i < j; i++) {
									tmp = this._model.data[obj.parents[i]];
									tmp.state[ t ? 'selected' : 'checked' ] = false;
									if(tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
										tmp.original.state.undetermined = false;
									}
									tmp = this.get_node(obj.parents[i], true);
									if(tmp && tmp.length) {
										tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
									}
								}
							}
							tmp = [];
							for(i = 0, j = this._data[ t ? 'core' : 'checkbox' ].selected.length; i < j; i++) {
								// apply down + apply up
								if(
									(s.indexOf('down') === -1 || $.inArray(this._data[ t ? 'core' : 'checkbox' ].selected[i], obj.children_d) === -1) &&
									(s.indexOf('up') === -1 || $.inArray(this._data[ t ? 'core' : 'checkbox' ].selected[i], obj.parents) === -1)
								) {
									tmp.push(this._data[ t ? 'core' : 'checkbox' ].selected[i]);
								}
							}
							this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(tmp);

							// apply down (process .children separately?)
							if(s.indexOf('down') !== -1 && dom.length) {
								dom.find('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', false);
							}
						}, this));
			}
			if(this.settings.checkbox.cascade.indexOf('up') !== -1) {
				this.element
					.on('delete_node.jstree', $.proxy(function (e, data) {
							// apply up (whole handler)
							var p = this.get_node(data.parent),
								m = this._model.data,
								i, j, c, tmp, t = this.settings.checkbox.tie_selection;
							while(p && p.id !== '#') {
								c = 0;
								for(i = 0, j = p.children.length; i < j; i++) {
									c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
								}
								if(c === j) {
									p.state[ t ? 'selected' : 'checked' ] = true;
									this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
									tmp = this.get_node(p, true);
									if(tmp && tmp.length) {
										tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
									}
								}
								else {
									break;
								}
								p = this.get_node(p.parent);
							}
						}, this))
					.on('move_node.jstree', $.proxy(function (e, data) {
							// apply up (whole handler)
							var is_multi = data.is_multi,
								old_par = data.old_parent,
								new_par = this.get_node(data.parent),
								m = this._model.data,
								p, c, i, j, tmp, t = this.settings.checkbox.tie_selection;
							if(!is_multi) {
								p = this.get_node(old_par);
								while(p && p.id !== '#') {
									c = 0;
									for(i = 0, j = p.children.length; i < j; i++) {
										c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
									}
									if(c === j) {
										p.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
									p = this.get_node(p.parent);
								}
							}
							p = new_par;
							while(p && p.id !== '#') {
								c = 0;
								for(i = 0, j = p.children.length; i < j; i++) {
									c += m[p.children[i]].state[ t ? 'selected' : 'checked' ];
								}
								if(c === j) {
									if(!p.state[ t ? 'selected' : 'checked' ]) {
										p.state[ t ? 'selected' : 'checked' ] = true;
										this._data[ t ? 'core' : 'checkbox' ].selected.push(p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
								}
								else {
									if(p.state[ t ? 'selected' : 'checked' ]) {
										p.state[ t ? 'selected' : 'checked' ] = false;
										this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_remove_item(this._data[ t ? 'core' : 'checkbox' ].selected, p.id);
										tmp = this.get_node(p, true);
										if(tmp && tmp.length) {
											tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
										}
									}
									else {
										break;
									}
								}
								p = this.get_node(p.parent);
							}
						}, this));
			}
		};
		/**
		 * set the undetermined state where and if necessary. Used internally.
		 * @private
		 * @name _undetermined()
		 * @plugin checkbox
		 */
		this._undetermined = function () {
			var i, j, m = this._model.data, t = this.settings.checkbox.tie_selection, s = this._data[ t ? 'core' : 'checkbox' ].selected, p = [], tt = this;
			for(i = 0, j = s.length; i < j; i++) {
				if(m[s[i]] && m[s[i]].parents) {
					p = p.concat(m[s[i]].parents);
				}
			}
			// attempt for server side undetermined state
			this.element.find('.jstree-closed').not(':has(.jstree-children)')
				.each(function () {
					var tmp = tt.get_node(this), tmp2;
					if(!tmp.state.loaded) {
						if(tmp.original && tmp.original.state && tmp.original.state.undetermined && tmp.original.state.undetermined === true) {
							p.push(tmp.id);
							p = p.concat(tmp.parents);
						}
					}
					else {
						for(i = 0, j = tmp.children_d.length; i < j; i++) {
							tmp2 = m[tmp.children_d[i]];
							if(!tmp2.state.loaded && tmp2.original && tmp2.original.state && tmp2.original.state.undetermined && tmp2.original.state.undetermined === true) {
								p.push(tmp2.id);
								p = p.concat(tmp2.parents);
							}
						}
					}
				});
			p = $.vakata.array_unique(p);
			p = $.vakata.array_remove_item(p,'#');

			this.element.find('.jstree-undetermined').removeClass('jstree-undetermined');
			for(i = 0, j = p.length; i < j; i++) {
				if(!m[p[i]].state[ t ? 'selected' : 'checked' ]) {
					s = this.get_node(p[i], true);
					if(s && s.length) {
						s.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-undetermined');
					}
				}
			}
		};
		this.redraw_node = function(obj, deep, is_callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if(obj) {
				var i, j, tmp = null;
				for(i = 0, j = obj.childNodes.length; i < j; i++) {
					if(obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
						tmp = obj.childNodes[i];
						break;
					}
				}
				if(tmp) {
					if(!this.settings.checkbox.tie_selection && this._model.data[obj.id].state.checked) { tmp.className += ' jstree-checked'; }
					tmp.insertBefore(_i.cloneNode(false), tmp.childNodes[0]);
				}
			}
			if(!is_callback && this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
				if(this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
				this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
			}
			return obj;
		};
		/**
		 * show the node checkbox icons
		 * @name show_checkboxes()
		 * @plugin checkbox
		 */
		this.show_checkboxes = function () { this._data.core.themes.checkboxes = true; this.get_container_ul().removeClass("jstree-no-checkboxes"); };
		/**
		 * hide the node checkbox icons
		 * @name hide_checkboxes()
		 * @plugin checkbox
		 */
		this.hide_checkboxes = function () { this._data.core.themes.checkboxes = false; this.get_container_ul().addClass("jstree-no-checkboxes"); };
		/**
		 * toggle the node icons
		 * @name toggle_checkboxes()
		 * @plugin checkbox
		 */
		this.toggle_checkboxes = function () { if(this._data.core.themes.checkboxes) { this.hide_checkboxes(); } else { this.show_checkboxes(); } };
		/**
		 * checks if a node is in an undetermined state
		 * @name is_undetermined(obj)
		 * @param  {mixed} obj
		 * @return {Boolean}
		 */
		this.is_undetermined = function (obj) {
			obj = this.get_node(obj);
			var s = this.settings.checkbox.cascade, i, j, t = this.settings.checkbox.tie_selection, d = this._data[ t ? 'core' : 'checkbox' ].selected, m = this._model.data;
			if(!obj || obj.state[ t ? 'selected' : 'checked' ] === true || s.indexOf('undetermined') === -1 || (s.indexOf('down') === -1 && s.indexOf('up') === -1)) {
				return false;
			}
			if(!obj.state.loaded && obj.original.state.undetermined === true) {
				return true;
			}
			for(i = 0, j = obj.children_d.length; i < j; i++) {
				if($.inArray(obj.children_d[i], d) !== -1 || (!m[obj.children_d[i]].state.loaded && m[obj.children_d[i]].original.state.undetermined)) {
					return true;
				}
			}
			return false;
		};

		this.activate_node = function (obj, e) {
			if(this.settings.checkbox.tie_selection && (this.settings.checkbox.whole_node || $(e.target).hasClass('jstree-checkbox'))) {
				e.ctrlKey = true;
			}
			if(this.settings.checkbox.tie_selection || (!this.settings.checkbox.whole_node && !$(e.target).hasClass('jstree-checkbox'))) {
				return parent.activate_node.call(this, obj, e);
			}
			if(this.is_disabled(obj)) {
				return false;
			}
			if(this.is_checked(obj)) {
				this.uncheck_node(obj, e);
			}
			else {
				this.check_node(obj, e);
			}
			this.trigger('activate_node', { 'node' : this.get_node(obj) });
		};

		/**
		 * check a node (only if tie_selection in checkbox settings is false, otherwise select_node will be called internally)
		 * @name check_node(obj)
		 * @param {mixed} obj an array can be used to check multiple nodes
		 * @trigger check_node.jstree
		 * @plugin checkbox
		 */
		this.check_node = function (obj, e) {
			if(this.settings.checkbox.tie_selection) { return this.select_node(obj, false, true, e); }
			var dom, t1, t2, th;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.check_node(obj[t1], e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			dom = this.get_node(obj, true);
			if(!obj.state.checked) {
				obj.state.checked = true;
				this._data.checkbox.selected.push(obj.id);
				if(dom && dom.length) {
					dom.children('.jstree-anchor').addClass('jstree-checked');
				}
				/**
				 * triggered when an node is checked (only if tie_selection in checkbox settings is false)
				 * @event
				 * @name check_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this check_node
				 * @plugin checkbox
				 */
				this.trigger('check_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
			}
		};
		/**
		 * uncheck a node (only if tie_selection in checkbox settings is false, otherwise deselect_node will be called internally)
		 * @name deselect_node(obj)
		 * @param {mixed} obj an array can be used to deselect multiple nodes
		 * @trigger uncheck_node.jstree
		 * @plugin checkbox
		 */
		this.uncheck_node = function (obj, e) {
			if(this.settings.checkbox.tie_selection) { return this.deselect_node(obj, false, e); }
			var t1, t2, dom;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.uncheck_node(obj[t1], e);
				}
				return true;
			}
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') {
				return false;
			}
			dom = this.get_node(obj, true);
			if(obj.state.checked) {
				obj.state.checked = false;
				this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, obj.id);
				if(dom.length) {
					dom.children('.jstree-anchor').removeClass('jstree-checked');
				}
				/**
				 * triggered when an node is unchecked (only if tie_selection in checkbox settings is false)
				 * @event
				 * @name uncheck_node.jstree
				 * @param {Object} node
				 * @param {Array} selected the current selection
				 * @param {Object} event the event (if any) that triggered this uncheck_node
				 * @plugin checkbox
				 */
				this.trigger('uncheck_node', { 'node' : obj, 'selected' : this._data.checkbox.selected, 'event' : e });
			}
		};
		/**
		 * checks all nodes in the tree (only if tie_selection in checkbox settings is false, otherwise select_all will be called internally)
		 * @name check_all()
		 * @trigger check_all.jstree, changed.jstree
		 * @plugin checkbox
		 */
		this.check_all = function () {
			if(this.settings.checkbox.tie_selection) { return this.select_all(); }
			var tmp = this._data.checkbox.selected.concat([]), i, j;
			this._data.checkbox.selected = this._model.data['#'].children_d.concat();
			for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
				if(this._model.data[this._data.checkbox.selected[i]]) {
					this._model.data[this._data.checkbox.selected[i]].state.checked = true;
				}
			}
			this.redraw(true);
			/**
			 * triggered when all nodes are checked (only if tie_selection in checkbox settings is false)
			 * @event
			 * @name check_all.jstree
			 * @param {Array} selected the current selection
			 * @plugin checkbox
			 */
			this.trigger('check_all', { 'selected' : this._data.checkbox.selected });
		};
		/**
		 * uncheck all checked nodes (only if tie_selection in checkbox settings is false, otherwise deselect_all will be called internally)
		 * @name uncheck_all()
		 * @trigger uncheck_all.jstree
		 * @plugin checkbox
		 */
		this.uncheck_all = function () {
			if(this.settings.checkbox.tie_selection) { return this.deselect_all(); }
			var tmp = this._data.checkbox.selected.concat([]), i, j;
			for(i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
				if(this._model.data[this._data.checkbox.selected[i]]) {
					this._model.data[this._data.checkbox.selected[i]].state.checked = false;
				}
			}
			this._data.checkbox.selected = [];
			this.element.find('.jstree-checked').removeClass('jstree-checked');
			/**
			 * triggered when all nodes are unchecked (only if tie_selection in checkbox settings is false)
			 * @event
			 * @name uncheck_all.jstree
			 * @param {Object} node the previous selection
			 * @param {Array} selected the current selection
			 * @plugin checkbox
			 */
			this.trigger('uncheck_all', { 'selected' : this._data.checkbox.selected, 'node' : tmp });
		};
		/**
		 * checks if a node is checked (if tie_selection is on in the settings this function will return the same as is_selected)
		 * @name is_checked(obj)
		 * @param  {mixed}  obj
		 * @return {Boolean}
		 * @plugin checkbox
		 */
		this.is_checked = function (obj) {
			if(this.settings.checkbox.tie_selection) { return this.is_selected(obj); }
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			return obj.state.checked;
		};
		/**
		 * get an array of all checked nodes (if tie_selection is on in the settings this function will return the same as get_selected)
		 * @name get_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_selected(full); }
			return full ? $.map(this._data.checkbox.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.checkbox.selected;
		};
		/**
		 * get an array of all top level checked nodes (ignoring children of checked nodes) (if tie_selection is on in the settings this function will return the same as get_top_selected)
		 * @name get_top_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_top_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_top_selected(full); }
			var tmp = this.get_checked(true),
				obj = {}, i, j, k, l;
			for(i = 0, j = tmp.length; i < j; i++) {
				obj[tmp[i].id] = tmp[i];
			}
			for(i = 0, j = tmp.length; i < j; i++) {
				for(k = 0, l = tmp[i].children_d.length; k < l; k++) {
					if(obj[tmp[i].children_d[k]]) {
						delete obj[tmp[i].children_d[k]];
					}
				}
			}
			tmp = [];
			for(i in obj) {
				if(obj.hasOwnProperty(i)) {
					tmp.push(i);
				}
			}
			return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
		};
		/**
		 * get an array of all bottom level checked nodes (ignoring selected parents) (if tie_selection is on in the settings this function will return the same as get_bottom_selected)
		 * @name get_bottom_checked([full])
		 * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
		 * @return {Array}
		 * @plugin checkbox
		 */
		this.get_bottom_checked = function (full) {
			if(this.settings.checkbox.tie_selection) { return this.get_bottom_selected(full); }
			var tmp = this.get_checked(true),
				obj = [], i, j;
			for(i = 0, j = tmp.length; i < j; i++) {
				if(!tmp[i].children.length) {
					obj.push(tmp[i].id);
				}
			}
			return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
		};
		this.load_node = function (obj, callback) {
			var k, l, i, j, c, tmp;
			if(!$.isArray(obj) && !this.settings.checkbox.tie_selection) {
				tmp = this.get_node(obj);
				if(tmp && tmp.state.loaded) {
					for(k = 0, l = tmp.children_d.length; k < l; k++) {
						if(this._model.data[tmp.children_d[k]].state.checked) {
							c = true;
							this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, tmp.children_d[k]);
						}
					}
				}
			}
			return parent.load_node.apply(this, arguments);
		};
		this.get_state = function () {
			var state = parent.get_state.apply(this, arguments);
			if(this.settings.checkbox.tie_selection) { return state; }
			state.checkbox = this._data.checkbox.selected.slice();
			return state;
		};
		this.set_state = function (state, callback) {
			var res = parent.set_state.apply(this, arguments);
			if(res && state.checkbox) {
				if(!this.settings.checkbox.tie_selection) {
					this.uncheck_all();
					var _this = this;
					$.each(state.checkbox, function (i, v) {
						_this.check_node(v);
					});
				}
				delete state.checkbox;
				return false;
			}
			return res;
		};
	};

	// include the checkbox plugin by default
	// $.jstree.defaults.plugins.push("checkbox");

/**
 * ### Contextmenu plugin
 *
 * Shows a context menu when a node is right-clicked.
 */

	var cto = null, ex, ey;

	/**
	 * stores all defaults for the contextmenu plugin
	 * @name $.jstree.defaults.contextmenu
	 * @plugin contextmenu
	 */
	$.jstree.defaults.contextmenu = {
		/**
		 * a boolean indicating if the node should be selected when the context menu is invoked on it. Defaults to `true`.
		 * @name $.jstree.defaults.contextmenu.select_node
		 * @plugin contextmenu
		 */
		select_node : true,
		/**
		 * a boolean indicating if the menu should be shown aligned with the node. Defaults to `true`, otherwise the mouse coordinates are used.
		 * @name $.jstree.defaults.contextmenu.show_at_node
		 * @plugin contextmenu
		 */
		show_at_node : true,
		/**
		 * an object of actions, or a function that accepts a node and a callback function and calls the callback function with an object of actions available for that node (you can also return the items too).
		 * 
		 * Each action consists of a key (a unique name) and a value which is an object with the following properties (only label and action are required):
		 * 
		 * * `separator_before` - a boolean indicating if there should be a separator before this item
		 * * `separator_after` - a boolean indicating if there should be a separator after this item
		 * * `_disabled` - a boolean indicating if this action should be disabled
		 * * `label` - a string - the name of the action (could be a function returning a string)
		 * * `action` - a function to be executed if this item is chosen
		 * * `icon` - a string, can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
		 * * `shortcut` - keyCode which will trigger the action if the menu is open (for example `113` for rename, which equals F2)
		 * * `shortcut_label` - shortcut label (like for example `F2` for rename)
		 * 
		 * @name $.jstree.defaults.contextmenu.items
		 * @plugin contextmenu
		 */
		items : function (o, cb) { // Could be an object directly
			return {
				"create" : {
					"separator_before"	: false,
					"separator_after"	: true,
					"_disabled"			: false, //(this.check("create_node", data.reference, {}, "last")),
					"label"				: "Create",
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						inst.create_node(obj, {}, "last", function (new_node) {
							setTimeout(function () { inst.edit(new_node); },0);
						});
					}
				},
				"rename" : {
					"separator_before"	: false,
					"separator_after"	: false,
					"_disabled"			: false, //(this.check("rename_node", data.reference, this.get_parent(data.reference), "")),
					"label"				: "Rename",
					/*
					"shortcut"			: 113,
					"shortcut_label"	: 'F2',
					"icon"				: "glyphicon glyphicon-leaf",
					*/
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						inst.edit(obj);
					}
				},
				"remove" : {
					"separator_before"	: false,
					"icon"				: false,
					"separator_after"	: false,
					"_disabled"			: false, //(this.check("delete_node", data.reference, this.get_parent(data.reference), "")),
					"label"				: "Delete",
					"action"			: function (data) {
						var inst = $.jstree.reference(data.reference),
							obj = inst.get_node(data.reference);
						if(inst.is_selected(obj)) {
							inst.delete_node(inst.get_selected());
						}
						else {
							inst.delete_node(obj);
						}
					}
				},
				"ccp" : {
					"separator_before"	: true,
					"icon"				: false,
					"separator_after"	: false,
					"label"				: "Edit",
					"action"			: false,
					"submenu" : {
						"cut" : {
							"separator_before"	: false,
							"separator_after"	: false,
							"label"				: "Cut",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								if(inst.is_selected(obj)) {
									inst.cut(inst.get_selected());
								}
								else {
									inst.cut(obj);
								}
							}
						},
						"copy" : {
							"separator_before"	: false,
							"icon"				: false,
							"separator_after"	: false,
							"label"				: "Copy",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								if(inst.is_selected(obj)) {
									inst.copy(inst.get_selected());
								}
								else {
									inst.copy(obj);
								}
							}
						},
						"paste" : {
							"separator_before"	: false,
							"icon"				: false,
							"_disabled"			: function (data) {
								return !$.jstree.reference(data.reference).can_paste();
							},
							"separator_after"	: false,
							"label"				: "Paste",
							"action"			: function (data) {
								var inst = $.jstree.reference(data.reference),
									obj = inst.get_node(data.reference);
								inst.paste(obj);
							}
						}
					}
				}
			};
		}
	};

	$.jstree.plugins.contextmenu = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			var last_ts = 0;
			this.element
				.on("contextmenu.jstree", ".jstree-anchor", $.proxy(function (e, data) {
						e.preventDefault();
						last_ts = e.ctrlKey ? +new Date() : 0;
						if(data || cto) {
							last_ts = (+new Date()) + 10000;
						}
						if(cto) {
							clearTimeout(cto);
						}
						if(!this.is_loading(e.currentTarget)) {
							this.show_contextmenu(e.currentTarget, e.pageX, e.pageY, e);
						}
					}, this))
				.on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
						if(this._data.contextmenu.visible && (!last_ts || (+new Date()) - last_ts > 250)) { // work around safari & macOS ctrl+click
							$.vakata.context.hide();
						}
						last_ts = 0;
					}, this))
				.on("touchstart.jstree", ".jstree-anchor", function (e) {
						if(!e.originalEvent || !e.originalEvent.changedTouches || !e.originalEvent.changedTouches[0]) {
							return;
						}
						ex = e.pageX;
						ey = e.pageY;
						cto = setTimeout(function () {
							$(e.currentTarget).trigger('contextmenu', true);
						}, 750);
					});
			/*
			if(!('oncontextmenu' in document.body) && ('ontouchstart' in document.body)) {
				var el = null, tm = null;
				this.element
					.on("touchstart", ".jstree-anchor", function (e) {
						el = e.currentTarget;
						tm = +new Date();
						$(document).one("touchend", function (e) {
							e.target = document.elementFromPoint(e.originalEvent.targetTouches[0].pageX - window.pageXOffset, e.originalEvent.targetTouches[0].pageY - window.pageYOffset);
							e.currentTarget = e.target;
							tm = ((+(new Date())) - tm);
							if(e.target === el && tm > 600 && tm < 1000) {
								e.preventDefault();
								$(el).trigger('contextmenu', e);
							}
							el = null;
							tm = null;
						});
					});
			}
			*/
			$(document).on("context_hide.vakata.jstree", $.proxy(function () { this._data.contextmenu.visible = false; }, this));
		};
		this.teardown = function () {
			if(this._data.contextmenu.visible) {
				$.vakata.context.hide();
			}
			parent.teardown.call(this);
		};

		/**
		 * prepare and show the context menu for a node
		 * @name show_contextmenu(obj [, x, y])
		 * @param {mixed} obj the node
		 * @param {Number} x the x-coordinate relative to the document to show the menu at
		 * @param {Number} y the y-coordinate relative to the document to show the menu at
		 * @param {Object} e the event if available that triggered the contextmenu
		 * @plugin contextmenu
		 * @trigger show_contextmenu.jstree
		 */
		this.show_contextmenu = function (obj, x, y, e) {
			obj = this.get_node(obj);
			if(!obj || obj.id === '#') { return false; }
			var s = this.settings.contextmenu,
				d = this.get_node(obj, true),
				a = d.children(".jstree-anchor"),
				o = false,
				i = false;
			if(s.show_at_node || x === undefined || y === undefined) {
				o = a.offset();
				x = o.left;
				y = o.top + this._data.core.li_height;
			}
			if(this.settings.contextmenu.select_node && !this.is_selected(obj)) {
				this.activate_node(obj, e);
			}

			i = s.items;
			if($.isFunction(i)) {
				i = i.call(this, obj, $.proxy(function (i) {
					this._show_contextmenu(obj, x, y, i);
				}, this));
			}
			if($.isPlainObject(i)) {
				this._show_contextmenu(obj, x, y, i);
			}
		};
		/**
		 * show the prepared context menu for a node
		 * @name _show_contextmenu(obj, x, y, i)
		 * @param {mixed} obj the node
		 * @param {Number} x the x-coordinate relative to the document to show the menu at
		 * @param {Number} y the y-coordinate relative to the document to show the menu at
		 * @param {Number} i the object of items to show
		 * @plugin contextmenu
		 * @trigger show_contextmenu.jstree
		 * @private
		 */
		this._show_contextmenu = function (obj, x, y, i) {
			var d = this.get_node(obj, true),
				a = d.children(".jstree-anchor");
			$(document).one("context_show.vakata.jstree", $.proxy(function (e, data) {
				var cls = 'jstree-contextmenu jstree-' + this.get_theme() + '-contextmenu';
				$(data.element).addClass(cls);
			}, this));
			this._data.contextmenu.visible = true;
			$.vakata.context.show(a, { 'x' : x, 'y' : y }, i);
			/**
			 * triggered when the contextmenu is shown for a node
			 * @event
			 * @name show_contextmenu.jstree
			 * @param {Object} node the node
			 * @param {Number} x the x-coordinate of the menu relative to the document
			 * @param {Number} y the y-coordinate of the menu relative to the document
			 * @plugin contextmenu
			 */
			this.trigger('show_contextmenu', { "node" : obj, "x" : x, "y" : y });
		};
	};

	$(function () {
		$(document)
			.on('touchmove.vakata.jstree', function (e) {
				if(cto && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0] && (Math.abs(ex - e.pageX) > 50 || Math.abs(ey - e.pageY) > 50)) {
					clearTimeout(cto);
				}
			})
			.on('touchend.vakata.jstree', function (e) {
				if(cto) {
					clearTimeout(cto);
				}
			});
	});

	// contextmenu helper
	(function ($) {
		var right_to_left = false,
			vakata_context = {
				element		: false,
				reference	: false,
				position_x	: 0,
				position_y	: 0,
				items		: [],
				html		: "",
				is_visible	: false
			};

		$.vakata.context = {
			settings : {
				hide_onmouseleave	: 0,
				icons				: true
			},
			_trigger : function (event_name) {
				$(document).triggerHandler("context_" + event_name + ".vakata", {
					"reference"	: vakata_context.reference,
					"element"	: vakata_context.element,
					"position"	: {
						"x" : vakata_context.position_x,
						"y" : vakata_context.position_y
					}
				});
			},
			_execute : function (i) {
				i = vakata_context.items[i];
				return i && (!i._disabled || ($.isFunction(i._disabled) && !i._disabled({ "item" : i, "reference" : vakata_context.reference, "element" : vakata_context.element }))) && i.action ? i.action.call(null, {
							"item"		: i,
							"reference"	: vakata_context.reference,
							"element"	: vakata_context.element,
							"position"	: {
								"x" : vakata_context.position_x,
								"y" : vakata_context.position_y
							}
						}) : false;
			},
			_parse : function (o, is_callback) {
				if(!o) { return false; }
				if(!is_callback) {
					vakata_context.html		= "";
					vakata_context.items	= [];
				}
				var str = "",
					sep = false,
					tmp;

				if(is_callback) { str += "<"+"ul>"; }
				$.each(o, function (i, val) {
					if(!val) { return true; }
					vakata_context.items.push(val);
					if(!sep && val.separator_before) {
						str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
					}
					sep = false;
					str += "<"+"li class='" + (val._class || "") + (val._disabled === true || ($.isFunction(val._disabled) && val._disabled({ "item" : val, "reference" : vakata_context.reference, "element" : vakata_context.element })) ? " vakata-contextmenu-disabled " : "") + "' "+(val.shortcut?" data-shortcut='"+val.shortcut+"' ":'')+">";
					str += "<"+"a href='#' rel='" + (vakata_context.items.length - 1) + "'>";
					if($.vakata.context.settings.icons) {
						str += "<"+"i ";
						if(val.icon) {
							if(val.icon.indexOf("/") !== -1 || val.icon.indexOf(".") !== -1) { str += " style='background:url(\"" + val.icon + "\") center center no-repeat' "; }
							else { str += " class='" + val.icon + "' "; }
						}
						str += "><"+"/i><"+"span class='vakata-contextmenu-sep'>&#160;<"+"/span>";
					}
					str += ($.isFunction(val.label) ? val.label({ "item" : i, "reference" : vakata_context.reference, "element" : vakata_context.element }) : val.label) + (val.shortcut?' <span class="vakata-contextmenu-shortcut vakata-contextmenu-shortcut-'+val.shortcut+'">'+ (val.shortcut_label || '') +'</span>':'') + "<"+"/a>";
					if(val.submenu) {
						tmp = $.vakata.context._parse(val.submenu, true);
						if(tmp) { str += tmp; }
					}
					str += "<"+"/li>";
					if(val.separator_after) {
						str += "<"+"li class='vakata-context-separator'><"+"a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<"+"/a><"+"/li>";
						sep = true;
					}
				});
				str  = str.replace(/<li class\='vakata-context-separator'\><\/li\>$/,"");
				if(is_callback) { str += "</ul>"; }
				/**
				 * triggered on the document when the contextmenu is parsed (HTML is built)
				 * @event
				 * @plugin contextmenu
				 * @name context_parse.vakata
				 * @param {jQuery} reference the element that was right clicked
				 * @param {jQuery} element the DOM element of the menu itself
				 * @param {Object} position the x & y coordinates of the menu
				 */
				if(!is_callback) { vakata_context.html = str; $.vakata.context._trigger("parse"); }
				return str.length > 10 ? str : false;
			},
			_show_submenu : function (o) {
				o = $(o);
				if(!o.length || !o.children("ul").length) { return; }
				var e = o.children("ul"),
					x = o.offset().left + o.outerWidth(),
					y = o.offset().top,
					w = e.width(),
					h = e.height(),
					dw = $(window).width() + $(window).scrollLeft(),
					dh = $(window).height() + $(window).scrollTop();
				// може да се спести е една проверка - дали няма някой от класовете вече нагоре
				if(right_to_left) {
					o[x - (w + 10 + o.outerWidth()) < 0 ? "addClass" : "removeClass"]("vakata-context-left");
				}
				else {
					o[x + w + 10 > dw ? "addClass" : "removeClass"]("vakata-context-right");
				}
				if(y + h + 10 > dh) {
					e.css("bottom","-1px");
				}
				e.show();
			},
			show : function (reference, position, data) {
				var o, e, x, y, w, h, dw, dh, cond = true;
				if(vakata_context.element && vakata_context.element.length) {
					vakata_context.element.width('');
				}
				switch(cond) {
					case (!position && !reference):
						return false;
					case (!!position && !!reference):
						vakata_context.reference	= reference;
						vakata_context.position_x	= position.x;
						vakata_context.position_y	= position.y;
						break;
					case (!position && !!reference):
						vakata_context.reference	= reference;
						o = reference.offset();
						vakata_context.position_x	= o.left + reference.outerHeight();
						vakata_context.position_y	= o.top;
						break;
					case (!!position && !reference):
						vakata_context.position_x	= position.x;
						vakata_context.position_y	= position.y;
						break;
				}
				if(!!reference && !data && $(reference).data('vakata_contextmenu')) {
					data = $(reference).data('vakata_contextmenu');
				}
				if($.vakata.context._parse(data)) {
					vakata_context.element.html(vakata_context.html);
				}
				if(vakata_context.items.length) {
					vakata_context.element.appendTo("body");
					e = vakata_context.element;
					x = vakata_context.position_x;
					y = vakata_context.position_y;
					w = e.width();
					h = e.height();
					dw = $(window).width() + $(window).scrollLeft();
					dh = $(window).height() + $(window).scrollTop();
					if(right_to_left) {
						x -= (e.outerWidth() - $(reference).outerWidth());
						if(x < $(window).scrollLeft() + 20) {
							x = $(window).scrollLeft() + 20;
						}
					}
					if(x + w + 20 > dw) {
						x = dw - (w + 20);
					}
					if(y + h + 20 > dh) {
						y = dh - (h + 20);
					}

					vakata_context.element
						.css({ "left" : x, "top" : y })
						.show()
						.find('a').first().focus().parent().addClass("vakata-context-hover");
					vakata_context.is_visible = true;
					/**
					 * triggered on the document when the contextmenu is shown
					 * @event
					 * @plugin contextmenu
					 * @name context_show.vakata
					 * @param {jQuery} reference the element that was right clicked
					 * @param {jQuery} element the DOM element of the menu itself
					 * @param {Object} position the x & y coordinates of the menu
					 */
					$.vakata.context._trigger("show");
				}
			},
			hide : function () {
				if(vakata_context.is_visible) {
					vakata_context.element.hide().find("ul").hide().end().find(':focus').blur().end().detach();
					vakata_context.is_visible = false;
					/**
					 * triggered on the document when the contextmenu is hidden
					 * @event
					 * @plugin contextmenu
					 * @name context_hide.vakata
					 * @param {jQuery} reference the element that was right clicked
					 * @param {jQuery} element the DOM element of the menu itself
					 * @param {Object} position the x & y coordinates of the menu
					 */
					$.vakata.context._trigger("hide");
				}
			}
		};
		$(function () {
			right_to_left = $("body").css("direction") === "rtl";
			var to = false;

			vakata_context.element = $("<ul class='vakata-context'></ul>");
			vakata_context.element
				.on("mouseenter", "li", function (e) {
					e.stopImmediatePropagation();

					if($.contains(this, e.relatedTarget)) {
						// премахнато заради delegate mouseleave по-долу
						// $(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
						return;
					}

					if(to) { clearTimeout(to); }
					vakata_context.element.find(".vakata-context-hover").removeClass("vakata-context-hover").end();

					$(this)
						.siblings().find("ul").hide().end().end()
						.parentsUntil(".vakata-context", "li").addBack().addClass("vakata-context-hover");
					$.vakata.context._show_submenu(this);
				})
				// тестово - дали не натоварва?
				.on("mouseleave", "li", function (e) {
					if($.contains(this, e.relatedTarget)) { return; }
					$(this).find(".vakata-context-hover").addBack().removeClass("vakata-context-hover");
				})
				.on("mouseleave", function (e) {
					$(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
					if($.vakata.context.settings.hide_onmouseleave) {
						to = setTimeout(
							(function (t) {
								return function () { $.vakata.context.hide(); };
							}(this)), $.vakata.context.settings.hide_onmouseleave);
					}
				})
				.on("click", "a", function (e) {
					e.preventDefault();
				//})
				//.on("mouseup", "a", function (e) {
					if(!$(this).blur().parent().hasClass("vakata-context-disabled") && $.vakata.context._execute($(this).attr("rel")) !== false) {
						$.vakata.context.hide();
					}
				})
				.on('keydown', 'a', function (e) {
						var o = null;
						switch(e.which) {
							case 13:
							case 32:
								e.type = "mouseup";
								e.preventDefault();
								$(e.currentTarget).trigger(e);
								break;
							case 37:
								if(vakata_context.is_visible) {
									vakata_context.element.find(".vakata-context-hover").last().closest("li").first().find("ul").hide().find(".vakata-context-hover").removeClass("vakata-context-hover").end().end().children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 38:
								if(vakata_context.is_visible) {
									o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").prevAll("li:not(.vakata-context-separator)").first();
									if(!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").last(); }
									o.addClass("vakata-context-hover").children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 39:
								if(vakata_context.is_visible) {
									vakata_context.element.find(".vakata-context-hover").last().children("ul").show().children("li:not(.vakata-context-separator)").removeClass("vakata-context-hover").first().addClass("vakata-context-hover").children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 40:
								if(vakata_context.is_visible) {
									o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").nextAll("li:not(.vakata-context-separator)").first();
									if(!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").first(); }
									o.addClass("vakata-context-hover").children('a').focus();
									e.stopImmediatePropagation();
									e.preventDefault();
								}
								break;
							case 27:
								$.vakata.context.hide();
								e.preventDefault();
								break;
							default:
								//console.log(e.which);
								break;
						}
					})
				.on('keydown', function (e) {
					e.preventDefault();
					var a = vakata_context.element.find('.vakata-contextmenu-shortcut-' + e.which).parent();
					if(a.parent().not('.vakata-context-disabled')) {
						a.click();
					}
				});

			$(document)
				.on("mousedown.vakata.jstree", function (e) {
					if(vakata_context.is_visible && !$.contains(vakata_context.element[0], e.target)) {
						$.vakata.context.hide();
					}
				})
				.on("context_show.vakata.jstree", function (e, data) {
					vakata_context.element.find("li:has(ul)").children("a").addClass("vakata-context-parent");
					if(right_to_left) {
						vakata_context.element.addClass("vakata-context-rtl").css("direction", "rtl");
					}
					// also apply a RTL class?
					vakata_context.element.find("ul").hide().end();
				});
		});
	}($));
	// $.jstree.defaults.plugins.push("contextmenu");

/**
 * ### Drag'n'drop plugin
 *
 * Enables dragging and dropping of nodes in the tree, resulting in a move or copy operations.
 */

	/**
	 * stores all defaults for the drag'n'drop plugin
	 * @name $.jstree.defaults.dnd
	 * @plugin dnd
	 */
	$.jstree.defaults.dnd = {
		/**
		 * a boolean indicating if a copy should be possible while dragging (by pressint the meta key or Ctrl). Defaults to `true`.
		 * @name $.jstree.defaults.dnd.copy
		 * @plugin dnd
		 */
		copy : true,
		/**
		 * a number indicating how long a node should remain hovered while dragging to be opened. Defaults to `500`.
		 * @name $.jstree.defaults.dnd.open_timeout
		 * @plugin dnd
		 */
		open_timeout : 500,
		/**
		 * a function invoked each time a node is about to be dragged, invoked in the tree's scope and receives the nodes about to be dragged as an argument (array) - return `false` to prevent dragging
		 * @name $.jstree.defaults.dnd.is_draggable
		 * @plugin dnd
		 */
		is_draggable : true,
		/**
		 * a boolean indicating if checks should constantly be made while the user is dragging the node (as opposed to checking only on drop), default is `true`
		 * @name $.jstree.defaults.dnd.check_while_dragging
		 * @plugin dnd
		 */
		check_while_dragging : true,
		/**
		 * a boolean indicating if nodes from this tree should only be copied with dnd (as opposed to moved), default is `false`
		 * @name $.jstree.defaults.dnd.always_copy
		 * @plugin dnd
		 */
		always_copy : false,
		/**
		 * when dropping a node "inside", this setting indicates the position the node should go to - it can be an integer or a string: "first" (same as 0) or "last", default is `0`
		 * @name $.jstree.defaults.dnd.inside_pos
		 * @plugin dnd
		 */
		inside_pos : 0,
		/**
		 * when starting the drag on a node that is selected this setting controls if all selected nodes are dragged or only the single node, default is `true`, which means all selected nodes are dragged when the drag is started on a selected node
		 * @name $.jstree.defaults.dnd.drag_selection
		 * @plugin dnd
		 */
		drag_selection : true,
		/**
		 * controls whether dnd works on touch devices. If left as boolean true dnd will work the same as in desktop browsers, which in some cases may impair scrolling. If set to boolean false dnd will not work on touch devices. There is a special third option - string "selected" which means only selected nodes can be dragged on touch devices.
		 * @name $.jstree.defaults.dnd.touch
		 * @plugin dnd
		 */
		touch : true
	};
	// TODO: now check works by checking for each node individually, how about max_children, unique, etc?
	$.jstree.plugins.dnd = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			this.element
				.on('mousedown.jstree touchstart.jstree', '.jstree-anchor', $.proxy(function (e) {
					if(e.type === "touchstart" && (!this.settings.dnd.touch || (this.settings.dnd.touch === 'selected' && !$(e.currentTarget).hasClass('jstree-clicked')))) {
						return true;
					}
					var obj = this.get_node(e.target),
						mlt = this.is_selected(obj) && this.settings.drag_selection ? this.get_selected().length : 1,
						txt = (mlt > 1 ? mlt + ' ' + this.get_string('nodes') : this.get_text(e.currentTarget));
					if(this.settings.core.force_text) {
						txt = $('<div />').text(txt).html();
					}
					if(obj && obj.id && obj.id !== "#" && (e.which === 1 || e.type === "touchstart") &&
						(this.settings.dnd.is_draggable === true || ($.isFunction(this.settings.dnd.is_draggable) && this.settings.dnd.is_draggable.call(this, (mlt > 1 ? this.get_selected(true) : [obj]))))
					) {
						this.element.trigger('mousedown.jstree');
						return $.vakata.dnd.start(e, { 'jstree' : true, 'origin' : this, 'obj' : this.get_node(obj,true), 'nodes' : mlt > 1 ? this.get_selected() : [obj.id] }, '<div id="jstree-dnd" class="jstree-' + this.get_theme() + ' jstree-' + this.get_theme() + '-' + this.get_theme_variant() + ' ' + ( this.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ) + '"><i class="jstree-icon jstree-er"></i>' + txt + '<ins class="jstree-copy" style="display:none;">+</ins></div>');
					}
				}, this));
		};
	};

	$(function() {
		// bind only once for all instances
		var lastmv = false,
			laster = false,
			opento = false,
			marker = $('<div id="jstree-marker">&#160;</div>').hide(); //.appendTo('body');

		$(document)
			.on('dnd_start.vakata.jstree', function (e, data) {
				lastmv = false;
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.appendTo('body'); //.show();
			})
			.on('dnd_move.vakata.jstree', function (e, data) {
				if(opento) { clearTimeout(opento); }
				if(!data || !data.data || !data.data.jstree) { return; }

				// if we are hovering the marker image do nothing (can happen on "inside" drags)
				if(data.event.target.id && data.event.target.id === 'jstree-marker') {
					return;
				}

				var ins = $.jstree.reference(data.event.target),
					ref = false,
					off = false,
					rel = false,
					l, t, h, p, i, o, ok, t1, t2, op, ps, pr, ip, tm;
				// if we are over an instance
				if(ins && ins._data && ins._data.dnd) {
					marker.attr('class', 'jstree-' + ins.get_theme() + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ));
					data.helper
						.children().attr('class', 'jstree-' + ins.get_theme() + ' jstree-' + ins.get_theme() + '-' + ins.get_theme_variant() + ' ' + ( ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '' ))
						.find('.jstree-copy').first()[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? 'show' : 'hide' ]();


					// if are hovering the container itself add a new root node
					if( (data.event.target === ins.element[0] || data.event.target === ins.get_container_ul()[0]) && ins.get_container_ul().children().length === 0) {
						ok = true;
						for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
							ok = ok && ins.check( (data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)) ) ? "copy_node" : "move_node"), (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), '#', 'last', { 'dnd' : true, 'ref' : ins.get_node('#'), 'pos' : 'i', 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) });
							if(!ok) { break; }
						}
						if(ok) {
							lastmv = { 'ins' : ins, 'par' : '#', 'pos' : 'last' };
							marker.hide();
							data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
							return;
						}
					}
					else {
						// if we are hovering a tree node
						ref = $(data.event.target).closest('.jstree-anchor');
						if(ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {
							off = ref.offset();
							rel = data.event.pageY - off.top;
							h = ref.height();
							if(rel < h / 3) {
								o = ['b', 'i', 'a'];
							}
							else if(rel > h - h / 3) {
								o = ['a', 'i', 'b'];
							}
							else {
								o = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];
							}
							$.each(o, function (j, v) {
								switch(v) {
									case 'b':
										l = off.left - 6;
										t = off.top;
										p = ins.get_parent(ref);
										i = ref.parent().index();
										break;
									case 'i':
										ip = ins.settings.dnd.inside_pos;
										tm = ins.get_node(ref.parent());
										l = off.left - 2;
										t = off.top + h / 2 + 1;
										p = tm.id;
										i = ip === 'first' ? 0 : (ip === 'last' ? tm.children.length : Math.min(ip, tm.children.length));
										break;
									case 'a':
										l = off.left - 6;
										t = off.top + h;
										p = ins.get_parent(ref);
										i = ref.parent().index() + 1;
										break;
								}
								ok = true;
								for(t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
									op = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? "copy_node" : "move_node";
									ps = i;
									if(op === "move_node" && v === 'a' && (data.data.origin && data.data.origin === ins) && p === ins.get_parent(data.data.nodes[t1])) {
										pr = ins.get_node(p);
										if(ps > $.inArray(data.data.nodes[t1], pr.children)) {
											ps -= 1;
										}
									}
									ok = ok && ( (ins && ins.settings && ins.settings.dnd && ins.settings.dnd.check_while_dragging === false) || ins.check(op, (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), p, ps, { 'dnd' : true, 'ref' : ins.get_node(ref.parent()), 'pos' : v, 'is_multi' : (data.data.origin && data.data.origin !== ins), 'is_foreign' : (!data.data.origin) }) );
									if(!ok) {
										if(ins && ins.last_error) { laster = ins.last_error(); }
										break;
									}
								}
								if(v === 'i' && ref.parent().is('.jstree-closed') && ins.settings.dnd.open_timeout) {
									opento = setTimeout((function (x, z) { return function () { x.open_node(z); }; }(ins, ref)), ins.settings.dnd.open_timeout);
								}
								if(ok) {
									lastmv = { 'ins' : ins, 'par' : p, 'pos' : v === 'i' && ip === 'last' && i === 0 && !ins.is_loaded(tm) ? 'last' : i };
									marker.css({ 'left' : l + 'px', 'top' : t + 'px' }).show();
									data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
									laster = {};
									o = true;
									return false;
								}
							});
							if(o === true) { return; }
						}
					}
				}
				lastmv = false;
				data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');
				marker.hide();
			})
			.on('dnd_scroll.vakata.jstree', function (e, data) {
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.hide();
				lastmv = false;
				data.helper.find('.jstree-icon').first().removeClass('jstree-ok').addClass('jstree-er');
			})
			.on('dnd_stop.vakata.jstree', function (e, data) {
				if(opento) { clearTimeout(opento); }
				if(!data || !data.data || !data.data.jstree) { return; }
				marker.hide().detach();
				var i, j, nodes = [];
				if(lastmv) {
					for(i = 0, j = data.data.nodes.length; i < j; i++) {
						nodes[i] = data.data.origin ? data.data.origin.get_node(data.data.nodes[i]) : data.data.nodes[i];
						if(data.data.origin) {
							nodes[i].instance = data.data.origin;
						}
					}
					lastmv.ins[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? 'copy_node' : 'move_node' ](nodes, lastmv.par, lastmv.pos);
					for(i = 0, j = nodes.length; i < j; i++) {
						if(nodes[i].instance) {
							nodes[i].instance = null;
						}
					}
				}
				else {
					i = $(data.event.target).closest('.jstree');
					if(i.length && laster && laster.error && laster.error === 'check') {
						i = i.jstree(true);
						if(i) {
							i.settings.core.error.call(this, laster);
						}
					}
				}
			})
			.on('keyup.jstree keydown.jstree', function (e, data) {
				data = $.vakata.dnd._get();
				if(data && data.data && data.data.jstree) {
					data.helper.find('.jstree-copy').first()[ data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (e.metaKey || e.ctrlKey))) ? 'show' : 'hide' ]();
				}
			});
	});

	// helpers
	(function ($) {
		// private variable
		var vakata_dnd = {
			element	: false,
			target	: false,
			is_down	: false,
			is_drag	: false,
			helper	: false,
			helper_w: 0,
			data	: false,
			init_x	: 0,
			init_y	: 0,
			scroll_l: 0,
			scroll_t: 0,
			scroll_e: false,
			scroll_i: false,
			is_touch: false
		};
		$.vakata.dnd = {
			settings : {
				scroll_speed		: 10,
				scroll_proximity	: 20,
				helper_left			: 5,
				helper_top			: 10,
				threshold			: 5,
				threshold_touch		: 50
			},
			_trigger : function (event_name, e) {
				var data = $.vakata.dnd._get();
				data.event = e;
				$(document).triggerHandler("dnd_" + event_name + ".vakata", data);
			},
			_get : function () {
				return {
					"data"		: vakata_dnd.data,
					"element"	: vakata_dnd.element,
					"helper"	: vakata_dnd.helper
				};
			},
			_clean : function () {
				if(vakata_dnd.helper) { vakata_dnd.helper.remove(); }
				if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
				vakata_dnd = {
					element	: false,
					target	: false,
					is_down	: false,
					is_drag	: false,
					helper	: false,
					helper_w: 0,
					data	: false,
					init_x	: 0,
					init_y	: 0,
					scroll_l: 0,
					scroll_t: 0,
					scroll_e: false,
					scroll_i: false,
					is_touch: false
				};
				$(document).off("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
				$(document).off("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
			},
			_scroll : function (init_only) {
				if(!vakata_dnd.scroll_e || (!vakata_dnd.scroll_l && !vakata_dnd.scroll_t)) {
					if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
					return false;
				}
				if(!vakata_dnd.scroll_i) {
					vakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100);
					return false;
				}
				if(init_only === true) { return false; }

				var i = vakata_dnd.scroll_e.scrollTop(),
					j = vakata_dnd.scroll_e.scrollLeft();
				vakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);
				vakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);
				if(i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {
					/**
					 * triggered on the document when a drag causes an element to scroll
					 * @event
					 * @plugin dnd
					 * @name dnd_scroll.vakata
					 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
					 * @param {DOM} element the DOM element being dragged
					 * @param {jQuery} helper the helper shown next to the mouse
					 * @param {jQuery} event the element that is scrolling
					 */
					$.vakata.dnd._trigger("scroll", vakata_dnd.scroll_e);
				}
			},
			start : function (e, data, html) {
				if(e.type === "touchstart" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(vakata_dnd.is_drag) { $.vakata.dnd.stop({}); }
				try {
					e.currentTarget.unselectable = "on";
					e.currentTarget.onselectstart = function() { return false; };
					if(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }
				} catch(ignore) { }
				vakata_dnd.init_x	= e.pageX;
				vakata_dnd.init_y	= e.pageY;
				vakata_dnd.data		= data;
				vakata_dnd.is_down	= true;
				vakata_dnd.element	= e.currentTarget;
				vakata_dnd.target	= e.target;
				vakata_dnd.is_touch	= e.type === "touchstart";
				if(html !== false) {
					vakata_dnd.helper = $("<div id='vakata-dnd'></div>").html(html).css({
						"display"		: "block",
						"margin"		: "0",
						"padding"		: "0",
						"position"		: "absolute",
						"top"			: "-2000px",
						"lineHeight"	: "16px",
						"zIndex"		: "10000"
					});
				}
				$(document).on("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
				$(document).on("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
				return false;
			},
			drag : function (e) {
				if(e.type === "touchmove" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(!vakata_dnd.is_down) { return; }
				if(!vakata_dnd.is_drag) {
					if(
						Math.abs(e.pageX - vakata_dnd.init_x) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold) ||
						Math.abs(e.pageY - vakata_dnd.init_y) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold)
					) {
						if(vakata_dnd.helper) {
							vakata_dnd.helper.appendTo("body");
							vakata_dnd.helper_w = vakata_dnd.helper.outerWidth();
						}
						vakata_dnd.is_drag = true;
						/**
						 * triggered on the document when a drag starts
						 * @event
						 * @plugin dnd
						 * @name dnd_start.vakata
						 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
						 * @param {DOM} element the DOM element being dragged
						 * @param {jQuery} helper the helper shown next to the mouse
						 * @param {Object} event the event that caused the start (probably mousemove)
						 */
						$.vakata.dnd._trigger("start", e);
					}
					else { return; }
				}

				var d  = false, w  = false,
					dh = false, wh = false,
					dw = false, ww = false,
					dt = false, dl = false,
					ht = false, hl = false;

				vakata_dnd.scroll_t = 0;
				vakata_dnd.scroll_l = 0;
				vakata_dnd.scroll_e = false;
				$($(e.target).parentsUntil("body").addBack().get().reverse())
					.filter(function () {
						return	(/^auto|scroll$/).test($(this).css("overflow")) &&
								(this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth);
					})
					.each(function () {
						var t = $(this), o = t.offset();
						if(this.scrollHeight > this.offsetHeight) {
							if(o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
							if(e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_t = -1; }
						}
						if(this.scrollWidth > this.offsetWidth) {
							if(o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
							if(e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_l = -1; }
						}
						if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
							vakata_dnd.scroll_e = $(this);
							return false;
						}
					});

				if(!vakata_dnd.scroll_e) {
					d  = $(document); w = $(window);
					dh = d.height(); wh = w.height();
					dw = d.width(); ww = w.width();
					dt = d.scrollTop(); dl = d.scrollLeft();
					if(dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_t = -1;  }
					if(dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
					if(dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_l = -1; }
					if(dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
					if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
						vakata_dnd.scroll_e = d;
					}
				}
				if(vakata_dnd.scroll_e) { $.vakata.dnd._scroll(true); }

				if(vakata_dnd.helper) {
					ht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);
					hl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);
					if(dh && ht + 25 > dh) { ht = dh - 50; }
					if(dw && hl + vakata_dnd.helper_w > dw) { hl = dw - (vakata_dnd.helper_w + 2); }
					vakata_dnd.helper.css({
						left	: hl + "px",
						top		: ht + "px"
					});
				}
				/**
				 * triggered on the document when a drag is in progress
				 * @event
				 * @plugin dnd
				 * @name dnd_move.vakata
				 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
				 * @param {DOM} element the DOM element being dragged
				 * @param {jQuery} helper the helper shown next to the mouse
				 * @param {Object} event the event that caused this to trigger (most likely mousemove)
				 */
				$.vakata.dnd._trigger("move", e);
				return false;
			},
			stop : function (e) {
				if(e.type === "touchend" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
					e.pageX = e.originalEvent.changedTouches[0].pageX;
					e.pageY = e.originalEvent.changedTouches[0].pageY;
					e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
				}
				if(vakata_dnd.is_drag) {
					/**
					 * triggered on the document when a drag stops (the dragged element is dropped)
					 * @event
					 * @plugin dnd
					 * @name dnd_stop.vakata
					 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
					 * @param {DOM} element the DOM element being dragged
					 * @param {jQuery} helper the helper shown next to the mouse
					 * @param {Object} event the event that caused the stop
					 */
					$.vakata.dnd._trigger("stop", e);
				}
				else {
					if(e.type === "touchend" && e.target === vakata_dnd.target) {
						var to = setTimeout(function () { $(e.target).click(); }, 100);
						$(e.target).one('click', function() { if(to) { clearTimeout(to); } });
					}
				}
				$.vakata.dnd._clean();
				return false;
			}
		};
	}($));

	// include the dnd plugin by default
	// $.jstree.defaults.plugins.push("dnd");


/**
 * ### Search plugin
 *
 * Adds search functionality to jsTree.
 */

	/**
	 * stores all defaults for the search plugin
	 * @name $.jstree.defaults.search
	 * @plugin search
	 */
	$.jstree.defaults.search = {
		/**
		 * a jQuery-like AJAX config, which jstree uses if a server should be queried for results. 
		 * 
		 * A `str` (which is the search string) parameter will be added with the request. The expected result is a JSON array with nodes that need to be opened so that matching nodes will be revealed.
		 * Leave this setting as `false` to not query the server. You can also set this to a function, which will be invoked in the instance's scope and receive 2 parameters - the search string and the callback to call with the array of nodes to load.
		 * @name $.jstree.defaults.search.ajax
		 * @plugin search
		 */
		ajax : false,
		/**
		 * Indicates if the search should be fuzzy or not (should `chnd3` match `child node 3`). Default is `false`.
		 * @name $.jstree.defaults.search.fuzzy
		 * @plugin search
		 */
		fuzzy : false,
		/**
		 * Indicates if the search should be case sensitive. Default is `false`.
		 * @name $.jstree.defaults.search.case_sensitive
		 * @plugin search
		 */
		case_sensitive : false,
		/**
		 * Indicates if the tree should be filtered (by default) to show only matching nodes (keep in mind this can be a heavy on large trees in old browsers). 
		 * This setting can be changed at runtime when calling the search method. Default is `false`.
		 * @name $.jstree.defaults.search.show_only_matches
		 * @plugin search
		 */
		show_only_matches : false,
		/**
		 * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.
		 * @name $.jstree.defaults.search.close_opened_onclear
		 * @plugin search
		 */
		close_opened_onclear : true,
		/**
		 * Indicates if only leaf nodes should be included in search results. Default is `false`.
		 * @name $.jstree.defaults.search.search_leaves_only
		 * @plugin search
		 */
		search_leaves_only : false,
		/**
		 * If set to a function it wil be called in the instance's scope with two arguments - search string and node (where node will be every node in the structure, so use with caution).
		 * If the function returns a truthy value the node will be considered a match (it might not be displayed if search_only_leaves is set to true and the node is not a leaf). Default is `false`.
		 * @name $.jstree.defaults.search.search_callback
		 * @plugin search
		 */
		search_callback : false
	};

	$.jstree.plugins.search = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			this._data.search.str = "";
			this._data.search.dom = $();
			this._data.search.res = [];
			this._data.search.opn = [];
			this._data.search.som = false;

			this.element
				.on('before_open.jstree', $.proxy(function (e, data) {
						var i, j, f, r = this._data.search.res, s = [], o = $();
						if(r && r.length) {
							this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #')));
							this._data.search.dom.children(".jstree-anchor").addClass('jstree-search');
							if(this._data.search.som && this._data.search.res.length) {
								for(i = 0, j = r.length; i < j; i++) {
									s = s.concat(this.get_node(r[i]).parents);
								}
								s = $.vakata.array_remove_item($.vakata.array_unique(s),'#');
								o = s.length ? $(this.element[0].querySelectorAll('#' + $.map(s, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #'))) : $();

								this.element.find(".jstree-node").hide().filter('.jstree-last').filter(function() { return this.nextSibling; }).removeClass('jstree-last');
								o = o.add(this._data.search.dom);
								o.parentsUntil(".jstree").addBack().show()
									.filter(".jstree-children").each(function () { $(this).children(".jstree-node:visible").eq(-1).addClass("jstree-last"); });
							}
						}
					}, this))
				.on("search.jstree", $.proxy(function (e, data) {
						if(this._data.search.som) {
							if(data.nodes.length) {
								this.element.find(".jstree-node").hide().filter('.jstree-last').filter(function() { return this.nextSibling; }).removeClass('jstree-last');
								data.nodes.parentsUntil(".jstree").addBack().show()
									.filter(".jstree-children").each(function () { $(this).children(".jstree-node:visible").eq(-1).addClass("jstree-last"); });
							}
						}
					}, this))
				.on("clear_search.jstree", $.proxy(function (e, data) {
						if(this._data.search.som && data.nodes.length) {
							this.element.find(".jstree-node").css("display","").filter('.jstree-last').filter(function() { return this.nextSibling; }).removeClass('jstree-last');
						}
					}, this));
		};
		/**
		 * used to search the tree nodes for a given string
		 * @name search(str [, skip_async])
		 * @param {String} str the search string
		 * @param {Boolean} skip_async if set to true server will not be queried even if configured
		 * @param {Boolean} show_only_matches if set to true only matching nodes will be shown (keep in mind this can be very slow on large trees or old browsers)
		 * @plugin search
		 * @trigger search.jstree
		 */
		this.search = function (str, skip_async, show_only_matches) {
			if(str === false || $.trim(str.toString()) === "") {
				return this.clear_search();
			}
			str = str.toString();
			var s = this.settings.search,
				a = s.ajax ? s.ajax : false,
				f = null,
				r = [],
				p = [], i, j;
			if(this._data.search.res.length) {
				this.clear_search();
			}
			if(show_only_matches === undefined) {
				show_only_matches = s.show_only_matches;
			}
			if(!skip_async && a !== false) {
				if($.isFunction(a)) {
					return a.call(this, str, $.proxy(function (d) {
							if(d && d.d) { d = d.d; }
							this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
								this.search(str, true, show_only_matches);
							}, true);
						}, this));
				}
				else {
					a = $.extend({}, a);
					if(!a.data) { a.data = {}; }
					a.data.str = str;
					return $.ajax(a)
						.fail($.proxy(function () {
							this._data.core.last_error = { 'error' : 'ajax', 'plugin' : 'search', 'id' : 'search_01', 'reason' : 'Could not load search parents', 'data' : JSON.stringify(a) };
							this.settings.core.error.call(this, this._data.core.last_error);
						}, this))
						.done($.proxy(function (d) {
							if(d && d.d) { d = d.d; }
							this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
								this.search(str, true, show_only_matches);
							}, true);
						}, this));
				}
			}
			this._data.search.str = str;
			this._data.search.dom = $();
			this._data.search.res = [];
			this._data.search.opn = [];
			this._data.search.som = show_only_matches;

			f = new $.vakata.search(str, true, { caseSensitive : s.case_sensitive, fuzzy : s.fuzzy });

			$.each(this._model.data, function (i, v) {
				if(v.text && ( (s.search_callback && s.search_callback.call(this, str, v)) || (!s.search_callback && f.search(v.text).isMatch) ) && (!s.search_leaves_only || (v.state.loaded && v.children.length === 0)) ) {
					r.push(i);
					p = p.concat(v.parents);
				}
			});
			if(r.length) {
				p = $.vakata.array_unique(p);
				this._search_open(p);
				this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex,'\\$&') : v.replace($.jstree.idregex,'\\$&'); }).join(', #')));
				this._data.search.res = r;
				this._data.search.dom.children(".jstree-anchor").addClass('jstree-search');
			}
			/**
			 * triggered after search is complete
			 * @event
			 * @name search.jstree
			 * @param {jQuery} nodes a jQuery collection of matching nodes
			 * @param {String} str the search string
			 * @param {Array} res a collection of objects represeing the matching nodes
			 * @plugin search
			 */
			this.trigger('search', { nodes : this._data.search.dom, str : str, res : this._data.search.res, show_only_matches : show_only_matches });
		};
		/**
		 * used to clear the last search (removes classes and shows all nodes if filtering is on)
		 * @name clear_search()
		 * @plugin search
		 * @trigger clear_search.jstree
		 */
		this.clear_search = function () {
			this._data.search.dom.children(".jstree-anchor").removeClass("jstree-search");
			if(this.settings.search.close_opened_onclear) {
				this.close_node(this._data.search.opn, 0);
			}
			/**
			 * triggered after search is complete
			 * @event
			 * @name clear_search.jstree
			 * @param {jQuery} nodes a jQuery collection of matching nodes (the result from the last search)
			 * @param {String} str the search string (the last search string)
			 * @param {Array} res a collection of objects represeing the matching nodes (the result from the last search)
			 * @plugin search
			 */
			this.trigger('clear_search', { 'nodes' : this._data.search.dom, str : this._data.search.str, res : this._data.search.res });
			this._data.search.str = "";
			this._data.search.res = [];
			this._data.search.opn = [];
			this._data.search.dom = $();
		};
		/**
		 * opens nodes that need to be opened to reveal the search results. Used only internally.
		 * @private
		 * @name _search_open(d)
		 * @param {Array} d an array of node IDs
		 * @plugin search
		 */
		this._search_open = function (d) {
			var t = this;
			$.each(d.concat([]), function (i, v) {
				if(v === "#") { return true; }
				try { v = $('#' + v.replace($.jstree.idregex,'\\$&'), t.element); } catch(ignore) { }
				if(v && v.length) {
					if(t.is_closed(v)) {
						t._data.search.opn.push(v[0].id);
						t.open_node(v, function () { t._search_open(d); }, 0);
					}
				}
			});
		};
	};

	// helpers
	(function ($) {
		// from http://kiro.me/projects/fuse.html
		$.vakata.search = function(pattern, txt, options) {
			options = options || {};
			if(options.fuzzy !== false) {
				options.fuzzy = true;
			}
			pattern = options.caseSensitive ? pattern : pattern.toLowerCase();
			var MATCH_LOCATION	= options.location || 0,
				MATCH_DISTANCE	= options.distance || 100,
				MATCH_THRESHOLD	= options.threshold || 0.6,
				patternLen = pattern.length,
				matchmask, pattern_alphabet, match_bitapScore, search;
			if(patternLen > 32) {
				options.fuzzy = false;
			}
			if(options.fuzzy) {
				matchmask = 1 << (patternLen - 1);
				pattern_alphabet = (function () {
					var mask = {},
						i = 0;
					for (i = 0; i < patternLen; i++) {
						mask[pattern.charAt(i)] = 0;
					}
					for (i = 0; i < patternLen; i++) {
						mask[pattern.charAt(i)] |= 1 << (patternLen - i - 1);
					}
					return mask;
				}());
				match_bitapScore = function (e, x) {
					var accuracy = e / patternLen,
						proximity = Math.abs(MATCH_LOCATION - x);
					if(!MATCH_DISTANCE) {
						return proximity ? 1.0 : accuracy;
					}
					return accuracy + (proximity / MATCH_DISTANCE);
				};
			}
			search = function (text) {
				text = options.caseSensitive ? text : text.toLowerCase();
				if(pattern === text || text.indexOf(pattern) !== -1) {
					return {
						isMatch: true,
						score: 0
					};
				}
				if(!options.fuzzy) {
					return {
						isMatch: false,
						score: 1
					};
				}
				var i, j,
					textLen = text.length,
					scoreThreshold = MATCH_THRESHOLD,
					bestLoc = text.indexOf(pattern, MATCH_LOCATION),
					binMin, binMid,
					binMax = patternLen + textLen,
					lastRd, start, finish, rd, charMatch,
					score = 1,
					locations = [];
				if (bestLoc !== -1) {
					scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
					bestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);
					if (bestLoc !== -1) {
						scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
					}
				}
				bestLoc = -1;
				for (i = 0; i < patternLen; i++) {
					binMin = 0;
					binMid = binMax;
					while (binMin < binMid) {
						if (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {
							binMin = binMid;
						} else {
							binMax = binMid;
						}
						binMid = Math.floor((binMax - binMin) / 2 + binMin);
					}
					binMax = binMid;
					start = Math.max(1, MATCH_LOCATION - binMid + 1);
					finish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;
					rd = new Array(finish + 2);
					rd[finish + 1] = (1 << i) - 1;
					for (j = finish; j >= start; j--) {
						charMatch = pattern_alphabet[text.charAt(j - 1)];
						if (i === 0) {
							rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
						} else {
							rd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((lastRd[j + 1] | lastRd[j]) << 1) | 1) | lastRd[j + 1];
						}
						if (rd[j] & matchmask) {
							score = match_bitapScore(i, j - 1);
							if (score <= scoreThreshold) {
								scoreThreshold = score;
								bestLoc = j - 1;
								locations.push(bestLoc);
								if (bestLoc > MATCH_LOCATION) {
									start = Math.max(1, 2 * MATCH_LOCATION - bestLoc);
								} else {
									break;
								}
							}
						}
					}
					if (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {
						break;
					}
					lastRd = rd;
				}
				return {
					isMatch: bestLoc >= 0,
					score: score
				};
			};
			return txt === true ? { 'search' : search } : search(txt);
		};
	}($));

	// include the search plugin by default
	// $.jstree.defaults.plugins.push("search");

/**
 * ### Sort plugin
 *
 * Automatically sorts all siblings in the tree according to a sorting function.
 */

	/**
	 * the settings function used to sort the nodes.
	 * It is executed in the tree's context, accepts two nodes as arguments and should return `1` or `-1`.
	 * @name $.jstree.defaults.sort
	 * @plugin sort
	 */
	$.jstree.defaults.sort = function (a, b) {
		//return this.get_type(a) === this.get_type(b) ? (this.get_text(a) > this.get_text(b) ? 1 : -1) : this.get_type(a) >= this.get_type(b);
		return this.get_text(a) > this.get_text(b) ? 1 : -1;
	};
	$.jstree.plugins.sort = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			this.element
				.on("model.jstree", $.proxy(function (e, data) {
						this.sort(data.parent, true);
					}, this))
				.on("rename_node.jstree create_node.jstree", $.proxy(function (e, data) {
						this.sort(data.parent || data.node.parent, false);
						this.redraw_node(data.parent || data.node.parent, true);
					}, this))
				.on("move_node.jstree copy_node.jstree", $.proxy(function (e, data) {
						this.sort(data.parent, false);
						this.redraw_node(data.parent, true);
					}, this));
		};
		/**
		 * used to sort a node's children
		 * @private
		 * @name sort(obj [, deep])
		 * @param  {mixed} obj the node
		 * @param {Boolean} deep if set to `true` nodes are sorted recursively.
		 * @plugin sort
		 * @trigger search.jstree
		 */
		this.sort = function (obj, deep) {
			var i, j;
			obj = this.get_node(obj);
			if(obj && obj.children && obj.children.length) {
				obj.children.sort($.proxy(this.settings.sort, this));
				if(deep) {
					for(i = 0, j = obj.children_d.length; i < j; i++) {
						this.sort(obj.children_d[i], false);
					}
				}
			}
		};
	};

	// include the sort plugin by default
	// $.jstree.defaults.plugins.push("sort");

/**
 * ### State plugin
 *
 * Saves the state of the tree (selected nodes, opened nodes) on the user's computer using available options (localStorage, cookies, etc)
 */

	var to = false;
	/**
	 * stores all defaults for the state plugin
	 * @name $.jstree.defaults.state
	 * @plugin state
	 */
	$.jstree.defaults.state = {
		/**
		 * A string for the key to use when saving the current tree (change if using multiple trees in your project). Defaults to `jstree`.
		 * @name $.jstree.defaults.state.key
		 * @plugin state
		 */
		key		: 'jstree',
		/**
		 * A space separated list of events that trigger a state save. Defaults to `changed.jstree open_node.jstree close_node.jstree`.
		 * @name $.jstree.defaults.state.events
		 * @plugin state
		 */
		events	: 'changed.jstree open_node.jstree close_node.jstree check_node.jstree uncheck_node.jstree',
		/**
		 * Time in milliseconds after which the state will expire. Defaults to 'false' meaning - no expire.
		 * @name $.jstree.defaults.state.ttl
		 * @plugin state
		 */
		ttl		: false,
		/**
		 * A function that will be executed prior to restoring state with one argument - the state object. Can be used to clear unwanted parts of the state.
		 * @name $.jstree.defaults.state.filter
		 * @plugin state
		 */
		filter	: false
	};
	$.jstree.plugins.state = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);
			var bind = $.proxy(function () {
				this.element.on(this.settings.state.events, $.proxy(function () {
					if(to) { clearTimeout(to); }
					to = setTimeout($.proxy(function () { this.save_state(); }, this), 100);
				}, this));
				/**
				 * triggered when the state plugin is finished restoring the state (and immediately after ready if there is no state to restore).
				 * @event
				 * @name state_ready.jstree
				 * @plugin state
				 */
				this.trigger('state_ready');
			}, this);
			this.element
				.on("ready.jstree", $.proxy(function (e, data) {
						this.element.one("restore_state.jstree", bind);
						if(!this.restore_state()) { bind(); }
					}, this));
		};
		/**
		 * save the state
		 * @name save_state()
		 * @plugin state
		 */
		this.save_state = function () {
			var st = { 'state' : this.get_state(), 'ttl' : this.settings.state.ttl, 'sec' : +(new Date()) };
			$.vakata.storage.set(this.settings.state.key, JSON.stringify(st));
		};
		/**
		 * restore the state from the user's computer
		 * @name restore_state()
		 * @plugin state
		 */
		this.restore_state = function () {
			var k = $.vakata.storage.get(this.settings.state.key);
			if(!!k) { try { k = JSON.parse(k); } catch(ex) { return false; } }
			if(!!k && k.ttl && k.sec && +(new Date()) - k.sec > k.ttl) { return false; }
			if(!!k && k.state) { k = k.state; }
			if(!!k && $.isFunction(this.settings.state.filter)) { k = this.settings.state.filter.call(this, k); }
			if(!!k) {
				this.element.one("set_state.jstree", function (e, data) { data.instance.trigger('restore_state', { 'state' : $.extend(true, {}, k) }); });
				this.set_state(k);
				return true;
			}
			return false;
		};
		/**
		 * clear the state on the user's computer
		 * @name clear_state()
		 * @plugin state
		 */
		this.clear_state = function () {
			return $.vakata.storage.del(this.settings.state.key);
		};
	};

	(function ($, undefined) {
		$.vakata.storage = {
			// simply specifying the functions in FF throws an error
			set : function (key, val) { return window.localStorage.setItem(key, val); },
			get : function (key) { return window.localStorage.getItem(key); },
			del : function (key) { return window.localStorage.removeItem(key); }
		};
	}($));

	// include the state plugin by default
	// $.jstree.defaults.plugins.push("state");

/**
 * ### Types plugin
 *
 * Makes it possible to add predefined types for groups of nodes, which make it possible to easily control nesting rules and icon for each group.
 */

	/**
	 * An object storing all types as key value pairs, where the key is the type name and the value is an object that could contain following keys (all optional).
	 * 
	 * * `max_children` the maximum number of immediate children this node type can have. Do not specify or set to `-1` for unlimited.
	 * * `max_depth` the maximum number of nesting this node type can have. A value of `1` would mean that the node can have children, but no grandchildren. Do not specify or set to `-1` for unlimited.
	 * * `valid_children` an array of node type strings, that nodes of this type can have as children. Do not specify or set to `-1` for no limits.
	 * * `icon` a string - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class. Omit to use the default icon from your theme.
	 *
	 * There are two predefined types:
	 * 
	 * * `#` represents the root of the tree, for example `max_children` would control the maximum number of root nodes.
	 * * `default` represents the default node - any settings here will be applied to all nodes that do not have a type specified.
	 * 
	 * @name $.jstree.defaults.types
	 * @plugin types
	 */
	$.jstree.defaults.types = {
		'#' : {},
		'default' : {}
	};

	$.jstree.plugins.types = function (options, parent) {
		this.init = function (el, options) {
			var i, j;
			if(options && options.types && options.types['default']) {
				for(i in options.types) {
					if(i !== "default" && i !== "#" && options.types.hasOwnProperty(i)) {
						for(j in options.types['default']) {
							if(options.types['default'].hasOwnProperty(j) && options.types[i][j] === undefined) {
								options.types[i][j] = options.types['default'][j];
							}
						}
					}
				}
			}
			parent.init.call(this, el, options);
			this._model.data['#'].type = '#';
		};
		this.refresh = function (skip_loading, forget_state) {
			parent.refresh.call(this, skip_loading, forget_state);
			this._model.data['#'].type = '#';
		};
		this.bind = function () {
			this.element
				.on('model.jstree', $.proxy(function (e, data) {
						var m = this._model.data,
							dpc = data.nodes,
							t = this.settings.types,
							i, j, c = 'default';
						for(i = 0, j = dpc.length; i < j; i++) {
							c = 'default';
							if(m[dpc[i]].original && m[dpc[i]].original.type && t[m[dpc[i]].original.type]) {
								c = m[dpc[i]].original.type;
							}
							if(m[dpc[i]].data && m[dpc[i]].data.jstree && m[dpc[i]].data.jstree.type && t[m[dpc[i]].data.jstree.type]) {
								c = m[dpc[i]].data.jstree.type;
							}
							m[dpc[i]].type = c;
							if(m[dpc[i]].icon === true && t[c].icon !== undefined) {
								m[dpc[i]].icon = t[c].icon;
							}
						}
						m['#'].type = '#';
					}, this));
			parent.bind.call(this);
		};
		this.get_json = function (obj, options, flat) {
			var i, j,
				m = this._model.data,
				opt = options ? $.extend(true, {}, options, {no_id:false}) : {},
				tmp = parent.get_json.call(this, obj, opt, flat);
			if(tmp === false) { return false; }
			if($.isArray(tmp)) {
				for(i = 0, j = tmp.length; i < j; i++) {
					tmp[i].type = tmp[i].id && m[tmp[i].id] && m[tmp[i].id].type ? m[tmp[i].id].type : "default";
					if(options && options.no_id) {
						delete tmp[i].id;
						if(tmp[i].li_attr && tmp[i].li_attr.id) {
							delete tmp[i].li_attr.id;
						}
						if(tmp[i].a_attr && tmp[i].a_attr.id) {
							delete tmp[i].a_attr.id;
						}
					}
				}
			}
			else {
				tmp.type = tmp.id && m[tmp.id] && m[tmp.id].type ? m[tmp.id].type : "default";
				if(options && options.no_id) {
					tmp = this._delete_ids(tmp);
				}
			}
			return tmp;
		};
		this._delete_ids = function (tmp) {
			if($.isArray(tmp)) {
				for(var i = 0, j = tmp.length; i < j; i++) {
					tmp[i] = this._delete_ids(tmp[i]);
				}
				return tmp;
			}
			delete tmp.id;
			if(tmp.li_attr && tmp.li_attr.id) {
				delete tmp.li_attr.id;
			}
			if(tmp.a_attr && tmp.a_attr.id) {
				delete tmp.a_attr.id;
			}
			if(tmp.children && $.isArray(tmp.children)) {
				tmp.children = this._delete_ids(tmp.children);
			}
			return tmp;
		};
		this.check = function (chk, obj, par, pos, more) {
			if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			var m = obj && obj.id ? $.jstree.reference(obj.id) : null, tmp, d, i, j;
			m = m && m._model && m._model.data ? m._model.data : null;
			switch(chk) {
				case "create_node":
				case "move_node":
				case "copy_node":
					if(chk !== 'move_node' || $.inArray(obj.id, par.children) === -1) {
						tmp = this.get_rules(par);
						if(tmp.max_children !== undefined && tmp.max_children !== -1 && tmp.max_children === par.children.length) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_01', 'reason' : 'max_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
							return false;
						}
						if(tmp.valid_children !== undefined && tmp.valid_children !== -1 && $.inArray((obj.type || 'default'), tmp.valid_children) === -1) {
							this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_02', 'reason' : 'valid_children prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
							return false;
						}
						if(m && obj.children_d && obj.parents) {
							d = 0;
							for(i = 0, j = obj.children_d.length; i < j; i++) {
								d = Math.max(d, m[obj.children_d[i]].parents.length);
							}
							d = d - obj.parents.length + 1;
						}
						if(d <= 0 || d === undefined) { d = 1; }
						do {
							if(tmp.max_depth !== undefined && tmp.max_depth !== -1 && tmp.max_depth < d) {
								this._data.core.last_error = { 'error' : 'check', 'plugin' : 'types', 'id' : 'types_03', 'reason' : 'max_depth prevents function: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
								return false;
							}
							par = this.get_node(par.parent);
							tmp = this.get_rules(par);
							d++;
						} while(par);
					}
					break;
			}
			return true;
		};
		/**
		 * used to retrieve the type settings object for a node
		 * @name get_rules(obj)
		 * @param {mixed} obj the node to find the rules for
		 * @return {Object}
		 * @plugin types
		 */
		this.get_rules = function (obj) {
			obj = this.get_node(obj);
			if(!obj) { return false; }
			var tmp = this.get_type(obj, true);
			if(tmp.max_depth === undefined) { tmp.max_depth = -1; }
			if(tmp.max_children === undefined) { tmp.max_children = -1; }
			if(tmp.valid_children === undefined) { tmp.valid_children = -1; }
			return tmp;
		};
		/**
		 * used to retrieve the type string or settings object for a node
		 * @name get_type(obj [, rules])
		 * @param {mixed} obj the node to find the rules for
		 * @param {Boolean} rules if set to `true` instead of a string the settings object will be returned
		 * @return {String|Object}
		 * @plugin types
		 */
		this.get_type = function (obj, rules) {
			obj = this.get_node(obj);
			return (!obj) ? false : ( rules ? $.extend({ 'type' : obj.type }, this.settings.types[obj.type]) : obj.type);
		};
		/**
		 * used to change a node's type
		 * @name set_type(obj, type)
		 * @param {mixed} obj the node to change
		 * @param {String} type the new type
		 * @plugin types
		 */
		this.set_type = function (obj, type) {
			var t, t1, t2, old_type, old_icon;
			if($.isArray(obj)) {
				obj = obj.slice();
				for(t1 = 0, t2 = obj.length; t1 < t2; t1++) {
					this.set_type(obj[t1], type);
				}
				return true;
			}
			t = this.settings.types;
			obj = this.get_node(obj);
			if(!t[type] || !obj) { return false; }
			old_type = obj.type;
			old_icon = this.get_icon(obj);
			obj.type = type;
			if(old_icon === true || (t[old_type] && t[old_type].icon !== undefined && old_icon === t[old_type].icon)) {
				this.set_icon(obj, t[type].icon !== undefined ? t[type].icon : true);
			}
			return true;
		};
	};
	// include the types plugin by default
	// $.jstree.defaults.plugins.push("types");

/**
 * ### Unique plugin
 *
 * Enforces that no nodes with the same name can coexist as siblings.
 */

	/**
	 * stores all defaults for the unique plugin
	 * @name $.jstree.defaults.unique
	 * @plugin unique
	 */
	$.jstree.defaults.unique = {
		/**
		 * Indicates if the comparison should be case sensitive. Default is `false`.
		 * @name $.jstree.defaults.unique.case_sensitive
		 * @plugin unique
		 */
		case_sensitive : false,
		/**
		 * A callback executed in the instance's scope when a new node is created and the name is already taken, the two arguments are the conflicting name and the counter. The default will produce results like `New node (2)`.
		 * @name $.jstree.defaults.unique.duplicate
		 * @plugin unique
		 */
		duplicate : function (name, counter) {
			return name + ' (' + counter + ')';
		}
	};

	$.jstree.plugins.unique = function (options, parent) {
		this.check = function (chk, obj, par, pos, more) {
			if(parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
			obj = obj && obj.id ? obj : this.get_node(obj);
			par = par && par.id ? par : this.get_node(par);
			if(!par || !par.children) { return true; }
			var n = chk === "rename_node" ? pos : obj.text,
				c = [],
				s = this.settings.unique.case_sensitive,
				m = this._model.data, i, j;
			for(i = 0, j = par.children.length; i < j; i++) {
				c.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
			}
			if(!s) { n = n.toLowerCase(); }
			switch(chk) {
				case "delete_node":
					return true;
				case "rename_node":
					i = ($.inArray(n, c) === -1 || (obj.text && obj.text[ s ? 'toString' : 'toLowerCase']() === n));
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_01', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "create_node":
					i = ($.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_04', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "copy_node":
					i = ($.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_02', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
				case "move_node":
					i = (obj.parent === par.id || $.inArray(n, c) === -1);
					if(!i) {
						this._data.core.last_error = { 'error' : 'check', 'plugin' : 'unique', 'id' : 'unique_03', 'reason' : 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data' : JSON.stringify({ 'chk' : chk, 'pos' : pos, 'obj' : obj && obj.id ? obj.id : false, 'par' : par && par.id ? par.id : false }) };
					}
					return i;
			}
			return true;
		};
		this.create_node = function (par, node, pos, callback, is_loaded) {
			if(!node || node.text === undefined) {
				if(par === null) {
					par = "#";
				}
				par = this.get_node(par);
				if(!par) {
					return parent.create_node.call(this, par, node, pos, callback, is_loaded);
				}
				pos = pos === undefined ? "last" : pos;
				if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
					return parent.create_node.call(this, par, node, pos, callback, is_loaded);
				}
				if(!node) { node = {}; }
				var tmp, n, dpc, i, j, m = this._model.data, s = this.settings.unique.case_sensitive, cb = this.settings.unique.duplicate;
				n = tmp = this.get_string('New node');
				dpc = [];
				for(i = 0, j = par.children.length; i < j; i++) {
					dpc.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
				}
				i = 1;
				while($.inArray(s ? n : n.toLowerCase(), dpc) !== -1) {
					n = cb.call(this, tmp, (++i)).toString();
				}
				node.text = n;
			}
			return parent.create_node.call(this, par, node, pos, callback, is_loaded);
		};
	};

	// include the unique plugin by default
	// $.jstree.defaults.plugins.push("unique");


/**
 * ### Wholerow plugin
 *
 * Makes each node appear block level. Making selection easier. May cause slow down for large trees in old browsers.
 */

	var div = document.createElement('DIV');
	div.setAttribute('unselectable','on');
	div.setAttribute('role','presentation');
	div.className = 'jstree-wholerow';
	div.innerHTML = '&#160;';
	$.jstree.plugins.wholerow = function (options, parent) {
		this.bind = function () {
			parent.bind.call(this);

			this.element
				.on('ready.jstree set_state.jstree', $.proxy(function () {
						this.hide_dots();
					}, this))
				.on("init.jstree loading.jstree ready.jstree", $.proxy(function () {
						//div.style.height = this._data.core.li_height + 'px';
						this.get_container_ul().addClass('jstree-wholerow-ul');
					}, this))
				.on("deselect_all.jstree", $.proxy(function (e, data) {
						this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
					}, this))
				.on("changed.jstree", $.proxy(function (e, data) {
						this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
						var tmp = false, i, j;
						for(i = 0, j = data.selected.length; i < j; i++) {
							tmp = this.get_node(data.selected[i], true);
							if(tmp && tmp.length) {
								tmp.children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
							}
						}
					}, this))
				.on("open_node.jstree", $.proxy(function (e, data) {
						this.get_node(data.node, true).find('.jstree-clicked').parent().children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
					}, this))
				.on("hover_node.jstree dehover_node.jstree", $.proxy(function (e, data) {
						if(e.type === "hover_node" && this.is_disabled(data.node)) { return; }
						this.get_node(data.node, true).children('.jstree-wholerow')[e.type === "hover_node"?"addClass":"removeClass"]('jstree-wholerow-hovered');
					}, this))
				.on("contextmenu.jstree", ".jstree-wholerow", $.proxy(function (e) {
						e.preventDefault();
						var tmp = $.Event('contextmenu', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey, pageX : e.pageX, pageY : e.pageY });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp);
					}, this))
				.on("click.jstree", ".jstree-wholerow", function (e) {
						e.stopImmediatePropagation();
						var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
					})
				.on("click.jstree", ".jstree-leaf > .jstree-ocl", $.proxy(function (e) {
						e.stopImmediatePropagation();
						var tmp = $.Event('click', { metaKey : e.metaKey, ctrlKey : e.ctrlKey, altKey : e.altKey, shiftKey : e.shiftKey });
						$(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
					}, this))
				.on("mouseover.jstree", ".jstree-wholerow, .jstree-icon", $.proxy(function (e) {
						e.stopImmediatePropagation();
						if(!this.is_disabled(e.currentTarget)) {
							this.hover_node(e.currentTarget);
						}
						return false;
					}, this))
				.on("mouseleave.jstree", ".jstree-node", $.proxy(function (e) {
						this.dehover_node(e.currentTarget);
					}, this));
		};
		this.teardown = function () {
			if(this.settings.wholerow) {
				this.element.find(".jstree-wholerow").remove();
			}
			parent.teardown.call(this);
		};
		this.redraw_node = function(obj, deep, callback, force_render) {
			obj = parent.redraw_node.apply(this, arguments);
			if(obj) {
				var tmp = div.cloneNode(true);
				//tmp.style.height = this._data.core.li_height + 'px';
				if($.inArray(obj.id, this._data.core.selected) !== -1) { tmp.className += ' jstree-wholerow-clicked'; }
				if(this._data.core.focused && this._data.core.focused === obj.id) { tmp.className += ' jstree-wholerow-hovered'; }
				obj.insertBefore(tmp, obj.childNodes[0]);
			}
			return obj;
		};
	};
	// include the wholerow plugin by default
	// $.jstree.defaults.plugins.push("wholerow");


(function ($) {
	if(document.registerElement && Object && Object.create) {
		var proto = Object.create(HTMLElement.prototype);
		proto.createdCallback = function () {
			var c = { core : {}, plugins : [] }, i;
			for(i in $.jstree.plugins) {
				if($.jstree.plugins.hasOwnProperty(i) && this.attributes[i]) {
					c.plugins.push(i);
					if(this.getAttribute(i) && JSON.parse(this.getAttribute(i))) {
						c[i] = JSON.parse(this.getAttribute(i));
					}
				}
			}
			for(i in $.jstree.defaults.core) {
				if($.jstree.defaults.core.hasOwnProperty(i) && this.attributes[i]) {
					c.core[i] = JSON.parse(this.getAttribute(i)) || this.getAttribute(i);
				}
			}
			jQuery(this).jstree(c);
		};
		// proto.attributeChangedCallback = function (name, previous, value) { };
		try {
			document.registerElement("vakata-jstree", { prototype: proto });
		} catch(ignore) { }
	}
});
}));
},{"jquery":25}],7:[function(require,module,exports){
$ = require("jquery");

/**
 * Expose `notify`.
 */

exports = module.exports = notify;

/**
 * Notification list.
 */

var listTpl = '<ul id="notifications"></ul>',
    spinnerTpl = '<div class="spinner">\
        <div class="double-bounce1"></div>\
        <div class="double-bounce2"></div>\
      </div>';

/**
 * Append to body when it exists.
 */

$(spinnerTpl).appendTo(document.body);
$(listTpl).appendTo(document.body);

var list = $('#notifications'),
    spinnerEl = $('.spinner'),
    active = false;

/**
 * Return a new `Notification` with the given
 * (optional) `title` and `msg`.
 *
 * @param {String} title or msg
 * @param {String} msg
 * @return {Dialog}
 * @api public
 */

function notify(title, msg){
  if (active) return false;
  active = true;
  setTimeout(function(){
    active = false;
  }, 3000);
  switch (arguments.length) {
    case 2:
      return new Notification({ title: title, message: msg })
        .effect('fade')
        .show()
        .hide(2000);
    case 1:
      return new Notification({ message: title })
        .effect('fade')
        .show()
        .hide(2000);
  }
}

function spinner(action) {
  switch(action) {
    case 'show':
      setTimeout(function() {
        spinnerEl.removeClass('hide').addClass('show');
      }, 0);
      break;
    case 'hide':
      $('.spinner').removeClass('show').addClass('hide');
      break;
  }
} 

/**
 * Construct a notification function for `type`.
 *
 * @param {String} type
 * @return {Function}
 * @api private
 */

function type(type) {
  return function(title, msg){
    return notify.apply(this, arguments)
      .type(type);
  };
}

/**
 * Notification methods.
 */

exports.spinner = spinner;
exports.info = notify;
exports.warn = type('warn');
exports.error = type('error');

/**
 * Expose constructor.
 */

exports.Notification = Notification;

/**
 * Initialize a new `Notification`.
 *
 * Options:
 *
 *    - `title` dialog title
 *    - `message` a message to display
 *
 * @param {Object} options
 * @api public
 */

function Notification(options) {
  options = options || {};
  this.el = '<li class="notification hide">\
            <div class="content">\
            <span class="title">Title</span>\
            <a href="#" class="close">&#215;</a>\
            <p>Message</p>\
            </div>\
            </li>';
  this.$el = $(this.el)
  this.render(options);
  if (options.classname) this.$el.addClass(options.classname);
  if (Notification.effect) this.effect(Notification.effect);
}

/**
 * Render with the given `options`.
 *
 * @param {Object} options
 * @api public
 */

Notification.prototype.render = function(options){
  var el = this.$el
    , title = options.title
    , msg = options.message
    , self = this;

  el.find('.close').on('click', function(){
    self.emit('close');
    self.hide();
    return false;
  });

  el.on('click', function(e){
    e.preventDefault();
    self.emit('click', e);
  }); 

  el.find('.title').text(title);
  if (!title) el.find('.title').remove();

  // message
  if ('string' == typeof msg) {
    el.find('p').text(msg);
  } else if (msg) {
    el.find('p').replace(msg.el || msg);
  }

  setTimeout(function(){
    el.removeClass('hide');
  }, 0);
};

/**
 * Enable the dialog close link.
 *
 * @return {Notification} for chaining
 * @api public
 */

Notification.prototype.closable = function(){
  this.$el.addClass('closable');
  return this;
};

/**
 * Set the effect to `type`.
 *
 * @param {String} type
 * @return {Notification} for chaining
 * @api public
 */

Notification.prototype.effect = function(type){
  this._effect = type;
  this.$el.addClass(type);
  return this;
};

/**
 * Show the notification.
 *
 * @return {Notification} for chaining
 * @api public
 */

Notification.prototype.show = function(){
  this.$el.appendTo(list);
  return this;
};

/**
 * Set the notification `type`.
 *
 * @param {String} type
 * @return {Notification} for chaining
 * @api public
 */

Notification.prototype.type = function(type){
  this._type = type;
  this.$el.addClass(type);
  return this;
};

/**
 * Make it stick (clear hide timer), and make it closable.
 *
 * @return {Notification} for chaining
 * @api public
 */

Notification.prototype.sticky = function(){
  return this.hide(0).closable();
};

/**
 * Hide the dialog with optional delay of `ms`,
 * otherwise the notification is removed immediately.
 *
 * @return {Number} ms
 * @return {Notification} for chaining
 * @api public
 */

Notification.prototype.hide = function(ms){
  var self = this;

  // duration
  if ('number' == typeof ms) {
    clearTimeout(this.timer);
    if (!ms) return this;
    this.timer = setTimeout(function(){
      self.hide();
    }, ms);
    return this;
  }

  // hide / remove
  this.$el.addClass('hide');
  if (this._effect) {
    setTimeout(function(self){
      self.remove();
    }, 500, this);
  } else {
    self.remove();
  }

  return this;
};

/**
 * Hide the notification without potential animation.
 *
 * @return {Dialog} for chaining
 * @api public
 */

Notification.prototype.remove = function(){
  this.$el.remove();
  return this;
};
},{"jquery":25}],8:[function(require,module,exports){
/*
*
* Copyright (c) 2011-2014- Justin Dearing (zippy1981@gmail.com)
* Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
* and GPL (http://www.opensource.org/licenses/gpl-license.php) version 2 licenses.
* This software is not distributed under version 3 or later of the GPL.
*
* Version 1.0.2
*
*/

if (!document) var document = { cookie: '' }; // fix crashes on node

/**
 * Javascript class that mimics how WCF serializes a object of type MongoDB.Bson.ObjectId
 * and converts between that format and the standard 24 character representation.
*/
var ObjectId = (function () {
    var increment = Math.floor(Math.random() * (16777216));
    var pid = Math.floor(Math.random() * (65536));
    var machine = Math.floor(Math.random() * (16777216));

    var setMachineCookie = function() {
        var cookieList = document.cookie.split('; ');
        for (var i in cookieList) {
            var cookie = cookieList[i].split('=');
            var cookieMachineId = parseInt(cookie[1], 10);
            if (cookie[0] == 'mongoMachineId' && cookieMachineId && cookieMachineId >= 0 && cookieMachineId <= 16777215) {
                machine = cookieMachineId;
                break;
            }
        }
        document.cookie = 'mongoMachineId=' + machine + ';expires=Tue, 19 Jan 2038 05:00:00 GMT;path=/';
    };
    if (typeof (localStorage) != 'undefined') {
        try {
            var mongoMachineId = parseInt(localStorage['mongoMachineId']);
            if (mongoMachineId >= 0 && mongoMachineId <= 16777215) {
                machine = Math.floor(localStorage['mongoMachineId']);
            }
            // Just always stick the value in.
            localStorage['mongoMachineId'] = machine;
        } catch (e) {
            setMachineCookie();
        }
    }
    else {
        setMachineCookie();
    }

    function ObjId() {
        if (!(this instanceof ObjectId)) {
            return new ObjectId(arguments[0], arguments[1], arguments[2], arguments[3]).toString();
        }

        if (typeof (arguments[0]) == 'object') {
            this.timestamp = arguments[0].timestamp;
            this.machine = arguments[0].machine;
            this.pid = arguments[0].pid;
            this.increment = arguments[0].increment;
        }
        else if (typeof (arguments[0]) == 'string' && arguments[0].length == 24) {
            this.timestamp = Number('0x' + arguments[0].substr(0, 8)),
            this.machine = Number('0x' + arguments[0].substr(8, 6)),
            this.pid = Number('0x' + arguments[0].substr(14, 4)),
            this.increment = Number('0x' + arguments[0].substr(18, 6))
        }
        else if (arguments.length == 4 && arguments[0] != null) {
            this.timestamp = arguments[0];
            this.machine = arguments[1];
            this.pid = arguments[2];
            this.increment = arguments[3];
        }
        else {
            this.timestamp = Math.floor(new Date().valueOf() / 1000);
            this.machine = machine;
            this.pid = pid;
            this.increment = increment++;
            if (increment > 0xffffff) {
                increment = 0;
            }
        }
    };
    return ObjId;
})();

ObjectId.prototype.getDate = function () {
    return new Date(this.timestamp * 1000);
};

ObjectId.prototype.toArray = function () {
    var strOid = this.toString();
    var array = [];
    var i;
    for(i = 0; i < 12; i++) {
        array[i] = parseInt(strOid.slice(i*2, i*2+2), 16);
    }
    return array;
};

/**
* Turns a WCF representation of a BSON ObjectId into a 24 character string representation.
*/
ObjectId.prototype.toString = function () {
    if (this.timestamp === undefined
        || this.machine === undefined
        || this.pid === undefined
        || this.increment === undefined) {
        return 'Invalid ObjectId';
    }

    var timestamp = this.timestamp.toString(16);
    var machine = this.machine.toString(16);
    var pid = this.pid.toString(16);
    var increment = this.increment.toString(16);
    return '00000000'.substr(0, 8 - timestamp.length) + timestamp +
           '000000'.substr(0, 6 - machine.length) + machine +
           '0000'.substr(0, 4 - pid.length) + pid +
           '000000'.substr(0, 6 - increment.length) + increment;
};

module.exports = ObjectId;
},{}],9:[function(require,module,exports){
var Backbone = require('backbone');

Backbone.Form.editors.ParentChooser = Backbone.Form.editors.Base.extend({

    tagName: 'div',

    className: 'parent',

    events: {
        'click .choose-parent': function(e) {
            e.preventDefault();
            this.trigger('click', this);
            this._onClickChoose();
        },
        'click .root-parent': function(e) {
            e.preventDefault();
            this.trigger('click', this);
            this._onClickRoot();
        },
        'click .add-child': function(e) {
            e.preventDefault();
            this.trigger('click', this);
            this._onAddChild();
        },
        'click .merge': function(e) {
            e.preventDefault();
            this.trigger('click', this);
            this._onMerge();
        },
        'click .remove': function(e) {
            e.preventDefault();
            this.trigger('click', this);
            this._onRemove();
        },
        'focus': function() {
            this.trigger('focus', this);
        },
        'blur': function() {
            this.trigger('blur', this);
        }
    },

    initialize: function(options) {
        Backbone.Form.editors.Base.prototype.initialize.call(this, options);
    },

    render: function() {
        var parentChooser = document.createElement('button');
        parentChooser.className = 'choose-parent btn';
        parentChooser.setAttribute('title', 'Choose new parent');
        parentChooser.innerHTML = '<i class="fa fa-bars"></i>';
        this.el.appendChild(parentChooser);
        
        var rootChooser = document.createElement('button');
        rootChooser.className = 'root-parent btn';
        rootChooser.setAttribute('title', 'Set root level');
        rootChooser.innerHTML = '<i class="fa fa-level-up"></i>';
        this.el.appendChild(rootChooser);

        var addChild = document.createElement('button');
        addChild.className = 'add-child btn';
        addChild.setAttribute('title', 'Add child subject');
        addChild.innerHTML = '<i class="fa fa-plus-square-o"></i>';
        this.el.appendChild(addChild);

        var mergeBtn = document.createElement('button');
        mergeBtn.className = 'merge btn';
        mergeBtn.setAttribute('title', 'Merge with another subject');
        mergeBtn.innerHTML = '<i class="fa fa-code-fork"></i>';
        this.el.appendChild(mergeBtn);

        var removeBtn = document.createElement('button');
        removeBtn.className = 'remove btn';
        removeBtn.setAttribute('title', 'Remove subject');
        removeBtn.innerHTML = '<i class="fa fa-trash-o"></i>';
        this.el.appendChild(removeBtn);

        return this;
    },

    _onClickChoose: function() {
      this.trigger('edit', this);
    },

    _onClickRoot: function() {
      this.model.set('parent','');
    },

    _onAddChild: function() {
      this.trigger('add', this);
    },

    _onMerge: function() {
      this.trigger('merge', this);
    },

    _onRemove: function() {
      var confirm = window.confirm("Are you sure you want to do this?\nThis action can't be undone. Think twice!");
      if(confirm) {
        this.model.destroy();
      }
    },

    focus: function() {
        if (this.hasFocus) return;

        this.$el.focus();
    },

    blur: function() {
        if (!this.hasFocus) return;

        this.$el.blur();
    }
});
},{"backbone":19}],10:[function(require,module,exports){
var Utility = require('./util.js');

var Document = Utility.model.extend({
  urlRoot: "/api/documents"
})
exports.document = Document

var Documents = Utility.collection.extend({
  model: Document,
  url: "/api/documents",
  state: {
    pageSize: 20,
    sortKey: "created_at",
    order: 1
  }
})
exports.documents = Documents
},{"./util.js":14}],11:[function(require,module,exports){
var _ = require("underscore")
  , document = require('./document.js')
  , subject = require('./subject.js')
  , menu = require('./menu.js')

module.exports = _.extend({}, document, subject, menu);
},{"./document.js":10,"./menu.js":12,"./subject.js":13,"underscore":30}],12:[function(require,module,exports){
var Backbone = require('backbone');

var MenuItem = Backbone.Model.extend({});
exports.menuItem = MenuItem

var MenuItems = Backbone.Collection.extend({ model: MenuItem });
exports.menuItems = MenuItems

var ContextItem = Backbone.Model.extend({});
exports.contextItem = ContextItem

var ContextItems = Backbone.Collection.extend({ model: ContextItem });
exports.contextItems = ContextItems
},{"backbone":19}],13:[function(require,module,exports){
var Utility = require('./util.js'),
    _ = require("underscore");

var Subject = Utility.model.extend({
  urlRoot: "/api/subjects",
  schema: {
    name: { type: 'Text', validators: ['required'], title: 'Title', editorAttrs: {autofocus:'autofocus'} },
    description: { type: 'TextArea', title: 'Description' },
    parent: { type: 'ParentChooser' }
  }
})
exports.subject = Subject

var Subjects = Utility.collection.extend({
  model: Subject,
  url: "/api/subjects",
  state: {
    pageSize: null,
    sortKey: "name",
    order: -1,
  },
  buildIndexes: function() {
    // Build a map of parents referencing their kids
    this.parentIndex = {};
    _.each(this.models, function(model) {
      var parent = model.get('parent') || "root";
      if (!this.parentIndex[parent]) {
        this.parentIndex[parent] = [ model ];
      } else {
        this.parentIndex[parent].push(model);
      }
    }, this);
  },
  getChildren: function(nodeId) {
    return this.parentIndex[nodeId] || [];
  },
  buildSubjectsTree: function() {
    var self = this;

    this.buildIndexes();

    function getChildren(parentId) {
      var res = [];
      var nodes = self.getChildren(parentId);
      if (nodes.length === 0) return res; // exit condition

      _.each(nodes, function(node) {
        var entry = {
          id: node.id,
          text: node.get('name'),
          children: getChildren(node.id) // get children for subj
        };
        res.push(entry);
      });
      return res;
    }

    return getChildren("root");
  },
  getChanged: function () {
    return this.models.filter(function(m) {
      return (m.hasChanged() || !m.get('id'));
    });
  },
  saveChanged: function() {
    var changed = this.getChanged();
    _.each(changed, function(m) {
      m.save();
    });
  }
})
exports.subjects = Subjects
},{"./util.js":14,"underscore":30}],14:[function(require,module,exports){
var Backbone = require('backbone')
  , Paginator = require('backbone.paginator');

var Model = Backbone.Model.extend({
  	idAttribute: '_id'
});
exports.model = Model;

var Collection = Backbone.PageableCollection.extend({
  mode: 'server',
  initialize: function(models, options) {
    var that = this;
    Backbone.PageableCollection.__super__.initialize.apply(this, arguments)
  },
	state: {
  	pageSize: 20,
  	sortKey: "name",
  	order: -1,
	},
	queryParams: {
		currentPage: "page",
		pageSize:	"per_page",
		totalPages:	"total_pages",
		totalRecords: "total_entries",
		sortKey: "sort_by",
    query: {}
	}
});
exports.collection = Collection;
},{"backbone":19,"backbone.paginator":17}],15:[function(require,module,exports){
(function (global){
/**
 * Backbone Forms v0.14.0
 *
 * Copyright (c) 2014 Charles Davison, Pow Media Ltd
 *
 * License and more information at:
 * http://github.com/powmedia/backbone-forms
 */
;(function(root) {

  //DEPENDENCIES
  //CommonJS
  if (typeof exports !== 'undefined' && typeof require !== 'undefined') {
    var _ = root._ || require('underscore'),
        Backbone = root.Backbone || require('backbone');
  }

  //Browser
  else {
    var _ = root._,
        Backbone = root.Backbone;
  }


  //SOURCE
  //==================================================================================================
//FORM
//==================================================================================================

var Form = Backbone.View.extend({

  events: {
    'submit': function(event) {
      this.trigger('submit', event);
    }
  },

  /**
   * Constructor
   * 
   * @param {Object} [options.schema]
   * @param {Backbone.Model} [options.model]
   * @param {Object} [options.data]
   * @param {String[]|Object[]} [options.fieldsets]
   * @param {String[]} [options.fields]
   * @param {String} [options.idPrefix]
   * @param {Form.Field} [options.Field]
   * @param {Form.Fieldset} [options.Fieldset]
   * @param {Function} [options.template]
   * @param {Boolean|String} [options.submitButton]
   */
  initialize: function(options) {
    var self = this;

    //Merge default options
    options = this.options = _.extend({
      submitButton: false
    }, options);

    //Find the schema to use
    var schema = this.schema = (function() {
      //Prefer schema from options
      if (options.schema) return _.result(options, 'schema');

      //Then schema on model
      var model = options.model;
      if (model && model.schema) return _.result(model, 'schema');

      //Then built-in schema
      if (self.schema) return _.result(self, 'schema');

      //Fallback to empty schema
      return {};
    })();

    //Store important data
    _.extend(this, _.pick(options, 'model', 'data', 'idPrefix', 'templateData'));

    //Override defaults
    var constructor = this.constructor;
    this.template = options.template || this.template || constructor.template;
    this.Fieldset = options.Fieldset || this.Fieldset || constructor.Fieldset;
    this.Field = options.Field || this.Field || constructor.Field;
    this.NestedField = options.NestedField || this.NestedField || constructor.NestedField;

    //Check which fields will be included (defaults to all)
    var selectedFields = this.selectedFields = options.fields || _.keys(schema);

    //Create fields
    var fields = this.fields = {};

    _.each(selectedFields, function(key) {
      var fieldSchema = schema[key];
      fields[key] = this.createField(key, fieldSchema);
    }, this);

    //Create fieldsets
    var fieldsetSchema = options.fieldsets || _.result(this, 'fieldsets') || _.result(this.model, 'fieldsets') || [selectedFields],
        fieldsets = this.fieldsets = [];

    _.each(fieldsetSchema, function(itemSchema) {
      this.fieldsets.push(this.createFieldset(itemSchema));
    }, this);
  },

  /**
   * Creates a Fieldset instance
   *
   * @param {String[]|Object[]} schema       Fieldset schema
   *
   * @return {Form.Fieldset}
   */
  createFieldset: function(schema) {
    var options = {
      schema: schema,
      fields: this.fields,
      legend: schema.legend || null
    };

    return new this.Fieldset(options);
  },

  /**
   * Creates a Field instance
   *
   * @param {String} key
   * @param {Object} schema       Field schema
   *
   * @return {Form.Field}
   */
  createField: function(key, schema) {
    var options = {
      form: this,
      key: key,
      schema: schema,
      idPrefix: this.idPrefix
    };

    if (this.model) {
      options.model = this.model;
    } else if (this.data) {
      options.value = this.data[key];
    } else {
      options.value = null;
    }

    var field = new this.Field(options);

    this.listenTo(field.editor, 'all', this.handleEditorEvent);

    return field;
  },

  /**
   * Callback for when an editor event is fired.
   * Re-triggers events on the form as key:event and triggers additional form-level events
   *
   * @param {String} event
   * @param {Editor} editor
   */
  handleEditorEvent: function(event, editor) {
    //Re-trigger editor events on the form
    var formEvent = editor.key+':'+event;

    this.trigger.call(this, formEvent, this, editor, Array.prototype.slice.call(arguments, 2));

    //Trigger additional events
    switch (event) {
      case 'change':
        this.trigger('change', this);
        break;

      case 'focus':
        if (!this.hasFocus) this.trigger('focus', this);
        break;

      case 'blur':
        if (this.hasFocus) {
          //TODO: Is the timeout etc needed?
          var self = this;
          setTimeout(function() {
            var focusedField = _.find(self.fields, function(field) {
              return field.editor.hasFocus;
            });

            if (!focusedField) self.trigger('blur', self);
          }, 0);
        }
        break;
    }
  },

  templateData: function() {
    var options = this.options;

    return {
      submitButton: options.submitButton
    }
  },

  render: function() {
    var self = this,
        fields = this.fields,
        $ = Backbone.$;

    //Render form
    var $form = $($.trim(this.template(_.result(this, 'templateData'))));

    //Render standalone editors
    $form.find('[data-editors]').add($form).each(function(i, el) {
      var $container = $(el),
          selection = $container.attr('data-editors');

      if (_.isUndefined(selection)) return;

      //Work out which fields to include
      var keys = (selection == '*')
        ? self.selectedFields || _.keys(fields)
        : selection.split(',');

      //Add them
      _.each(keys, function(key) {
        var field = fields[key];

        $container.append(field.editor.render().el);
      });
    });

    //Render standalone fields
    $form.find('[data-fields]').add($form).each(function(i, el) {
      var $container = $(el),
          selection = $container.attr('data-fields');

      if (_.isUndefined(selection)) return;

      //Work out which fields to include
      var keys = (selection == '*')
        ? self.selectedFields || _.keys(fields)
        : selection.split(',');

      //Add them
      _.each(keys, function(key) {
        var field = fields[key];

        $container.append(field.render().el);
      });
    });

    //Render fieldsets
    $form.find('[data-fieldsets]').add($form).each(function(i, el) {
      var $container = $(el),
          selection = $container.attr('data-fieldsets');

      if (_.isUndefined(selection)) return;

      _.each(self.fieldsets, function(fieldset) {
        $container.append(fieldset.render().el);
      });
    });

    //Set the main element
    this.setElement($form);
    
    //Set class
    $form.addClass(this.className);

    return this;
  },

  /**
   * Validate the data
   *
   * @return {Object}       Validation errors
   */
  validate: function(options) {
    var self = this,
        fields = this.fields,
        model = this.model,
        errors = {};

    options = options || {};

    //Collect errors from schema validation
    _.each(fields, function(field) {
      var error = field.validate();
      if (error) {
        errors[field.key] = error;
      }
    });

    //Get errors from default Backbone model validator
    if (!options.skipModelValidate && model && model.validate) {
      var modelErrors = model.validate(this.getValue());

      if (modelErrors) {
        var isDictionary = _.isObject(modelErrors) && !_.isArray(modelErrors);

        //If errors are not in object form then just store on the error object
        if (!isDictionary) {
          errors._others = errors._others || [];
          errors._others.push(modelErrors);
        }

        //Merge programmatic errors (requires model.validate() to return an object e.g. { fieldKey: 'error' })
        if (isDictionary) {
          _.each(modelErrors, function(val, key) {
            //Set error on field if there isn't one already
            if (fields[key] && !errors[key]) {
              fields[key].setError(val);
              errors[key] = val;
            }

            else {
              //Otherwise add to '_others' key
              errors._others = errors._others || [];
              var tmpErr = {};
              tmpErr[key] = val;
              errors._others.push(tmpErr);
            }
          });
        }
      }
    }

    return _.isEmpty(errors) ? null : errors;
  },

  /**
   * Update the model with all latest values.
   *
   * @param {Object} [options]  Options to pass to Model#set (e.g. { silent: true })
   *
   * @return {Object}  Validation errors
   */
  commit: function(options) {
    //Validate
    options = options || {};

    var validateOptions = {
        skipModelValidate: !options.validate
    };

    var errors = this.validate(validateOptions);
    if (errors) return errors;

    //Commit
    var modelError;

    var setOptions = _.extend({
      error: function(model, e) {
        modelError = e;
      }
    }, options);

    this.model.set(this.getValue(), setOptions);
    
    if (modelError) return modelError;
  },

  /**
   * Get all the field values as an object.
   * Use this method when passing data instead of objects
   *
   * @param {String} [key]    Specific field value to get
   */
  getValue: function(key) {
    //Return only given key if specified
    if (key) return this.fields[key].getValue();

    //Otherwise return entire form
    var values = {};
    _.each(this.fields, function(field) {
      values[field.key] = field.getValue();
    });

    return values;
  },

  /**
   * Update field values, referenced by key
   *
   * @param {Object|String} key     New values to set, or property to set
   * @param val                     Value to set
   */
  setValue: function(prop, val) {
    var data = {};
    if (typeof prop === 'string') {
      data[prop] = val;
    } else {
      data = prop;
    }

    var key;
    for (key in this.schema) {
      if (data[key] !== undefined) {
        this.fields[key].setValue(data[key]);
      }
    }
  },

  /**
   * Returns the editor for a given field key
   *
   * @param {String} key
   *
   * @return {Editor}
   */
  getEditor: function(key) {
    var field = this.fields[key];
    if (!field) throw new Error('Field not found: '+key);

    return field.editor;
  },

  /**
   * Gives the first editor in the form focus
   */
  focus: function() {
    if (this.hasFocus) return;

    //Get the first field
    var fieldset = this.fieldsets[0],
        field = fieldset.getFieldAt(0);

    if (!field) return;

    //Set focus
    field.editor.focus();
  },

  /**
   * Removes focus from the currently focused editor
   */
  blur: function() {
    if (!this.hasFocus) return;

    var focusedField = _.find(this.fields, function(field) {
      return field.editor.hasFocus;
    });

    if (focusedField) focusedField.editor.blur();
  },

  /**
   * Manages the hasFocus property
   *
   * @param {String} event
   */
  trigger: function(event) {
    if (event === 'focus') {
      this.hasFocus = true;
    }
    else if (event === 'blur') {
      this.hasFocus = false;
    }

    return Backbone.View.prototype.trigger.apply(this, arguments);
  },

  /**
   * Override default remove function in order to remove embedded views
   *
   * TODO: If editors are included directly with data-editors="x", they need to be removed
   * May be best to use XView to manage adding/removing views
   */
  remove: function() {
    _.each(this.fieldsets, function(fieldset) {
      fieldset.remove();
    });

    _.each(this.fields, function(field) {
      field.remove();
    });

    return Backbone.View.prototype.remove.apply(this, arguments);
  }

}, {

  //STATICS
  template: _.template('\
    <form>\
     <div data-fieldsets></div>\
      <% if (submitButton) { %>\
        <button type="submit"><%= submitButton %></button>\
      <% } %>\
    </form>\
  ', null, this.templateSettings),

  templateSettings: {
    evaluate: /<%([\s\S]+?)%>/g, 
    interpolate: /<%=([\s\S]+?)%>/g, 
    escape: /<%-([\s\S]+?)%>/g
  },

  editors: {}

});

  
//==================================================================================================
//VALIDATORS
//==================================================================================================

Form.validators = (function() {

  var validators = {};

  validators.errMessages = {
    required: 'Required',
    regexp: 'Invalid',
    number: 'Must be a number',
    email: 'Invalid email address',
    url: 'Invalid URL',
    match: _.template('Must match field "<%= field %>"', null, Form.templateSettings)
  };
  
  validators.required = function(options) {
    options = _.extend({
      type: 'required',
      message: this.errMessages.required
    }, options);
     
    return function required(value) {
      options.value = value;
      
      var err = {
        type: options.type,
        message: _.isFunction(options.message) ? options.message(options) : options.message
      };
      
      if (value === null || value === undefined || value === false || value === '') return err;
    };
  };
  
  validators.regexp = function(options) {
    if (!options.regexp) throw new Error('Missing required "regexp" option for "regexp" validator');
  
    options = _.extend({
      type: 'regexp',
      match: true,
      message: this.errMessages.regexp
    }, options);
    
    return function regexp(value) {
      options.value = value;
      
      var err = {
        type: options.type,
        message: _.isFunction(options.message) ? options.message(options) : options.message
      };
      
      //Don't check empty values (add a 'required' validator for this)
      if (value === null || value === undefined || value === '') return;

      //Create RegExp from string if it's valid
      if ('string' === typeof options.regexp) options.regexp = new RegExp(options.regexp, options.flags);

      if ((options.match) ? !options.regexp.test(value) : options.regexp.test(value)) return err;
    };
  };

  validators.number = function(options) {
    options = _.extend({
      type: 'number',
      message: this.errMessages.number,
      regexp: /^[0-9]*\.?[0-9]*?$/
    }, options);
    
    return validators.regexp(options);
  };
  
  validators.email = function(options) {
    options = _.extend({
      type: 'email',
      message: this.errMessages.email,
      regexp: /^[\w\-]{1,}([\w\-\+.]{1,1}[\w\-]{1,}){0,}[@][\w\-]{1,}([.]([\w\-]{1,})){1,3}$/
    }, options);
    
    return validators.regexp(options);
  };
  
  validators.url = function(options) {
    options = _.extend({
      type: 'url',
      message: this.errMessages.url,
      regexp: /^(http|https):\/\/(([A-Z0-9][A-Z0-9_\-]*)(\.[A-Z0-9][A-Z0-9_\-]*)+)(:(\d+))?\/?/i
    }, options);
    
    return validators.regexp(options);
  };
  
  validators.match = function(options) {
    if (!options.field) throw new Error('Missing required "field" options for "match" validator');
    
    options = _.extend({
      type: 'match',
      message: this.errMessages.match
    }, options);
    
    return function match(value, attrs) {
      options.value = value;
      
      var err = {
        type: options.type,
        message: _.isFunction(options.message) ? options.message(options) : options.message
      };
      
      //Don't check empty values (add a 'required' validator for this)
      if (value === null || value === undefined || value === '') return;
      
      if (value !== attrs[options.field]) return err;
    };
  };


  return validators;

})();


//==================================================================================================
//FIELDSET
//==================================================================================================

Form.Fieldset = Backbone.View.extend({

  /**
   * Constructor
   *
   * Valid fieldset schemas:
   *   ['field1', 'field2']
   *   { legend: 'Some Fieldset', fields: ['field1', 'field2'] }
   *
   * @param {String[]|Object[]} options.schema      Fieldset schema
   * @param {Object} options.fields           Form fields
   */
  initialize: function(options) {
    options = options || {};

    //Create the full fieldset schema, merging defaults etc.
    var schema = this.schema = this.createSchema(options.schema);

    //Store the fields for this fieldset
    this.fields = _.pick(options.fields, schema.fields);
    
    //Override defaults
    this.template = options.template || schema.template || this.template || this.constructor.template;
  },

  /**
   * Creates the full fieldset schema, normalising, merging defaults etc.
   *
   * @param {String[]|Object[]} schema
   *
   * @return {Object}
   */
  createSchema: function(schema) {
    //Normalise to object
    if (_.isArray(schema)) {
      schema = { fields: schema };
    }

    //Add null legend to prevent template error
    schema.legend = schema.legend || null;

    return schema;
  },

  /**
   * Returns the field for a given index
   *
   * @param {Number} index
   *
   * @return {Field}
   */
  getFieldAt: function(index) {
    var key = this.schema.fields[index];

    return this.fields[key];
  },

  /**
   * Returns data to pass to template
   *
   * @return {Object}
   */
  templateData: function() {
    return this.schema;
  },

  /**
   * Renders the fieldset and fields
   *
   * @return {Fieldset} this
   */
  render: function() {
    var schema = this.schema,
        fields = this.fields,
        $ = Backbone.$;

    //Render fieldset
    var $fieldset = $($.trim(this.template(_.result(this, 'templateData'))));

    //Render fields
    $fieldset.find('[data-fields]').add($fieldset).each(function(i, el) {
      var $container = $(el),
          selection = $container.attr('data-fields');

      if (_.isUndefined(selection)) return;

      _.each(fields, function(field) {
        $container.append(field.render().el);
      });
    });

    this.setElement($fieldset);

    return this;
  },

  /**
   * Remove embedded views then self
   */
  remove: function() {
    _.each(this.fields, function(field) {
      field.remove();
    });

    Backbone.View.prototype.remove.call(this);
  }
  
}, {
  //STATICS

  template: _.template('\
    <fieldset data-fields>\
      <% if (legend) { %>\
        <legend><%= legend %></legend>\
      <% } %>\
    </fieldset>\
  ', null, Form.templateSettings)

});


//==================================================================================================
//FIELD
//==================================================================================================

Form.Field = Backbone.View.extend({

  /**
   * Constructor
   *
   * @param {Object} options.key
   * @param {Object} options.form
   * @param {Object} [options.schema]
   * @param {Function} [options.schema.template]
   * @param {Backbone.Model} [options.model]
   * @param {Object} [options.value]
   * @param {String} [options.idPrefix]
   * @param {Function} [options.template]
   * @param {Function} [options.errorClassName]
   */
  initialize: function(options) {
    options = options || {};

    //Store important data
    _.extend(this, _.pick(options, 'form', 'key', 'model', 'value', 'idPrefix'));

    //Create the full field schema, merging defaults etc.
    var schema = this.schema = this.createSchema(options.schema);

    //Override defaults
    this.template = options.template || schema.template || this.template || this.constructor.template;
    this.errorClassName = options.errorClassName || this.errorClassName || this.constructor.errorClassName;

    //Create editor
    this.editor = this.createEditor();
  },

  /**
   * Creates the full field schema, merging defaults etc.
   *
   * @param {Object|String} schema
   *
   * @return {Object}
   */
  createSchema: function(schema) {
    if (_.isString(schema)) schema = { type: schema };

    //Set defaults
    schema = _.extend({
      type: 'Text',
      title: this.createTitle()
    }, schema);

    //Get the real constructor function i.e. if type is a string such as 'Text'
    schema.type = (_.isString(schema.type)) ? Form.editors[schema.type] : schema.type;

    return schema;
  },

  /**
   * Creates the editor specified in the schema; either an editor string name or
   * a constructor function
   *
   * @return {View}
   */
  createEditor: function() {
    var options = _.extend(
      _.pick(this, 'schema', 'form', 'key', 'model', 'value'),
      { id: this.createEditorId() }
    );

    var constructorFn = this.schema.type;

    return new constructorFn(options);
  },

  /**
   * Creates the ID that will be assigned to the editor
   *
   * @return {String}
   */
  createEditorId: function() {
    var prefix = this.idPrefix,
        id = this.key;

    //Replace periods with underscores (e.g. for when using paths)
    id = id.replace(/\./g, '_');

    //If a specific ID prefix is set, use it
    if (_.isString(prefix) || _.isNumber(prefix)) return prefix + id;
    if (_.isNull(prefix)) return id;

    //Otherwise, if there is a model use it's CID to avoid conflicts when multiple forms are on the page
    if (this.model) return this.model.cid + '_' + id;

    return id;
  },

  /**
   * Create the default field title (label text) from the key name.
   * (Converts 'camelCase' to 'Camel Case')
   *
   * @return {String}
   */
  createTitle: function() {
    var str = this.key;

    //Add spaces
    str = str.replace(/([A-Z])/g, ' $1');

    //Uppercase first character
    str = str.replace(/^./, function(str) { return str.toUpperCase(); });

    return str;
  },

  /**
   * Returns the data to be passed to the template
   *
   * @return {Object}
   */
  templateData: function() {
    var schema = this.schema;

    return {
      help: schema.help || '',
      title: schema.title,
      titleHTML: schema.titleHTML,
      fieldAttrs: schema.fieldAttrs,
      editorAttrs: schema.editorAttrs,
      key: this.key,
      editorId: this.editor.id
    };
  },

  /**
   * Render the field and editor
   *
   * @return {Field} self
   */
  render: function() {
    var schema = this.schema,
        editor = this.editor,
        $ = Backbone.$;

    //Only render the editor if requested
    if (this.editor.noField === true) {
      return this.setElement(editor.render().el);
    }

    //Render field
    var $field = $($.trim(this.template(_.result(this, 'templateData'))));

    if (schema.fieldClass) $field.addClass(schema.fieldClass);
    if (schema.fieldAttrs) $field.attr(schema.fieldAttrs);

    //Render editor
    $field.find('[data-editor]').add($field).each(function(i, el) {
      var $container = $(el),
          selection = $container.attr('data-editor');

      if (_.isUndefined(selection)) return;

      $container.append(editor.render().el);
    });

    this.setElement($field);

    return this;
  },

  /**
   * Disable the field's editor
   * Will call the editor's disable method if it exists
   * Otherwise will add the disabled attribute to all inputs in the editor
   */
  disable: function(){
    if ( _.isFunction(this.editor.disable) ){
      this.editor.disable();
    }
    else {
      $input = this.editor.$el;
      $input = $input.is("input") ? $input : $input.find("input");
      $input.attr("disabled",true);
    }
  },

  /**
   * Enable the field's editor
   * Will call the editor's disable method if it exists
   * Otherwise will remove the disabled attribute to all inputs in the editor
   */
  enable: function(){
    if ( _.isFunction(this.editor.enable) ){
      this.editor.enable();
    }
    else {
      $input = this.editor.$el;
      $input = $input.is("input") ? $input : $input.find("input");
      $input.attr("disabled",false);
    }
  },

  /**
   * Check the validity of the field
   *
   * @return {String}
   */
  validate: function() {
    var error = this.editor.validate();

    if (error) {
      this.setError(error.message);
    } else {
      this.clearError();
    }

    return error;
  },

  /**
   * Set the field into an error state, adding the error class and setting the error message
   *
   * @param {String} msg     Error message
   */
  setError: function(msg) {
    //Nested form editors (e.g. Object) set their errors internally
    if (this.editor.hasNestedForm) return;

    //Add error CSS class
    this.$el.addClass(this.errorClassName);

    //Set error message
    this.$('[data-error]').html(msg);
  },

  /**
   * Clear the error state and reset the help message
   */
  clearError: function() {
    //Remove error CSS class
    this.$el.removeClass(this.errorClassName);

    //Clear error message
    this.$('[data-error]').empty();
  },

  /**
   * Update the model with the new value from the editor
   *
   * @return {Mixed}
   */
  commit: function() {
    return this.editor.commit();
  },

  /**
   * Get the value from the editor
   *
   * @return {Mixed}
   */
  getValue: function() {
    return this.editor.getValue();
  },

  /**
   * Set/change the value of the editor
   *
   * @param {Mixed} value
   */
  setValue: function(value) {
    this.editor.setValue(value);
  },

  /**
   * Give the editor focus
   */
  focus: function() {
    this.editor.focus();
  },

  /**
   * Remove focus from the editor
   */
  blur: function() {
    this.editor.blur();
  },

  /**
   * Remove the field and editor views
   */
  remove: function() {
    this.editor.remove();

    Backbone.View.prototype.remove.call(this);
  }

}, {
  //STATICS

  template: _.template('\
    <div>\
      <label for="<%= editorId %>">\
        <% if (titleHTML){ %><%= titleHTML %>\
        <% } else { %><%- title %><% } %>\
      </label>\
      <div>\
        <span data-editor></span>\
        <div data-error></div>\
        <div><%= help %></div>\
      </div>\
    </div>\
  ', null, Form.templateSettings),

  /**
   * CSS class name added to the field when there is a validation error
   */
  errorClassName: 'error'

});


//==================================================================================================
//NESTEDFIELD
//==================================================================================================

Form.NestedField = Form.Field.extend({

  template: _.template('\
    <div>\
      <label for="<%= editorId %>">\
        <% if (titleHTML){ %><%= titleHTML %>\
        <% } else { %><%- title %><% } %>\
      </label>\
      <div>\
        <span data-editor></span>\
        <div class="error-text" data-error></div>\
        <div class="error-help"><%= help %></div>\
      </div>\
    </div>\
  ', null, Form.templateSettings)

});

/**
 * Base editor (interface). To be extended, not used directly
 *
 * @param {Object} options
 * @param {String} [options.id]         Editor ID
 * @param {Model} [options.model]       Use instead of value, and use commit()
 * @param {String} [options.key]        The model attribute key. Required when using 'model'
 * @param {Mixed} [options.value]       When not using a model. If neither provided, defaultValue will be used
 * @param {Object} [options.schema]     Field schema; may be required by some editors
 * @param {Object} [options.validators] Validators; falls back to those stored on schema
 * @param {Object} [options.form]       The form
 */
Form.Editor = Form.editors.Base = Backbone.View.extend({

  defaultValue: null,

  hasFocus: false,

  initialize: function(options) {
    var options = options || {};

    //Set initial value
    if (options.model) {
      if (!options.key) throw new Error("Missing option: 'key'");

      this.model = options.model;

      this.value = this.model.get(options.key);
    }
    else if (options.value !== undefined) {
      this.value = options.value;
    }

    if (this.value === undefined) this.value = this.defaultValue;

    //Store important data
    _.extend(this, _.pick(options, 'key', 'form'));

    var schema = this.schema = options.schema || {};

    this.validators = options.validators || schema.validators;

    //Main attributes
    this.$el.attr('id', this.id);
    this.$el.attr('name', this.getName());
    if (schema.editorClass) this.$el.addClass(schema.editorClass);
    if (schema.editorAttrs) this.$el.attr(schema.editorAttrs);
  },

  /**
   * Get the value for the form input 'name' attribute
   *
   * @return {String}
   *
   * @api private
   */
  getName: function() {
    var key = this.key || '';

    //Replace periods with underscores (e.g. for when using paths)
    return key.replace(/\./g, '_');
  },

  /**
   * Get editor value
   * Extend and override this method to reflect changes in the DOM
   *
   * @return {Mixed}
   */
  getValue: function() {
    return this.value;
  },

  /**
   * Set editor value
   * Extend and override this method to reflect changes in the DOM
   *
   * @param {Mixed} value
   */
  setValue: function(value) {
    this.value = value;
  },

  /**
   * Give the editor focus
   * Extend and override this method
   */
  focus: function() {
    throw new Error('Not implemented');
  },
  
  /**
   * Remove focus from the editor
   * Extend and override this method
   */
  blur: function() {
    throw new Error('Not implemented');
  },

  /**
   * Update the model with the current value
   *
   * @param {Object} [options]              Options to pass to model.set()
   * @param {Boolean} [options.validate]    Set to true to trigger built-in model validation
   *
   * @return {Mixed} error
   */
  commit: function(options) {
    var error = this.validate();
    if (error) return error;

    this.listenTo(this.model, 'invalid', function(model, e) {
      error = e;
    });
    this.model.set(this.key, this.getValue(), options);

    if (error) return error;
  },

  /**
   * Check validity
   *
   * @return {Object|Undefined}
   */
  validate: function() {
    var $el = this.$el,
        error = null,
        value = this.getValue(),
        formValues = this.form ? this.form.getValue() : {},
        validators = this.validators,
        getValidator = this.getValidator;

    if (validators) {
      //Run through validators until an error is found
      _.every(validators, function(validator) {
        error = getValidator(validator)(value, formValues);

        return error ? false : true;
      });
    }

    return error;
  },

  /**
   * Set this.hasFocus, or call parent trigger()
   *
   * @param {String} event
   */
  trigger: function(event) {
    if (event === 'focus') {
      this.hasFocus = true;
    }
    else if (event === 'blur') {
      this.hasFocus = false;
    }

    return Backbone.View.prototype.trigger.apply(this, arguments);
  },

  /**
   * Returns a validation function based on the type defined in the schema
   *
   * @param {RegExp|String|Function} validator
   * @return {Function}
   */
  getValidator: function(validator) {
    var validators = Form.validators;

    //Convert regular expressions to validators
    if (_.isRegExp(validator)) {
      return validators.regexp({ regexp: validator });
    }
    
    //Use a built-in validator if given a string
    if (_.isString(validator)) {
      if (!validators[validator]) throw new Error('Validator "'+validator+'" not found');
      
      return validators[validator]();
    }

    //Functions can be used directly
    if (_.isFunction(validator)) return validator;

    //Use a customised built-in validator if given an object
    if (_.isObject(validator) && validator.type) {
      var config = validator;
      
      return validators[config.type](config);
    }
    
    //Unkown validator type
    throw new Error('Invalid validator: ' + validator);
  }
});

/**
 * Text
 * 
 * Text input with focus, blur and change events
 */
Form.editors.Text = Form.Editor.extend({

  tagName: 'input',

  defaultValue: '',

  previousValue: '',

  events: {
    'keyup':    'determineChange',
    'keypress': function(event) {
      var self = this;
      setTimeout(function() {
        self.determineChange();
      }, 0);
    },
    'select':   function(event) {
      this.trigger('select', this);
    },
    'focus':    function(event) {
      this.trigger('focus', this);
    },
    'blur':     function(event) {
      this.trigger('blur', this);
    }
  },

  initialize: function(options) {
    Form.editors.Base.prototype.initialize.call(this, options);

    var schema = this.schema;

    //Allow customising text type (email, phone etc.) for HTML5 browsers
    var type = 'text';

    if (schema && schema.editorAttrs && schema.editorAttrs.type) type = schema.editorAttrs.type;
    if (schema && schema.dataType) type = schema.dataType;

    this.$el.attr('type', type);
  },

  /**
   * Adds the editor to the DOM
   */
  render: function() {
    this.setValue(this.value);

    return this;
  },

  determineChange: function(event) {
    var currentValue = this.$el.val();
    var changed = (currentValue !== this.previousValue);

    if (changed) {
      this.previousValue = currentValue;

      this.trigger('change', this);
    }
  },

  /**
   * Returns the current editor value
   * @return {String}
   */
  getValue: function() {
    return this.$el.val();
  },

  /**
   * Sets the value of the form element
   * @param {String}
   */
  setValue: function(value) {
    this.$el.val(value);
  },

  focus: function() {
    if (this.hasFocus) return;

    this.$el.focus();
  },

  blur: function() {
    if (!this.hasFocus) return;

    this.$el.blur();
  },

  select: function() {
    this.$el.select();
  }

});

/**
 * TextArea editor
 */
Form.editors.TextArea = Form.editors.Text.extend({

  tagName: 'textarea',

  /**
   * Override Text constructor so type property isn't set (issue #261)
   */
  initialize: function(options) {
    Form.editors.Base.prototype.initialize.call(this, options);
  }

});

/**
 * Password editor
 */
Form.editors.Password = Form.editors.Text.extend({

  initialize: function(options) {
    Form.editors.Text.prototype.initialize.call(this, options);

    this.$el.attr('type', 'password');
  }

});

/**
 * NUMBER
 * 
 * Normal text input that only allows a number. Letters etc. are not entered.
 */
Form.editors.Number = Form.editors.Text.extend({

  defaultValue: 0,

  events: _.extend({}, Form.editors.Text.prototype.events, {
    'keypress': 'onKeyPress',
    'change': 'onKeyPress'
  }),

  initialize: function(options) {
    Form.editors.Text.prototype.initialize.call(this, options);

    var schema = this.schema;

    this.$el.attr('type', 'number');

    if (!schema || !schema.editorAttrs || !schema.editorAttrs.step) {
      // provide a default for `step` attr,
      // but don't overwrite if already specified
      this.$el.attr('step', 'any');
    }
  },

  /**
   * Check value is numeric
   */
  onKeyPress: function(event) {
    var self = this,
        delayedDetermineChange = function() {
          setTimeout(function() {
            self.determineChange();
          }, 0);
        };

    //Allow backspace
    if (event.charCode === 0) {
      delayedDetermineChange();
      return;
    }

    //Get the whole new value so that we can prevent things like double decimals points etc.
    var newVal = this.$el.val()
    if( event.charCode != undefined ) {
      newVal = newVal + String.fromCharCode(event.charCode);
    }

    var numeric = /^[0-9]*\.?[0-9]*?$/.test(newVal);

    if (numeric) {
      delayedDetermineChange();
    }
    else {
      event.preventDefault();
    }
  },

  getValue: function() {
    var value = this.$el.val();

    return value === "" ? null : parseFloat(value, 10);
  },

  setValue: function(value) {
    value = (function() {
      if (_.isNumber(value)) return value;

      if (_.isString(value) && value !== '') return parseFloat(value, 10);

      return null;
    })();

    if (_.isNaN(value)) value = null;

    Form.editors.Text.prototype.setValue.call(this, value);
  }

});

/**
 * Hidden editor
 */
Form.editors.Hidden = Form.editors.Text.extend({

  defaultValue: '',

  noField: true,

  initialize: function(options) {
    Form.editors.Text.prototype.initialize.call(this, options);

    this.$el.attr('type', 'hidden');
  },

  focus: function() {

  },

  blur: function() {

  }

});

/**
 * Checkbox editor
 *
 * Creates a single checkbox, i.e. boolean value
 */
Form.editors.Checkbox = Form.editors.Base.extend({

  defaultValue: false,

  tagName: 'input',

  events: {
    'click':  function(event) {
      this.trigger('change', this);
    },
    'focus':  function(event) {
      this.trigger('focus', this);
    },
    'blur':   function(event) {
      this.trigger('blur', this);
    }
  },

  initialize: function(options) {
    Form.editors.Base.prototype.initialize.call(this, options);

    this.$el.attr('type', 'checkbox');
  },

  /**
   * Adds the editor to the DOM
   */
  render: function() {
    this.setValue(this.value);

    return this;
  },

  getValue: function() {
    return this.$el.prop('checked');
  },

  setValue: function(value) {
    if (value) {
      this.$el.prop('checked', true);
    }else{
      this.$el.prop('checked', false);
    }
  },

  focus: function() {
    if (this.hasFocus) return;

    this.$el.focus();
  },

  blur: function() {
    if (!this.hasFocus) return;

    this.$el.blur();
  }

});

/**
 * Select editor
 *
 * Renders a <select> with given options
 *
 * Requires an 'options' value on the schema.
 *  Can be an array of options, a function that calls back with the array of options, a string of HTML
 *  or a Backbone collection. If a collection, the models must implement a toString() method
 */
Form.editors.Select = Form.editors.Base.extend({

  tagName: 'select',

  previousValue: '',

  events: {
    'keyup':    'determineChange',
    'keypress': function(event) {
      var self = this;
      setTimeout(function() {
        self.determineChange();
      }, 0);
    },
    'change': function(event) {
      this.trigger('change', this);
    },
    'focus':  function(event) {
      this.trigger('focus', this);
    },
    'blur':   function(event) {
      this.trigger('blur', this);
    }
  },

  initialize: function(options) {
    Form.editors.Base.prototype.initialize.call(this, options);

    if (!this.schema || !this.schema.options) throw new Error("Missing required 'schema.options'");
  },

  render: function() {
    this.setOptions(this.schema.options);

    return this;
  },

  /**
   * Sets the options that populate the <select>
   *
   * @param {Mixed} options
   */
  setOptions: function(options) {
    var self = this;

    //If a collection was passed, check if it needs fetching
    if (options instanceof Backbone.Collection) {
      var collection = options;

      //Don't do the fetch if it's already populated
      if (collection.length > 0) {
        this.renderOptions(options);
      } else {
        collection.fetch({
          success: function(collection) {
            self.renderOptions(options);
          }
        });
      }
    }

    //If a function was passed, run it to get the options
    else if (_.isFunction(options)) {
      options(function(result) {
        self.renderOptions(result);
      }, self);
    }

    //Otherwise, ready to go straight to renderOptions
    else {
      this.renderOptions(options);
    }
  },

  /**
   * Adds the <option> html to the DOM
   * @param {Mixed}   Options as a simple array e.g. ['option1', 'option2']
   *                      or as an array of objects e.g. [{val: 543, label: 'Title for object 543'}]
   *                      or as a string of <option> HTML to insert into the <select>
   *                      or any object
   */
  renderOptions: function(options) {
    var $select = this.$el,
        html;

    html = this._getOptionsHtml(options);

    //Insert options
    $select.html(html);

    //Select correct option
    this.setValue(this.value);
  },

  _getOptionsHtml: function(options) {
    var html;
    //Accept string of HTML
    if (_.isString(options)) {
      html = options;
    }

    //Or array
    else if (_.isArray(options)) {
      html = this._arrayToHtml(options);
    }

    //Or Backbone collection
    else if (options instanceof Backbone.Collection) {
      html = this._collectionToHtml(options);
    }

    else if (_.isFunction(options)) {
      var newOptions;

      options(function(opts) {
        newOptions = opts;
      }, this);

      html = this._getOptionsHtml(newOptions);
    //Or any object
    }else{
      html = this._objectToHtml(options);
    }

    return html;
  },

  determineChange: function(event) {
    var currentValue = this.getValue();
    var changed = (currentValue !== this.previousValue);

    if (changed) {
      this.previousValue = currentValue;

      this.trigger('change', this);
    }
  },

  getValue: function() {
    return this.$el.val();
  },

  setValue: function(value) {
    this.$el.val(value);
  },

  focus: function() {
    if (this.hasFocus) return;

    this.$el.focus();
  },

  blur: function() {
    if (!this.hasFocus) return;

    this.$el.blur();
  },

  /**
   * Transforms a collection into HTML ready to use in the renderOptions method
   * @param {Backbone.Collection}
   * @return {String}
   */
  _collectionToHtml: function(collection) {
    //Convert collection to array first
    var array = [];
    collection.each(function(model) {
      array.push({ val: model.id, label: model.toString() });
    });

    //Now convert to HTML
    var html = this._arrayToHtml(array);

    return html;
  },
  /**
   * Transforms an object into HTML ready to use in the renderOptions method
   * @param {Object}
   * @return {String}
   */
  _objectToHtml: function(obj) {
    //Convert object to array first
    var array = [];
    for(var key in obj){
      if( obj.hasOwnProperty( key ) ) {
        array.push({ val: key, label: obj[key] });
      }
    }

    //Now convert to HTML
    var html = this._arrayToHtml(array);

    return html;
  },



  /**
   * Create the <option> HTML
   * @param {Array}   Options as a simple array e.g. ['option1', 'option2']
   *                      or as an array of objects e.g. [{val: 543, label: 'Title for object 543'}]
   * @return {String} HTML
   */
  _arrayToHtml: function(array) {
    var html = $();

    //Generate HTML
    _.each(array, function(option) {
      if (_.isObject(option)) {
        if (option.group) {
          var optgroup = $("<optgroup>")
            .attr("label",option.group)
            .html( this._getOptionsHtml(option.options) );
          html = html.add(optgroup);
        } else {
          var val = (option.val || option.val === 0) ? option.val : '';
          html = html.add( $('<option>').val(val).text(option.label) );
        }
      }
      else {
        html = html.add( $('<option>').text(option) );
      }
    }, this);

    return html;
  }

});

/**
 * Radio editor
 *
 * Renders a <ul> with given options represented as <li> objects containing radio buttons
 *
 * Requires an 'options' value on the schema.
 *  Can be an array of options, a function that calls back with the array of options, a string of HTML
 *  or a Backbone collection. If a collection, the models must implement a toString() method
 */
Form.editors.Radio = Form.editors.Select.extend({

  tagName: 'ul',

  events: {
    'change input[type=radio]': function() {
      this.trigger('change', this);
    },
    'focus input[type=radio]': function() {
      if (this.hasFocus) return;
      this.trigger('focus', this);
    },
    'blur input[type=radio]': function() {
      if (!this.hasFocus) return;
      var self = this;
      setTimeout(function() {
        if (self.$('input[type=radio]:focus')[0]) return;
        self.trigger('blur', self);
      }, 0);
    }
  },

  /**
   * Returns the template. Override for custom templates
   *
   * @return {Function}       Compiled template
   */
  getTemplate: function() {
    return this.schema.template || this.constructor.template;
  },

  getValue: function() {
    return this.$('input[type=radio]:checked').val();
  },

  setValue: function(value) {
    this.$('input[type=radio]').val([value]);
  },

  focus: function() {
    if (this.hasFocus) return;

    var checked = this.$('input[type=radio]:checked');
    if (checked[0]) {
      checked.focus();
      return;
    }

    this.$('input[type=radio]').first().focus();
  },

  blur: function() {
    if (!this.hasFocus) return;

    this.$('input[type=radio]:focus').blur();
  },

  /**
   * Create the radio list HTML
   * @param {Array}   Options as a simple array e.g. ['option1', 'option2']
   *                      or as an array of objects e.g. [{val: 543, label: 'Title for object 543'}]
   * @return {String} HTML
   */
  _arrayToHtml: function (array) {
    var self = this;

    var template = this.getTemplate(),
        name = self.getName(),
        id = self.id;

    var items = _.map(array, function(option, index) {
      var item = {
        name: name,
        id: id + '-' + index
      };

      if (_.isObject(option)) {
        item.value = (option.val || option.val === 0) ? option.val : '';
        item.label = option.label;
        item.labelHTML = option.labelHTML;
      } else {
        item.value = option;
        item.label = option;
      }

      return item;
    });

    return template({ items: items });
  }

}, {

  //STATICS
  template: _.template('\
    <% _.each(items, function(item) { %>\
      <li>\
        <input type="radio" name="<%= item.name %>" value="<%- item.value %>" id="<%= item.id %>" />\
        <label for="<%= item.id %>"><% if (item.labelHTML){ %><%= item.labelHTML %><% }else{ %><%- item.label %><% } %></label>\
      </li>\
    <% }); %>\
  ', null, Form.templateSettings)

});

/**
 * Checkboxes editor
 *
 * Renders a <ul> with given options represented as <li> objects containing checkboxes
 *
 * Requires an 'options' value on the schema.
 *  Can be an array of options, a function that calls back with the array of options, a string of HTML
 *  or a Backbone collection. If a collection, the models must implement a toString() method
 */
Form.editors.Checkboxes = Form.editors.Select.extend({

  tagName: 'ul',

  groupNumber: 0,

  events: {
    'click input[type=checkbox]': function() {
      this.trigger('change', this);
    },
    'focus input[type=checkbox]': function() {
      if (this.hasFocus) return;
      this.trigger('focus', this);
    },
    'blur input[type=checkbox]':  function() {
      if (!this.hasFocus) return;
      var self = this;
      setTimeout(function() {
        if (self.$('input[type=checkbox]:focus')[0]) return;
        self.trigger('blur', self);
      }, 0);
    }
  },

  getValue: function() {
    var values = [];
    this.$('input[type=checkbox]:checked').each(function() {
      values.push($(this).val());
    });
    return values;
  },

  setValue: function(values) {
    if (!_.isArray(values)) values = [values];
    this.$('input[type=checkbox]').val(values);
  },

  focus: function() {
    if (this.hasFocus) return;

    this.$('input[type=checkbox]').first().focus();
  },

  blur: function() {
    if (!this.hasFocus) return;

    this.$('input[type=checkbox]:focus').blur();
  },

  /**
   * Create the checkbox list HTML
   * @param {Array}   Options as a simple array e.g. ['option1', 'option2']
   *                      or as an array of objects e.g. [{val: 543, label: 'Title for object 543'}]
   * @return {String} HTML
   */
  _arrayToHtml: function (array) {
    var html = $();
    var self = this;

    _.each(array, function(option, index) {
      var itemHtml = $('<li>');
      if (_.isObject(option)) {
        if (option.group) {
          var originalId = self.id;
          self.id += "-" + self.groupNumber++;
          itemHtml = $('<fieldset class="group">').append( $('<legend>').text(option.group) );
          itemHtml = itemHtml.append( self._arrayToHtml(option.options) );
          self.id = originalId;
          close = false;
        }else{
          var val = (option.val || option.val === 0) ? option.val : '';
          itemHtml.append( $('<input type="checkbox" name="'+self.getName()+'" id="'+self.id+'-'+index+'" />').val(val) );
          if (option.labelHTML){
            itemHtml.append( $('<label for="'+self.id+'-'+index+'">').html(option.labelHTML) );
          }
          else {
            itemHtml.append( $('<label for="'+self.id+'-'+index+'">').text(option.label) );
          }
        }
      }
      else {
        itemHtml.append( $('<input type="checkbox" name="'+self.getName()+'" id="'+self.id+'-'+index+'" />').val(option) );
        itemHtml.append( $('<label for="'+self.id+'-'+index+'">').text(option) );
      }
      html = html.add(itemHtml);
    });

    return html;
  }

});

/**
 * Object editor
 *
 * Creates a child form. For editing Javascript objects
 *
 * @param {Object} options
 * @param {Form} options.form                 The form this editor belongs to; used to determine the constructor for the nested form
 * @param {Object} options.schema             The schema for the object
 * @param {Object} options.schema.subSchema   The schema for the nested form
 */
Form.editors.Object = Form.editors.Base.extend({
  //Prevent error classes being set on the main control; they are internally on the individual fields
  hasNestedForm: true,

  initialize: function(options) {
    //Set default value for the instance so it's not a shared object
    this.value = {};

    //Init
    Form.editors.Base.prototype.initialize.call(this, options);

    //Check required options
    if (!this.form) throw new Error('Missing required option "form"');
    if (!this.schema.subSchema) throw new Error("Missing required 'schema.subSchema' option for Object editor");
  },

  render: function() {
    //Get the constructor for creating the nested form; i.e. the same constructor as used by the parent form
    var NestedForm = this.form.constructor;

    //Create the nested form
    this.nestedForm = new NestedForm({
      schema: this.schema.subSchema,
      data: this.value,
      idPrefix: this.id + '_',
      Field: NestedForm.NestedField
    });

    this._observeFormEvents();

    this.$el.html(this.nestedForm.render().el);

    if (this.hasFocus) this.trigger('blur', this);

    return this;
  },

  getValue: function() {
    if (this.nestedForm) return this.nestedForm.getValue();

    return this.value;
  },

  setValue: function(value) {
    this.value = value;

    this.render();
  },

  focus: function() {
    if (this.hasFocus) return;

    this.nestedForm.focus();
  },

  blur: function() {
    if (!this.hasFocus) return;

    this.nestedForm.blur();
  },

  remove: function() {
    this.nestedForm.remove();

    Backbone.View.prototype.remove.call(this);
  },

  validate: function() {
    var errors = _.extend({}, 
      Form.editors.Base.prototype.validate.call(this),
      this.nestedForm.validate()
    );
    return _.isEmpty(errors)?false:errors;
  },

  _observeFormEvents: function() {
    if (!this.nestedForm) return;
    
    this.nestedForm.on('all', function() {
      // args = ["key:change", form, fieldEditor]
      var args = _.toArray(arguments);
      args[1] = this;
      // args = ["key:change", this=objectEditor, fieldEditor]

      this.trigger.apply(this, args);
    }, this);
  }

});

/**
 * NestedModel editor
 *
 * Creates a child form. For editing nested Backbone models
 *
 * Special options:
 *   schema.model:   Embedded model constructor
 */
Form.editors.NestedModel = Form.editors.Object.extend({
  initialize: function(options) {
    Form.editors.Base.prototype.initialize.call(this, options);

    if (!this.form) throw new Error('Missing required option "form"');
    if (!options.schema.model) throw new Error('Missing required "schema.model" option for NestedModel editor');
  },

  render: function() {
    //Get the constructor for creating the nested form; i.e. the same constructor as used by the parent form
    var NestedForm = this.form.constructor;

    var data = this.value || {},
        key = this.key,
        nestedModel = this.schema.model;

    //Wrap the data in a model if it isn't already a model instance
    var modelInstance = (data.constructor === nestedModel) ? data : new nestedModel(data);

    this.nestedForm = new NestedForm({
      model: modelInstance,
      idPrefix: this.id + '_',
      fieldTemplate: 'nestedField'
    });

    this._observeFormEvents();

    //Render form
    this.$el.html(this.nestedForm.render().el);

    if (this.hasFocus) this.trigger('blur', this);

    return this;
  },

  /**
   * Update the embedded model, checking for nested validation errors and pass them up
   * Then update the main model if all OK
   *
   * @return {Error|null} Validation error or null
   */
  commit: function() {
    var error = this.nestedForm.commit();
    if (error) {
      this.$el.addClass('error');
      return error;
    }

    return Form.editors.Object.prototype.commit.call(this);
  }

});

/**
 * Date editor
 *
 * Schema options
 * @param {Number|String} [options.schema.yearStart]  First year in list. Default: 100 years ago
 * @param {Number|String} [options.schema.yearEnd]    Last year in list. Default: current year
 *
 * Config options (if not set, defaults to options stored on the main Date class)
 * @param {Boolean} [options.showMonthNames]  Use month names instead of numbers. Default: true
 * @param {String[]} [options.monthNames]     Month names. Default: Full English names
 */
Form.editors.Date = Form.editors.Base.extend({

  events: {
    'change select':  function() {
      this.updateHidden();
      this.trigger('change', this);
    },
    'focus select':   function() {
      if (this.hasFocus) return;
      this.trigger('focus', this);
    },
    'blur select':    function() {
      if (!this.hasFocus) return;
      var self = this;
      setTimeout(function() {
        if (self.$('select:focus')[0]) return;
        self.trigger('blur', self);
      }, 0);
    }
  },

  initialize: function(options) {
    options = options || {};

    Form.editors.Base.prototype.initialize.call(this, options);

    var Self = Form.editors.Date,
        today = new Date();

    //Option defaults
    this.options = _.extend({
      monthNames: Self.monthNames,
      showMonthNames: Self.showMonthNames
    }, options);

    //Schema defaults
    this.schema = _.extend({
      yearStart: today.getFullYear() - 100,
      yearEnd: today.getFullYear()
    }, options.schema || {});

    //Cast to Date
    if (this.value && !_.isDate(this.value)) {
      this.value = new Date(this.value);
    }

    //Set default date
    if (!this.value) {
      var date = new Date();
      date.setSeconds(0);
      date.setMilliseconds(0);

      this.value = date;
    }

    //Template
    this.template = options.template || this.constructor.template;
  },

  render: function() {
    var options = this.options,
        schema = this.schema,
        $ = Backbone.$;

    var datesOptions = _.map(_.range(1, 32), function(date) {
      return '<option value="'+date+'">' + date + '</option>';
    });

    var monthsOptions = _.map(_.range(0, 12), function(month) {
      var value = (options.showMonthNames)
          ? options.monthNames[month]
          : (month + 1);

      return '<option value="'+month+'">' + value + '</option>';
    });

    var yearRange = (schema.yearStart < schema.yearEnd)
      ? _.range(schema.yearStart, schema.yearEnd + 1)
      : _.range(schema.yearStart, schema.yearEnd - 1, -1);

    var yearsOptions = _.map(yearRange, function(year) {
      return '<option value="'+year+'">' + year + '</option>';
    });

    //Render the selects
    var $el = $($.trim(this.template({
      dates: datesOptions.join(''),
      months: monthsOptions.join(''),
      years: yearsOptions.join('')
    })));

    //Store references to selects
    this.$date = $el.find('[data-type="date"]');
    this.$month = $el.find('[data-type="month"]');
    this.$year = $el.find('[data-type="year"]');

    //Create the hidden field to store values in case POSTed to server
    this.$hidden = $('<input type="hidden" name="'+this.key+'" />');
    $el.append(this.$hidden);

    //Set value on this and hidden field
    this.setValue(this.value);

    //Remove the wrapper tag
    this.setElement($el);
    this.$el.attr('id', this.id);
    this.$el.attr('name', this.getName());

    if (this.hasFocus) this.trigger('blur', this);

    return this;
  },

  /**
   * @return {Date}   Selected date
   */
  getValue: function() {
    var year = this.$year.val(),
        month = this.$month.val(),
        date = this.$date.val();

    if (!year || !month || !date) return null;

    return new Date(year, month, date);
  },

  /**
   * @param {Date} date
   */
  setValue: function(date) {
    this.$date.val(date.getDate());
    this.$month.val(date.getMonth());
    this.$year.val(date.getFullYear());

    this.updateHidden();
  },

  focus: function() {
    if (this.hasFocus) return;

    this.$('select').first().focus();
  },

  blur: function() {
    if (!this.hasFocus) return;

    this.$('select:focus').blur();
  },

  /**
   * Update the hidden input which is maintained for when submitting a form
   * via a normal browser POST
   */
  updateHidden: function() {
    var val = this.getValue();

    if (_.isDate(val)) val = val.toISOString();

    this.$hidden.val(val);
  }

}, {
  //STATICS
  template: _.template('\
    <div>\
      <select data-type="date"><%= dates %></select>\
      <select data-type="month"><%= months %></select>\
      <select data-type="year"><%= years %></select>\
    </div>\
  ', null, Form.templateSettings),

  //Whether to show month names instead of numbers
  showMonthNames: true,

  //Month names to use if showMonthNames is true
  //Replace for localisation, e.g. Form.editors.Date.monthNames = ['Janvier', 'Fevrier'...]
  monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
});

/**
 * DateTime editor
 *
 * @param {Editor} [options.DateEditor]           Date editor view to use (not definition)
 * @param {Number} [options.schema.minsInterval]  Interval between minutes. Default: 15
 */
Form.editors.DateTime = Form.editors.Base.extend({

  events: {
    'change select':  function() {
      this.updateHidden();
      this.trigger('change', this);
    },
    'focus select':   function() {
      if (this.hasFocus) return;
      this.trigger('focus', this);
    },
    'blur select':    function() {
      if (!this.hasFocus) return;
      var self = this;
      setTimeout(function() {
        if (self.$('select:focus')[0]) return;
        self.trigger('blur', self);
      }, 0);
    }
  },

  initialize: function(options) {
    options = options || {};

    Form.editors.Base.prototype.initialize.call(this, options);

    //Option defaults
    this.options = _.extend({
      DateEditor: Form.editors.DateTime.DateEditor
    }, options);

    //Schema defaults
    this.schema = _.extend({
      minsInterval: 15
    }, options.schema || {});

    //Create embedded date editor
    this.dateEditor = new this.options.DateEditor(options);

    this.value = this.dateEditor.value;

    //Template
    this.template = options.template || this.constructor.template;
  },

  render: function() {
    function pad(n) {
      return n < 10 ? '0' + n : n;
    }

    var schema = this.schema,
        $ = Backbone.$;

    //Create options
    var hoursOptions = _.map(_.range(0, 24), function(hour) {
      return '<option value="'+hour+'">' + pad(hour) + '</option>';
    });

    var minsOptions = _.map(_.range(0, 60, schema.minsInterval), function(min) {
      return '<option value="'+min+'">' + pad(min) + '</option>';
    });

    //Render time selects
    var $el = $($.trim(this.template({
      hours: hoursOptions.join(),
      mins: minsOptions.join()
    })));

    //Include the date editor
    $el.find('[data-date]').append(this.dateEditor.render().el);

    //Store references to selects
    this.$hour = $el.find('select[data-type="hour"]');
    this.$min = $el.find('select[data-type="min"]');

    //Get the hidden date field to store values in case POSTed to server
    this.$hidden = $el.find('input[type="hidden"]');

    //Set time
    this.setValue(this.value);

    this.setElement($el);
    this.$el.attr('id', this.id);
    this.$el.attr('name', this.getName());

    if (this.hasFocus) this.trigger('blur', this);

    return this;
  },

  /**
   * @return {Date}   Selected datetime
   */
  getValue: function() {
    var date = this.dateEditor.getValue();

    var hour = this.$hour.val(),
        min = this.$min.val();

    if (!date || !hour || !min) return null;

    date.setHours(hour);
    date.setMinutes(min);

    return date;
  },

  /**
   * @param {Date}
   */
  setValue: function(date) {
    if (!_.isDate(date)) date = new Date(date);

    this.dateEditor.setValue(date);

    this.$hour.val(date.getHours());
    this.$min.val(date.getMinutes());

    this.updateHidden();
  },

  focus: function() {
    if (this.hasFocus) return;

    this.$('select').first().focus();
  },

  blur: function() {
    if (!this.hasFocus) return;

    this.$('select:focus').blur();
  },

  /**
   * Update the hidden input which is maintained for when submitting a form
   * via a normal browser POST
   */
  updateHidden: function() {
    var val = this.getValue();
    if (_.isDate(val)) val = val.toISOString();

    this.$hidden.val(val);
  },

  /**
   * Remove the Date editor before removing self
   */
  remove: function() {
    this.dateEditor.remove();

    Form.editors.Base.prototype.remove.call(this);
  }

}, {
  //STATICS
  template: _.template('\
    <div class="bbf-datetime">\
      <div class="bbf-date-container" data-date></div>\
      <select data-type="hour"><%= hours %></select>\
      :\
      <select data-type="min"><%= mins %></select>\
    </div>\
  ', null, Form.templateSettings),

  //The date editor to use (constructor function, not instance)
  DateEditor: Form.editors.Date
});



  //Metadata
  Form.VERSION = '0.14.0';


  //Exports
  Backbone.Form = Form;
  if (typeof module !== 'undefined') module.exports = Form;

})(window || global || this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"backbone":19,"underscore":30}],16:[function(require,module,exports){
(function (global){
/*!
 * backbone.layoutmanager.js v0.9.5
 * Copyright 2013, Tim Branyen (@tbranyen)
 * backbone.layoutmanager.js may be freely distributed under the MIT license.
 */
(function(window, factory) {
  "use strict";

  // AMD. Register as an anonymous module.  Wrap in function so we have access
  // to root via `this`.
  if (typeof define === "function" && define.amd) {
    define(["backbone", "underscore", "jquery"], function() {
      return factory.apply(window, arguments);
    });
  }

  // Node. Does not work with strict CommonJS, but only CommonJS-like
  // environments that support module.exports, like Node.
  else if (typeof exports === "object") {
    var Backbone = require("backbone");
    var _ = require("underscore");
    // In a browserify build, since this is the entry point, Backbone.$
    // is not bound. Ensure that it is.
    Backbone.$ = Backbone.$ || require("jquery");

    module.exports = factory.call(window, Backbone, _, Backbone.$);
  }

  // Browser globals.
  else {
    factory.call(window, window.Backbone, window._, window.Backbone.$);
  }
}(typeof global === "object" ? global : this, function (Backbone, _, $) {
"use strict";

// Create a reference to the global object. In browsers, it will map to the
// `window` object; in Node, it will be `global`.
var window = this;

// Maintain reference to the original constructor.
var ViewConstructor = Backbone.View;

// Cache these methods for performance.
var aPush = Array.prototype.push;
var aConcat = Array.prototype.concat;
var aSplice = Array.prototype.splice;
var trim = String.prototype.trim ?
  _.bind(String.prototype.trim.call, String.prototype.trim) :
  $.trim;

// LayoutManager is a wrapper around a `Backbone.View`.
// Backbone.View.extend takes options (protoProps, staticProps)
var LayoutManager = Backbone.View.extend({
  _render: function() {
    // Keep the view consistent between callbacks and deferreds.
    var view = this;
    // Shorthand the manager.
    var manager = view.__manager__;
    // Cache these properties.
    var beforeRender = view.beforeRender;
    // Create a deferred instead of going off
    var def = view.deferred();

    // Ensure all nested Views are properly scrubbed if re-rendering.
    if (view.hasRendered) {
      view._removeViews();
    }

    // This continues the render flow after `beforeRender` has completed.
    manager.callback = function() {
      // Clean up asynchronous manager properties.
      delete manager.isAsync;
      delete manager.callback;

      // Always emit a beforeRender event.
      view.trigger("beforeRender", view);

      // Render!
      view._viewRender(manager).render().then(function() {
        // Complete this deferred once resolved.
        def.resolve();
      });
    };

    // If a beforeRender function is defined, call it.
    if (beforeRender) {
      beforeRender.call(view, view);
    }

    if (!manager.isAsync) {
      manager.callback();
    }

    // Return this intermediary promise.
    return def.promise();
  },

  // This function is responsible for pairing the rendered template into the
  // DOM element.
  _applyTemplate: function(rendered, manager, def) {
    // Actually put the rendered contents into the element.
    if (_.isString(rendered)) {
      // If no container is specified, we must replace the content.
      if (manager.noel) {
        rendered = $.parseHTML(rendered, true);

        // Remove extra root elements.
        this.$el.slice(1).remove();

        // Swap out the View on the first top level element to avoid
        // duplication.
        this.$el.replaceWith(rendered);

        // Don't delegate events here - we'll do that in resolve()
        this.setElement(rendered, false);
      } else {
        this.html(this.$el, rendered);
      }
    }

    // Resolve only after fetch and render have succeeded.
    def.resolveWith(this, [this]);
  },

  // Creates a deferred and returns a function to call when finished.
  // This gets passed to all _render methods.  The `root` value here is passed
  // from the `manage(this).render()` line in the `_render` function
  _viewRender: function(manager) {
    var url, contents, def;
    var root = this;

    // Once the template is successfully fetched, use its contents to proceed.
    // Context argument is first, since it is bound for partial application
    // reasons.
    function done(context, template) {
      // Store the rendered template someplace so it can be re-assignable.
      var rendered;

      // Trigger this once the render method has completed.
      manager.callback = function(rendered) {
        // Clean up asynchronous manager properties.
        delete manager.isAsync;
        delete manager.callback;

        root._applyTemplate(rendered, manager, def);
      };

      // Ensure the cache is up-to-date.
      LayoutManager.cache(url, template);

      // Render the View into the el property.
      if (template) {
        rendered = root.renderTemplate.call(root, template, context);
      }

      // If the function was synchronous, continue execution.
      if (!manager.isAsync) {
        root._applyTemplate(rendered, manager, def);
      }
    }

    return {
      // This `render` function is what gets called inside of the View render,
      // when `manage(this).render` is called.  Returns a promise that can be
      // used to know when the element has been rendered into its parent.
      render: function() {
        var context = root.serialize;
        var template = root.template;

        // Create a deferred specifically for fetching.
        def = root.deferred();

        // If data is a function, immediately call it.
        if (_.isFunction(context)) {
          context = context.call(root);
        }

        // Set the internal callback to trigger once the asynchronous or
        // synchronous behavior has completed.
        manager.callback = function(contents) {
          // Clean up asynchronous manager properties.
          delete manager.isAsync;
          delete manager.callback;

          done(context, contents);
        };

        // Set the url to the prefix + the view's template property.
        if (typeof template === "string") {
          url = root.prefix + template;
        }

        // Check if contents are already cached and if they are, simply process
        // the template with the correct data.
        if (contents = LayoutManager.cache(url)) {
          done(context, contents, url);

          return def;
        }

        // Fetch layout and template contents.
        if (typeof template === "string") {
          contents = root.fetchTemplate.call(root, root.prefix +
            template);
        // If the template is already a function, simply call it.
        } else if (typeof template === "function") {
          contents = template;
        // If its not a string and not undefined, pass the value to `fetch`.
        } else if (template != null) {
          contents = root.fetchTemplate.call(root, template);
        }

        // If the function was synchronous, continue execution.
        if (!manager.isAsync) {
          done(context, contents);
        }

        return def;
      }
    };
  },

  // This named function allows for significantly easier debugging.
  constructor: function Layout(options) {
    // Grant this View superpowers.
    this.manage = true;

    // Give this View access to all passed options as instance properties.
    _.extend(this, options);

    // Have Backbone set up the rest of this View.
    Backbone.View.apply(this, arguments);
  },

  // This method is used within specific methods to indicate that they should
  // be treated as asynchronous.  This method should only be used within the
  // render chain, otherwise unexpected behavior may occur.
  async: function() {
    var manager = this.__manager__;

    // Set this View's action to be asynchronous.
    manager.isAsync = true;

    // Return the callback.
    return manager.callback;
  },

  promise: function() {
    return this.__manager__.renderDeferred.promise();
  },

  // Proxy `then` for easier invocation.
  then: function() {
    return this.promise().then.apply(this, arguments);
  },

  // Sometimes it's desirable to only render the child views under the parent.
  // This is typical for a layout that does not change.  This method will
  // iterate over the provided views or delegate to `getViews` to fetch child
  // Views and aggregate all render promises and return the parent View.
  // The internal `promise()` method will return the aggregate promise that
  // resolves once all children have completed their render.
  renderViews: function(views) {
    var root = this;
    var manager = root.__manager__;
    var newDeferred = root.deferred();

    // If the caller provided an array of views then render those, otherwise
    // delegate to getViews.
    if (views && _.isArray(views)) {
      views = _.chain(views);
    } else {
      views = root.getViews(views);
    }

    // Collect all promises from rendering the child views and wait till they
    // all complete.
    var promises = views.map(function(view) {
      return view.render().__manager__.renderDeferred;
    }).value();

    // Simulate a parent render to remain consistent.
    manager.renderDeferred = newDeferred.promise();

    // Once all child views have completed rendering, resolve parent deferred
    // with the correct context.
    root.when(promises).then(function() {
      newDeferred.resolveWith(root, [root]);
    });

    // Allow this method to be chained.
    return root;
  },

  // Shorthand to `setView` function with the `insert` flag set.
  insertView: function(selector, view) {
    // If the `view` argument exists, then a selector was passed in.  This code
    // path will forward the selector on to `setView`.
    if (view) {
      return this.setView(selector, view, true);
    }

    // If no `view` argument is defined, then assume the first argument is the
    // View, somewhat now confusingly named `selector`.
    return this.setView(selector, true);
  },

  // Iterate over an object and ensure every value is wrapped in an array to
  // ensure they will be inserted, then pass that object to `setViews`.
  insertViews: function(views) {
    // If an array of views was passed it should be inserted into the
    // root view. Much like calling insertView without a selector.
    if (_.isArray(views)) {
      return this.setViews({ "": views });
    }

    _.each(views, function(view, selector) {
      views[selector] = _.isArray(view) ? view : [view];
    });

    return this.setViews(views);
  },

  // Returns the View that matches the `getViews` filter function.
  getView: function(fn) {
    // If `getView` is invoked with undefined as the first argument, then the
    // second argument will be used instead.  This is to allow
    // `getViews(undefined, fn)` to work as `getViews(fn)`.  Useful for when
    // you are allowing an optional selector.
    if (fn == null) {
      fn = arguments[1];
    }

    return this.getViews(fn).first().value();
  },

  // Provide a filter function to get a flattened array of all the subviews.
  // If the filter function is omitted it will return all subviews.  If a
  // String is passed instead, it will return the Views for that selector.
  getViews: function(fn) {
    var views;

    // If the filter argument is a String, then return a chained Version of the
    // elements. The value at the specified filter may be undefined, a single
    // view, or an array of views; in all cases, chain on a flat array.
    if (typeof fn === "string") {
      fn = this.sections[fn] || fn;
      views = this.views[fn] || [];

      // If Views is undefined you are concatenating an `undefined` to an array
      // resulting in a value being returned.  Defaulting to an array prevents
      // this.
      //return _.chain([].concat(views || []));
      return _.chain([].concat(views));
    }

    // Generate an array of all top level (no deeply nested) Views flattened.
    views = _.chain(this.views).map(function(view) {
      return _.isArray(view) ? view : [view];
    }, this).flatten();

    // If the argument passed is an Object, then pass it to `_.where`.
    if (typeof fn === "object") {
      return views.where(fn);
    }

    // If a filter function is provided, run it on all Views and return a
    // wrapped chain. Otherwise, simply return a wrapped chain of all Views.
    return typeof fn === "function" ? views.filter(fn) : views;
  },

  // Use this to remove Views, internally uses `getViews` so you can pass the
  // same argument here as you would to that method.
  removeView: function(fn) {
    // Allow an optional selector or function to find the right model and
    // remove nested Views based off the results of the selector or filter.
    return this.getViews(fn).each(function(nestedView) {
      nestedView.remove();
    });
  },

  // This takes in a partial name and view instance and assigns them to
  // the internal collection of views.  If a view is not a LayoutManager
  // instance, then mix in the LayoutManager prototype.  This ensures
  // all Views can be used successfully.
  //
  // Must definitely wrap any render method passed in or defaults to a
  // typical render function `return layout(this).render()`.
  setView: function(name, view, insert) {
    var manager, selector;
    // Parent view, the one you are setting a View on.
    var root = this;

    // If no name was passed, use an empty string and shift all arguments.
    if (typeof name !== "string") {
      insert = view;
      view = name;
      name = "";
    }

    // Shorthand the `__manager__` property.
    manager = view.__manager__;

    // If the View has not been properly set up, throw an Error message
    // indicating that the View needs `manage: true` set.
    if (!manager) {
      throw new Error("The argument associated with selector '" + name +
        "' is defined and a View.  Set `manage` property to true for " +
        "Backbone.View instances.");
    }

    // Add reference to the parentView.
    manager.parent = root;

    // Add reference to the placement selector used.
    selector = manager.selector = root.sections[name] || name;

    // Code path is less complex for Views that are not being inserted.  Simply
    // remove existing Views and bail out with the assignment.
    if (!insert) {
      // Ensure remove is called only when swapping in a new view (when the
      // view is the same, it does not need to be removed or cleaned up).
      if (root.getView(name) !== view) {
        root.removeView(name);
      }

      // Assign to main views object and return for chainability.
      return root.views[selector] = view;
    }

    // Ensure this.views[selector] is an array and push this View to
    // the end.
    root.views[selector] = aConcat.call([], root.views[name] || [], view);

    // Put the parent view into `insert` mode.
    root.__manager__.insert = true;

    return view;
  },

  // Allows the setting of multiple views instead of a single view.
  setViews: function(views) {
    // Iterate over all the views and use the View's view method to assign.
    _.each(views, function(view, name) {
      // If the view is an array put all views into insert mode.
      if (_.isArray(view)) {
        return _.each(view, function(view) {
          this.insertView(name, view);
        }, this);
      }

      // Assign each view using the view function.
      this.setView(name, view);
    }, this);

    // Allow for chaining
    return this;
  },

  // By default this should find all nested views and render them into
  // the this.el and call done once all of them have successfully been
  // resolved.
  //
  // This function returns a promise that can be chained to determine
  // once all subviews and main view have been rendered into the view.el.
  render: function() {
    var root = this;
    var manager = root.__manager__;
    var parent = manager.parent;
    var rentManager = parent && parent.__manager__;
    var def = root.deferred();

    // Triggered once the render has succeeded.
    function resolve() {

      // Insert all subViews into the parent at once.
      _.each(root.views, function(views, selector) {
        // Fragments aren't used on arrays of subviews.
        if (_.isArray(views)) {
          root.htmlBatch(root, views, selector);
        }
      });

      // If there is a parent and we weren't attached to it via the previous
      // method (single view), attach.
      if (parent && !manager.insertedViaFragment) {
        if (!root.contains(parent.el, root.el)) {
          // Apply the partial using parent's html() method.
          parent.partial(parent.$el, root.$el, rentManager, manager);
        }
      }

      // Ensure events are always correctly bound after rendering.
      root.delegateEvents();

      // Set this View as successfully rendered.
      root.hasRendered = true;
      manager.renderInProgress = false;

      // Clear triggeredByRAF flag.
      delete manager.triggeredByRAF;

      // Only process the queue if it exists.
      if (manager.queue && manager.queue.length) {
        // Ensure that the next render is only called after all other
        // `done` handlers have completed.  This will prevent `render`
        // callbacks from firing out of order.
        (manager.queue.shift())();
      } else {
        // Once the queue is depleted, remove it, the render process has
        // completed.
        delete manager.queue;
      }

      // Reusable function for triggering the afterRender callback and event.
      function completeRender() {
        var console = window.console;
        var afterRender = root.afterRender;

        if (afterRender) {
          afterRender.call(root, root);
        }

        // Always emit an afterRender event.
        root.trigger("afterRender", root);

        // If there are multiple top level elements and `el: false` is used,
        // display a warning message and a stack trace.
        if (manager.noel && root.$el.length > 1) {
          // Do not display a warning while testing or if warning suppression
          // is enabled.
          if (_.isFunction(console.warn) && !root.suppressWarnings) {
            console.warn("`el: false` with multiple top level elements is " +
              "not supported.");

            // Provide a stack trace if available to aid with debugging.
            if (_.isFunction(console.trace)) {
              console.trace();
            }
          }
        }
      }

      // If the parent is currently rendering, wait until it has completed
      // until calling the nested View's `afterRender`.
      if (rentManager && (rentManager.renderInProgress || rentManager.queue)) {
        // Wait until the parent View has finished rendering, which could be
        // asynchronous, and trigger afterRender on this View once it has
        // completed.
        parent.once("afterRender", completeRender);
      } else {
        // This View and its parent have both rendered.
        completeRender();
      }

      return def.resolveWith(root, [root]);
    }

    // Actually facilitate a render.
    function actuallyRender() {

      // The `_viewRender` method is broken out to abstract away from having
      // too much code in `actuallyRender`.
      root._render().done(function() {
        // If there are no children to worry about, complete the render
        // instantly.
        if (!_.keys(root.views).length) {
          return resolve();
        }

        // Create a list of promises to wait on until rendering is done.
        // Since this method will run on all children as well, its sufficient
        // for a full hierarchical.
        var promises = _.map(root.views, function(view) {
          var insert = _.isArray(view);

          // If items are being inserted, they will be in a non-zero length
          // Array.
          if (insert && view.length) {
            // Mark each subview's manager so they don't attempt to attach by
            // themselves.  Return a single promise representing the entire
            // render.
            return root.when(_.map(view, function(subView) {
              subView.__manager__.insertedViaFragment = true;
              return subView.render().__manager__.renderDeferred;
            }));
          }

          // Only return the fetch deferred, resolve the main deferred after
          // the element has been attached to it's parent.
          return !insert ? view.render().__manager__.renderDeferred : view;
        });

        // Once all nested Views have been rendered, resolve this View's
        // deferred.
        root.when(promises).done(resolve);
      });
    }

    // Mark this render as in progress. This will prevent
    // afterRender from being fired until the entire chain has rendered.
    manager.renderInProgress = true;

    // Start the render.
    // Register this request & cancel any that conflict.
    root._registerWithRAF(actuallyRender, def);

    // Put the deferred inside of the `__manager__` object, since we don't want
    // end users accessing this directly anymore in favor of the `afterRender`
    // event.  So instead of doing `render().then(...` do
    // `render().once("afterRender", ...`.
    // FIXME: I think we need to move back to promises so that we don't
    // miss events, regardless of sync/async (useRAF setting)
    manager.renderDeferred = def;

    // Return the actual View for chainability purposes.
    return root;
  },

  // Ensure the cleanup function is called whenever remove is called.
  remove: function() {
    // Force remove itself from its parent.
    LayoutManager._removeView(this, true);

    // Call the original remove function.
    return this._remove.apply(this, arguments);
  },

  // Register a view render with RAF.
  _registerWithRAF: function(callback, deferred) {
    var root = this;
    var manager = root.__manager__;
    var rentManager = manager.parent && manager.parent.__manager__;

    // Allow RAF processing to be shut off using `useRAF`:false.
    if (this.useRAF === false) {
      if (manager.queue) {
        aPush.call(manager.queue, callback);
      } else {
        manager.queue = [];
        callback();
      }
      return;
    }

    // Keep track of all deferreds so we can resolve them.
    manager.deferreds = manager.deferreds || [];
    manager.deferreds.push(deferred);

    // Schedule resolving all deferreds that are waiting.
    deferred.done(resolveDeferreds);

    // Cancel any other renders on this view that are queued to execute.
    this._cancelQueuedRAFRender();

    // Trigger immediately if the parent was triggered by RAF.
    // The flag propagates downward so this view's children are also
    // rendered immediately.
    if (rentManager && rentManager.triggeredByRAF) {
      return finish();
    }

    // Register this request with requestAnimationFrame.
    manager.rafID = root.requestAnimationFrame(finish);

    function finish() {
      // Remove this ID as it is no longer valid.
      manager.rafID = null;

      // Set flag (will propagate to children) so they render
      // without waiting for RAF.
      manager.triggeredByRAF = true;

      // Call original cb.
      callback();
    }

    // Resolve all deferreds that were cancelled previously, if any.
    // This allows the user to bind callbacks to any render callback,
    // even if it was cancelled above.
    function resolveDeferreds() {
      for (var i = 0; i < manager.deferreds.length; i++){
        manager.deferreds[i].resolveWith(root, [root]);
      }
      manager.deferreds = [];
    }
  },

  // Cancel any queued render requests.
  _cancelQueuedRAFRender: function() {
    var root = this;
    var manager = root.__manager__;
    if (manager.rafID != null) {
      root.cancelAnimationFrame(manager.rafID);
    }
  }
},

// Static Properties
{
  // Clearable cache.
  _cache: {},

  // Remove all nested Views.
  _removeViews: function(root, force) {
    // Shift arguments around.
    if (typeof root === "boolean") {
      force = root;
      root = this;
    }

    // Allow removeView to be called on instances.
    root = root || this;

    // Iterate over all of the nested View's and remove.
    root.getViews().each(function(view) {
      // Force doesn't care about if a View has rendered or not.
      if (view.hasRendered || force) {
        LayoutManager._removeView(view, force);
      }
    });
  },

  // Remove a single nested View.
  _removeView: function(view, force) {
    var parentViews;
    // Shorthand the managers for easier access.
    var manager = view.__manager__;
    var rentManager = manager.parent && manager.parent.__manager__;
    // Test for keep.
    var keep = typeof view.keep === "boolean" ? view.keep : view.options.keep;

    // In insert mode, remove views that do not have `keep` attribute set,
    // unless the force flag is set.
    if ((!keep && rentManager && rentManager.insert === true) || force) {
      // Clean out the events.
      LayoutManager.cleanViews(view);

      // Since we are removing this view, force subviews to remove
      view._removeViews(true);

      // Remove the View completely.
      view.$el.remove();

      // Cancel any pending renders, if present.
      view._cancelQueuedRAFRender();

      // Bail out early if no parent exists.
      if (!manager.parent) { return; }

      // Assign (if they exist) the sibling Views to a property.
      parentViews = manager.parent.views[manager.selector];

      // If this is an array of items remove items that are not marked to
      // keep.
      if (_.isArray(parentViews)) {
        // Remove duplicate Views.
        return _.each(_.clone(parentViews), function(view, i) {
          // If the managers match, splice off this View.
          if (view && view.__manager__ === manager) {
            aSplice.call(parentViews, i, 1);
          }
        });
      }

      // Otherwise delete the parent selector.
      delete manager.parent.views[manager.selector];
    }
  },

  // Cache templates into LayoutManager._cache.
  cache: function(path, contents) {
    // If template path is found in the cache, return the contents.
    if (path in this._cache && contents == null) {
      return this._cache[path];
    // Ensure path and contents aren't undefined.
    } else if (path != null && contents != null) {
      return this._cache[path] = contents;
    }

    // If the template is not in the cache, return undefined.
  },

  // Accept either a single view or an array of views to clean of all DOM
  // events internal model and collection references and all Backbone.Events.
  cleanViews: function(views) {
    // Clear out all existing views.
    _.each(aConcat.call([], views), function(view) {
      // Remove all custom events attached to this View.
      view.unbind();

      // Automatically unbind `model`.
      if (view.model instanceof Backbone.Model) {
        view.model.off(null, null, view);
      }

      // Automatically unbind `collection`.
      if (view.collection instanceof Backbone.Collection) {
        view.collection.off(null, null, view);
      }

      // Automatically unbind events bound to this View.
      view.stopListening();

      // If a custom cleanup method was provided on the view, call it after
      // the initial cleanup is done
      if (_.isFunction(view.cleanup)) {
        view.cleanup();
      }
    });
  },

  // This static method allows for global configuration of LayoutManager.
  configure: function(options) {
    _.extend(LayoutManager.prototype, options);

    // Allow LayoutManager to manage Backbone.View.prototype.
    if (options.manage) {
      Backbone.View.prototype.manage = true;
    }

    // Disable the element globally.
    if (options.el === false) {
      Backbone.View.prototype.el = false;
    }

    // Allow global configuration of `suppressWarnings`.
    if (options.suppressWarnings === true) {
      Backbone.View.prototype.suppressWarnings = true;
    }

    // Allow global configuration of `useRAF`.
    if (options.useRAF === false) {
      Backbone.View.prototype.useRAF = false;
    }
  },

  // Configure a View to work with the LayoutManager plugin.
  setupView: function(views, options) {
    // Ensure that options is always an object, and clone it so that
    // changes to the original object don't screw up this view.
    options = _.extend({}, options);

    // Set up all Views passed.
    _.each(aConcat.call([], views), function(view) {
      // If the View has already been setup, no need to do it again.
      if (view.__manager__) {
        return;
      }

      var views, declaredViews;
      var proto = LayoutManager.prototype;

      // Ensure necessary properties are set.
      _.defaults(view, {
        // Ensure a view always has a views object.
        views: {},

        // Ensure a view always has a sections object.
        sections: {},

        // Internal state object used to store whether or not a View has been
        // taken over by layout manager and if it has been rendered into the
        // DOM.
        __manager__: {},

        // Add the ability to remove all Views.
        _removeViews: LayoutManager._removeViews,

        // Add the ability to remove itself.
        _removeView: LayoutManager._removeView

      // Mix in all LayoutManager prototype properties as well.
      }, LayoutManager.prototype);

      // Assign passed options.
      view.options = options;

      // Merge the View options into the View.
      _.extend(view, options);

      // By default the original Remove function is the Backbone.View one.
      view._remove = Backbone.View.prototype.remove;

      // Ensure the render is always set correctly.
      view.render = LayoutManager.prototype.render;

      // If the user provided their own remove override, use that instead of
      // the default.
      if (view.remove !== proto.remove) {
        view._remove = view.remove;
        view.remove = proto.remove;
      }

      // Normalize views to exist on either instance or options, default to
      // options.
      views = options.views || view.views;

      // Set the internal views, only if selectors have been provided.
      if (_.keys(views).length) {
        // Keep original object declared containing Views.
        declaredViews = views;

        // Reset the property to avoid duplication or overwritting.
        view.views = {};

        // If any declared view is wrapped in a function, invoke it.
        _.each(declaredViews, function(declaredView, key) {
          if (typeof declaredView === "function") {
            declaredViews[key] = declaredView.call(view, view);
          }
        });

        // Set the declared Views.
        view.setViews(declaredViews);
      }
    });
  }
});

LayoutManager.VERSION = "0.9.5";

// Expose through Backbone object.
Backbone.Layout = LayoutManager;

// Override _configure to provide extra functionality that is necessary in
// order for the render function reference to be bound during initialize.
Backbone.View.prototype.constructor = function(options) {
  var noel;

  // Ensure options is always an object.
  options = options || {};

  // Remove the container element provided by Backbone.
  if ("el" in options ? options.el === false : this.el === false) {
    noel = true;
  }

  // If manage is set, do it!
  if (options.manage || this.manage) {
    // Set up this View.
    LayoutManager.setupView(this, options);
  }

  // Assign the `noel` property once we're sure the View we're working with is
  // managed by LayoutManager.
  if (this.__manager__) {
    this.__manager__.noel = noel;
    this.__manager__.suppressWarnings = options.suppressWarnings;
  }

  // Act like nothing happened.
  ViewConstructor.apply(this, arguments);
};

Backbone.View = Backbone.View.prototype.constructor;

// Copy over the extend method.
Backbone.View.extend = ViewConstructor.extend;

// Copy over the prototype as well.
Backbone.View.prototype = ViewConstructor.prototype;

// Default configuration options; designed to be overriden.
var defaultOptions = {
  // Prefix template/layout paths.
  prefix: "",

  // Use requestAnimationFrame to queue up view rendering and cancel
  // repeat requests. Leave on for better performance.
  useRAF: true,

  // Can be used to supply a different deferred implementation.
  deferred: function() {
    return $.Deferred();
  },

  // Fetch is passed a path and is expected to return template contents as a
  // function or string.
  fetchTemplate: function(path) {
    return _.template($(path).html());
  },

  // By default, render using underscore's templating and trim output.
  renderTemplate: function(template, context) {
    return trim(template.call(this, context));
  },

  // By default, pass model attributes to the templates
  serialize: function() {
    return this.model ? _.clone(this.model.attributes) : {};
  },

  // This is the most common way you will want to partially apply a view into
  // a layout.
  partial: function($root, $el, rentManager, manager) {
    var $filtered;

    // If selector is specified, attempt to find it.
    if (manager.selector) {
      if (rentManager.noel) {
        $filtered = $root.filter(manager.selector);
        $root = $filtered.length ? $filtered : $root.find(manager.selector);
      } else {
        $root = $root.find(manager.selector);
      }
    }

    // Use the insert method if the parent's `insert` argument is true.
    if (rentManager.insert) {
      this.insert($root, $el);
    } else {
      this.html($root, $el);
    }
  },

  // Override this with a custom HTML method, passed a root element and content
  // (a jQuery collection or a string) to replace the innerHTML with.
  html: function($root, content) {
    $root.html(content);
  },

  // Used for inserting subViews in a single batch.  This gives a small
  // performance boost as we write to a disconnected fragment instead of to the
  // DOM directly. Smarter browsers like Chrome will batch writes internally
  // and layout as seldom as possible, but even in that case this provides a
  // decent boost.  jQuery will use a DocumentFragment for the batch update,
  // but Cheerio in Node will not.
  htmlBatch: function(rootView, subViews, selector) {
    // Shorthand the parent manager object.
    var rentManager = rootView.__manager__;
    // Create a simplified manager object that tells partial() where
    // place the elements.
    var manager = { selector: selector };

    // Get the elements to be inserted into the root view.
    var els = _.reduce(subViews, function(memo, sub) {
      // Check if keep is present - do boolean check in case the user
      // has created a `keep` function.
      var keep = typeof sub.keep === "boolean" ? sub.keep : sub.options.keep;
      // If a subView is present, don't push it.  This can only happen if
      // `keep: true`.  We do the keep check for speed as $.contains is not
      // cheap.
      var exists = keep && $.contains(rootView.el, sub.el);

      // If there is an element and it doesn't already exist in our structure
      // attach it.
      if (sub.el && !exists) {
        memo.push(sub.el);
      }

      return memo;
    }, []);

    // Use partial to apply the elements. Wrap els in jQ obj for cheerio.
    return this.partial(rootView.$el, $(els), rentManager, manager);
  },

  // Very similar to HTML except this one will appendChild by default.
  insert: function($root, $el) {
    $root.append($el);
  },

  // Return a deferred for when all promises resolve/reject.
  when: function(promises) {
    return $.when.apply(null, promises);
  },

  // A method to determine if a View contains another.
  contains: function(parent, child) {
    return $.contains(parent, child);
  },

  // Based on:
  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
  // requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and
  // Tino Zijdel.
  requestAnimationFrame: (function() {
    var lastTime = 0;
    var vendors = ["ms", "moz", "webkit", "o"];
    var requestAnimationFrame = window.requestAnimationFrame;

    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
      requestAnimationFrame = window[vendors[i] + "RequestAnimationFrame"];
    }

    if (!requestAnimationFrame){
      requestAnimationFrame = function(callback) {
        var currTime = new Date().getTime();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = window.setTimeout(function() {
          callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }

    return _.bind(requestAnimationFrame, window);
  })(),

  cancelAnimationFrame: (function() {
    var vendors = ["ms", "moz", "webkit", "o"];
    var cancelAnimationFrame = window.cancelAnimationFrame;

    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
      cancelAnimationFrame =
        window[vendors[i] + "CancelAnimationFrame"] ||
        window[vendors[i] + "CancelRequestAnimationFrame"];
    }

    if (!cancelAnimationFrame) {
      cancelAnimationFrame = function(id) {
        clearTimeout(id);
      };
    }

    return _.bind(cancelAnimationFrame, window);
  })()
};

// Extend LayoutManager with default options.
_.extend(LayoutManager.prototype, defaultOptions);

// Assign `LayoutManager` object for AMD loaders.
return LayoutManager;

}));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"backbone":19,"jquery":25,"underscore":30}],17:[function(require,module,exports){
/*
  backbone.paginator 2.0.0
  http://github.com/backbone-paginator/backbone.paginator

  Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
  Licensed under the MIT @license.
*/

(function (factory) {

  // CommonJS
  if (typeof exports == "object") {
    module.exports = factory(require("underscore"), require("backbone"));
  }
  // AMD
  else if (typeof define == "function" && define.amd) {
    define(["underscore", "backbone"], factory);
  }
  // Browser
  else if (typeof _ !== "undefined" && typeof Backbone !== "undefined") {
    var oldPageableCollection = Backbone.PageableCollection;
    var PageableCollection = factory(_, Backbone);

    /**
       __BROWSER ONLY__

       If you already have an object named `PageableCollection` attached to the
       `Backbone` module, you can use this to return a local reference to this
       Backbone.PageableCollection class and reset the name
       Backbone.PageableCollection to its previous definition.

           // The left hand side gives you a reference to this
           // Backbone.PageableCollection implementation, the right hand side
           // resets Backbone.PageableCollection to your other
           // Backbone.PageableCollection.
           var PageableCollection = Backbone.PageableCollection.noConflict();

       @static
       @member Backbone.PageableCollection
       @return {Backbone.PageableCollection}
    */
    Backbone.PageableCollection.noConflict = function () {
      Backbone.PageableCollection = oldPageableCollection;
      return PageableCollection;
    };
  }

}(function (_, Backbone) {

  "use strict";

  var _extend = _.extend;
  var _omit = _.omit;
  var _clone = _.clone;
  var _each = _.each;
  var _pick = _.pick;
  var _contains = _.contains;
  var _isEmpty = _.isEmpty;
  var _pairs = _.pairs;
  var _invert = _.invert;
  var _isArray = _.isArray;
  var _isFunction = _.isFunction;
  var _isObject = _.isObject;
  var _keys = _.keys;
  var _isUndefined = _.isUndefined;
  var ceil = Math.ceil;
  var floor = Math.floor;
  var max = Math.max;

  var BBColProto = Backbone.Collection.prototype;

  function finiteInt (val, name) {
    if (!_.isNumber(val) || _.isNaN(val) || !_.isFinite(val) || ~~val !== val) {
      throw new TypeError("`" + name + "` must be a finite integer");
    }
    return val;
  }

  function queryStringToParams (qs) {
    var kvp, k, v, ls, params = {}, decode = decodeURIComponent;
    var kvps = qs.split('&');
    for (var i = 0, l = kvps.length; i < l; i++) {
      var param = kvps[i];
      kvp = param.split('='), k = kvp[0], v = kvp[1] || true;
      k = decode(k), v = decode(v), ls = params[k];
      if (_isArray(ls)) ls.push(v);
      else if (ls) params[k] = [ls, v];
      else params[k] = v;
    }
    return params;
  }

  // hack to make sure the whatever event handlers for this event is run
  // before func is, and the event handlers that func will trigger.
  function runOnceAtLastHandler (col, event, func) {
    var eventHandlers = col._events[event];
    if (eventHandlers && eventHandlers.length) {
      var lastHandler = eventHandlers[eventHandlers.length - 1];
      var oldCallback = lastHandler.callback;
      lastHandler.callback = function () {
        try {
          oldCallback.apply(this, arguments);
          func();
        }
        catch (e) {
          throw e;
        }
        finally {
          lastHandler.callback = oldCallback;
        }
      };
    }
    else func();
  }

  var PARAM_TRIM_RE = /[\s'"]/g;
  var URL_TRIM_RE = /[<>\s'"]/g;

  /**
     Drop-in replacement for Backbone.Collection. Supports server-side and
     client-side pagination and sorting. Client-side mode also support fully
     multi-directional synchronization of changes between pages.

     @class Backbone.PageableCollection
     @extends Backbone.Collection
  */
  var PageableCollection = Backbone.PageableCollection = Backbone.Collection.extend({

    /**
       The container object to store all pagination states.

       You can override the default state by extending this class or specifying
       them in an `options` hash to the constructor.

       @property {Object} state

       @property {0|1} [state.firstPage=1] The first page index. Set to 0 if
       your server API uses 0-based indices. You should only override this value
       during extension, initialization or reset by the server after
       fetching. This value should be read only at other times.

       @property {number} [state.lastPage=null] The last page index. This value
       is __read only__ and it's calculated based on whether `firstPage` is 0 or
       1, during bootstrapping, fetching and resetting. Please don't change this
       value under any circumstances.

       @property {number} [state.currentPage=null] The current page index. You
       should only override this value during extension, initialization or reset
       by the server after fetching. This value should be read only at other
       times. Can be a 0-based or 1-based index, depending on whether
       `firstPage` is 0 or 1. If left as default, it will be set to `firstPage`
       on initialization.

       @property {number} [state.pageSize=25] How many records to show per
       page. This value is __read only__ after initialization, if you want to
       change the page size after initialization, you must call #setPageSize.

       @property {number} [state.totalPages=null] How many pages there are. This
       value is __read only__ and it is calculated from `totalRecords`.

       @property {number} [state.totalRecords=null] How many records there
       are. This value is __required__ under server mode. This value is optional
       for client mode as the number will be the same as the number of models
       during bootstrapping and during fetching, either supplied by the server
       in the metadata, or calculated from the size of the response.

       @property {string} [state.sortKey=null] The model attribute to use for
       sorting.

       @property {-1|0|1} [state.order=-1] The order to use for sorting. Specify
       -1 for ascending order or 1 for descending order. If 0, no client side
       sorting will be done and the order query parameter will not be sent to
       the server during a fetch.
    */
    state: {
      firstPage: 1,
      lastPage: null,
      currentPage: null,
      pageSize: 25,
      totalPages: null,
      totalRecords: null,
      sortKey: null,
      order: -1
    },

    /**
       @property {"server"|"client"|"infinite"} [mode="server"] The mode of
       operations for this collection. `"server"` paginates on the server-side,
       `"client"` paginates on the client-side and `"infinite"` paginates on the
       server-side for APIs that do not support `totalRecords`.
    */
    mode: "server",

    /**
       A translation map to convert Backbone.PageableCollection state attributes
       to the query parameters accepted by your server API.

       You can override the default state by extending this class or specifying
       them in `options.queryParams` object hash to the constructor.

       @property {Object} queryParams
       @property {string} [queryParams.currentPage="page"]
       @property {string} [queryParams.pageSize="per_page"]
       @property {string} [queryParams.totalPages="total_pages"]
       @property {string} [queryParams.totalRecords="total_entries"]
       @property {string} [queryParams.sortKey="sort_by"]
       @property {string} [queryParams.order="order"]
       @property {string} [queryParams.directions={"-1": "asc", "1": "desc"}] A
       map for translating a Backbone.PageableCollection#state.order constant to
       the ones your server API accepts.
    */
    queryParams: {
      currentPage: "page",
      pageSize: "per_page",
      totalPages: "total_pages",
      totalRecords: "total_entries",
      sortKey: "sort_by",
      order: "order",
      directions: {
        "-1": "asc",
        "1": "desc"
      }
    },

    /**
       __CLIENT MODE ONLY__

       This collection is the internal storage for the bootstrapped or fetched
       models. You can use this if you want to operate on all the pages.

       @property {Backbone.Collection} fullCollection
    */

    /**
       Given a list of models or model attributues, bootstraps the full
       collection in client mode or infinite mode, or just the page you want in
       server mode.

       If you want to initialize a collection to a different state than the
       default, you can specify them in `options.state`. Any state parameters
       supplied will be merged with the default. If you want to change the
       default mapping from #state keys to your server API's query parameter
       names, you can specifiy an object hash in `option.queryParams`. Likewise,
       any mapping provided will be merged with the default. Lastly, all
       Backbone.Collection constructor options are also accepted.

       See:

       - Backbone.PageableCollection#state
       - Backbone.PageableCollection#queryParams
       - [Backbone.Collection#initialize](http://backbonejs.org/#Collection-constructor)

       @param {Array.<Object>} [models]

       @param {Object} [options]

       @param {function(*, *): number} [options.comparator] If specified, this
       comparator is set to the current page under server mode, or the #fullCollection
       otherwise.

       @param {boolean} [options.full] If `false` and either a
       `options.comparator` or `sortKey` is defined, the comparator is attached
       to the current page. Default is `true` under client or infinite mode and
       the comparator will be attached to the #fullCollection.

       @param {Object} [options.state] The state attributes overriding the defaults.

       @param {string} [options.state.sortKey] The model attribute to use for
       sorting. If specified instead of `options.comparator`, a comparator will
       be automatically created using this value, and optionally a sorting order
       specified in `options.state.order`. The comparator is then attached to
       the new collection instance.

       @param {-1|1} [options.state.order] The order to use for sorting. Specify
       -1 for ascending order and 1 for descending order.

       @param {Object} [options.queryParam]
    */
    constructor: function (models, options) {

      BBColProto.constructor.apply(this, arguments);

      options = options || {};

      var mode = this.mode = options.mode || this.mode || PageableProto.mode;

      var queryParams = _extend({}, PageableProto.queryParams, this.queryParams,
                                options.queryParams || {});

      queryParams.directions = _extend({},
                                       PageableProto.queryParams.directions,
                                       this.queryParams.directions,
                                       queryParams.directions || {});

      this.queryParams = queryParams;

      var state = this.state = _extend({}, PageableProto.state, this.state,
                                       options.state || {});

      state.currentPage = state.currentPage == null ?
        state.firstPage :
        state.currentPage;

      if (!_isArray(models)) models = models ? [models] : [];
      models = models.slice();

      if (mode != "server" && state.totalRecords == null && !_isEmpty(models)) {
        state.totalRecords = models.length;
      }

      this.switchMode(mode, _extend({fetch: false,
                                     resetState: false,
                                     models: models}, options));

      var comparator = options.comparator;

      if (state.sortKey && !comparator) {
        this.setSorting(state.sortKey, state.order, options);
      }

      if (mode != "server") {
        var fullCollection = this.fullCollection;

        if (comparator && options.full) {
          this.comparator = null;
          fullCollection.comparator = comparator;
        }

        if (options.full) fullCollection.sort();

        // make sure the models in the current page and full collection have the
        // same references
        if (models && !_isEmpty(models)) {
          this.reset(models, _extend({silent: true}, options));
          this.getPage(state.currentPage);
          models.splice.apply(models, [0, models.length].concat(this.models));
        }
      }

      this._initState = _clone(this.state);
    },

    /**
       Makes a Backbone.Collection that contains all the pages.

       @private
       @param {Array.<Object|Backbone.Model>} models
       @param {Object} options Options for Backbone.Collection constructor.
       @return {Backbone.Collection}
    */
    _makeFullCollection: function (models, options) {

      var properties = ["url", "model", "sync", "comparator"];
      var thisProto = this.constructor.prototype;
      var i, length, prop;

      var proto = {};
      for (i = 0, length = properties.length; i < length; i++) {
        prop = properties[i];
        if (!_isUndefined(thisProto[prop])) {
          proto[prop] = thisProto[prop];
        }
      }

      var fullCollection = new (Backbone.Collection.extend(proto))(models, options);

      for (i = 0, length = properties.length; i < length; i++) {
        prop = properties[i];
        if (this[prop] !== thisProto[prop]) {
          fullCollection[prop] = this[prop];
        }
      }

      return fullCollection;
    },

    /**
       Factory method that returns a Backbone event handler that responses to
       the `add`, `remove`, `reset`, and the `sort` events. The returned event
       handler will synchronize the current page collection and the full
       collection's models.

       @private

       @param {Backbone.PageableCollection} pageCol
       @param {Backbone.Collection} fullCol

       @return {function(string, Backbone.Model, Backbone.Collection, Object)}
       Collection event handler
    */
    _makeCollectionEventHandler: function (pageCol, fullCol) {

      return function collectionEventHandler (event, model, collection, options) {

        var handlers = pageCol._handlers;
        _each(_keys(handlers), function (event) {
          var handler = handlers[event];
          pageCol.off(event, handler);
          fullCol.off(event, handler);
        });

        var state = _clone(pageCol.state);
        var firstPage = state.firstPage;
        var currentPage = firstPage === 0 ?
          state.currentPage :
          state.currentPage - 1;
        var pageSize = state.pageSize;
        var pageStart = currentPage * pageSize, pageEnd = pageStart + pageSize;

        if (event == "add") {
          var pageIndex, fullIndex, addAt, colToAdd, options = options || {};
          if (collection == fullCol) {
            fullIndex = fullCol.indexOf(model);
            if (fullIndex >= pageStart && fullIndex < pageEnd) {
              colToAdd = pageCol;
              pageIndex = addAt = fullIndex - pageStart;
            }
          }
          else {
            pageIndex = pageCol.indexOf(model);
            fullIndex = pageStart + pageIndex;
            colToAdd = fullCol;
            var addAt = !_isUndefined(options.at) ?
              options.at + pageStart :
              fullIndex;
          }

          if (!options.onRemove) {
            ++state.totalRecords;
            delete options.onRemove;
          }

          pageCol.state = pageCol._checkState(state);

          if (colToAdd) {
            colToAdd.add(model, _extend({}, options || {}, {at: addAt}));
            var modelToRemove = pageIndex >= pageSize ?
              model :
              !_isUndefined(options.at) && addAt < pageEnd && pageCol.length > pageSize ?
              pageCol.at(pageSize) :
              null;
            if (modelToRemove) {
              runOnceAtLastHandler(collection, event, function () {
                pageCol.remove(modelToRemove, {onAdd: true});
              });
            }
          }
        }

        // remove the model from the other collection as well
        if (event == "remove") {
          if (!options.onAdd) {
            // decrement totalRecords and update totalPages and lastPage
            if (!--state.totalRecords) {
              state.totalRecords = null;
              state.totalPages = null;
            }
            else {
              var totalPages = state.totalPages = ceil(state.totalRecords / pageSize);
              state.lastPage = firstPage === 0 ? totalPages - 1 : totalPages || firstPage;
              if (state.currentPage > totalPages) state.currentPage = state.lastPage;
            }
            pageCol.state = pageCol._checkState(state);

            var nextModel, removedIndex = options.index;
            if (collection == pageCol) {
              if (nextModel = fullCol.at(pageEnd)) {
                runOnceAtLastHandler(pageCol, event, function () {
                  pageCol.push(nextModel, {onRemove: true});
                });
              }
              else if (!pageCol.length && state.totalRecords) {
                pageCol.reset(fullCol.models.slice(pageStart - pageSize, pageEnd - pageSize),
                              _extend({}, options, {parse: false}));
              }
              fullCol.remove(model);
            }
            else if (removedIndex >= pageStart && removedIndex < pageEnd) {
              if (nextModel = fullCol.at(pageEnd - 1)) {
                runOnceAtLastHandler(pageCol, event, function() {
                  pageCol.push(nextModel, {onRemove: true});
                });
              }
              pageCol.remove(model);
              if (!pageCol.length && state.totalRecords) {
                pageCol.reset(fullCol.models.slice(pageStart - pageSize, pageEnd - pageSize),
                              _extend({}, options, {parse: false}));
              }
            }
          }
          else delete options.onAdd;
        }

        if (event == "reset") {
          options = collection;
          collection = model;

          // Reset that's not a result of getPage
          if (collection == pageCol && options.from == null &&
              options.to == null) {
            var head = fullCol.models.slice(0, pageStart);
            var tail = fullCol.models.slice(pageStart + pageCol.models.length);
            fullCol.reset(head.concat(pageCol.models).concat(tail), options);
          }
          else if (collection == fullCol) {
            if (!(state.totalRecords = fullCol.models.length)) {
              state.totalRecords = null;
              state.totalPages = null;
            }
            if (pageCol.mode == "client") {
              state.lastPage = state.currentPage = state.firstPage;
            }
            pageCol.state = pageCol._checkState(state);
            pageCol.reset(fullCol.models.slice(pageStart, pageEnd),
                          _extend({}, options, {parse: false}));
          }
        }

        if (event == "sort") {
          options = collection;
          collection = model;
          if (collection === fullCol) {
            pageCol.reset(fullCol.models.slice(pageStart, pageEnd),
                          _extend({}, options, {parse: false}));
          }
        }

        _each(_keys(handlers), function (event) {
          var handler = handlers[event];
          _each([pageCol, fullCol], function (col) {
            col.on(event, handler);
            var callbacks = col._events[event] || [];
            callbacks.unshift(callbacks.pop());
          });
        });
      };
    },

    /**
       Sanity check this collection's pagination states. Only perform checks
       when all the required pagination state values are defined and not null.
       If `totalPages` is undefined or null, it is set to `totalRecords` /
       `pageSize`. `lastPage` is set according to whether `firstPage` is 0 or 1
       when no error occurs.

       @private

       @throws {TypeError} If `totalRecords`, `pageSize`, `currentPage` or
       `firstPage` is not a finite integer.

       @throws {RangeError} If `pageSize`, `currentPage` or `firstPage` is out
       of bounds.

       @return {Object} Returns the `state` object if no error was found.
    */
    _checkState: function (state) {

      var mode = this.mode;
      var links = this.links;
      var totalRecords = state.totalRecords;
      var pageSize = state.pageSize;
      var currentPage = state.currentPage;
      var firstPage = state.firstPage;
      var totalPages = state.totalPages;

      if (totalRecords != null && pageSize != null && currentPage != null &&
          firstPage != null && (mode == "infinite" ? links : true)) {

        totalRecords = finiteInt(totalRecords, "totalRecords");
        pageSize = finiteInt(pageSize, "pageSize");
        currentPage = finiteInt(currentPage, "currentPage");
        firstPage = finiteInt(firstPage, "firstPage");

        if (pageSize < 1) {
          throw new RangeError("`pageSize` must be >= 1");
        }

        totalPages = state.totalPages = ceil(totalRecords / pageSize);

        if (firstPage < 0 || firstPage > 1) {
          throw new RangeError("`firstPage must be 0 or 1`");
        }

        state.lastPage = firstPage === 0 ? max(0, totalPages - 1) : totalPages || firstPage;

        if (mode == "infinite") {
          if (!links[currentPage + '']) {
            throw new RangeError("No link found for page " + currentPage);
          }
        }
        else if (currentPage < firstPage ||
                 (totalPages > 0 &&
                  (firstPage ? currentPage > totalPages : currentPage >= totalPages))) {
          throw new RangeError("`currentPage` must be firstPage <= currentPage " +
                               (firstPage ? ">" : ">=") +
                               " totalPages if " + firstPage + "-based. Got " +
                               currentPage + '.');
        }
      }

      return state;
    },

    /**
       Change the page size of this collection.

       Under most if not all circumstances, you should call this method to
       change the page size of a pageable collection because it will keep the
       pagination state sane. By default, the method will recalculate the
       current page number to one that will retain the current page's models
       when increasing the page size. When decreasing the page size, this method
       will retain the last models to the current page that will fit into the
       smaller page size.

       If `options.first` is true, changing the page size will also reset the
       current page back to the first page instead of trying to be smart.

       For server mode operations, changing the page size will trigger a #fetch
       and subsequently a `reset` event.

       For client mode operations, changing the page size will `reset` the
       current page by recalculating the current page boundary on the client
       side.

       If `options.fetch` is true, a fetch can be forced if the collection is in
       client mode.

       @param {number} pageSize The new page size to set to #state.
       @param {Object} [options] {@link #fetch} options.
       @param {boolean} [options.first=false] Reset the current page number to
       the first page if `true`.
       @param {boolean} [options.fetch] If `true`, force a fetch in client mode.

       @throws {TypeError} If `pageSize` is not a finite integer.
       @throws {RangeError} If `pageSize` is less than 1.

       @chainable
       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
       from fetch or this.
    */
    setPageSize: function (pageSize, options) {
      pageSize = finiteInt(pageSize, "pageSize");

      options = options || {first: false};

      var state = this.state;
      var totalPages = ceil(state.totalRecords / pageSize);
      var currentPage = totalPages ?
          max(state.firstPage, floor(totalPages * state.currentPage / state.totalPages)) :
        state.firstPage;

      state = this.state = this._checkState(_extend({}, state, {
        pageSize: pageSize,
        currentPage: options.first ? state.firstPage : currentPage,
        totalPages: totalPages
      }));

      return this.getPage(state.currentPage, _omit(options, ["first"]));
    },

    /**
       Switching between client, server and infinite mode.

       If switching from client to server mode, the #fullCollection is emptied
       first and then deleted and a fetch is immediately issued for the current
       page from the server. Pass `false` to `options.fetch` to skip fetching.

       If switching to infinite mode, and if `options.models` is given for an
       array of models, #links will be populated with a URL per page, using the
       default URL for this collection.

       If switching from server to client mode, all of the pages are immediately
       refetched. If you have too many pages, you can pass `false` to
       `options.fetch` to skip fetching.

       If switching to any mode from infinite mode, the #links will be deleted.

       @param {"server"|"client"|"infinite"} [mode] The mode to switch to.

       @param {Object} [options]

       @param {boolean} [options.fetch=true] If `false`, no fetching is done.

       @param {boolean} [options.resetState=true] If 'false', the state is not
       reset, but checked for sanity instead.

       @chainable
       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
       from fetch or this if `options.fetch` is `false`.
    */
    switchMode: function (mode, options) {

      if (!_contains(["server", "client", "infinite"], mode)) {
        throw new TypeError('`mode` must be one of "server", "client" or "infinite"');
      }

      options = options || {fetch: true, resetState: true};

      var state = this.state = options.resetState ?
        _clone(this._initState) :
        this._checkState(_extend({}, this.state));

      this.mode = mode;

      var self = this;
      var fullCollection = this.fullCollection;
      var handlers = this._handlers = this._handlers || {}, handler;
      if (mode != "server" && !fullCollection) {
        fullCollection = this._makeFullCollection(options.models || [], options);
        fullCollection.pageableCollection = this;
        this.fullCollection = fullCollection;
        var allHandler = this._makeCollectionEventHandler(this, fullCollection);
        _each(["add", "remove", "reset", "sort"], function (event) {
          handlers[event] = handler = _.bind(allHandler, {}, event);
          self.on(event, handler);
          fullCollection.on(event, handler);
        });
        fullCollection.comparator = this._fullComparator;
      }
      else if (mode == "server" && fullCollection) {
        _each(_keys(handlers), function (event) {
          handler = handlers[event];
          self.off(event, handler);
          fullCollection.off(event, handler);
        });
        delete this._handlers;
        this._fullComparator = fullCollection.comparator;
        delete this.fullCollection;
      }

      if (mode == "infinite") {
        var links = this.links = {};
        var firstPage = state.firstPage;
        var totalPages = ceil(state.totalRecords / state.pageSize);
        var lastPage = firstPage === 0 ? max(0, totalPages - 1) : totalPages || firstPage;
        for (var i = state.firstPage; i <= lastPage; i++) {
          links[i] = this.url;
        }
      }
      else if (this.links) delete this.links;

      return options.fetch ?
        this.fetch(_omit(options, "fetch", "resetState")) :
        this;
    },

    /**
       @return {boolean} `true` if this collection can page backward, `false`
       otherwise.
    */
    hasPreviousPage: function () {
      var state = this.state;
      var currentPage = state.currentPage;
      if (this.mode != "infinite") return currentPage > state.firstPage;
      return !!this.links[currentPage - 1];
    },

    /**
       @return {boolean} `true` if this collection can page forward, `false`
       otherwise.
    */
    hasNextPage: function () {
      var state = this.state;
      var currentPage = this.state.currentPage;
      if (this.mode != "infinite") return currentPage < state.lastPage;
      return !!this.links[currentPage + 1];
    },

    /**
       Fetch the first page in server mode, or reset the current page of this
       collection to the first page in client or infinite mode.

       @param {Object} options {@link #getPage} options.

       @chainable
       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
       from fetch or this.
    */
    getFirstPage: function (options) {
      return this.getPage("first", options);
    },

    /**
       Fetch the previous page in server mode, or reset the current page of this
       collection to the previous page in client or infinite mode.

       @param {Object} options {@link #getPage} options.

       @chainable
       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
       from fetch or this.
    */
    getPreviousPage: function (options) {
      return this.getPage("prev", options);
    },

    /**
       Fetch the next page in server mode, or reset the current page of this
       collection to the next page in client mode.

       @param {Object} options {@link #getPage} options.

       @chainable
       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
       from fetch or this.
    */
    getNextPage: function (options) {
      return this.getPage("next", options);
    },

    /**
       Fetch the last page in server mode, or reset the current page of this
       collection to the last page in client mode.

       @param {Object} options {@link #getPage} options.

       @chainable
       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
       from fetch or this.
    */
    getLastPage: function (options) {
      return this.getPage("last", options);
    },

    /**
       Given a page index, set #state.currentPage to that index. If this
       collection is in server mode, fetch the page using the updated state,
       otherwise, reset the current page of this collection to the page
       specified by `index` in client mode. If `options.fetch` is true, a fetch
       can be forced in client mode before resetting the current page. Under
       infinite mode, if the index is less than the current page, a reset is
       done as in client mode. If the index is greater than the current page
       number, a fetch is made with the results **appended** to #fullCollection.
       The current page will then be reset after fetching.

       @param {number|string} index The page index to go to, or the page name to
       look up from #links in infinite mode.
       @param {Object} [options] {@link #fetch} options or
       [reset](http://backbonejs.org/#Collection-reset) options for client mode
       when `options.fetch` is `false`.
       @param {boolean} [options.fetch=false] If true, force a {@link #fetch} in
       client mode.

       @throws {TypeError} If `index` is not a finite integer under server or
       client mode, or does not yield a URL from #links under infinite mode.

       @throws {RangeError} If `index` is out of bounds.

       @chainable
       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
       from fetch or this.
    */
    getPage: function (index, options) {

      var mode = this.mode, fullCollection = this.fullCollection;

      options = options || {fetch: false};

      var state = this.state,
      firstPage = state.firstPage,
      currentPage = state.currentPage,
      lastPage = state.lastPage,
      pageSize = state.pageSize;

      var pageNum = index;
      switch (index) {
        case "first": pageNum = firstPage; break;
        case "prev": pageNum = currentPage - 1; break;
        case "next": pageNum = currentPage + 1; break;
        case "last": pageNum = lastPage; break;
        default: pageNum = finiteInt(index, "index");
      }

      this.state = this._checkState(_extend({}, state, {currentPage: pageNum}));

      options.from = currentPage, options.to = pageNum;

      var pageStart = (firstPage === 0 ? pageNum : pageNum - 1) * pageSize;
      var pageModels = fullCollection && fullCollection.length ?
        fullCollection.models.slice(pageStart, pageStart + pageSize) :
        [];
      if ((mode == "client" || (mode == "infinite" && !_isEmpty(pageModels))) &&
          !options.fetch) {
        this.reset(pageModels, _omit(options, "fetch"));
        return this;
      }

      if (mode == "infinite") options.url = this.links[pageNum];

      return this.fetch(_omit(options, "fetch"));
    },

    /**
       Fetch the page for the provided item offset in server mode, or reset the current page of this
       collection to the page for the provided item offset in client mode.

       @param {Object} options {@link #getPage} options.

       @chainable
       @return {XMLHttpRequest|Backbone.PageableCollection} The XMLHttpRequest
       from fetch or this.
    */
    getPageByOffset: function (offset, options) {
      if (offset < 0) {
        throw new RangeError("`offset must be > 0`");
      }
      offset = finiteInt(offset);

      var page = floor(offset / this.state.pageSize);
      if (this.state.firstPage !== 0) page++;
      if (page > this.state.lastPage) page = this.state.lastPage;
      return this.getPage(page, options);
    },

    /**
       Overidden to make `getPage` compatible with Zepto.

       @param {string} method
       @param {Backbone.Model|Backbone.Collection} model
       @param {Object} [options]

       @return {XMLHttpRequest}
    */
    sync: function (method, model, options) {
      var self = this;
      if (self.mode == "infinite") {
        var success = options.success;
        var currentPage = self.state.currentPage;
        options.success = function (resp, status, xhr) {
          var links = self.links;
          var newLinks = self.parseLinks(resp, _extend({xhr: xhr}, options));
          if (newLinks.first) links[self.state.firstPage] = newLinks.first;
          if (newLinks.prev) links[currentPage - 1] = newLinks.prev;
          if (newLinks.next) links[currentPage + 1] = newLinks.next;
          if (success) success(resp, status, xhr);
        };
      }

      return (BBColProto.sync || Backbone.sync).call(self, method, model, options);
    },

    /**
       Parse pagination links from the server response. Only valid under
       infinite mode.

       Given a response body and a XMLHttpRequest object, extract pagination
       links from them for infinite paging.

       This default implementation parses the RFC 5988 `Link` header and extract
       3 links from it - `first`, `prev`, `next`. Any subclasses overriding this
       method __must__ return an object hash having only the keys
       above. However, simply returning a `next` link or an empty hash if there
       are no more links should be enough for most implementations.

       @param {*} resp The deserialized response body.
       @param {Object} [options]
       @param {XMLHttpRequest} [options.xhr] The XMLHttpRequest object for this
       response.
       @return {Object}
    */
    parseLinks: function (resp, options) {
      var links = {};
      var linkHeader = options.xhr.getResponseHeader("Link");
      if (linkHeader) {
        var relations = ["first", "prev", "next"];
        _each(linkHeader.split(","), function (linkValue) {
          var linkParts = linkValue.split(";");
          var url = linkParts[0].replace(URL_TRIM_RE, '');
          var params = linkParts.slice(1);
          _each(params, function (param) {
            var paramParts = param.split("=");
            var key = paramParts[0].replace(PARAM_TRIM_RE, '');
            var value = paramParts[1].replace(PARAM_TRIM_RE, '');
            if (key == "rel" && _contains(relations, value)) links[value] = url;
          });
        });
      }

      return links;
    },

    /**
       Parse server response data.

       This default implementation assumes the response data is in one of two
       structures:

           [
             {}, // Your new pagination state
             [{}, ...] // An array of JSON objects
           ]

       Or,

           [{}] // An array of JSON objects

       The first structure is the preferred form because the pagination states
       may have been updated on the server side, sending them down again allows
       this collection to update its states. If the response has a pagination
       state object, it is checked for errors.

       The second structure is the
       [Backbone.Collection#parse](http://backbonejs.org/#Collection-parse)
       default.

       **Note:** this method has been further simplified since 1.1.7. While
       existing #parse implementations will continue to work, new code is
       encouraged to override #parseState and #parseRecords instead.

       @param {Object} resp The deserialized response data from the server.
       @param {Object} the options for the ajax request

       @return {Array.<Object>} An array of model objects
    */
    parse: function (resp, options) {
      var newState = this.parseState(resp, _clone(this.queryParams), _clone(this.state), options);
      if (newState) this.state = this._checkState(_extend({}, this.state, newState));
      return this.parseRecords(resp, options);
    },

    /**
       Parse server response for server pagination state updates. Not applicable
       under infinite mode.

       This default implementation first checks whether the response has any
       state object as documented in #parse. If it exists, a state object is
       returned by mapping the server state keys to this pageable collection
       instance's query parameter keys using `queryParams`.

       It is __NOT__ neccessary to return a full state object complete with all
       the mappings defined in #queryParams. Any state object resulted is merged
       with a copy of the current pageable collection state and checked for
       sanity before actually updating. Most of the time, simply providing a new
       `totalRecords` value is enough to trigger a full pagination state
       recalculation.

           parseState: function (resp, queryParams, state, options) {
             return {totalRecords: resp.total_entries};
           }

       If you want to use header fields use:

           parseState: function (resp, queryParams, state, options) {
               return {totalRecords: options.xhr.getResponseHeader("X-total")};
           }

       This method __MUST__ return a new state object instead of directly
       modifying the #state object. The behavior of directly modifying #state is
       undefined.

       @param {Object} resp The deserialized response data from the server.
       @param {Object} queryParams A copy of #queryParams.
       @param {Object} state A copy of #state.
       @param {Object} [options] The options passed through from
       `parse`. (backbone >= 0.9.10 only)

       @return {Object} A new (partial) state object.
     */
    parseState: function (resp, queryParams, state, options) {
      if (resp && resp.length === 2 && _isObject(resp[0]) && _isArray(resp[1])) {

        var newState = _clone(state);
        var serverState = resp[0];

        _each(_pairs(_omit(queryParams, "directions")), function (kvp) {
          var k = kvp[0], v = kvp[1];
          var serverVal = serverState[v];
          if (!_isUndefined(serverVal) && !_.isNull(serverVal)) newState[k] = serverState[v];
        });

        if (serverState.order) {
          newState.order = _invert(queryParams.directions)[serverState.order] * 1;
        }

        return newState;
      }
    },

    /**
       Parse server response for an array of model objects.

       This default implementation first checks whether the response has any
       state object as documented in #parse. If it exists, the array of model
       objects is assumed to be the second element, otherwise the entire
       response is returned directly.

       @param {Object} resp The deserialized response data from the server.
       @param {Object} [options] The options passed through from the
       `parse`. (backbone >= 0.9.10 only)

       @return {Array.<Object>} An array of model objects
     */
    parseRecords: function (resp, options) {
      if (resp && resp.length === 2 && _isObject(resp[0]) && _isArray(resp[1])) {
        return resp[1];
      }

      return resp;
    },

    /**
       Fetch a page from the server in server mode, or all the pages in client
       mode. Under infinite mode, the current page is refetched by default and
       then reset.

       The query string is constructed by translating the current pagination
       state to your server API query parameter using #queryParams. The current
       page will reset after fetch.

       @param {Object} [options] Accepts all
       [Backbone.Collection#fetch](http://backbonejs.org/#Collection-fetch)
       options.

       @return {XMLHttpRequest}
    */
    fetch: function (options) {

      options = options || {};

      var state = this._checkState(this.state);

      var mode = this.mode;

      if (mode == "infinite" && !options.url) {
        options.url = this.links[state.currentPage];
      }

      var data = options.data || {};

      // dedup query params
      var url = options.url || this.url || "";
      if (_isFunction(url)) url = url.call(this);
      var qsi = url.indexOf('?');
      if (qsi != -1) {
        _extend(data, queryStringToParams(url.slice(qsi + 1)));
        url = url.slice(0, qsi);
      }

      options.url = url;
      options.data = data;

      // map params except directions
      var queryParams = this.mode == "client" ?
        _pick(this.queryParams, "sortKey", "order") :
        _omit(_pick(this.queryParams, _keys(PageableProto.queryParams)),
              "directions");

      var i, kvp, k, v, kvps = _pairs(queryParams), thisCopy = _clone(this);
      for (i = 0; i < kvps.length; i++) {
        kvp = kvps[i], k = kvp[0], v = kvp[1];
        v = _isFunction(v) ? v.call(thisCopy) : v;
        if (state[k] != null && v != null) {
          data[v] = state[k];
        }
      }

      // fix up sorting parameters
      if (state.sortKey && state.order) {
        var o = _isFunction(queryParams.order) ?
          queryParams.order.call(thisCopy) :
          queryParams.order;
        data[o] = this.queryParams.directions[state.order + ""];
      }
      else if (!state.sortKey) delete data[queryParams.order];

      // map extra query parameters
      var extraKvps = _pairs(_omit(this.queryParams,
                                   _keys(PageableProto.queryParams)));
      for (i = 0; i < extraKvps.length; i++) {
        kvp = extraKvps[i];
        v = kvp[1];
        v = _isFunction(v) ? v.call(thisCopy) : v;
        if (v != null) data[kvp[0]] = v;
      }

      if (mode != "server") {
        var self = this, fullCol = this.fullCollection;
        var success = options.success;
        options.success = function (col, resp, opts) {

          // make sure the caller's intent is obeyed
          opts = opts || {};
          if (_isUndefined(options.silent)) delete opts.silent;
          else opts.silent = options.silent;

          var models = col.models;
          if (mode == "client") fullCol.reset(models, opts);
          else {
            fullCol.add(models, _extend({at: fullCol.length},
                                        _extend(opts, {parse: false})));
            self.trigger("reset", self, opts);
          }

          if (success) success(col, resp, opts);
        };

        // silent the first reset from backbone
        return BBColProto.fetch.call(this, _extend({}, options, {silent: true}));
      }

      return BBColProto.fetch.call(this, options);
    },

    /**
       Convenient method for making a `comparator` sorted by a model attribute
       identified by `sortKey` and ordered by `order`.

       Like a Backbone.Collection, a Backbone.PageableCollection will maintain
       the __current page__ in sorted order on the client side if a `comparator`
       is attached to it. If the collection is in client mode, you can attach a
       comparator to #fullCollection to have all the pages reflect the global
       sorting order by specifying an option `full` to `true`. You __must__ call
       `sort` manually or #fullCollection.sort after calling this method to
       force a resort.

       While you can use this method to sort the current page in server mode,
       the sorting order may not reflect the global sorting order due to the
       additions or removals of the records on the server since the last
       fetch. If you want the most updated page in a global sorting order, it is
       recommended that you set #state.sortKey and optionally #state.order, and
       then call #fetch.

       @protected

       @param {string} [sortKey=this.state.sortKey] See `state.sortKey`.
       @param {number} [order=this.state.order] See `state.order`.
       @param {(function(Backbone.Model, string): Object) | string} [sortValue] See #setSorting.

       See [Backbone.Collection.comparator](http://backbonejs.org/#Collection-comparator).
    */
    _makeComparator: function (sortKey, order, sortValue) {
      var state = this.state;

      sortKey = sortKey || state.sortKey;
      order = order || state.order;

      if (!sortKey || !order) return;

      if (!sortValue) sortValue = function (model, attr) {
        return model.get(attr);
      };

      return function (left, right) {
        var l = sortValue(left, sortKey), r = sortValue(right, sortKey), t;
        if (order === 1) t = l, l = r, r = t;
        if (l === r) return 0;
        else if (l < r) return -1;
        return 1;
      };
    },

    /**
       Adjusts the sorting for this pageable collection.

       Given a `sortKey` and an `order`, sets `state.sortKey` and
       `state.order`. A comparator can be applied on the client side to sort in
       the order defined if `options.side` is `"client"`. By default the
       comparator is applied to the #fullCollection. Set `options.full` to
       `false` to apply a comparator to the current page under any mode. Setting
       `sortKey` to `null` removes the comparator from both the current page and
       the full collection.

       If a `sortValue` function is given, it will be passed the `(model,
       sortKey)` arguments and is used to extract a value from the model during
       comparison sorts. If `sortValue` is not given, `model.get(sortKey)` is
       used for sorting.

       @chainable

       @param {string} sortKey See `state.sortKey`.
       @param {number} [order=this.state.order] See `state.order`.
       @param {Object} [options]
       @param {"server"|"client"} [options.side] By default, `"client"` if
       `mode` is `"client"`, `"server"` otherwise.
       @param {boolean} [options.full=true]
       @param {(function(Backbone.Model, string): Object) | string} [options.sortValue]
    */
    setSorting: function (sortKey, order, options) {

      var state = this.state;

      state.sortKey = sortKey;
      state.order = order = order || state.order;

      var fullCollection = this.fullCollection;

      var delComp = false, delFullComp = false;

      if (!sortKey) delComp = delFullComp = true;

      var mode = this.mode;
      options = _extend({side: mode == "client" ? mode : "server", full: true},
                        options);

      var comparator = this._makeComparator(sortKey, order, options.sortValue);

      var full = options.full, side = options.side;

      if (side == "client") {
        if (full) {
          if (fullCollection) fullCollection.comparator = comparator;
          delComp = true;
        }
        else {
          this.comparator = comparator;
          delFullComp = true;
        }
      }
      else if (side == "server" && !full) {
        this.comparator = comparator;
      }

      if (delComp) this.comparator = null;
      if (delFullComp && fullCollection) fullCollection.comparator = null;

      return this;
    }

  });

  var PageableProto = PageableCollection.prototype;

  return PageableCollection;

}));

},{"backbone":19,"underscore":18}],18:[function(require,module,exports){
//     Underscore.js 1.7.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.7.0';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var createCallback = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  _.iteratee = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return createCallback(value, context, argCount);
    if (_.isObject(value)) return _.matches(value);
    return _.property(value);
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    if (obj == null) return obj;
    iteratee = createCallback(iteratee, context);
    var i, length = obj.length;
    if (length === +length) {
      for (i = 0; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    if (obj == null) return [];
    iteratee = _.iteratee(iteratee, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length),
        currentKey;
    for (var index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {
    if (obj == null) obj = [];
    iteratee = createCallback(iteratee, context, 4);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index = 0, currentKey;
    if (arguments.length < 3) {
      if (!length) throw new TypeError(reduceError);
      memo = obj[keys ? keys[index++] : index++];
    }
    for (; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {
    if (obj == null) obj = [];
    iteratee = createCallback(iteratee, context, 4);
    var keys = obj.length !== + obj.length && _.keys(obj),
        index = (keys || obj).length,
        currentKey;
    if (arguments.length < 3) {
      if (!index) throw new TypeError(reduceError);
      memo = obj[keys ? keys[--index] : --index];
    }
    while (index--) {
      currentKey = keys ? keys[index] : index;
      memo = iteratee(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    predicate = _.iteratee(predicate, context);
    _.some(obj, function(value, index, list) {
      if (predicate(value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    predicate = _.iteratee(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(_.iteratee(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    if (obj == null) return true;
    predicate = _.iteratee(predicate, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index, currentKey;
    for (index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    if (obj == null) return false;
    predicate = _.iteratee(predicate, context);
    var keys = obj.length !== +obj.length && _.keys(obj),
        length = (keys || obj).length,
        index, currentKey;
    for (index = 0; index < length; index++) {
      currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (obj.length !== +obj.length) obj = _.values(obj);
    return _.indexOf(obj, target) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = obj.length === +obj.length ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = obj.length === +obj.length ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = obj && obj.length === +obj.length ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = _.iteratee(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = _.iteratee(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = _.iteratee(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = low + high >>> 1;
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return obj.length === +obj.length ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = _.iteratee(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    for (var i = 0, length = input.length; i < length; i++) {
      var value = input[i];
      if (!_.isArray(value) && !_.isArguments(value)) {
        if (!strict) output.push(value);
      } else if (shallow) {
        push.apply(output, value);
      } else {
        flatten(value, shallow, strict, output);
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (array == null) return [];
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = _.iteratee(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = array.length; i < length; i++) {
      var value = array[i];
      if (isSorted) {
        if (!i || seen !== value) result.push(value);
        seen = value;
      } else if (iteratee) {
        var computed = iteratee(value, i, array);
        if (_.indexOf(seen, computed) < 0) {
          seen.push(computed);
          result.push(value);
        }
      } else if (_.indexOf(result, value) < 0) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true, []));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    if (array == null) return [];
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = array.length; i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(slice.call(arguments, 1), true, true, []);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function(array) {
    if (array == null) return [];
    var length = _.max(arguments, 'length').length;
    var results = Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted;
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var idx = array.length;
    if (typeof from == 'number') {
      idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1);
    }
    while (--idx >= 0) if (array[idx] === item) return idx;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var Ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    args = slice.call(arguments, 2);
    bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      Ctor.prototype = func.prototype;
      var self = new Ctor;
      Ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (_.isObject(result)) return result;
      return self;
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = hasher ? hasher.apply(this, arguments) : key;
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last > 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed before being called N times.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      } else {
        func = null;
      }
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    if (!_.isObject(obj)) return obj;
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (hasOwnProperty.call(source, prop)) {
            obj[prop] = source[prop];
        }
      }
    }
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj, iteratee, context) {
    var result = {}, key;
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      iteratee = createCallback(iteratee, context);
      for (key in obj) {
        var value = obj[key];
        if (iteratee(value, key, obj)) result[key] = value;
      }
    } else {
      var keys = concat.apply([], slice.call(arguments, 1));
      obj = new Object(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        key = keys[i];
        if (key in obj) result[key] = obj[key];
      }
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    if (!_.isObject(obj)) return obj;
    for (var i = 1, length = arguments.length; i < length; i++) {
      var source = arguments[i];
      for (var prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (
      aCtor !== bCtor &&
      // Handle Object.create(x) cases
      'constructor' in a && 'constructor' in b &&
      !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
        _.isFunction(bCtor) && bCtor instanceof bCtor)
    ) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size, result;
    // Recursively compare objects and arrays.
    if (className === '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size === b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      size = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      result = _.keys(b).length === size;
      if (result) {
        while (size--) {
          // Deep compare each member
          key = keys[size];
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around an IE 11 bug.
  if (typeof /./ !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    var pairs = _.pairs(attrs), length = pairs.length;
    return function(obj) {
      if (obj == null) return !length;
      obj = new Object(obj);
      for (var i = 0; i < length; i++) {
        var pair = pairs[i], key = pair[0];
        if (pair[1] !== obj[key] || !(key in obj)) return false;
      }
      return true;
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = createCallback(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? object[property]() : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],19:[function(require,module,exports){
//     Backbone.js 1.1.2

//     (c) 2010-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(root, factory) {

  // Set up Backbone appropriately for the environment. Start with AMD.
  if (typeof define === 'function' && define.amd) {
    define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
      // Export global even in AMD case in case this script is loaded with
      // others that may still expect a global Backbone.
      root.Backbone = factory(root, exports, _, $);
    });

  // Next for Node.js or CommonJS. jQuery may not be needed as a module.
  } else if (typeof exports !== 'undefined') {
    var _ = require('underscore');
    factory(root, exports, _);

  // Finally, as a browser global.
  } else {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

}(this, function(root, Backbone, _, $) {

  // Initial Setup
  // -------------

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.1.2';

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = $;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PATCH"`, `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = void 0;
        return this;
      }
      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeningTo = this._listeningTo;
      if (!listeningTo) return this;
      var remove = !name && !callback;
      if (!callback && typeof name === 'object') callback = this;
      if (obj) (listeningTo = {})[obj._listenId] = obj;
      for (var id in listeningTo) {
        obj = listeningTo[id];
        obj.off(name, callback, this);
        if (remove || _.isEmpty(obj._events)) delete this._listeningTo[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args); return;
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeningTo = this._listeningTo || (this._listeningTo = {});
      var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
      listeningTo[id] = obj;
      if (!callback && typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    if (options.collection) this.collection = options.collection;
    if (options.parse) attrs = this.parse(attrs, options) || {};
    attrs = _.defaults({}, attrs, _.result(this, 'defaults'));
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = options;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          options = this._pending;
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options = _.extend({validate: true}, options);

      // If we're not waiting and attributes exist, save acts as
      // `set(attr).save(null, opts)` with validation. Otherwise, check if
      // the model will be valid when the attributes, if any, are set.
      if (attrs && !options.wait) {
        if (!this.set(attrs, options)) return false;
      } else {
        if (!this._validate(attrs, options)) return false;
      }

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base =
        _.result(this, 'urlRoot') ||
        _.result(this.collection, 'url') ||
        urlError();
      if (this.isNew()) return base;
      return base.replace(/([^\/])$/, '$1/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return !this.has(this.idAttribute);
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.extend({merge: false}, options, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      var singular = !_.isArray(models);
      models = singular ? [models] : _.clone(models);
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = models[i] = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model, options);
      }
      return singular ? models[0] : models;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults({}, options, setOptions);
      if (options.parse) models = this.parse(models, options);
      var singular = !_.isArray(models);
      models = singular ? (models ? [models] : []) : _.clone(models);
      var i, l, id, model, attrs, existing, sort;
      var at = options.at;
      var targetModel = this.model;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};
      var add = options.add, merge = options.merge, remove = options.remove;
      var order = !sortable && add && remove ? [] : false;

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        attrs = models[i] || {};
        if (attrs instanceof Model) {
          id = model = attrs;
        } else {
          id = attrs[targetModel.prototype.idAttribute || 'id'];
        }

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(id)) {
          if (remove) modelMap[existing.cid] = true;
          if (merge) {
            attrs = attrs === model ? model.attributes : attrs;
            if (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }
          models[i] = existing;

        // If this is a new, valid model, push it to the `toAdd` list.
        } else if (add) {
          model = models[i] = this._prepareModel(attrs, options);
          if (!model) continue;
          toAdd.push(model);
          this._addReference(model, options);
        }

        // Do not add multiple models with the same `id`.
        model = existing || model;
        if (order && (model.isNew() || !modelMap[model.id])) order.push(model);
        modelMap[model.id] = true;
      }

      // Remove nonexistent models if appropriate.
      if (remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length || (order && order.length)) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          for (i = 0, l = toAdd.length; i < l; i++) {
            this.models.splice(at + i, 0, toAdd[i]);
          }
        } else {
          if (order) this.models.length = 0;
          var orderedModels = order || toAdd;
          for (i = 0, l = orderedModels.length; i < l; i++) {
            this.models.push(orderedModels[i]);
          }
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      // Unless silenced, it's time to fire all appropriate add/sort events.
      if (!options.silent) {
        for (i = 0, l = toAdd.length; i < l; i++) {
          (model = toAdd[i]).trigger('add', model, this, options);
        }
        if (sort || (order && order.length)) this.trigger('sort', this, options);
      }

      // Return the added (or merged) model (or models).
      return singular ? models[0] : models;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i], options);
      }
      options.previousModels = this.models;
      this._reset();
      models = this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return models;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      return this.add(model, _.extend({at: this.length}, options));
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      return this.add(model, _.extend({at: 0}, options));
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function() {
      return slice.apply(this.models, arguments);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj] || this._byId[obj.id] || this._byId[obj.cid];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(model, resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) return attrs;
      options = options ? _.clone(options) : {};
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model.validationError) return model;
      this.trigger('invalid', this, model.validationError, options);
      return false;
    },

    // Internal method to create a model's ties to a collection.
    _addReference: function(model, options) {
      this._byId[model.cid] = model;
      if (model.id != null) this._byId[model.id] = model;
      if (!model.collection) model.collection = this;
      model.on('all', this._onModelEvent, this);
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model, options) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'difference', 'indexOf', 'shuffle',
    'lastIndexOf', 'isEmpty', 'chain', 'sample'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy', 'indexBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    options || (options = {});
    _.extend(this, _.pick(options, viewOptions));
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be preferred to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save',
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && noXhrPatch) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  var noXhrPatch =
    typeof window !== 'undefined' && !!window.ActiveXObject &&
      !(window.XMLHttpRequest && (new XMLHttpRequest).dispatchEvent);

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        router.execute(callback, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Execute a route handler with the provided parameters.  This is an
    // excellent place to do pre-route setup or post-route cleanup.
    execute: function(callback, args) {
      if (callback) callback.apply(this, args);
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional) {
                     return optional ? match : '([^/?]+)';
                   })
                   .replace(splatParam, '([^?]*?)');
      return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param, i) {
        // Don't decode the search params.
        if (i === params.length - 1) return param || null;
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Cached regex for stripping urls of hash.
  var pathStripper = /#.*$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Are we at the app root?
    atRoot: function() {
      return this.location.pathname.replace(/[^\/]$/, '$&/') === this.root;
    },

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = decodeURI(this.location.pathname + this.location.search);
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.slice(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        var frame = Backbone.$('<iframe src="javascript:0" tabindex="-1">');
        this.iframe = frame.hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;

      // Transition from hashChange to pushState or vice versa if both are
      // requested.
      if (this._wantsHashChange && this._wantsPushState) {

        // If we've started off with a route from a `pushState`-enabled
        // browser, but we're currently in a browser that doesn't support it...
        if (!this._hasPushState && !this.atRoot()) {
          this.fragment = this.getFragment(null, true);
          this.location.replace(this.root + '#' + this.fragment);
          // Return immediately as browser will do redirect to new url
          return true;

        // Or if we've started out with a hash-based route, but we're currently
        // in a browser where it could be `pushState`-based instead...
        } else if (this._hasPushState && this.atRoot() && loc.hash) {
          this.fragment = this.getHash().replace(routeStripper, '');
          this.history.replaceState({}, document.title, this.root + this.fragment);
        }

      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl();
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragment) {
      fragment = this.fragment = this.getFragment(fragment);
      return _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: !!options};

      var url = this.root + (fragment = this.getFragment(fragment || ''));

      // Strip the hash for matching.
      fragment = fragment.replace(pathStripper, '');

      if (this.fragment === fragment) return;
      this.fragment = fragment;

      // Don't include a trailing slash on the root.
      if (fragment === '' && url !== '/') url = url.slice(0, -1);

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) return this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function(model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

  return Backbone;

}));

},{"underscore":20}],20:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],21:[function(require,module,exports){
/*
  backgrid-filter
  http://github.com/wyuenho/backgrid

  Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
  Licensed under the MIT @license.
*/
(function (root, factory) {

  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(["underscore", "backbone", "backgrid"], factory);
  } else if (typeof exports == "object") {
    // CommonJS
    (function () {
      var lunr;
      try { lunr = require("lunr"); } catch (e) {}
      module.exports = factory(require("underscore"),
                               require("backbone"),
                               require("backgrid"),
                               lunr);
    }());
  } else {
    // Browser
    factory(root._, root.Backbone, root.Backgrid, root.lunr);
  }

}(this, function (_, Backbone, Backgrid, lunr) {

  "use strict";

  /**
     ServerSideFilter is a search form widget that submits a query to the server
     for filtering the current collection.

     @class Backgrid.Extension.ServerSideFilter
  */
  var ServerSideFilter = Backgrid.Extension.ServerSideFilter = Backbone.View.extend({

    /** @property */
    tagName: "form",

    /** @property */
    className: "backgrid-filter form-search",

    /** @property {function(Object, ?Object=): string} template */
    template: function (data) {
      return '<span class="search">&nbsp;</span><input type="search" ' + (data.placeholder ? 'placeholder="' + data.placeholder + '"' : '') + ' name="' + data.name + '" ' + (data.value ? 'value="' + data.value + '"' : '') + '/><a class="clear" data-backgrid-action="clear" href="#">&times;</a>';
    },

    /** @property */
    events: {
      "keyup input[type=search]": "showClearButtonMaybe",
      "click a[data-backgrid-action=clear]": "clear",
      "submit": "search"
    },

    /** @property {string} [name='q'] Query key */
    name: "q",

    /** @property {string} [value] The search box value.  */
    value: null,

    /**
       @property {string} [placeholder] The HTML5 placeholder to appear beneath
       the search box.
    */
    placeholder: null,

    /**
       @param {Object} options
       @param {Backbone.Collection} options.collection
       @param {string} [options.name]
       @param {string} [options.value]
       @param {string} [options.placeholder]
       @param {function(Object): string} [options.template]
    */
    initialize: function (options) {
      ServerSideFilter.__super__.initialize.apply(this, arguments);
      this.name = options.name || this.name;
      this.value = options.value || this.value;
      this.placeholder = options.placeholder || this.placeholder;
      this.template = options.template || this.template;

      // Persist the query on pagination
      var collection = this.collection, self = this;
      if (Backbone.PageableCollection &&
          collection instanceof Backbone.PageableCollection &&
          collection.mode == "server") {
        collection.queryParams[this.name] = function () {
          return self.searchBox().val() || null;
        };
      }
    },

    /**
       Event handler. Clear the search box and reset the internal search value.
     */
    clearSearchBox: function() {
      this.value = null;
      this.searchBox().val(null);
      this.showClearButtonMaybe();
    },

    /**
       Event handler. Show the clear button when the search box has text, hide
       it otherwise.
     */
    showClearButtonMaybe: function () {
      var $clearButton = this.clearButton();
      var searchTerms = this.searchBox().val();
      if (searchTerms) $clearButton.show();
      else $clearButton.hide();
    },

    /**
       Returns the search input box.
     */
    searchBox: function () {
      return this.$el.find("input[type=search]");
    },

    /**
       Returns the clear button.
     */
    clearButton: function () {
      return this.$el.find("a[data-backgrid-action=clear]");
    },


    /**
       Returns the current search query.
     */
    query: function() {
      this.value = this.searchBox().val();
      return this.value;
    },

    /**
       Upon search form submission, this event handler constructs a query
       parameter object and pass it to Collection#fetch for server-side
       filtering.

       If the collection is a PageableCollection, searching will go back to the
       first page.
    */
    search: function (e) {
      if (e) e.preventDefault();

      var data = {};
      var query = this.query();
      if (query) data[this.name] = query;

      var collection = this.collection;

      // go back to the first page on search
      if (Backbone.PageableCollection &&
          collection instanceof Backbone.PageableCollection) {
        collection.getFirstPage({data: data, reset: true, fetch: true});
      }
      else collection.fetch({data: data, reset: true});
    },

    /**
       Event handler for the clear button. Clears the search box and refetch the
       collection.

       If the collection is a PageableCollection, clearing will go back to the
       first page.
    */
    clear: function (e) {
      if (e) e.preventDefault();
      this.clearSearchBox();

      var collection = this.collection;

      // go back to the first page on clear
      if (Backbone.PageableCollection &&
          collection instanceof Backbone.PageableCollection) {
        collection.getFirstPage({reset: true, fetch: true});
      }
      else collection.fetch({reset: true});
    },

    /**
       Renders a search form with a text box, optionally with a placeholder and
       a preset value if supplied during initialization.
    */
    render: function () {
      this.$el.empty().append(this.template({
        name: this.name,
        placeholder: this.placeholder,
        value: this.value
      }));
      this.showClearButtonMaybe();
      this.delegateEvents();
      return this;
    }

  });

  /**
     ClientSideFilter is a search form widget that searches a collection for
     model matches against a query on the client side. The exact matching
     algorithm can be overriden by subclasses.

     @class Backgrid.Extension.ClientSideFilter
     @extends Backgrid.Extension.ServerSideFilter
  */
  var ClientSideFilter = Backgrid.Extension.ClientSideFilter = ServerSideFilter.extend({

    /** @property */
    events: _.extend({}, ServerSideFilter.prototype.events, {
      "click a[data-backgrid-action=clear]": function (e) {
        e.preventDefault();
        this.clear();
      },
      "keydown input[type=search]": "search",
      "submit": function (e) {
        e.preventDefault();
        this.search();
      }
    }),

    /**
       @property {?Array.<string>} [fields] A list of model field names to
       search for matches. If null, all of the fields will be searched.
    */
    fields: null,

    /**
       @property [wait=149] The time in milliseconds to wait since the last
       change to the search box's value before searching. This value can be
       adjusted depending on how often the search box is used and how large the
       search index is.
    */
    wait: 149,

    /**
       Debounces the #search and #clear methods and makes a copy of the given
       collection for searching.

       @param {Object} options
       @param {Backbone.Collection} options.collection
       @param {string} [options.placeholder]
       @param {string} [options.fields]
       @param {string} [options.wait=149]
    */
    initialize: function (options) {
      ClientSideFilter.__super__.initialize.apply(this, arguments);

      this.fields = options.fields || this.fields;
      this.wait = options.wait || this.wait;

      this._debounceMethods(["search", "clear"]);

      var collection = this.collection = this.collection.fullCollection || this.collection;
      var shadowCollection = this.shadowCollection = collection.clone();

      this.listenTo(collection, "add", function (model, collection, options) {
        shadowCollection.add(model, options);
      });
      this.listenTo(collection, "remove", function (model, collection, options) {
        shadowCollection.remove(model, options);
      });
      this.listenTo(collection, "sort", function (col) {
        if (!this.searchBox().val()) shadowCollection.reset(col.models);
      });
      this.listenTo(collection, "reset", function (col, options) {
        options = _.extend({reindex: true}, options || {});
        if (options.reindex && options.from == null && options.to == null) {
          shadowCollection.reset(col.models);
        }
      });
    },

    _debounceMethods: function (methodNames) {
      if (_.isString(methodNames)) methodNames = [methodNames];

      this.undelegateEvents();

      for (var i = 0, l = methodNames.length; i < l; i++) {
        var methodName = methodNames[i];
        var method = this[methodName];
        this[methodName] = _.debounce(method, this.wait);
      }

      this.delegateEvents();
    },

    /**
       Constructs a Javascript regular expression object for #makeMatcher.

       This default implementation takes a query string and returns a Javascript
       RegExp object that matches any of the words contained in the query string
       case-insensitively. Override this method to return a different regular
       expression matcher if this behavior is not desired.

       @param {string} query The search query in the search box.
       @return {RegExp} A RegExp object to match against model #fields.
     */
    makeRegExp: function (query) {
      return new RegExp(query.trim().split(/\s+/).join("|"), "i");
    },

    /**
       This default implementation takes a query string and returns a matcher
       function that looks for matches in the model's #fields or all of its
       fields if #fields is null, for any of the words in the query
       case-insensitively using the regular expression object returned from
       #makeRegExp.

       Most of time, you'd want to override the regular expression used for
       matching. If so, please refer to the #makeRegExp documentation,
       otherwise, you can override this method to return a custom matching
       function.

       Subclasses overriding this method must take care to conform to the
       signature of the matcher function. The matcher function is a function
       that takes a model as paramter and returns true if the model matches a
       search, or false otherwise.

       In addition, when the matcher function is called, its context will be
       bound to this ClientSideFilter object so it has access to the filter's
       attributes and methods.

       @param {string} query The search query in the search box.
       @return {function(Backbone.Model):boolean} A matching function.
    */
    makeMatcher: function (query) {
      var regexp = this.makeRegExp(query);
      return function (model) {
        var keys = this.fields || model.keys();
        for (var i = 0, l = keys.length; i < l; i++) {
          if (regexp.test(model.get(keys[i]) + "")) return true;
        }
        return false;
      };
    },

    /**
       Takes the query from the search box, constructs a matcher with it and
       loops through collection looking for matches. Reset the given collection
       when all the matches have been found.

       If the collection is a PageableCollection, searching will go back to the
       first page.
    */
    search: function () {
      var matcher = _.bind(this.makeMatcher(this.query()), this);
      var col = this.collection;
      if (col.pageableCollection) col.pageableCollection.getFirstPage({silent: true});
      col.reset(this.shadowCollection.filter(matcher), {reindex: false});
    },

    /**
       Clears the search box and reset the collection to its original.

       If the collection is a PageableCollection, clearing will go back to the
       first page.
    */
    clear: function () {
      this.clearSearchBox();
      var col = this.collection;
      if (col.pageableCollection) col.pageableCollection.getFirstPage({silent: true});
      col.reset(this.shadowCollection.models, {reindex: false});
    }

  });

  /**
     LunrFilter is a ClientSideFilter that uses [lunrjs](http://lunrjs.com/) to
     index the text fields of each model for a collection, and performs
     full-text searching.

     @class Backgrid.Extension.LunrFilter
     @extends Backgrid.Extension.ClientSideFilter
  */
  var LunrFilter = Backgrid.Extension.LunrFilter = ClientSideFilter.extend({

    /**
       @property {string} [ref="id"]｀lunrjs` document reference attribute name.
    */
    ref: "id",

    /**
       @property {Object} fields A hash of `lunrjs` index field names and boost
       value. Unlike ClientSideFilter#fields, LunrFilter#fields is _required_ to
       initialize the index.
    */
    fields: null,

    /**
       Indexes the underlying collection on construction. The index will refresh
       when the underlying collection is reset. If any model is added, removed
       or if any indexed fields of any models has changed, the index will be
       updated.

       @param {Object} options
       @param {Backbone.Collection} options.collection
       @param {string} [options.placeholder]
       @param {string} [options.ref] ｀lunrjs` document reference attribute name.
       @param {Object} [options.fields] A hash of `lunrjs` index field names and
       boost value.
       @param {number} [options.wait]
    */
    initialize: function (options) {
      LunrFilter.__super__.initialize.apply(this, arguments);

      this.ref = options.ref || this.ref;

      var collection = this.collection = this.collection.fullCollection || this.collection;
      this.listenTo(collection, "add", this.addToIndex);
      this.listenTo(collection, "remove", this.removeFromIndex);
      this.listenTo(collection, "reset", this.resetIndex);
      this.listenTo(collection, "change", this.updateIndex);

      this.resetIndex(collection);
    },

    /**
       Reindex the collection. If `options.reindex` is `false`, this method is a
       no-op.

       @param {Backbone.Collection} collection
       @param {Object} [options]
       @param {boolean} [options.reindex=true]
    */
    resetIndex: function (collection, options) {
      options = _.extend({reindex: true}, options || {});

      if (options.reindex) {
        var self = this;
        this.index = lunr(function () {
          _.each(self.fields, function (boost, fieldName) {
            this.field(fieldName, boost);
            this.ref(self.ref);
          }, this);
        });

        collection.each(function (model) {
          this.addToIndex(model);
        }, this);
      }
    },

    /**
       Adds the given model to the index.

       @param {Backbone.Model} model
    */
    addToIndex: function (model) {
      var index = this.index;
      var doc = model.toJSON();
      if (index.documentStore.has(doc[this.ref])) index.update(doc);
      else index.add(doc);
    },

    /**
       Removes the given model from the index.

       @param {Backbone.Model} model
    */
    removeFromIndex: function (model) {
      var index = this.index;
      var doc = model.toJSON();
      if (index.documentStore.has(doc[this.ref])) index.remove(doc);
    },

    /**
       Updates the index for the given model.

       @param {Backbone.Model} model
    */
    updateIndex: function (model) {
      var changed = model.changedAttributes();
      if (changed && !_.isEmpty(_.intersection(_.keys(this.fields),
                                               _.keys(changed)))) {
        this.index.update(model.toJSON());
      }
    },

    /**
       Takes the query from the search box and performs a full-text search on
       the client-side. The search result is returned by resetting the
       underlying collection to the models after interrogating the index for the
       query answer.

       If the collection is a PageableCollection, searching will go back to the
       first page.
    */
    search: function () {
      var col = this.collection;
      if (!this.query()) {
        col.reset(this.shadowCollection.models, {reindex: false});
        return;
      }

      var searchResults = this.index.search(this.query());
      var models = [];
      for (var i = 0; i < searchResults.length; i++) {
        var result = searchResults[i];
        models.push(this.shadowCollection.get(result.ref));
      }

      if (col.pageableCollection) col.pageableCollection.getFirstPage({silent: true});
      col.reset(models, {reindex: false});
    }

  });

}));

},{"backbone":19,"backgrid":23,"lunr":22,"underscore":30}],22:[function(require,module,exports){
/**
 * lunr - http://lunrjs.com - A bit like Solr, but much smaller and not as bright - 0.4.5
 * Copyright (C) 2014 Oliver Nightingale
 * MIT Licensed
 * @license
 */

/**
 * Convenience function for instantiating a new lunr index and configuring it
 * with the default pipeline functions and the passed config function.
 *
 * When using this convenience function a new index will be created with the
 * following functions already in the pipeline:
 *
 * lunr.StopWordFilter - filters out any stop words before they enter the
 * index
 *
 * lunr.stemmer - stems the tokens before entering the index.
 *
 * Example:
 *
 *     var idx = lunr(function () {
 *       this.field('title', 10)
 *       this.field('tags', 100)
 *       this.field('body')
 *       
 *       this.ref('cid')
 *       
 *       this.pipeline.add(function () {
 *         // some custom pipeline function
 *       })
 *       
 *     })
 *
 * @param {Function} config A function that will be called with the new instance
 * of the lunr.Index as both its context and first parameter. It can be used to
 * customize the instance of new lunr.Index.
 * @namespace
 * @module
 * @returns {lunr.Index}
 *
 */
var lunr = function (config) {
  var idx = new lunr.Index

  idx.pipeline.add(lunr.stopWordFilter, lunr.stemmer)

  if (config) config.call(idx, idx)

  return idx
}

lunr.version = "0.4.5"

if (typeof module !== 'undefined') {
  module.exports = lunr
}
;
/*!
 * lunr.utils
 * Copyright (C) 2014 Oliver Nightingale
 */

/**
 * A namespace containing utils for the rest of the lunr library
 */
lunr.utils = {}

/**
 * Print a warning message to the console.
 *
 * @param {String} message The message to be printed.
 * @memberOf Utils
 */
lunr.utils.warn = (function (global) {
  return function (message) {
    if (global.console && console.warn) {
      console.warn(message)
    }
  }
})(this)

/**
 * Returns a zero filled array of the length specified.
 *
 * @param {Number} length The number of zeros required.
 * @returns {Array}
 * @memberOf Utils
 */
lunr.utils.zeroFillArray = (function () {
  var zeros = [0]

  return function (length) {
    while (zeros.length < length) {
      zeros = zeros.concat(zeros)
    }

    return zeros.slice(0, length)
  }
})()
;
/*!
 * lunr.EventEmitter
 * Copyright (C) 2014 Oliver Nightingale
 */

/**
 * lunr.EventEmitter is an event emitter for lunr. It manages adding and removing event handlers and triggering events and their handlers.
 *
 * @constructor
 */
lunr.EventEmitter = function () {
  this.events = {}
}

/**
 * Binds a handler function to a specific event(s).
 *
 * Can bind a single function to many different events in one call.
 *
 * @param {String} [eventName] The name(s) of events to bind this function to.
 * @param {Function} handler The function to call when an event is fired.
 * @memberOf EventEmitter
 */
lunr.EventEmitter.prototype.addListener = function () {
  var args = Array.prototype.slice.call(arguments),
      fn = args.pop(),
      names = args

  if (typeof fn !== "function") throw new TypeError ("last argument must be a function")

  names.forEach(function (name) {
    if (!this.hasHandler(name)) this.events[name] = []
    this.events[name].push(fn)
  }, this)
}

/**
 * Removes a handler function from a specific event.
 *
 * @param {String} eventName The name of the event to remove this function from.
 * @param {Function} handler The function to remove from an event.
 * @memberOf EventEmitter
 */
lunr.EventEmitter.prototype.removeListener = function (name, fn) {
  if (!this.hasHandler(name)) return

  var fnIndex = this.events[name].indexOf(fn)
  this.events[name].splice(fnIndex, 1)

  if (!this.events[name].length) delete this.events[name]
}

/**
 * Calls all functions bound to the given event.
 *
 * Additional data can be passed to the event handler as arguments to `emit`
 * after the event name.
 *
 * @param {String} eventName The name of the event to emit.
 * @memberOf EventEmitter
 */
lunr.EventEmitter.prototype.emit = function (name) {
  if (!this.hasHandler(name)) return

  var args = Array.prototype.slice.call(arguments, 1)

  this.events[name].forEach(function (fn) {
    fn.apply(undefined, args)
  })
}

/**
 * Checks whether a handler has ever been stored against an event.
 *
 * @param {String} eventName The name of the event to check.
 * @private
 * @memberOf EventEmitter
 */
lunr.EventEmitter.prototype.hasHandler = function (name) {
  return name in this.events
}

;
/*!
 * lunr.tokenizer
 * Copyright (C) 2014 Oliver Nightingale
 */

/**
 * A function for splitting a string into tokens ready to be inserted into
 * the search index.
 *
 * @module
 * @param {String} obj The string to convert into tokens
 * @returns {Array}
 */
lunr.tokenizer = function (obj) {
  if (!arguments.length || obj == null || obj == undefined) return []
  if (Array.isArray(obj)) return obj.map(function (t) { return t.toLowerCase() })

  var str = obj.toString().replace(/^\s+/, '')

  for (var i = str.length - 1; i >= 0; i--) {
    if (/\S/.test(str.charAt(i))) {
      str = str.substring(0, i + 1)
      break
    }
  }

  return str
    .split(/\s+/)
    .map(function (token) {
      return token.replace(/^\W+/, '').replace(/\W+$/, '').toLowerCase()
    })
}
;
/*!
 * lunr.Pipeline
 * Copyright (C) 2014 Oliver Nightingale
 */

/**
 * lunr.Pipelines maintain an ordered list of functions to be applied to all
 * tokens in documents entering the search index and queries being ran against
 * the index.
 *
 * An instance of lunr.Index created with the lunr shortcut will contain a
 * pipeline with a stop word filter and an English language stemmer. Extra
 * functions can be added before or after either of these functions or these
 * default functions can be removed.
 *
 * When run the pipeline will call each function in turn, passing a token, the
 * index of that token in the original list of all tokens and finally a list of
 * all the original tokens.
 *
 * The output of functions in the pipeline will be passed to the next function
 * in the pipeline. To exclude a token from entering the index the function
 * should return undefined, the rest of the pipeline will not be called with
 * this token.
 *
 * For serialisation of pipelines to work, all functions used in an instance of
 * a pipeline should be registered with lunr.Pipeline. Registered functions can
 * then be loaded. If trying to load a serialised pipeline that uses functions
 * that are not registered an error will be thrown.
 *
 * If not planning on serialising the pipeline then registering pipeline functions
 * is not necessary.
 *
 * @constructor
 */
lunr.Pipeline = function () {
  this._stack = []
}

lunr.Pipeline.registeredFunctions = {}

/**
 * Register a function with the pipeline.
 *
 * Functions that are used in the pipeline should be registered if the pipeline
 * needs to be serialised, or a serialised pipeline needs to be loaded.
 *
 * Registering a function does not add it to a pipeline, functions must still be
 * added to instances of the pipeline for them to be used when running a pipeline.
 *
 * @param {Function} fn The function to check for.
 * @param {String} label The label to register this function with
 * @memberOf Pipeline
 */
lunr.Pipeline.registerFunction = function (fn, label) {
  if (label in this.registeredFunctions) {
    lunr.utils.warn('Overwriting existing registered function: ' + label)
  }

  fn.label = label
  lunr.Pipeline.registeredFunctions[fn.label] = fn
}

/**
 * Warns if the function is not registered as a Pipeline function.
 *
 * @param {Function} fn The function to check for.
 * @private
 * @memberOf Pipeline
 */
lunr.Pipeline.warnIfFunctionNotRegistered = function (fn) {
  var isRegistered = fn.label && (fn.label in this.registeredFunctions)

  if (!isRegistered) {
    lunr.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\n', fn)
  }
}

/**
 * Loads a previously serialised pipeline.
 *
 * All functions to be loaded must already be registered with lunr.Pipeline.
 * If any function from the serialised data has not been registered then an
 * error will be thrown.
 *
 * @param {Object} serialised The serialised pipeline to load.
 * @returns {lunr.Pipeline}
 * @memberOf Pipeline
 */
lunr.Pipeline.load = function (serialised) {
  var pipeline = new lunr.Pipeline

  serialised.forEach(function (fnName) {
    var fn = lunr.Pipeline.registeredFunctions[fnName]

    if (fn) {
      pipeline.add(fn)
    } else {
      throw new Error ('Cannot load un-registered function: ' + fnName)
    }
  })

  return pipeline
}

/**
 * Adds new functions to the end of the pipeline.
 *
 * Logs a warning if the function has not been registered.
 *
 * @param {Function} functions Any number of functions to add to the pipeline.
 * @memberOf Pipeline
 */
lunr.Pipeline.prototype.add = function () {
  var fns = Array.prototype.slice.call(arguments)

  fns.forEach(function (fn) {
    lunr.Pipeline.warnIfFunctionNotRegistered(fn)
    this._stack.push(fn)
  }, this)
}

/**
 * Adds a single function after a function that already exists in the
 * pipeline.
 *
 * Logs a warning if the function has not been registered.
 *
 * @param {Function} existingFn A function that already exists in the pipeline.
 * @param {Function} newFn The new function to add to the pipeline.
 * @memberOf Pipeline
 */
lunr.Pipeline.prototype.after = function (existingFn, newFn) {
  lunr.Pipeline.warnIfFunctionNotRegistered(newFn)

  var pos = this._stack.indexOf(existingFn) + 1
  this._stack.splice(pos, 0, newFn)
}

/**
 * Adds a single function before a function that already exists in the
 * pipeline.
 *
 * Logs a warning if the function has not been registered.
 *
 * @param {Function} existingFn A function that already exists in the pipeline.
 * @param {Function} newFn The new function to add to the pipeline.
 * @memberOf Pipeline
 */
lunr.Pipeline.prototype.before = function (existingFn, newFn) {
  lunr.Pipeline.warnIfFunctionNotRegistered(newFn)

  var pos = this._stack.indexOf(existingFn)
  this._stack.splice(pos, 0, newFn)
}

/**
 * Removes a function from the pipeline.
 *
 * @param {Function} fn The function to remove from the pipeline.
 * @memberOf Pipeline
 */
lunr.Pipeline.prototype.remove = function (fn) {
  var pos = this._stack.indexOf(fn)
  this._stack.splice(pos, 1)
}

/**
 * Runs the current list of functions that make up the pipeline against the
 * passed tokens.
 *
 * @param {Array} tokens The tokens to run through the pipeline.
 * @returns {Array}
 * @memberOf Pipeline
 */
lunr.Pipeline.prototype.run = function (tokens) {
  var out = [],
      tokenLength = tokens.length,
      stackLength = this._stack.length

  for (var i = 0; i < tokenLength; i++) {
    var token = tokens[i]

    for (var j = 0; j < stackLength; j++) {
      token = this._stack[j](token, i, tokens)
      if (token === void 0) break
    };

    if (token !== void 0) out.push(token)
  };

  return out
}

/**
 * Returns a representation of the pipeline ready for serialisation.
 *
 * Logs a warning if the function has not been registered.
 *
 * @returns {Array}
 * @memberOf Pipeline
 */
lunr.Pipeline.prototype.toJSON = function () {
  return this._stack.map(function (fn) {
    lunr.Pipeline.warnIfFunctionNotRegistered(fn)

    return fn.label
  })
}
;
/*!
 * lunr.Vector
 * Copyright (C) 2014 Oliver Nightingale
 */

/**
 * lunr.Vectors wrap arrays and add vector related operations for the array
 * elements.
 *
 * @constructor
 * @param {Array} elements Elements that make up the vector.
 */
lunr.Vector = function (elements) {
  this.elements = elements
}

/**
 * Calculates the magnitude of this vector.
 *
 * @returns {Number}
 * @memberOf Vector
 */
lunr.Vector.prototype.magnitude = function () {
  if (this._magnitude) return this._magnitude

  var sumOfSquares = 0,
      elems = this.elements,
      len = elems.length,
      el

  for (var i = 0; i < len; i++) {
    el = elems[i]
    sumOfSquares += el * el
  };

  return this._magnitude = Math.sqrt(sumOfSquares)
}

/**
 * Calculates the dot product of this vector and another vector.
 *
 * @param {lunr.Vector} otherVector The vector to compute the dot product with.
 * @returns {Number}
 * @memberOf Vector
 */
lunr.Vector.prototype.dot = function (otherVector) {
  var elem1 = this.elements,
      elem2 = otherVector.elements,
      length = elem1.length,
      dotProduct = 0

  for (var i = 0; i < length; i++) {
    dotProduct += elem1[i] * elem2[i]
  };

  return dotProduct
}

/**
 * Calculates the cosine similarity between this vector and another
 * vector.
 *
 * @param {lunr.Vector} otherVector The other vector to calculate the
 * similarity with.
 * @returns {Number}
 * @memberOf Vector
 */
lunr.Vector.prototype.similarity = function (otherVector) {
  return this.dot(otherVector) / (this.magnitude() * otherVector.magnitude())
}

/**
 * Converts this vector back into an array.
 *
 * @returns {Array}
 * @memberOf Vector
 */
lunr.Vector.prototype.toArray = function () {
  return this.elements
}
;
/*!
 * lunr.SortedSet
 * Copyright (C) 2014 Oliver Nightingale
 */

/**
 * lunr.SortedSets are used to maintain an array of uniq values in a sorted
 * order.
 *
 * @constructor
 */
lunr.SortedSet = function () {
  this.length = 0
  this.elements = []
}

/**
 * Loads a previously serialised sorted set.
 *
 * @param {Array} serialisedData The serialised set to load.
 * @returns {lunr.SortedSet}
 * @memberOf SortedSet
 */
lunr.SortedSet.load = function (serialisedData) {
  var set = new this

  set.elements = serialisedData
  set.length = serialisedData.length

  return set
}

/**
 * Inserts new items into the set in the correct position to maintain the
 * order.
 *
 * @param {Object} The objects to add to this set.
 * @memberOf SortedSet
 */
lunr.SortedSet.prototype.add = function () {
  Array.prototype.slice.call(arguments).forEach(function (element) {
    if (~this.indexOf(element)) return
    this.elements.splice(this.locationFor(element), 0, element)
  }, this)

  this.length = this.elements.length
}

/**
 * Converts this sorted set into an array.
 *
 * @returns {Array}
 * @memberOf SortedSet
 */
lunr.SortedSet.prototype.toArray = function () {
  return this.elements.slice()
}

/**
 * Creates a new array with the results of calling a provided function on every
 * element in this sorted set.
 *
 * Delegates to Array.prototype.map and has the same signature.
 *
 * @param {Function} fn The function that is called on each element of the
 * set.
 * @param {Object} ctx An optional object that can be used as the context
 * for the function fn.
 * @returns {Array}
 * @memberOf SortedSet
 */
lunr.SortedSet.prototype.map = function (fn, ctx) {
  return this.elements.map(fn, ctx)
}

/**
 * Executes a provided function once per sorted set element.
 *
 * Delegates to Array.prototype.forEach and has the same signature.
 *
 * @param {Function} fn The function that is called on each element of the
 * set.
 * @param {Object} ctx An optional object that can be used as the context
 * @memberOf SortedSet
 * for the function fn.
 */
lunr.SortedSet.prototype.forEach = function (fn, ctx) {
  return this.elements.forEach(fn, ctx)
}

/**
 * Returns the index at which a given element can be found in the
 * sorted set, or -1 if it is not present.
 *
 * @param {Object} elem The object to locate in the sorted set.
 * @param {Number} start An optional index at which to start searching from
 * within the set.
 * @param {Number} end An optional index at which to stop search from within
 * the set.
 * @returns {Number}
 * @memberOf SortedSet
 */
lunr.SortedSet.prototype.indexOf = function (elem, start, end) {
  var start = start || 0,
      end = end || this.elements.length,
      sectionLength = end - start,
      pivot = start + Math.floor(sectionLength / 2),
      pivotElem = this.elements[pivot]

  if (sectionLength <= 1) {
    if (pivotElem === elem) {
      return pivot
    } else {
      return -1
    }
  }

  if (pivotElem < elem) return this.indexOf(elem, pivot, end)
  if (pivotElem > elem) return this.indexOf(elem, start, pivot)
  if (pivotElem === elem) return pivot
}

/**
 * Returns the position within the sorted set that an element should be
 * inserted at to maintain the current order of the set.
 *
 * This function assumes that the element to search for does not already exist
 * in the sorted set.
 *
 * @param {Object} elem The elem to find the position for in the set
 * @param {Number} start An optional index at which to start searching from
 * within the set.
 * @param {Number} end An optional index at which to stop search from within
 * the set.
 * @returns {Number}
 * @memberOf SortedSet
 */
lunr.SortedSet.prototype.locationFor = function (elem, start, end) {
  var start = start || 0,
      end = end || this.elements.length,
      sectionLength = end - start,
      pivot = start + Math.floor(sectionLength / 2),
      pivotElem = this.elements[pivot]

  if (sectionLength <= 1) {
    if (pivotElem > elem) return pivot
    if (pivotElem < elem) return pivot + 1
  }

  if (pivotElem < elem) return this.locationFor(elem, pivot, end)
  if (pivotElem > elem) return this.locationFor(elem, start, pivot)
}

/**
 * Creates a new lunr.SortedSet that contains the elements in the intersection
 * of this set and the passed set.
 *
 * @param {lunr.SortedSet} otherSet The set to intersect with this set.
 * @returns {lunr.SortedSet}
 * @memberOf SortedSet
 */
lunr.SortedSet.prototype.intersect = function (otherSet) {
  var intersectSet = new lunr.SortedSet,
      i = 0, j = 0,
      a_len = this.length, b_len = otherSet.length,
      a = this.elements, b = otherSet.elements

  while (true) {
    if (i > a_len - 1 || j > b_len - 1) break

    if (a[i] === b[j]) {
      intersectSet.add(a[i])
      i++, j++
      continue
    }

    if (a[i] < b[j]) {
      i++
      continue
    }

    if (a[i] > b[j]) {
      j++
      continue
    }
  };

  return intersectSet
}

/**
 * Makes a copy of this set
 *
 * @returns {lunr.SortedSet}
 * @memberOf SortedSet
 */
lunr.SortedSet.prototype.clone = function () {
  var clone = new lunr.SortedSet

  clone.elements = this.toArray()
  clone.length = clone.elements.length

  return clone
}

/**
 * Creates a new lunr.SortedSet that contains the elements in the union
 * of this set and the passed set.
 *
 * @param {lunr.SortedSet} otherSet The set to union with this set.
 * @returns {lunr.SortedSet}
 * @memberOf SortedSet
 */
lunr.SortedSet.prototype.union = function (otherSet) {
  var longSet, shortSet, unionSet

  if (this.length >= otherSet.length) {
    longSet = this, shortSet = otherSet
  } else {
    longSet = otherSet, shortSet = this
  }

  unionSet = longSet.clone()

  unionSet.add.apply(unionSet, shortSet.toArray())

  return unionSet
}

/**
 * Returns a representation of the sorted set ready for serialisation.
 *
 * @returns {Array}
 * @memberOf SortedSet
 */
lunr.SortedSet.prototype.toJSON = function () {
  return this.toArray()
}
;
/*!
 * lunr.Index
 * Copyright (C) 2014 Oliver Nightingale
 */

/**
 * lunr.Index is object that manages a search index.  It contains the indexes
 * and stores all the tokens and document lookups.  It also provides the main
 * user facing API for the library.
 *
 * @constructor
 */
lunr.Index = function () {
  this._fields = []
  this._ref = 'id'
  this.pipeline = new lunr.Pipeline
  this.documentStore = new lunr.Store
  this.tokenStore = new lunr.TokenStore
  this.corpusTokens = new lunr.SortedSet
  this.eventEmitter =  new lunr.EventEmitter

  this._idfCache = {}

  this.on('add', 'remove', 'update', (function () {
    this._idfCache = {}
  }).bind(this))
}

/**
 * Bind a handler to events being emitted by the index.
 *
 * The handler can be bound to many events at the same time.
 *
 * @param {String} [eventName] The name(s) of events to bind the function to.
 * @param {Function} handler The serialised set to load.
 * @memberOf Index
 */
lunr.Index.prototype.on = function () {
  var args = Array.prototype.slice.call(arguments)
  return this.eventEmitter.addListener.apply(this.eventEmitter, args)
}

/**
 * Removes a handler from an event being emitted by the index.
 *
 * @param {String} eventName The name of events to remove the function from.
 * @param {Function} handler The serialised set to load.
 * @memberOf Index
 */
lunr.Index.prototype.off = function (name, fn) {
  return this.eventEmitter.removeListener(name, fn)
}

/**
 * Loads a previously serialised index.
 *
 * Issues a warning if the index being imported was serialised
 * by a different version of lunr.
 *
 * @param {Object} serialisedData The serialised set to load.
 * @returns {lunr.Index}
 * @memberOf Index
 */
lunr.Index.load = function (serialisedData) {
  if (serialisedData.version !== lunr.version) {
    lunr.utils.warn('version mismatch: current ' + lunr.version + ' importing ' + serialisedData.version)
  }

  var idx = new this

  idx._fields = serialisedData.fields
  idx._ref = serialisedData.ref

  idx.documentStore = lunr.Store.load(serialisedData.documentStore)
  idx.tokenStore = lunr.TokenStore.load(serialisedData.tokenStore)
  idx.corpusTokens = lunr.SortedSet.load(serialisedData.corpusTokens)
  idx.pipeline = lunr.Pipeline.load(serialisedData.pipeline)

  return idx
}

/**
 * Adds a field to the list of fields that will be searchable within documents
 * in the index.
 *
 * An optional boost param can be passed to affect how much tokens in this field
 * rank in search results, by default the boost value is 1.
 *
 * Fields should be added before any documents are added to the index, fields
 * that are added after documents are added to the index will only apply to new
 * documents added to the index.
 *
 * @param {String} fieldName The name of the field within the document that
 * should be indexed
 * @param {Number} boost An optional boost that can be applied to terms in this
 * field.
 * @returns {lunr.Index}
 * @memberOf Index
 */
lunr.Index.prototype.field = function (fieldName, opts) {
  var opts = opts || {},
      field = { name: fieldName, boost: opts.boost || 1 }

  this._fields.push(field)
  return this
}

/**
 * Sets the property used to uniquely identify documents added to the index,
 * by default this property is 'id'.
 *
 * This should only be changed before adding documents to the index, changing
 * the ref property without resetting the index can lead to unexpected results.
 *
 * @param {String} refName The property to use to uniquely identify the
 * documents in the index.
 * @param {Boolean} emitEvent Whether to emit add events, defaults to true
 * @returns {lunr.Index}
 * @memberOf Index
 */
lunr.Index.prototype.ref = function (refName) {
  this._ref = refName
  return this
}

/**
 * Add a document to the index.
 *
 * This is the way new documents enter the index, this function will run the
 * fields from the document through the index's pipeline and then add it to
 * the index, it will then show up in search results.
 *
 * An 'add' event is emitted with the document that has been added and the index
 * the document has been added to. This event can be silenced by passing false
 * as the second argument to add.
 *
 * @param {Object} doc The document to add to the index.
 * @param {Boolean} emitEvent Whether or not to emit events, default true.
 * @memberOf Index
 */
lunr.Index.prototype.add = function (doc, emitEvent) {
  var docTokens = {},
      allDocumentTokens = new lunr.SortedSet,
      docRef = doc[this._ref],
      emitEvent = emitEvent === undefined ? true : emitEvent

  this._fields.forEach(function (field) {
    var fieldTokens = this.pipeline.run(lunr.tokenizer(doc[field.name]))

    docTokens[field.name] = fieldTokens
    lunr.SortedSet.prototype.add.apply(allDocumentTokens, fieldTokens)
  }, this)

  this.documentStore.set(docRef, allDocumentTokens)
  lunr.SortedSet.prototype.add.apply(this.corpusTokens, allDocumentTokens.toArray())

  for (var i = 0; i < allDocumentTokens.length; i++) {
    var token = allDocumentTokens.elements[i]
    var tf = this._fields.reduce(function (memo, field) {
      var fieldLength = docTokens[field.name].length

      if (!fieldLength) return memo

      var tokenCount = docTokens[field.name].filter(function (t) { return t === token }).length

      return memo + (tokenCount / fieldLength * field.boost)
    }, 0)

    this.tokenStore.add(token, { ref: docRef, tf: tf })
  };

  if (emitEvent) this.eventEmitter.emit('add', doc, this)
}

/**
 * Removes a document from the index.
 *
 * To make sure documents no longer show up in search results they can be
 * removed from the index using this method.
 *
 * The document passed only needs to have the same ref property value as the
 * document that was added to the index, they could be completely different
 * objects.
 *
 * A 'remove' event is emitted with the document that has been removed and the index
 * the document has been removed from. This event can be silenced by passing false
 * as the second argument to remove.
 *
 * @param {Object} doc The document to remove from the index.
 * @param {Boolean} emitEvent Whether to emit remove events, defaults to true
 * @memberOf Index
 */
lunr.Index.prototype.remove = function (doc, emitEvent) {
  var docRef = doc[this._ref],
      emitEvent = emitEvent === undefined ? true : emitEvent

  if (!this.documentStore.has(docRef)) return

  var docTokens = this.documentStore.get(docRef)

  this.documentStore.remove(docRef)

  docTokens.forEach(function (token) {
    this.tokenStore.remove(token, docRef)
  }, this)

  if (emitEvent) this.eventEmitter.emit('remove', doc, this)
}

/**
 * Updates a document in the index.
 *
 * When a document contained within the index gets updated, fields changed,
 * added or removed, to make sure it correctly matched against search queries,
 * it should be updated in the index.
 *
 * This method is just a wrapper around `remove` and `add`
 *
 * An 'update' event is emitted with the document that has been updated and the index.
 * This event can be silenced by passing false as the second argument to update. Only
 * an update event will be fired, the 'add' and 'remove' events of the underlying calls
 * are silenced.
 *
 * @param {Object} doc The document to update in the index.
 * @param {Boolean} emitEvent Whether to emit update events, defaults to true
 * @see Index.prototype.remove
 * @see Index.prototype.add
 * @memberOf Index
 */
lunr.Index.prototype.update = function (doc, emitEvent) {
  var emitEvent = emitEvent === undefined ? true : emitEvent

  this.remove(doc, false)
  this.add(doc, false)

  if (emitEvent) this.eventEmitter.emit('update', doc, this)
}

/**
 * Calculates the inverse document frequency for a token within the index.
 *
 * @param {String} token The token to calculate the idf of.
 * @see Index.prototype.idf
 * @private
 * @memberOf Index
 */
lunr.Index.prototype.idf = function (term) {
  var cacheKey = "@" + term
  if (Object.prototype.hasOwnProperty.call(this._idfCache, cacheKey)) return this._idfCache[cacheKey]

  var documentFrequency = this.tokenStore.count(term),
      idf = 1

  if (documentFrequency > 0) {
    idf = 1 + Math.log(this.tokenStore.length / documentFrequency)
  }

  return this._idfCache[cacheKey] = idf
}

/**
 * Searches the index using the passed query.
 *
 * Queries should be a string, multiple words are allowed and will lead to an
 * AND based query, e.g. `idx.search('foo bar')` will run a search for
 * documents containing both 'foo' and 'bar'.
 *
 * All query tokens are passed through the same pipeline that document tokens
 * are passed through, so any language processing involved will be run on every
 * query term.
 *
 * Each query term is expanded, so that the term 'he' might be expanded to
 * 'hello' and 'help' if those terms were already included in the index.
 *
 * Matching documents are returned as an array of objects, each object contains
 * the matching document ref, as set for this index, and the similarity score
 * for this document against the query.
 *
 * @param {String} query The query to search the index with.
 * @returns {Object}
 * @see Index.prototype.idf
 * @see Index.prototype.documentVector
 * @memberOf Index
 */
lunr.Index.prototype.search = function (query) {
  var queryTokens = this.pipeline.run(lunr.tokenizer(query)),
      queryArr = lunr.utils.zeroFillArray(this.corpusTokens.length),
      documentSets = [],
      fieldBoosts = this._fields.reduce(function (memo, f) { return memo + f.boost }, 0)

  var hasSomeToken = queryTokens.some(function (token) {
    return this.tokenStore.has(token)
  }, this)

  if (!hasSomeToken) return []

  queryTokens
    .forEach(function (token, i, tokens) {
      var tf = 1 / tokens.length * this._fields.length * fieldBoosts,
          self = this

      var set = this.tokenStore.expand(token).reduce(function (memo, key) {
        var pos = self.corpusTokens.indexOf(key),
            idf = self.idf(key),
            similarityBoost = 1,
            set = new lunr.SortedSet

        // if the expanded key is not an exact match to the token then
        // penalise the score for this key by how different the key is
        // to the token.
        if (key !== token) {
          var diff = Math.max(3, key.length - token.length)
          similarityBoost = 1 / Math.log(diff)
        }

        // calculate the query tf-idf score for this token
        // applying an similarityBoost to ensure exact matches
        // these rank higher than expanded terms
        if (pos > -1) queryArr[pos] = tf * idf * similarityBoost

        // add all the documents that have this key into a set
        Object.keys(self.tokenStore.get(key)).forEach(function (ref) { set.add(ref) })

        return memo.union(set)
      }, new lunr.SortedSet)

      documentSets.push(set)
    }, this)

  var documentSet = documentSets.reduce(function (memo, set) {
    return memo.intersect(set)
  })

  var queryVector = new lunr.Vector (queryArr)

  return documentSet
    .map(function (ref) {
      return { ref: ref, score: queryVector.similarity(this.documentVector(ref)) }
    }, this)
    .sort(function (a, b) {
      return b.score - a.score
    })
}

/**
 * Generates a vector containing all the tokens in the document matching the
 * passed documentRef.
 *
 * The vector contains the tf-idf score for each token contained in the
 * document with the passed documentRef.  The vector will contain an element
 * for every token in the indexes corpus, if the document does not contain that
 * token the element will be 0.
 *
 * @param {Object} documentRef The ref to find the document with.
 * @returns {lunr.Vector}
 * @private
 * @memberOf Index
 */
lunr.Index.prototype.documentVector = function (documentRef) {
  var documentTokens = this.documentStore.get(documentRef),
      documentTokensLength = documentTokens.length,
      documentArr = lunr.utils.zeroFillArray(this.corpusTokens.length)

  for (var i = 0; i < documentTokensLength; i++) {
    var token = documentTokens.elements[i],
        tf = this.tokenStore.get(token)[documentRef].tf,
        idf = this.idf(token)

    documentArr[this.corpusTokens.indexOf(token)] = tf * idf
  };

  return new lunr.Vector (documentArr)
}

/**
 * Returns a representation of the index ready for serialisation.
 *
 * @returns {Object}
 * @memberOf Index
 */
lunr.Index.prototype.toJSON = function () {
  return {
    version: lunr.version,
    fields: this._fields,
    ref: this._ref,
    documentStore: this.documentStore.toJSON(),
    tokenStore: this.tokenStore.toJSON(),
    corpusTokens: this.corpusTokens.toJSON(),
    pipeline: this.pipeline.toJSON()
  }
}
;
/*!
 * lunr.Store
 * Copyright (C) 2014 Oliver Nightingale
 */

/**
 * lunr.Store is a simple key-value store used for storing sets of tokens for
 * documents stored in index.
 *
 * @constructor
 * @module
 */
lunr.Store = function () {
  this.store = {}
  this.length = 0
}

/**
 * Loads a previously serialised store
 *
 * @param {Object} serialisedData The serialised store to load.
 * @returns {lunr.Store}
 * @memberOf Store
 */
lunr.Store.load = function (serialisedData) {
  var store = new this

  store.length = serialisedData.length
  store.store = Object.keys(serialisedData.store).reduce(function (memo, key) {
    memo[key] = lunr.SortedSet.load(serialisedData.store[key])
    return memo
  }, {})

  return store
}

/**
 * Stores the given tokens in the store against the given id.
 *
 * @param {Object} id The key used to store the tokens against.
 * @param {Object} tokens The tokens to store against the key.
 * @memberOf Store
 */
lunr.Store.prototype.set = function (id, tokens) {
  this.store[id] = tokens
  this.length = Object.keys(this.store).length
}

/**
 * Retrieves the tokens from the store for a given key.
 *
 * @param {Object} id The key to lookup and retrieve from the store.
 * @returns {Object}
 * @memberOf Store
 */
lunr.Store.prototype.get = function (id) {
  return this.store[id]
}

/**
 * Checks whether the store contains a key.
 *
 * @param {Object} id The id to look up in the store.
 * @returns {Boolean}
 * @memberOf Store
 */
lunr.Store.prototype.has = function (id) {
  return id in this.store
}

/**
 * Removes the value for a key in the store.
 *
 * @param {Object} id The id to remove from the store.
 * @memberOf Store
 */
lunr.Store.prototype.remove = function (id) {
  if (!this.has(id)) return

  delete this.store[id]
  this.length--
}

/**
 * Returns a representation of the store ready for serialisation.
 *
 * @returns {Object}
 * @memberOf Store
 */
lunr.Store.prototype.toJSON = function () {
  return {
    store: this.store,
    length: this.length
  }
}

;
/*!
 * lunr.stemmer
 * Copyright (C) 2014 Oliver Nightingale
 * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
 */

/**
 * lunr.stemmer is an english language stemmer, this is a JavaScript
 * implementation of the PorterStemmer taken from http://tartaurs.org/~martin
 *
 * @module
 * @param {String} str The string to stem
 * @returns {String}
 * @see lunr.Pipeline
 */
lunr.stemmer = (function(){
  var step2list = {
      "ational" : "ate",
      "tional" : "tion",
      "enci" : "ence",
      "anci" : "ance",
      "izer" : "ize",
      "bli" : "ble",
      "alli" : "al",
      "entli" : "ent",
      "eli" : "e",
      "ousli" : "ous",
      "ization" : "ize",
      "ation" : "ate",
      "ator" : "ate",
      "alism" : "al",
      "iveness" : "ive",
      "fulness" : "ful",
      "ousness" : "ous",
      "aliti" : "al",
      "iviti" : "ive",
      "biliti" : "ble",
      "logi" : "log"
    },

    step3list = {
      "icate" : "ic",
      "ative" : "",
      "alize" : "al",
      "iciti" : "ic",
      "ical" : "ic",
      "ful" : "",
      "ness" : ""
    },

    c = "[^aeiou]",          // consonant
    v = "[aeiouy]",          // vowel
    C = c + "[^aeiouy]*",    // consonant sequence
    V = v + "[aeiou]*",      // vowel sequence

    mgr0 = "^(" + C + ")?" + V + C,               // [C]VC... is m>0
    meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",  // [C]VC[V] is m=1
    mgr1 = "^(" + C + ")?" + V + C + V + C,       // [C]VCVC... is m>1
    s_v = "^(" + C + ")?" + v;                   // vowel in stem

  return function (w) {
    var   stem,
      suffix,
      firstch,
      re,
      re2,
      re3,
      re4;

    if (w.length < 3) { return w; }

    firstch = w.substr(0,1);
    if (firstch == "y") {
      w = firstch.toUpperCase() + w.substr(1);
    }

    // Step 1a
    re = /^(.+?)(ss|i)es$/;
    re2 = /^(.+?)([^s])s$/;

    if (re.test(w)) { w = w.replace(re,"$1$2"); }
    else if (re2.test(w)) { w = w.replace(re2,"$1$2"); }

    // Step 1b
    re = /^(.+?)eed$/;
    re2 = /^(.+?)(ed|ing)$/;
    if (re.test(w)) {
      var fp = re.exec(w);
      re = new RegExp(mgr0);
      if (re.test(fp[1])) {
        re = /.$/;
        w = w.replace(re,"");
      }
    } else if (re2.test(w)) {
      var fp = re2.exec(w);
      stem = fp[1];
      re2 = new RegExp(s_v);
      if (re2.test(stem)) {
        w = stem;
        re2 = /(at|bl|iz)$/;
        re3 = new RegExp("([^aeiouylsz])\\1$");
        re4 = new RegExp("^" + C + v + "[^aeiouwxy]$");
        if (re2.test(w)) {  w = w + "e"; }
        else if (re3.test(w)) { re = /.$/; w = w.replace(re,""); }
        else if (re4.test(w)) { w = w + "e"; }
      }
    }

    // Step 1c
    re = /^(.+?)y$/;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      re = new RegExp(s_v);
      if (re.test(stem)) { w = stem + "i"; }
    }

    // Step 2
    re = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      suffix = fp[2];
      re = new RegExp(mgr0);
      if (re.test(stem)) {
        w = stem + step2list[suffix];
      }
    }

    // Step 3
    re = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      suffix = fp[2];
      re = new RegExp(mgr0);
      if (re.test(stem)) {
        w = stem + step3list[suffix];
      }
    }

    // Step 4
    re = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
    re2 = /^(.+?)(s|t)(ion)$/;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      re = new RegExp(mgr1);
      if (re.test(stem)) {
        w = stem;
      }
    } else if (re2.test(w)) {
      var fp = re2.exec(w);
      stem = fp[1] + fp[2];
      re2 = new RegExp(mgr1);
      if (re2.test(stem)) {
        w = stem;
      }
    }

    // Step 5
    re = /^(.+?)e$/;
    if (re.test(w)) {
      var fp = re.exec(w);
      stem = fp[1];
      re = new RegExp(mgr1);
      re2 = new RegExp(meq1);
      re3 = new RegExp("^" + C + v + "[^aeiouwxy]$");
      if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {
        w = stem;
      }
    }

    re = /ll$/;
    re2 = new RegExp(mgr1);
    if (re.test(w) && re2.test(w)) {
      re = /.$/;
      w = w.replace(re,"");
    }

    // and turn initial Y back to y

    if (firstch == "y") {
      w = firstch.toLowerCase() + w.substr(1);
    }

    return w;
  }
})();

lunr.Pipeline.registerFunction(lunr.stemmer, 'stemmer')
;
/*!
 * lunr.stopWordFilter
 * Copyright (C) 2014 Oliver Nightingale
 */

/**
 * lunr.stopWordFilter is an English language stop word list filter, any words
 * contained in the list will not be passed through the filter.
 *
 * This is intended to be used in the Pipeline. If the token does not pass the
 * filter then undefined will be returned.
 *
 * @module
 * @param {String} token The token to pass through the filter
 * @returns {String}
 * @see lunr.Pipeline
 */
lunr.stopWordFilter = function (token) {
  if (lunr.stopWordFilter.stopWords.indexOf(token) === -1) return token
}

lunr.stopWordFilter.stopWords = new lunr.SortedSet
lunr.stopWordFilter.stopWords.length = 119
lunr.stopWordFilter.stopWords.elements = [
  "",
  "a",
  "able",
  "about",
  "across",
  "after",
  "all",
  "almost",
  "also",
  "am",
  "among",
  "an",
  "and",
  "any",
  "are",
  "as",
  "at",
  "be",
  "because",
  "been",
  "but",
  "by",
  "can",
  "cannot",
  "could",
  "dear",
  "did",
  "do",
  "does",
  "either",
  "else",
  "ever",
  "every",
  "for",
  "from",
  "get",
  "got",
  "had",
  "has",
  "have",
  "he",
  "her",
  "hers",
  "him",
  "his",
  "how",
  "however",
  "i",
  "if",
  "in",
  "into",
  "is",
  "it",
  "its",
  "just",
  "least",
  "let",
  "like",
  "likely",
  "may",
  "me",
  "might",
  "most",
  "must",
  "my",
  "neither",
  "no",
  "nor",
  "not",
  "of",
  "off",
  "often",
  "on",
  "only",
  "or",
  "other",
  "our",
  "own",
  "rather",
  "said",
  "say",
  "says",
  "she",
  "should",
  "since",
  "so",
  "some",
  "than",
  "that",
  "the",
  "their",
  "them",
  "then",
  "there",
  "these",
  "they",
  "this",
  "tis",
  "to",
  "too",
  "twas",
  "us",
  "wants",
  "was",
  "we",
  "were",
  "what",
  "when",
  "where",
  "which",
  "while",
  "who",
  "whom",
  "why",
  "will",
  "with",
  "would",
  "yet",
  "you",
  "your"
]

lunr.Pipeline.registerFunction(lunr.stopWordFilter, 'stopWordFilter')
;
/*!
 * lunr.stemmer
 * Copyright (C) 2014 Oliver Nightingale
 * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
 */

/**
 * lunr.TokenStore is used for efficient storing and lookup of the reverse
 * index of token to document ref.
 *
 * @constructor
 */
lunr.TokenStore = function () {
  this.root = { docs: {} }
  this.length = 0
}

/**
 * Loads a previously serialised token store
 *
 * @param {Object} serialisedData The serialised token store to load.
 * @returns {lunr.TokenStore}
 * @memberOf TokenStore
 */
lunr.TokenStore.load = function (serialisedData) {
  var store = new this

  store.root = serialisedData.root
  store.length = serialisedData.length

  return store
}

/**
 * Adds a new token doc pair to the store.
 *
 * By default this function starts at the root of the current store, however
 * it can start at any node of any token store if required.
 *
 * @param {String} token The token to store the doc under
 * @param {Object} doc The doc to store against the token
 * @param {Object} root An optional node at which to start looking for the
 * correct place to enter the doc, by default the root of this lunr.TokenStore
 * is used.
 * @memberOf TokenStore
 */
lunr.TokenStore.prototype.add = function (token, doc, root) {
  var root = root || this.root,
      key = token[0],
      rest = token.slice(1)

  if (!(key in root)) root[key] = {docs: {}}

  if (rest.length === 0) {
    root[key].docs[doc.ref] = doc
    this.length += 1
    return
  } else {
    return this.add(rest, doc, root[key])
  }
}

/**
 * Checks whether this key is contained within this lunr.TokenStore.
 *
 * By default this function starts at the root of the current store, however
 * it can start at any node of any token store if required.
 *
 * @param {String} token The token to check for
 * @param {Object} root An optional node at which to start
 * @memberOf TokenStore
 */
lunr.TokenStore.prototype.has = function (token) {
  if (!token) return false

  var node = this.root

  for (var i = 0; i < token.length; i++) {
    if (!node[token[i]]) return false

    node = node[token[i]]
  }

  return true
}

/**
 * Retrieve a node from the token store for a given token.
 *
 * By default this function starts at the root of the current store, however
 * it can start at any node of any token store if required.
 *
 * @param {String} token The token to get the node for.
 * @param {Object} root An optional node at which to start.
 * @returns {Object}
 * @see TokenStore.prototype.get
 * @memberOf TokenStore
 */
lunr.TokenStore.prototype.getNode = function (token) {
  if (!token) return {}

  var node = this.root

  for (var i = 0; i < token.length; i++) {
    if (!node[token[i]]) return {}

    node = node[token[i]]
  }

  return node
}

/**
 * Retrieve the documents for a node for the given token.
 *
 * By default this function starts at the root of the current store, however
 * it can start at any node of any token store if required.
 *
 * @param {String} token The token to get the documents for.
 * @param {Object} root An optional node at which to start.
 * @returns {Object}
 * @memberOf TokenStore
 */
lunr.TokenStore.prototype.get = function (token, root) {
  return this.getNode(token, root).docs || {}
}

lunr.TokenStore.prototype.count = function (token, root) {
  return Object.keys(this.get(token, root)).length
}

/**
 * Remove the document identified by ref from the token in the store.
 *
 * By default this function starts at the root of the current store, however
 * it can start at any node of any token store if required.
 *
 * @param {String} token The token to get the documents for.
 * @param {String} ref The ref of the document to remove from this token.
 * @param {Object} root An optional node at which to start.
 * @returns {Object}
 * @memberOf TokenStore
 */
lunr.TokenStore.prototype.remove = function (token, ref) {
  if (!token) return
  var node = this.root

  for (var i = 0; i < token.length; i++) {
    if (!(token[i] in node)) return
    node = node[token[i]]
  }

  delete node.docs[ref]
}

/**
 * Find all the possible suffixes of the passed token using tokens
 * currently in the store.
 *
 * @param {String} token The token to expand.
 * @returns {Array}
 * @memberOf TokenStore
 */
lunr.TokenStore.prototype.expand = function (token, memo) {
  var root = this.getNode(token),
      docs = root.docs || {},
      memo = memo || []

  if (Object.keys(docs).length) memo.push(token)

  Object.keys(root)
    .forEach(function (key) {
      if (key === 'docs') return

      memo.concat(this.expand(token + key, memo))
    }, this)

  return memo
}

/**
 * Returns a representation of the token store ready for serialisation.
 *
 * @returns {Object}
 * @memberOf TokenStore
 */
lunr.TokenStore.prototype.toJSON = function () {
  return {
    root: this.root,
    length: this.length
  }
}

;

},{}],23:[function(require,module,exports){
/*!
  backgrid
  http://github.com/wyuenho/backgrid

  Copyright (c) 2014 Jimmy Yuen Ho Wong and contributors <wyuenho@gmail.com>
  Licensed under the MIT license.
*/

(function (root, factory) {

  if (typeof define === "function" && define.amd) {
    // AMD (+ global for extensions)
    define(["underscore", "backbone"], function (_, Backbone) {
      return (root.Backgrid = factory(_, Backbone));
    });
  } else if (typeof exports === "object") {
    // CommonJS
    module.exports = factory(require("underscore"), require("backbone"));
  } else {
    // Browser
    root.Backgrid = factory(root._, root.Backbone);
  }}(this, function (_, Backbone) {

  "use strict";

/*
  backgrid
  http://github.com/wyuenho/backgrid

  Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
  Licensed under the MIT license.
*/

// Copyright 2009, 2010 Kristopher Michael Kowal
// https://github.com/kriskowal/es5-shim
// ES5 15.5.4.20
// http://es5.github.com/#x15.5.4.20
var ws = "\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003" +
  "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028" +
  "\u2029\uFEFF";
if (!String.prototype.trim || ws.trim()) {
  // http://blog.stevenlevithan.com/archives/faster-trim-javascript
  // http://perfectionkills.com/whitespace-deviations/
  ws = "[" + ws + "]";
  var trimBeginRegexp = new RegExp("^" + ws + ws + "*"),
  trimEndRegexp = new RegExp(ws + ws + "*$");
  String.prototype.trim = function trim() {
    if (this === undefined || this === null) {
      throw new TypeError("can't convert " + this + " to object");
    }
    return String(this)
      .replace(trimBeginRegexp, "")
      .replace(trimEndRegexp, "");
  };
}

function lpad(str, length, padstr) {
  var paddingLen = length - (str + '').length;
  paddingLen =  paddingLen < 0 ? 0 : paddingLen;
  var padding = '';
  for (var i = 0; i < paddingLen; i++) {
    padding = padding + padstr;
  }
  return padding + str;
}

var $ = Backbone.$;

var Backgrid = {

  Extension: {},

  resolveNameToClass: function (name, suffix) {
    if (_.isString(name)) {
      var key = _.map(name.split('-'), function (e) {
        return e.slice(0, 1).toUpperCase() + e.slice(1);
      }).join('') + suffix;
      var klass = Backgrid[key] || Backgrid.Extension[key];
      if (_.isUndefined(klass)) {
        throw new ReferenceError("Class '" + key + "' not found");
      }
      return klass;
    }

    return name;
  },

  callByNeed: function () {
    var value = arguments[0];
    if (!_.isFunction(value)) return value;

    var context = arguments[1];
    var args = [].slice.call(arguments, 2);
    return value.apply(context, !!(args + '') ? args : []);
  }

};
_.extend(Backgrid, Backbone.Events);

/**
   Command translates a DOM Event into commands that Backgrid
   recognizes. Interested parties can listen on selected Backgrid events that
   come with an instance of this class and act on the commands.

   It is also possible to globally rebind the keyboard shortcuts by replacing
   the methods in this class' prototype.

   @class Backgrid.Command
   @constructor
 */
var Command = Backgrid.Command = function (evt) {
  _.extend(this, {
    altKey: !!evt.altKey,
    "char": evt["char"],
    charCode: evt.charCode,
    ctrlKey: !!evt.ctrlKey,
    key: evt.key,
    keyCode: evt.keyCode,
    locale: evt.locale,
    location: evt.location,
    metaKey: !!evt.metaKey,
    repeat: !!evt.repeat,
    shiftKey: !!evt.shiftKey,
    which: evt.which
  });
};
_.extend(Command.prototype, {
  /**
     Up Arrow

     @member Backgrid.Command
   */
  moveUp: function () { return this.keyCode == 38; },
  /**
     Down Arrow

     @member Backgrid.Command
   */
  moveDown: function () { return this.keyCode === 40; },
  /**
     Shift Tab

     @member Backgrid.Command
   */
  moveLeft: function () { return this.shiftKey && this.keyCode === 9; },
  /**
     Tab

     @member Backgrid.Command
   */
  moveRight: function () { return !this.shiftKey && this.keyCode === 9; },
  /**
     Enter

     @member Backgrid.Command
   */
  save: function () { return this.keyCode === 13; },
  /**
     Esc

     @member Backgrid.Command
   */
  cancel: function () { return this.keyCode === 27; },
  /**
     None of the above.

     @member Backgrid.Command
   */
  passThru: function () {
    return !(this.moveUp() || this.moveDown() || this.moveLeft() ||
             this.moveRight() || this.save() || this.cancel());
  }
});

/*
  backgrid
  http://github.com/wyuenho/backgrid

  Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
  Licensed under the MIT license.
*/

/**
   Just a convenient class for interested parties to subclass.

   The default Cell classes don't require the formatter to be a subclass of
   Formatter as long as the fromRaw(rawData) and toRaw(formattedData) methods
   are defined.

   @abstract
   @class Backgrid.CellFormatter
   @constructor
*/
var CellFormatter = Backgrid.CellFormatter = function () {};
_.extend(CellFormatter.prototype, {

  /**
     Takes a raw value from a model and returns an optionally formatted string
     for display. The default implementation simply returns the supplied value
     as is without any type conversion.

     @member Backgrid.CellFormatter
     @param {*} rawData
     @param {Backbone.Model} model Used for more complicated formatting
     @return {*}
  */
  fromRaw: function (rawData, model) {
    return rawData;
  },

  /**
     Takes a formatted string, usually from user input, and returns a
     appropriately typed value for persistence in the model.

     If the user input is invalid or unable to be converted to a raw value
     suitable for persistence in the model, toRaw must return `undefined`.

     @member Backgrid.CellFormatter
     @param {string} formattedData
     @param {Backbone.Model} model Used for more complicated formatting
     @return {*|undefined}
  */
  toRaw: function (formattedData, model) {
    return formattedData;
  }

});

/**
   A floating point number formatter. Doesn't understand scientific notation at
   the moment.

   @class Backgrid.NumberFormatter
   @extends Backgrid.CellFormatter
   @constructor
   @throws {RangeError} If decimals < 0 or > 20.
*/
var NumberFormatter = Backgrid.NumberFormatter = function (options) {
  _.extend(this, this.defaults, options || {});

  if (this.decimals < 0 || this.decimals > 20) {
    throw new RangeError("decimals must be between 0 and 20");
  }
};
NumberFormatter.prototype = new CellFormatter();
_.extend(NumberFormatter.prototype, {

  /**
     @member Backgrid.NumberFormatter
     @cfg {Object} options

     @cfg {number} [options.decimals=2] Number of decimals to display. Must be an integer.

     @cfg {string} [options.decimalSeparator='.'] The separator to use when
     displaying decimals.

     @cfg {string} [options.orderSeparator=','] The separator to use to
     separator thousands. May be an empty string.
   */
  defaults: {
    decimals: 2,
    decimalSeparator: '.',
    orderSeparator: ','
  },

  HUMANIZED_NUM_RE: /(\d)(?=(?:\d{3})+$)/g,

  /**
     Takes a floating point number and convert it to a formatted string where
     every thousand is separated by `orderSeparator`, with a `decimal` number of
     decimals separated by `decimalSeparator`. The number returned is rounded
     the usual way.

     @member Backgrid.NumberFormatter
     @param {number} number
     @param {Backbone.Model} model Used for more complicated formatting
     @return {string}
  */
  fromRaw: function (number, model) {
    if (_.isNull(number) || _.isUndefined(number)) return '';

    number = number.toFixed(~~this.decimals);

    var parts = number.split('.');
    var integerPart = parts[0];
    var decimalPart = parts[1] ? (this.decimalSeparator || '.') + parts[1] : '';

    return integerPart.replace(this.HUMANIZED_NUM_RE, '$1' + this.orderSeparator) + decimalPart;
  },

  /**
     Takes a string, possibly formatted with `orderSeparator` and/or
     `decimalSeparator`, and convert it back to a number.

     @member Backgrid.NumberFormatter
     @param {string} formattedData
     @param {Backbone.Model} model Used for more complicated formatting
     @return {number|undefined} Undefined if the string cannot be converted to
     a number.
  */
  toRaw: function (formattedData, model) {
    formattedData = formattedData.trim();

    if (formattedData === '') return null;

    var rawData = '';

    var thousands = formattedData.split(this.orderSeparator);
    for (var i = 0; i < thousands.length; i++) {
      rawData += thousands[i];
    }

    var decimalParts = rawData.split(this.decimalSeparator);
    rawData = '';
    for (var i = 0; i < decimalParts.length; i++) {
      rawData = rawData + decimalParts[i] + '.';
    }

    if (rawData[rawData.length - 1] === '.') {
      rawData = rawData.slice(0, rawData.length - 1);
    }

    var result = (rawData * 1).toFixed(~~this.decimals) * 1;
    if (_.isNumber(result) && !_.isNaN(result)) return result;
  }

});

/**
   A number formatter that converts a floating point number, optionally
   multiplied by a multiplier, to a percentage string and vice versa.

   @class Backgrid.PercentFormatter
   @extends Backgrid.NumberFormatter
   @constructor
   @throws {RangeError} If decimals < 0 or > 20.
 */
var PercentFormatter = Backgrid.PercentFormatter = function () {
  Backgrid.NumberFormatter.apply(this, arguments);
};

PercentFormatter.prototype = new Backgrid.NumberFormatter(),

_.extend(PercentFormatter.prototype, {

  /**
     @member Backgrid.PercentFormatter
     @cfg {Object} options

     @cfg {number} [options.multiplier=1] The number used to multiply the model
     value for display.

     @cfg {string} [options.symbol='%'] The symbol to append to the percentage
     string.
   */
  defaults: _.extend({}, NumberFormatter.prototype.defaults, {
    multiplier: 1,
    symbol: "%"
  }),

  /**
     Takes a floating point number, where the number is first multiplied by
     `multiplier`, then converted to a formatted string like
     NumberFormatter#fromRaw, then finally append `symbol` to the end.

     @member Backgrid.PercentFormatter
     @param {number} rawValue
     @param {Backbone.Model} model Used for more complicated formatting
     @return {string}
  */
  fromRaw: function (number, model) {
    var args = [].slice.call(arguments, 1);
    args.unshift(number * this.multiplier);
    return (NumberFormatter.prototype.fromRaw.apply(this, args) || "0") + this.symbol;
  },

  /**
     Takes a string, possibly appended with `symbol` and/or `decimalSeparator`,
     and convert it back to a number for the model like NumberFormatter#toRaw,
     and then dividing it by `multiplier`.

     @member Backgrid.PercentFormatter
     @param {string} formattedData
     @param {Backbone.Model} model Used for more complicated formatting
     @return {number|undefined} Undefined if the string cannot be converted to
     a number.
  */
  toRaw: function (formattedValue, model) {
    var tokens = formattedValue.split(this.symbol);
    if (tokens && tokens[0] && tokens[1] === "" || tokens[1] == null) {
      var rawValue = NumberFormatter.prototype.toRaw.call(this, tokens[0]);
      if (_.isUndefined(rawValue)) return rawValue;
      return rawValue / this.multiplier;
    }
  }

});

/**
   Formatter to converts between various datetime formats.

   This class only understands ISO-8601 formatted datetime strings and UNIX
   offset (number of milliseconds since UNIX Epoch). See
   Backgrid.Extension.MomentFormatter if you need a much more flexible datetime
   formatter.

   @class Backgrid.DatetimeFormatter
   @extends Backgrid.CellFormatter
   @constructor
   @throws {Error} If both `includeDate` and `includeTime` are false.
*/
var DatetimeFormatter = Backgrid.DatetimeFormatter = function (options) {
  _.extend(this, this.defaults, options || {});

  if (!this.includeDate && !this.includeTime) {
    throw new Error("Either includeDate or includeTime must be true");
  }
};
DatetimeFormatter.prototype = new CellFormatter();
_.extend(DatetimeFormatter.prototype, {

  /**
     @member Backgrid.DatetimeFormatter

     @cfg {Object} options

     @cfg {boolean} [options.includeDate=true] Whether the values include the
     date part.

     @cfg {boolean} [options.includeTime=true] Whether the values include the
     time part.

     @cfg {boolean} [options.includeMilli=false] If `includeTime` is true,
     whether to include the millisecond part, if it exists.
   */
  defaults: {
    includeDate: true,
    includeTime: true,
    includeMilli: false
  },

  DATE_RE: /^([+\-]?\d{4})-(\d{2})-(\d{2})$/,
  TIME_RE: /^(\d{2}):(\d{2}):(\d{2})(\.(\d{3}))?$/,
  ISO_SPLITTER_RE: /T|Z| +/,

  _convert: function (data, validate) {
    if ((data + '').trim() === '') return null;

    var date, time = null;
    if (_.isNumber(data)) {
      var jsDate = new Date(data);
      date = lpad(jsDate.getUTCFullYear(), 4, 0) + '-' + lpad(jsDate.getUTCMonth() + 1, 2, 0) + '-' + lpad(jsDate.getUTCDate(), 2, 0);
      time = lpad(jsDate.getUTCHours(), 2, 0) + ':' + lpad(jsDate.getUTCMinutes(), 2, 0) + ':' + lpad(jsDate.getUTCSeconds(), 2, 0);
    }
    else {
      data = data.trim();
      var parts = data.split(this.ISO_SPLITTER_RE) || [];
      date = this.DATE_RE.test(parts[0]) ? parts[0] : '';
      time = date && parts[1] ? parts[1] : this.TIME_RE.test(parts[0]) ? parts[0] : '';
    }

    var YYYYMMDD = this.DATE_RE.exec(date) || [];
    var HHmmssSSS = this.TIME_RE.exec(time) || [];

    if (validate) {
      if (this.includeDate && _.isUndefined(YYYYMMDD[0])) return;
      if (this.includeTime && _.isUndefined(HHmmssSSS[0])) return;
      if (!this.includeDate && date) return;
      if (!this.includeTime && time) return;
    }

    var jsDate = new Date(Date.UTC(YYYYMMDD[1] * 1 || 0,
                                   YYYYMMDD[2] * 1 - 1 || 0,
                                   YYYYMMDD[3] * 1 || 0,
                                   HHmmssSSS[1] * 1 || null,
                                   HHmmssSSS[2] * 1 || null,
                                   HHmmssSSS[3] * 1 || null,
                                   HHmmssSSS[5] * 1 || null));

    var result = '';

    if (this.includeDate) {
      result = lpad(jsDate.getUTCFullYear(), 4, 0) + '-' + lpad(jsDate.getUTCMonth() + 1, 2, 0) + '-' + lpad(jsDate.getUTCDate(), 2, 0);
    }

    if (this.includeTime) {
      result = result + (this.includeDate ? 'T' : '') + lpad(jsDate.getUTCHours(), 2, 0) + ':' + lpad(jsDate.getUTCMinutes(), 2, 0) + ':' + lpad(jsDate.getUTCSeconds(), 2, 0);

      if (this.includeMilli) {
        result = result + '.' + lpad(jsDate.getUTCMilliseconds(), 3, 0);
      }
    }

    if (this.includeDate && this.includeTime) {
      result += "Z";
    }

    return result;
  },

  /**
     Converts an ISO-8601 formatted datetime string to a datetime string, date
     string or a time string. The timezone is ignored if supplied.

     @member Backgrid.DatetimeFormatter
     @param {string} rawData
     @param {Backbone.Model} model Used for more complicated formatting
     @return {string|null|undefined} ISO-8601 string in UTC. Null and undefined
     values are returned as is.
  */
  fromRaw: function (rawData, model) {
    if (_.isNull(rawData) || _.isUndefined(rawData)) return '';
    return this._convert(rawData);
  },

  /**
     Converts an ISO-8601 formatted datetime string to a datetime string, date
     string or a time string. The timezone is ignored if supplied. This method
     parses the input values exactly the same way as
     Backgrid.Extension.MomentFormatter#fromRaw(), in addition to doing some
     sanity checks.

     @member Backgrid.DatetimeFormatter
     @param {string} formattedData
     @param {Backbone.Model} model Used for more complicated formatting
     @return {string|undefined} ISO-8601 string in UTC. Undefined if a date is
     found when `includeDate` is false, or a time is found when `includeTime` is
     false, or if `includeDate` is true and a date is not found, or if
     `includeTime` is true and a time is not found.
  */
  toRaw: function (formattedData, model) {
    return this._convert(formattedData, true);
  }

});

/**
   Formatter to convert any value to string.

   @class Backgrid.StringFormatter
   @extends Backgrid.CellFormatter
   @constructor
 */
var StringFormatter = Backgrid.StringFormatter = function () {};
StringFormatter.prototype = new CellFormatter();
_.extend(StringFormatter.prototype, {
  /**
     Converts any value to a string using Ecmascript's implicit type
     conversion. If the given value is `null` or `undefined`, an empty string is
     returned instead.

     @member Backgrid.StringFormatter
     @param {*} rawValue
     @param {Backbone.Model} model Used for more complicated formatting
     @return {string}
   */
  fromRaw: function (rawValue, model) {
    if (_.isUndefined(rawValue) || _.isNull(rawValue)) return '';
    return rawValue + '';
  }
});

/**
   Simple email validation formatter.

   @class Backgrid.EmailFormatter
   @extends Backgrid.CellFormatter
   @constructor
 */
var EmailFormatter = Backgrid.EmailFormatter = function () {};
EmailFormatter.prototype = new CellFormatter();
_.extend(EmailFormatter.prototype, {
  /**
     Return the input if it is a string that contains an '@' character and if
     the strings before and after '@' are non-empty. If the input does not
     validate, `undefined` is returned.

     @member Backgrid.EmailFormatter
     @param {*} formattedData
     @param {Backbone.Model} model Used for more complicated formatting
     @return {string|undefined}
   */
  toRaw: function (formattedData, model) {
    var parts = formattedData.trim().split("@");
    if (parts.length === 2 && _.all(parts)) {
      return formattedData;
    }
  }
});

/**
   Formatter for SelectCell.

   If the type of a model value is not a string, it is expected that a subclass
   of this formatter is provided to the SelectCell, with #toRaw overridden to
   convert the string value returned from the DOM back to whatever value is
   expected in the model.

   @class Backgrid.SelectFormatter
   @extends Backgrid.CellFormatter
   @constructor
*/
var SelectFormatter = Backgrid.SelectFormatter = function () {};
SelectFormatter.prototype = new CellFormatter();
_.extend(SelectFormatter.prototype, {


  /**
     Normalizes raw scalar or array values to an array.

     @member Backgrid.SelectFormatter
     @param {*} rawValue
     @param {Backbone.Model} model Used for more complicated formatting
     @return {Array.<*>}
  */
  fromRaw: function (rawValue, model) {
    return _.isArray(rawValue) ? rawValue : rawValue != null ? [rawValue] : [];
  }
});

var $ = require('jquery');
/*
  backgrid
  http://github.com/wyuenho/backgrid

  Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
  Licensed under the MIT license.
*/

/**
   Generic cell editor base class. Only defines an initializer for a number of
   required parameters.

   @abstract
   @class Backgrid.CellEditor
   @extends Backbone.View
*/
var CellEditor = Backgrid.CellEditor = Backbone.View.extend({

  /**
     Initializer.

     @param {Object} options
     @param {Backgrid.CellFormatter} options.formatter
     @param {Backgrid.Column} options.column
     @param {Backbone.Model} options.model

     @throws {TypeError} If `formatter` is not a formatter instance, or when
     `model` or `column` are undefined.
  */
  initialize: function (options) {
    this.formatter = options.formatter;
    this.column = options.column;
    if (!(this.column instanceof Column)) {
      this.column = new Column(this.column);
    }

    this.listenTo(this.model, "backgrid:editing", this.postRender);
  },

  /**
     Post-rendering setup and initialization. Focuses the cell editor's `el` in
     this default implementation. **Should** be called by Cell classes after
     calling Backgrid.CellEditor#render.
  */
  postRender: function (model, column) {
    if (column == null || column.get("name") == this.column.get("name")) {
      this.$el.focus();
    }
    return this;
  }

});

/**
   InputCellEditor the cell editor type used by most core cell types. This cell
   editor renders a text input box as its editor. The input will render a
   placeholder if the value is empty on supported browsers.

   @class Backgrid.InputCellEditor
   @extends Backgrid.CellEditor
*/
var InputCellEditor = Backgrid.InputCellEditor = CellEditor.extend({

  /** @property */
  tagName: "input",

  /** @property */
  attributes: {
    type: "text"
  },

  /** @property */
  events: {
    "blur": "saveOrCancel",
    "keydown": "saveOrCancel"
  },

  /**
     Initializer. Removes this `el` from the DOM when a `done` event is
     triggered.

     @param {Object} options
     @param {Backgrid.CellFormatter} options.formatter
     @param {Backgrid.Column} options.column
     @param {Backbone.Model} options.model
     @param {string} [options.placeholder]
  */
  initialize: function (options) {
    InputCellEditor.__super__.initialize.apply(this, arguments);

    if (options.placeholder) {
      this.$el.attr("placeholder", options.placeholder);
    }
  },

  /**
     Renders a text input with the cell value formatted for display, if it
     exists.
  */
  render: function () {
    var model = this.model;
    this.$el.val(this.formatter.fromRaw(model.get(this.column.get("name")), model));
    return this;
  },

  /**
     If the key pressed is `enter`, `tab`, `up`, or `down`, converts the value
     in the editor to a raw value for saving into the model using the formatter.

     If the key pressed is `esc` the changes are undone.

     If the editor goes out of focus (`blur`) but the value is invalid, the
     event is intercepted and cancelled so the cell remains in focus pending for
     further action. The changes are saved otherwise.

     Triggers a Backbone `backgrid:edited` event from the model when successful,
     and `backgrid:error` if the value cannot be converted. Classes listening to
     the `error` event, usually the Cell classes, should respond appropriately,
     usually by rendering some kind of error feedback.

     @param {Event} e
  */
  saveOrCancel: function (e) {

    var formatter = this.formatter;
    var model = this.model;
    var column = this.column;

    var command = new Command(e);
    var blurred = e.type === "blur";

    if (command.moveUp() || command.moveDown() || command.moveLeft() || command.moveRight() ||
        command.save() || blurred) {

      e.preventDefault();
      e.stopPropagation();

      var val = this.$el.val();
      var newValue = formatter.toRaw(val, model);
      if (_.isUndefined(newValue)) {
        model.trigger("backgrid:error", model, column, val);
      }
      else {
        model.set(column.get("name"), newValue);
        model.trigger("backgrid:edited", model, column, command);
      }
    }
    // esc
    else if (command.cancel()) {
      // undo
      e.stopPropagation();
      model.trigger("backgrid:edited", model, column, command);
    }
  },

  postRender: function (model, column) {
    if (column == null || column.get("name") == this.column.get("name")) {
      // move the cursor to the end on firefox if text is right aligned
      if (this.$el.css("text-align") === "right") {
        var val = this.$el.val();
        this.$el.focus().val(null).val(val);
      }
      else this.$el.focus();
    }
    return this;
  }

});

/**
   The super-class for all Cell types. By default, this class renders a plain
   table cell with the model value converted to a string using the
   formatter. The table cell is clickable, upon which the cell will go into
   editor mode, which is rendered by a Backgrid.InputCellEditor instance by
   default. Upon encountering any formatting errors, this class will add an
   `error` CSS class to the table cell.

   @abstract
   @class Backgrid.Cell
   @extends Backbone.View
*/
var Cell = Backgrid.Cell = Backbone.View.extend({

  /** @property */
  tagName: "td",

  /**
     @property {Backgrid.CellFormatter|Object|string} [formatter=CellFormatter]
  */
  formatter: CellFormatter,

  /**
     @property {Backgrid.CellEditor} [editor=Backgrid.InputCellEditor] The
     default editor for all cell instances of this class. This value must be a
     class, it will be automatically instantiated upon entering edit mode.

     See Backgrid.CellEditor
  */
  editor: InputCellEditor,

  /** @property */
  events: {
    "click": "enterEditMode"
  },

  /**
     Initializer.

     @param {Object} options
     @param {Backbone.Model} options.model
     @param {Backgrid.Column} options.column

     @throws {ReferenceError} If formatter is a string but a formatter class of
     said name cannot be found in the Backgrid module.
  */
  initialize: function (options) {
    this.column = options.column;
    if (!(this.column instanceof Column)) {
      this.column = new Column(this.column);
    }

    var column = this.column, model = this.model, $el = this.$el;

    var formatter = Backgrid.resolveNameToClass(column.get("formatter") ||
                                                this.formatter, "Formatter");

    if (!_.isFunction(formatter.fromRaw) && !_.isFunction(formatter.toRaw)) {
      formatter = new formatter();
    }

    this.formatter = formatter;

    this.editor = Backgrid.resolveNameToClass(this.editor, "CellEditor");

    this.listenTo(model, "change:" + column.get("name"), function () {
      if (!$el.hasClass("editor")) this.render();
    });

    this.listenTo(model, "backgrid:error", this.renderError);

    this.listenTo(column, "change:editable change:sortable change:renderable",
                  function (column) {
                    var changed = column.changedAttributes();
                    for (var key in changed) {
                      if (changed.hasOwnProperty(key)) {
                        $el.toggleClass(key, changed[key]);
                      }
                    }
                  });

    if (Backgrid.callByNeed(column.editable(), column, model)) $el.addClass("editable");
    if (Backgrid.callByNeed(column.sortable(), column, model)) $el.addClass("sortable");
    if (Backgrid.callByNeed(column.renderable(), column, model)) $el.addClass("renderable");
  },

  /**
     Render a text string in a table cell. The text is converted from the
     model's raw value for this cell's column.
  */
  render: function () {
    this.$el.empty();
    var model = this.model;
    this.$el.text(this.formatter.fromRaw(model.get(this.column.get("name")), model));
    this.delegateEvents();
    return this;
  },

  /**
     If this column is editable, a new CellEditor instance is instantiated with
     its required parameters. An `editor` CSS class is added to the cell upon
     entering edit mode.

     This method triggers a Backbone `backgrid:edit` event from the model when
     the cell is entering edit mode and an editor instance has been constructed,
     but before it is rendered and inserted into the DOM. The cell and the
     constructed cell editor instance are sent as event parameters when this
     event is triggered.

     When this cell has finished switching to edit mode, a Backbone
     `backgrid:editing` event is triggered from the model. The cell and the
     constructed cell instance are also sent as parameters in the event.

     When the model triggers a `backgrid:error` event, it means the editor is
     unable to convert the current user input to an apprpriate value for the
     model's column, and an `error` CSS class is added to the cell accordingly.
  */
  enterEditMode: function () {
    var model = this.model;
    var column = this.column;

    var editable = Backgrid.callByNeed(column.editable(), column, model);
    if (editable) {

      this.currentEditor = new this.editor({
        column: this.column,
        model: this.model,
        formatter: this.formatter
      });

      model.trigger("backgrid:edit", model, column, this, this.currentEditor);

      // Need to redundantly undelegate events for Firefox
      this.undelegateEvents();
      this.$el.empty();
      this.$el.append(this.currentEditor.$el);
      this.currentEditor.render();
      this.$el.addClass("editor");

      model.trigger("backgrid:editing", model, column, this, this.currentEditor);
    }
  },

  /**
     Put an `error` CSS class on the table cell.
  */
  renderError: function (model, column) {
    if (column == null || column.get("name") == this.column.get("name")) {
      this.$el.addClass("error");
    }
  },

  /**
     Removes the editor and re-render in display mode.
  */
  exitEditMode: function () {
    this.$el.removeClass("error");
    this.currentEditor.remove();
    this.stopListening(this.currentEditor);
    delete this.currentEditor;
    this.$el.removeClass("editor");
    this.render();
  },

  /**
     Clean up this cell.

     @chainable
  */
  remove: function () {
    if (this.currentEditor) {
      this.currentEditor.remove.apply(this.currentEditor, arguments);
      delete this.currentEditor;
    }
    return Cell.__super__.remove.apply(this, arguments);
  }

});

/**
   StringCell displays HTML escaped strings and accepts anything typed in.

   @class Backgrid.StringCell
   @extends Backgrid.Cell
*/
var StringCell = Backgrid.StringCell = Cell.extend({

  /** @property */
  className: "string-cell",

  formatter: StringFormatter

});

/**
   UriCell renders an HTML `<a>` anchor for the value and accepts URIs as user
   input values. No type conversion or URL validation is done by the formatter
   of this cell. Users who need URL validation are encourage to subclass UriCell
   to take advantage of the parsing capabilities of the HTMLAnchorElement
   available on HTML5-capable browsers or using a third-party library like
   [URI.js](https://github.com/medialize/URI.js).

   @class Backgrid.UriCell
   @extends Backgrid.Cell
*/
var UriCell = Backgrid.UriCell = Cell.extend({

  /** @property */
  className: "uri-cell",

  /**
     @property {string} [title] The title attribute of the generated anchor. It
     uses the display value formatted by the `formatter.fromRaw` by default.
  */
  title: null,

  /**
     @property {string} [target="_blank"] The target attribute of the generated
     anchor.
  */
  target: "_blank",

  initialize: function (options) {
    UriCell.__super__.initialize.apply(this, arguments);
    this.title = options.title || this.title;
    this.target = options.target || this.target;
  },

  render: function () {
    this.$el.empty();
    var rawValue = this.model.get(this.column.get("name"));
    var formattedValue = this.formatter.fromRaw(rawValue, this.model);
    this.$el.append($("<a>", {
      tabIndex: -1,
      href: rawValue,
      title: this.title || formattedValue,
      target: this.target
    }).text(formattedValue));
    this.delegateEvents();
    return this;
  }

});

/**
   Like Backgrid.UriCell, EmailCell renders an HTML `<a>` anchor for the
   value. The `href` in the anchor is prefixed with `mailto:`. EmailCell will
   complain if the user enters a string that doesn't contain the `@` sign.

   @class Backgrid.EmailCell
   @extends Backgrid.StringCell
*/
var EmailCell = Backgrid.EmailCell = StringCell.extend({

  /** @property */
  className: "email-cell",

  formatter: EmailFormatter,

  render: function () {
    this.$el.empty();
    var model = this.model;
    var formattedValue = this.formatter.fromRaw(model.get(this.column.get("name")), model);
    this.$el.append($("<a>", {
      tabIndex: -1,
      href: "mailto:" + formattedValue,
      title: formattedValue
    }).text(formattedValue));
    this.delegateEvents();
    return this;
  }

});

/**
   NumberCell is a generic cell that renders all numbers. Numbers are formatted
   using a Backgrid.NumberFormatter.

   @class Backgrid.NumberCell
   @extends Backgrid.Cell
*/
var NumberCell = Backgrid.NumberCell = Cell.extend({

  /** @property */
  className: "number-cell",

  /**
     @property {number} [decimals=2] Must be an integer.
  */
  decimals: NumberFormatter.prototype.defaults.decimals,

  /** @property {string} [decimalSeparator='.'] */
  decimalSeparator: NumberFormatter.prototype.defaults.decimalSeparator,

  /** @property {string} [orderSeparator=','] */
  orderSeparator: NumberFormatter.prototype.defaults.orderSeparator,

  /** @property {Backgrid.CellFormatter} [formatter=Backgrid.NumberFormatter] */
  formatter: NumberFormatter,

  /**
     Initializes this cell and the number formatter.

     @param {Object} options
     @param {Backbone.Model} options.model
     @param {Backgrid.Column} options.column
  */
  initialize: function (options) {
    NumberCell.__super__.initialize.apply(this, arguments);
    var formatter = this.formatter;
    formatter.decimals = this.decimals;
    formatter.decimalSeparator = this.decimalSeparator;
    formatter.orderSeparator = this.orderSeparator;
  }

});

/**
   An IntegerCell is just a Backgrid.NumberCell with 0 decimals. If a floating
   point number is supplied, the number is simply rounded the usual way when
   displayed.

   @class Backgrid.IntegerCell
   @extends Backgrid.NumberCell
*/
var IntegerCell = Backgrid.IntegerCell = NumberCell.extend({

  /** @property */
  className: "integer-cell",

  /**
     @property {number} decimals Must be an integer.
  */
  decimals: 0
});

/**
   A PercentCell is another Backgrid.NumberCell that takes a floating number,
   optionally multiplied by a multiplier and display it as a percentage.

   @class Backgrid.PercentCell
   @extends Backgrid.NumberCell
 */
var PercentCell = Backgrid.PercentCell = NumberCell.extend({

  /** @property */
  className: "percent-cell",

  /** @property {number} [multiplier=1] */
  multiplier: PercentFormatter.prototype.defaults.multiplier,

  /** @property {string} [symbol='%'] */
  symbol: PercentFormatter.prototype.defaults.symbol,

  /** @property {Backgrid.CellFormatter} [formatter=Backgrid.PercentFormatter] */
  formatter: PercentFormatter,

  /**
     Initializes this cell and the percent formatter.

     @param {Object} options
     @param {Backbone.Model} options.model
     @param {Backgrid.Column} options.column
  */
  initialize: function () {
    PercentCell.__super__.initialize.apply(this, arguments);
    var formatter = this.formatter;
    formatter.multiplier = this.multiplier;
    formatter.symbol = this.symbol;
  }

});

/**
   DatetimeCell is a basic cell that accepts datetime string values in RFC-2822
   or W3C's subset of ISO-8601 and displays them in ISO-8601 format. For a much
   more sophisticated date time cell with better datetime formatting, take a
   look at the Backgrid.Extension.MomentCell extension.

   @class Backgrid.DatetimeCell
   @extends Backgrid.Cell

   See:

   - Backgrid.Extension.MomentCell
   - Backgrid.DatetimeFormatter
*/
var DatetimeCell = Backgrid.DatetimeCell = Cell.extend({

  /** @property */
  className: "datetime-cell",

  /**
     @property {boolean} [includeDate=true]
  */
  includeDate: DatetimeFormatter.prototype.defaults.includeDate,

  /**
     @property {boolean} [includeTime=true]
  */
  includeTime: DatetimeFormatter.prototype.defaults.includeTime,

  /**
     @property {boolean} [includeMilli=false]
  */
  includeMilli: DatetimeFormatter.prototype.defaults.includeMilli,

  /** @property {Backgrid.CellFormatter} [formatter=Backgrid.DatetimeFormatter] */
  formatter: DatetimeFormatter,

  /**
     Initializes this cell and the datetime formatter.

     @param {Object} options
     @param {Backbone.Model} options.model
     @param {Backgrid.Column} options.column
  */
  initialize: function (options) {
    DatetimeCell.__super__.initialize.apply(this, arguments);
    var formatter = this.formatter;
    formatter.includeDate = this.includeDate;
    formatter.includeTime = this.includeTime;
    formatter.includeMilli = this.includeMilli;

    var placeholder = this.includeDate ? "YYYY-MM-DD" : "";
    placeholder += (this.includeDate && this.includeTime) ? "T" : "";
    placeholder += this.includeTime ? "HH:mm:ss" : "";
    placeholder += (this.includeTime && this.includeMilli) ? ".SSS" : "";

    this.editor = this.editor.extend({
      attributes: _.extend({}, this.editor.prototype.attributes, this.editor.attributes, {
        placeholder: placeholder
      })
    });
  }

});

/**
   DateCell is a Backgrid.DatetimeCell without the time part.

   @class Backgrid.DateCell
   @extends Backgrid.DatetimeCell
*/
var DateCell = Backgrid.DateCell = DatetimeCell.extend({

  /** @property */
  className: "date-cell",

  /** @property */
  includeTime: false

});

/**
   TimeCell is a Backgrid.DatetimeCell without the date part.

   @class Backgrid.TimeCell
   @extends Backgrid.DatetimeCell
*/
var TimeCell = Backgrid.TimeCell = DatetimeCell.extend({

  /** @property */
  className: "time-cell",

  /** @property */
  includeDate: false

});

/**
   BooleanCellEditor renders a checkbox as its editor.

   @class Backgrid.BooleanCellEditor
   @extends Backgrid.CellEditor
*/
var BooleanCellEditor = Backgrid.BooleanCellEditor = CellEditor.extend({

  /** @property */
  tagName: "input",

  /** @property */
  attributes: {
    tabIndex: -1,
    type: "checkbox"
  },

  /** @property */
  events: {
    "mousedown": function () {
      this.mouseDown = true;
    },
    "blur": "enterOrExitEditMode",
    "mouseup": function () {
      this.mouseDown = false;
    },
    "change": "saveOrCancel",
    "keydown": "saveOrCancel"
  },

  /**
     Renders a checkbox and check it if the model value of this column is true,
     uncheck otherwise.
  */
  render: function () {
    var model = this.model;
    var val = this.formatter.fromRaw(model.get(this.column.get("name")), model);
    this.$el.prop("checked", val);
    return this;
  },

  /**
     Event handler. Hack to deal with the case where `blur` is fired before
     `change` and `click` on a checkbox.
  */
  enterOrExitEditMode: function (e) {
    if (!this.mouseDown) {
      var model = this.model;
      model.trigger("backgrid:edited", model, this.column, new Command(e));
    }
  },

  /**
     Event handler. Save the value into the model if the event is `change` or
     one of the keyboard navigation key presses. Exit edit mode without saving
     if `escape` was pressed.
  */
  saveOrCancel: function (e) {
    var model = this.model;
    var column = this.column;
    var formatter = this.formatter;
    var command = new Command(e);
    // skip ahead to `change` when space is pressed
    if (command.passThru() && e.type != "change") return true;
    if (command.cancel()) {
      e.stopPropagation();
      model.trigger("backgrid:edited", model, column, command);
    }

    var $el = this.$el;
    if (command.save() || command.moveLeft() || command.moveRight() || command.moveUp() ||
        command.moveDown()) {
      e.preventDefault();
      e.stopPropagation();
      var val = formatter.toRaw($el.prop("checked"), model);
      model.set(column.get("name"), val);
      model.trigger("backgrid:edited", model, column, command);
    }
    else if (e.type == "change") {
      var val = formatter.toRaw($el.prop("checked"), model);
      model.set(column.get("name"), val);
      $el.focus();
    }
  }

});

/**
   BooleanCell renders a checkbox both during display mode and edit mode. The
   checkbox is checked if the model value is true, unchecked otherwise.

   @class Backgrid.BooleanCell
   @extends Backgrid.Cell
*/
var BooleanCell = Backgrid.BooleanCell = Cell.extend({

  /** @property */
  className: "boolean-cell",

  /** @property */
  editor: BooleanCellEditor,

  /** @property */
  events: {
    "click": "enterEditMode"
  },

  /**
     Renders a checkbox and check it if the model value of this column is true,
     uncheck otherwise.
  */
  render: function () {
    this.$el.empty();
    var model = this.model, column = this.column;
    var editable = Backgrid.callByNeed(column.editable(), column, model);
    this.$el.append($("<input>", {
      tabIndex: -1,
      type: "checkbox",
      checked: this.formatter.fromRaw(model.get(column.get("name")), model),
      disabled: !editable
    }));
    this.delegateEvents();
    return this;
  }

});

/**
   SelectCellEditor renders an HTML `<select>` fragment as the editor.

   @class Backgrid.SelectCellEditor
   @extends Backgrid.CellEditor
*/
var SelectCellEditor = Backgrid.SelectCellEditor = CellEditor.extend({

  /** @property */
  tagName: "select",

  /** @property */
  events: {
    "change": "save",
    "blur": "close",
    "keydown": "close"
  },

  /** @property {function(Object, ?Object=): string} template */
  template: _.template('<option value="<%- value %>" <%= selected ? \'selected="selected"\' : "" %>><%- text %></option>', null, {variable: null}),

  setOptionValues: function (optionValues) {
    this.optionValues = optionValues;
    this.optionValues = _.result(this, "optionValues");
  },

  setMultiple: function (multiple) {
    this.multiple = multiple;
    this.$el.prop("multiple", multiple);
  },

  _renderOptions: function (nvps, selectedValues) {
    var options = '';
    for (var i = 0; i < nvps.length; i++) {
      options = options + this.template({
        text: nvps[i][0],
        value: nvps[i][1],
        selected: _.indexOf(selectedValues, nvps[i][1]) > -1
      });
    }
    return options;
  },

  /**
     Renders the options if `optionValues` is a list of name-value pairs. The
     options are contained inside option groups if `optionValues` is a list of
     object hashes. The name is rendered at the option text and the value is the
     option value. If `optionValues` is a function, it is called without a
     parameter.
  */
  render: function () {
    this.$el.empty();

    var optionValues = _.result(this, "optionValues");
    var model = this.model;
    var selectedValues = this.formatter.fromRaw(model.get(this.column.get("name")), model);

    if (!_.isArray(optionValues)) throw new TypeError("optionValues must be an array");

    var optionValue = null;
    var optionText = null;
    var optionValue = null;
    var optgroupName = null;
    var optgroup = null;

    for (var i = 0; i < optionValues.length; i++) {
      var optionValue = optionValues[i];

      if (_.isArray(optionValue)) {
        optionText  = optionValue[0];
        optionValue = optionValue[1];

        this.$el.append(this.template({
          text: optionText,
          value: optionValue,
          selected: _.indexOf(selectedValues, optionValue) > -1
        }));
      }
      else if (_.isObject(optionValue)) {
        optgroupName = optionValue.name;
        optgroup = $("<optgroup></optgroup>", { label: optgroupName });
        optgroup.append(this._renderOptions.call(this, optionValue.values, selectedValues));
        this.$el.append(optgroup);
      }
      else {
        throw new TypeError("optionValues elements must be a name-value pair or an object hash of { name: 'optgroup label', value: [option name-value pairs] }");
      }
    }

    this.delegateEvents();

    return this;
  },

  /**
     Saves the value of the selected option to the model attribute.
  */
  save: function (e) {
    var model = this.model;
    var column = this.column;
    model.set(column.get("name"), this.formatter.toRaw(this.$el.val(), model));
  },

  /**
     Triggers a `backgrid:edited` event from the model so the body can close
     this editor.
  */
  close: function (e) {
    var model = this.model;
    var column = this.column;
    var command = new Command(e);
    if (command.cancel()) {
      e.stopPropagation();
      model.trigger("backgrid:edited", model, column, new Command(e));
    }
    else if (command.save() || command.moveLeft() || command.moveRight() ||
             command.moveUp() || command.moveDown() || e.type == "blur") {
      e.preventDefault();
      e.stopPropagation();
      this.save(e);
      model.trigger("backgrid:edited", model, column, new Command(e));
    }
  }

});

/**
   SelectCell is also a different kind of cell in that upon going into edit mode
   the cell renders a list of options to pick from, as opposed to an input box.

   SelectCell cannot be referenced by its string name when used in a column
   definition because it requires an `optionValues` class attribute to be
   defined. `optionValues` can either be a list of name-value pairs, to be
   rendered as options, or a list of object hashes which consist of a key *name*
   which is the option group name, and a key *values* which is a list of
   name-value pairs to be rendered as options under that option group.

   In addition, `optionValues` can also be a parameter-less function that
   returns one of the above. If the options are static, it is recommended the
   returned values to be memoized. `_.memoize()` is a good function to help with
   that.

   During display mode, the default formatter will normalize the raw model value
   to an array of values whether the raw model value is a scalar or an
   array. Each value is compared with the `optionValues` values using
   Ecmascript's implicit type conversion rules. When exiting edit mode, no type
   conversion is performed when saving into the model. This behavior is not
   always desirable when the value type is anything other than string. To
   control type conversion on the client-side, you should subclass SelectCell to
   provide a custom formatter or provide the formatter to your column
   definition.

   See:
     [$.fn.val()](http://api.jquery.com/val/)

   @class Backgrid.SelectCell
   @extends Backgrid.Cell
*/
var SelectCell = Backgrid.SelectCell = Cell.extend({

  /** @property */
  className: "select-cell",

  /** @property */
  editor: SelectCellEditor,

  /** @property */
  multiple: false,

  /** @property */
  formatter: SelectFormatter,

  /**
     @property {Array.<Array>|Array.<{name: string, values: Array.<Array>}>} optionValues
  */
  optionValues: undefined,

  /** @property */
  delimiter: ', ',

  /**
     Initializer.

     @param {Object} options
     @param {Backbone.Model} options.model
     @param {Backgrid.Column} options.column

     @throws {TypeError} If `optionsValues` is undefined.
  */
  initialize: function (options) {
    SelectCell.__super__.initialize.apply(this, arguments);
    this.listenTo(this.model, "backgrid:edit", function (model, column, cell, editor) {
      if (column.get("name") == this.column.get("name")) {
        editor.setOptionValues(this.optionValues);
        editor.setMultiple(this.multiple);
      }
    });
  },

  /**
     Renders the label using the raw value as key to look up from `optionValues`.

     @throws {TypeError} If `optionValues` is malformed.
  */
  render: function () {
    this.$el.empty();

    var optionValues = _.result(this, "optionValues");
    var model = this.model;
    var rawData = this.formatter.fromRaw(model.get(this.column.get("name")), model);

    var selectedText = [];

    try {
      if (!_.isArray(optionValues) || _.isEmpty(optionValues)) throw new TypeError;

      for (var k = 0; k < rawData.length; k++) {
        var rawDatum = rawData[k];

        for (var i = 0; i < optionValues.length; i++) {
          var optionValue = optionValues[i];

          if (_.isArray(optionValue)) {
            var optionText  = optionValue[0];
            var optionValue = optionValue[1];

            if (optionValue == rawDatum) selectedText.push(optionText);
          }
          else if (_.isObject(optionValue)) {
            var optionGroupValues = optionValue.values;

            for (var j = 0; j < optionGroupValues.length; j++) {
              var optionGroupValue = optionGroupValues[j];
              if (optionGroupValue[1] == rawDatum) {
                selectedText.push(optionGroupValue[0]);
              }
            }
          }
          else {
            throw new TypeError;
          }
        }
      }

      this.$el.append(selectedText.join(this.delimiter));
    }
    catch (ex) {
      if (ex instanceof TypeError) {
        throw new TypeError("'optionValues' must be of type {Array.<Array>|Array.<{name: string, values: Array.<Array>}>}");
      }
      throw ex;
    }

    this.delegateEvents();

    return this;
  }

});

/*
  backgrid
  http://github.com/wyuenho/backgrid

  Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
  Licensed under the MIT license.
*/

/**
   A Column is a placeholder for column metadata.

   You usually don't need to create an instance of this class yourself as a
   collection of column instances will be created for you from a list of column
   attributes in the Backgrid.js view class constructors.

   @class Backgrid.Column
   @extends Backbone.Model
*/
var Column = Backgrid.Column = Backbone.Model.extend({

  /**
     @cfg {Object} defaults Column defaults. To override any of these default
     values, you can either change the prototype directly to override
     Column.defaults globally or extend Column and supply the custom class to
     Backgrid.Grid:

         // Override Column defaults globally
         Column.prototype.defaults.sortable = false;

         // Override Column defaults locally
         var MyColumn = Column.extend({
           defaults: _.defaults({
             editable: false
           }, Column.prototype.defaults)
         });

         var grid = new Backgrid.Grid(columns: new Columns([{...}, {...}], {
           model: MyColumn
         }));

     @cfg {string} [defaults.name] The default name of the model attribute.

     @cfg {string} [defaults.label] The default label to show in the header.

     @cfg {string|Backgrid.Cell} [defaults.cell] The default cell type. If this
     is a string, the capitalized form will be used to look up a cell class in
     Backbone, i.e.: string => StringCell. If a Cell subclass is supplied, it is
     initialized with a hash of parameters. If a Cell instance is supplied, it
     is used directly.

     @cfg {string|Backgrid.HeaderCell} [defaults.headerCell] The default header
     cell type.

     @cfg {boolean|string|function(): boolean} [defaults.sortable=true] Whether
     this column is sortable. If the value is a string, a method will the same
     name will be looked up from the column instance to determine whether the
     column should be sortable. The method's signature must be `function
     (Backgrid.Column, Backbone.Model): boolean`.

     @cfg {boolean|string|function(): boolean} [defaults.editable=true] Whether
     this column is editable. If the value is a string, a method will the same
     name will be looked up from the column instance to determine whether the
     column should be editable. The method's signature must be `function
     (Backgrid.Column, Backbone.Model): boolean`.

     @cfg {boolean|string|function(): boolean} [defaults.renderable=true]
     Whether this column is renderable. If the value is a string, a method will
     the same name will be looked up from the column instance to determine
     whether the column should be renderable. The method's signature must be
     `function (Backrid.Column, Backbone.Model): boolean`.

     @cfg {Backgrid.CellFormatter | Object | string} [defaults.formatter] The
     formatter to use to convert between raw model values and user input.

     @cfg {"toggle"|"cycle"} [defaults.sortType="cycle"] Whether sorting will
     toggle between ascending and descending order, or cycle between insertion
     order, ascending and descending order.

     @cfg {(function(Backbone.Model, string): *) | string} [defaults.sortValue]
     The function to use to extract a value from the model for comparison during
     sorting. If this value is a string, a method with the same name will be
     looked up from the column instance.

     @cfg {"ascending"|"descending"|null} [defaults.direction=null] The initial
     sorting direction for this column. The default is ordered by
     Backbone.Model.cid, which usually means the collection is ordered by
     insertion order.
  */
  defaults: {
    name: undefined,
    label: undefined,
    sortable: true,
    editable: true,
    renderable: true,
    formatter: undefined,
    sortType: "cycle",
    sortValue: undefined,
    direction: null,
    cell: undefined,
    headerCell: undefined
  },

  /**
     Initializes this Column instance.

     @param {Object} attrs

     @param {string} attrs.name The model attribute this column is responsible
     for.

     @param {string|Backgrid.Cell} attrs.cell The cell type to use to render
     this column.

     @param {string} [attrs.label]

     @param {string|Backgrid.HeaderCell} [attrs.headerCell]

     @param {boolean|string|function(): boolean} [attrs.sortable=true]

     @param {boolean|string|function(): boolean} [attrs.editable=true]

     @param {boolean|string|function(): boolean} [attrs.renderable=true]

     @param {Backgrid.CellFormatter | Object | string} [attrs.formatter]

     @param {"toggle"|"cycle"}  [attrs.sortType="cycle"]

     @param {(function(Backbone.Model, string): *) | string} [attrs.sortValue]

     @throws {TypeError} If attrs.cell or attrs.options are not supplied.

     @throws {ReferenceError} If formatter is a string but a formatter class of
     said name cannot be found in the Backgrid module.

     See:

     - Backgrid.Column.defaults
     - Backgrid.Cell
     - Backgrid.CellFormatter
   */
  initialize: function () {
    if (!this.has("label")) {
      this.set({ label: this.get("name") }, { silent: true });
    }

    var headerCell = Backgrid.resolveNameToClass(this.get("headerCell"), "HeaderCell");

    var cell = Backgrid.resolveNameToClass(this.get("cell"), "Cell");

    this.set({cell: cell, headerCell: headerCell}, { silent: true });
  },

  /**
     Returns an appropriate value extraction function from a model for sorting.

     If the column model contains an attribute `sortValue`, if it is a string, a
     method from the column instance identifified by the `sortValue` string is
     returned. If it is a function, it it returned as is. If `sortValue` isn't
     found from the column model's attributes, a default value extraction
     function is returned which will compare according to the natural order of
     the value's type.

     @return {function(Backbone.Model, string): *}
   */
  sortValue: function () {
    var sortValue = this.get("sortValue");
    if (_.isString(sortValue)) return this[sortValue];
    else if (_.isFunction(sortValue)) return sortValue;

    return function (model, colName) {
      return model.get(colName);
    };
  }

  /**
     @member Backgrid.Column
     @protected
     @method sortable
     @return {function(Backgrid.Column, Backbone.Model): boolean | boolean}
  */

  /**
     @member Backgrid.Column
     @protected
     @method editable
     @return {function(Backgrid.Column, Backbone.Model): boolean | boolean}
  */

  /**
     @member Backgrid.Column
     @protected
     @method renderable
     @return {function(Backgrid.Column, Backbone.Model): boolean | boolean}
  */
});

_.each(["sortable", "renderable", "editable"], function (key) {
  Column.prototype[key] = function () {
    var value = this.get(key);
    if (_.isString(value)) return this[value];
    else if (_.isFunction(value)) return value;

    return !!value;
  };
});

/**
   A Backbone collection of Column instances.

   @class Backgrid.Columns
   @extends Backbone.Collection
 */
var Columns = Backgrid.Columns = Backbone.Collection.extend({

  /**
     @property {Backgrid.Column} model
   */
  model: Column
});

/*
  backgrid
  http://github.com/wyuenho/backgrid

  Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
  Licensed under the MIT license.
*/

/**
   Row is a simple container view that takes a model instance and a list of
   column metadata describing how each of the model's attribute is to be
   rendered, and apply the appropriate cell to each attribute.

   @class Backgrid.Row
   @extends Backbone.View
*/
var Row = Backgrid.Row = Backbone.View.extend({

  /** @property */
  tagName: "tr",

  /**
     Initializes a row view instance.

     @param {Object} options
     @param {Backbone.Collection.<Backgrid.Column>|Array.<Backgrid.Column>|Array.<Object>} options.columns Column metadata.
     @param {Backbone.Model} options.model The model instance to render.

     @throws {TypeError} If options.columns or options.model is undefined.
  */
  initialize: function (options) {

    var columns = this.columns = options.columns;
    if (!(columns instanceof Backbone.Collection)) {
      columns = this.columns = new Columns(columns);
    }

    var cells = this.cells = [];
    for (var i = 0; i < columns.length; i++) {
      cells.push(this.makeCell(columns.at(i), options));
    }

    this.listenTo(columns, "add", function (column, columns) {
      var i = columns.indexOf(column);
      var cell = this.makeCell(column, options);
      cells.splice(i, 0, cell);

      var $el = this.$el;
      if (i === 0) {
        $el.prepend(cell.render().$el);
      }
      else if (i === columns.length - 1) {
        $el.append(cell.render().$el);
      }
      else {
        $el.children().eq(i).before(cell.render().$el);
      }
    });

    this.listenTo(columns, "remove", function (column, columns, opts) {
      cells[opts.index].remove();
      cells.splice(opts.index, 1);
    });
  },

  /**
     Factory method for making a cell. Used by #initialize internally. Override
     this to provide an appropriate cell instance for a custom Row subclass.

     @protected

     @param {Backgrid.Column} column
     @param {Object} options The options passed to #initialize.

     @return {Backgrid.Cell}
  */
  makeCell: function (column) {
    return new (column.get("cell"))({
      column: column,
      model: this.model
    });
  },

  /**
     Renders a row of cells for this row's model.
  */
  render: function () {
    this.$el.empty();

    var fragment = document.createDocumentFragment();
    for (var i = 0; i < this.cells.length; i++) {
      fragment.appendChild(this.cells[i].render().el);
    }

    this.el.appendChild(fragment);

    this.delegateEvents();

    return this;
  },

  /**
     Clean up this row and its cells.

     @chainable
  */
  remove: function () {
    for (var i = 0; i < this.cells.length; i++) {
      var cell = this.cells[i];
      cell.remove.apply(cell, arguments);
    }
    return Backbone.View.prototype.remove.apply(this, arguments);
  }

});

/**
   EmptyRow is a simple container view that takes a list of column and render a
   row with a single column.

   @class Backgrid.EmptyRow
   @extends Backbone.View
*/
var EmptyRow = Backgrid.EmptyRow = Backbone.View.extend({

  /** @property */
  tagName: "tr",

  /** @property {string|function(): string} */
  emptyText: null,

  /**
     Initializer.

     @param {Object} options
     @param {string|function(): string} options.emptyText
     @param {Backbone.Collection.<Backgrid.Column>|Array.<Backgrid.Column>|Array.<Object>} options.columns Column metadata.
   */
  initialize: function (options) {
    this.emptyText = options.emptyText;
    this.columns =  options.columns;
  },

  /**
     Renders an empty row.
  */
  render: function () {
    this.$el.empty();

    var td = document.createElement("td");
    td.setAttribute("colspan", this.columns.length);
    td.appendChild(document.createTextNode(_.result(this, "emptyText")));

    this.el.className = "empty";
    this.el.appendChild(td);

    return this;
  }
});

/*
  backgrid
  http://github.com/wyuenho/backgrid

  Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
  Licensed under the MIT license.
*/

/**
   HeaderCell is a special cell class that renders a column header cell. If the
   column is sortable, a sorter is also rendered and will trigger a table
   refresh after sorting.

   @class Backgrid.HeaderCell
   @extends Backbone.View
 */
var HeaderCell = Backgrid.HeaderCell = Backbone.View.extend({

  /** @property */
  tagName: "th",

  /** @property */
  events: {
    "click a": "onClick"
  },

  /**
     Initializer.

     @param {Object} options
     @param {Backgrid.Column|Object} options.column

     @throws {TypeError} If options.column or options.collection is undefined.
   */
  initialize: function (options) {
    this.column = options.column;
    if (!(this.column instanceof Column)) {
      this.column = new Column(this.column);
    }

    var column = this.column, collection = this.collection, $el = this.$el;

    this.listenTo(column, "change:editable change:sortable change:renderable",
                  function (column) {
                    var changed = column.changedAttributes();
                    for (var key in changed) {
                      if (changed.hasOwnProperty(key)) {
                        $el.toggleClass(key, changed[key]);
                      }
                    }
                  });
    this.listenTo(column, "change:direction", this.setCellDirection);
    this.listenTo(column, "change:name change:label", this.render);

    if (Backgrid.callByNeed(column.editable(), column, collection)) $el.addClass("editable");
    if (Backgrid.callByNeed(column.sortable(), column, collection)) $el.addClass("sortable");
    if (Backgrid.callByNeed(column.renderable(), column, collection)) $el.addClass("renderable");

    this.listenTo(collection.fullCollection || collection, "sort", this.removeCellDirection);
  },

  /**
     Event handler for the collection's `sort` event. Removes all the CSS
     direction classes.
   */
  removeCellDirection: function () {
    this.$el.removeClass("ascending").removeClass("descending");
    this.column.set("direction", null);
  },

  /**
     Event handler for the column's `change:direction` event. If this
     HeaderCell's column is being sorted on, it applies the direction given as a
     CSS class to the header cell. Removes all the CSS direction classes
     otherwise.
   */
  setCellDirection: function (column, direction) {
    this.$el.removeClass("ascending").removeClass("descending");
    if (column.cid == this.column.cid) this.$el.addClass(direction);
  },

  /**
     Event handler for the `click` event on the cell's anchor. If the column is
     sortable, clicking on the anchor will cycle through 3 sorting orderings -
     `ascending`, `descending`, and default.
   */
  onClick: function (e) {
    e.preventDefault();

    var column = this.column;
    var collection = this.collection;
    var event = "backgrid:sort";

    function cycleSort(header, col) {
      if (column.get("direction") === "ascending") collection.trigger(event, col, "descending");
      else if (column.get("direction") === "descending") collection.trigger(event, col, null);
      else collection.trigger(event, col, "ascending");
    }

    function toggleSort(header, col) {
      if (column.get("direction") === "ascending") collection.trigger(event, col, "descending");
      else collection.trigger(event, col, "ascending");
    }

    var sortable = Backgrid.callByNeed(column.sortable(), column, this.collection);
    if (sortable) {
      var sortType = column.get("sortType");
      if (sortType === "toggle") toggleSort(this, column);
      else cycleSort(this, column);
    }
  },

  /**
     Renders a header cell with a sorter, a label, and a class name for this
     column.
   */
  render: function () {
    this.$el.empty();
    var column = this.column;
    var sortable = Backgrid.callByNeed(column.sortable(), column, this.collection);
    var label;
    if(sortable){
      label = $("<a>").text(column.get("label")).append("<b class='sort-caret'></b>");
    } else {
      label = document.createTextNode(column.get("label"));
    }

    this.$el.append(label);
    this.$el.addClass(column.get("name"));
    this.$el.addClass(column.get("direction"));
    this.delegateEvents();
    return this;
  }

});

/**
   HeaderRow is a controller for a row of header cells.

   @class Backgrid.HeaderRow
   @extends Backgrid.Row
 */
var HeaderRow = Backgrid.HeaderRow = Backgrid.Row.extend({

  requiredOptions: ["columns", "collection"],

  /**
     Initializer.

     @param {Object} options
     @param {Backbone.Collection.<Backgrid.Column>|Array.<Backgrid.Column>|Array.<Object>} options.columns
     @param {Backgrid.HeaderCell} [options.headerCell] Customized default
     HeaderCell for all the columns. Supply a HeaderCell class or instance to a
     the `headerCell` key in a column definition for column-specific header
     rendering.

     @throws {TypeError} If options.columns or options.collection is undefined.
   */
  initialize: function () {
    Backgrid.Row.prototype.initialize.apply(this, arguments);
  },

  makeCell: function (column, options) {
    var headerCell = column.get("headerCell") || options.headerCell || HeaderCell;
    headerCell = new headerCell({
      column: column,
      collection: this.collection
    });
    return headerCell;
  }

});

/**
   Header is a special structural view class that renders a table head with a
   single row of header cells.

   @class Backgrid.Header
   @extends Backbone.View
 */
var Header = Backgrid.Header = Backbone.View.extend({

  /** @property */
  tagName: "thead",

  /**
     Initializer. Initializes this table head view to contain a single header
     row view.

     @param {Object} options
     @param {Backbone.Collection.<Backgrid.Column>|Array.<Backgrid.Column>|Array.<Object>} options.columns Column metadata.
     @param {Backbone.Model} options.model The model instance to render.

     @throws {TypeError} If options.columns or options.model is undefined.
   */
  initialize: function (options) {
    this.columns = options.columns;
    if (!(this.columns instanceof Backbone.Collection)) {
      this.columns = new Columns(this.columns);
    }

    this.row = new Backgrid.HeaderRow({
      columns: this.columns,
      collection: this.collection
    });
  },

  /**
     Renders this table head with a single row of header cells.
   */
  render: function () {
    this.$el.append(this.row.render().$el);
    this.delegateEvents();
    return this;
  },

  /**
     Clean up this header and its row.

     @chainable
   */
  remove: function () {
    this.row.remove.apply(this.row, arguments);
    return Backbone.View.prototype.remove.apply(this, arguments);
  }

});

/*
  backgrid
  http://github.com/wyuenho/backgrid

  Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
  Licensed under the MIT license.
*/

/**
   Body is the table body which contains the rows inside a table. Body is
   responsible for refreshing the rows after sorting, insertion and removal.

   @class Backgrid.Body
   @extends Backbone.View
*/
var Body = Backgrid.Body = Backbone.View.extend({

  /** @property */
  tagName: "tbody",

  /**
     Initializer.

     @param {Object} options
     @param {Backbone.Collection} options.collection
     @param {Backbone.Collection.<Backgrid.Column>|Array.<Backgrid.Column>|Array.<Object>} options.columns
     Column metadata.
     @param {Backgrid.Row} [options.row=Backgrid.Row] The Row class to use.
     @param {string|function(): string} [options.emptyText] The text to display in the empty row.

     @throws {TypeError} If options.columns or options.collection is undefined.

     See Backgrid.Row.
  */
  initialize: function (options) {

    this.columns = options.columns;
    if (!(this.columns instanceof Backbone.Collection)) {
      this.columns = new Columns(this.columns);
    }

    this.row = options.row || Row;
    this.rows = this.collection.map(function (model) {
      var row = new this.row({
        columns: this.columns,
        model: model
      });

      return row;
    }, this);

    this.emptyText = options.emptyText;
    this._unshiftEmptyRowMayBe();

    var collection = this.collection;
    this.listenTo(collection, "add", this.insertRow);
    this.listenTo(collection, "remove", this.removeRow);
    this.listenTo(collection, "sort", this.refresh);
    this.listenTo(collection, "reset", this.refresh);
    this.listenTo(collection, "backgrid:sort", this.sort);
    this.listenTo(collection, "backgrid:edited", this.moveToNextCell);
  },

  _unshiftEmptyRowMayBe: function () {
    if (this.rows.length === 0 && this.emptyText != null) {
      this.rows.unshift(new EmptyRow({
        emptyText: this.emptyText,
        columns: this.columns
      }));
    }
  },

  /**
     This method can be called either directly or as a callback to a
     [Backbone.Collecton#add](http://backbonejs.org/#Collection-add) event.

     When called directly, it accepts a model or an array of models and an
     option hash just like
     [Backbone.Collection#add](http://backbonejs.org/#Collection-add) and
     delegates to it. Once the model is added, a new row is inserted into the
     body and automatically rendered.

     When called as a callback of an `add` event, splices a new row into the
     body and renders it.

     @param {Backbone.Model} model The model to render as a row.
     @param {Backbone.Collection} collection When called directly, this
     parameter is actually the options to
     [Backbone.Collection#add](http://backbonejs.org/#Collection-add).
     @param {Object} options When called directly, this must be null.

     See:

     - [Backbone.Collection#add](http://backbonejs.org/#Collection-add)
  */
  insertRow: function (model, collection, options) {

    if (this.rows[0] instanceof EmptyRow) this.rows.pop().remove();

    // insertRow() is called directly
    if (!(collection instanceof Backbone.Collection) && !options) {
      this.collection.add(model, (options = collection));
      return;
    }

    var row = new this.row({
      columns: this.columns,
      model: model
    });

    var index = collection.indexOf(model);
    this.rows.splice(index, 0, row);

    var $el = this.$el;
    var $children = $el.children();
    var $rowEl = row.render().$el;

    if (index >= $children.length) {
      $el.append($rowEl);
    }
    else {
      $children.eq(index).before($rowEl);
    }

    return this;
  },

  /**
     The method can be called either directly or as a callback to a
     [Backbone.Collection#remove](http://backbonejs.org/#Collection-remove)
     event.

     When called directly, it accepts a model or an array of models and an
     option hash just like
     [Backbone.Collection#remove](http://backbonejs.org/#Collection-remove) and
     delegates to it. Once the model is removed, a corresponding row is removed
     from the body.

     When called as a callback of a `remove` event, splices into the rows and
     removes the row responsible for rendering the model.

     @param {Backbone.Model} model The model to remove from the body.
     @param {Backbone.Collection} collection When called directly, this
     parameter is actually the options to
     [Backbone.Collection#remove](http://backbonejs.org/#Collection-remove).
     @param {Object} options When called directly, this must be null.

     See:

     - [Backbone.Collection#remove](http://backbonejs.org/#Collection-remove)
  */
  removeRow: function (model, collection, options) {

    // removeRow() is called directly
    if (!options) {
      this.collection.remove(model, (options = collection));
      this._unshiftEmptyRowMayBe();
      return;
    }

    if (_.isUndefined(options.render) || options.render) {
      this.rows[options.index].remove();
    }

    this.rows.splice(options.index, 1);
    this._unshiftEmptyRowMayBe();

    return this;
  },

  /**
     Reinitialize all the rows inside the body and re-render them. Triggers a
     Backbone `backgrid:refresh` event from the collection along with the body
     instance as its sole parameter when done.
  */
  refresh: function () {
    for (var i = 0; i < this.rows.length; i++) {
      this.rows[i].remove();
    }

    this.rows = this.collection.map(function (model) {
      var row = new this.row({
        columns: this.columns,
        model: model
      });

      return row;
    }, this);
    this._unshiftEmptyRowMayBe();

    this.render();

    this.collection.trigger("backgrid:refresh", this);

    return this;
  },

  /**
     Renders all the rows inside this body. If the collection is empty and
     `options.emptyText` is defined and not null in the constructor, an empty
     row is rendered, otherwise no row is rendered.
  */
  render: function () {
    this.$el.empty();

    var fragment = document.createDocumentFragment();
    for (var i = 0; i < this.rows.length; i++) {
      var row = this.rows[i];
      fragment.appendChild(row.render().el);
    }

    this.el.appendChild(fragment);

    this.delegateEvents();

    return this;
  },

  /**
     Clean up this body and it's rows.

     @chainable
  */
  remove: function () {
    for (var i = 0; i < this.rows.length; i++) {
      var row = this.rows[i];
      row.remove.apply(row, arguments);
    }
    return Backbone.View.prototype.remove.apply(this, arguments);
  },

  /**
     If the underlying collection is a Backbone.PageableCollection in
     server-mode or infinite-mode, a page of models is fetched after sorting is
     done on the server.

     If the underlying collection is a Backbone.PageableCollection in
     client-mode, or any
     [Backbone.Collection](http://backbonejs.org/#Collection) instance, sorting
     is done on the client side. If the collection is an instance of a
     Backbone.PageableCollection, sorting will be done globally on all the pages
     and the current page will then be returned.

     Triggers a Backbone `backgrid:sorted` event from the collection when done
     with the column, direction and a reference to the collection.

     @param {Backgrid.Column} column
     @param {null|"ascending"|"descending"} direction

     See [Backbone.Collection#comparator](http://backbonejs.org/#Collection-comparator)
  */
  sort: function (column, direction) {

    if (!_.contains(["ascending", "descending", null], direction)) {
      throw new RangeError('direction must be one of "ascending", "descending" or `null`');
    }

    if (_.isString(column)) column = this.columns.findWhere({name: column});

    var collection = this.collection;

    var order;
    if (direction === "ascending") order = -1;
    else if (direction === "descending") order = 1;
    else order = null;

    var comparator = this.makeComparator(column.get("name"), order,
                                         order ?
                                         column.sortValue() :
                                         function (model) {
                                           return model.cid.replace('c', '') * 1;
                                         });

    if (Backbone.PageableCollection &&
        collection instanceof Backbone.PageableCollection) {

      collection.setSorting(order && column.get("name"), order,
                            {sortValue: column.sortValue()});

      if (collection.fullCollection) {
        // If order is null, pageable will remove the comparator on both sides,
        // in this case the default insertion order comparator needs to be
        // attached to get back to the order before sorting.
        if (collection.fullCollection.comparator == null) {
          collection.fullCollection.comparator = comparator;
        }
        collection.fullCollection.sort();
        collection.trigger("backgrid:sorted", column, direction, collection);
      }
      else collection.fetch({reset: true, success: function () {
        collection.trigger("backgrid:sorted", column, direction, collection);
      }});
    }
    else {
      collection.comparator = comparator;
      collection.sort();
      collection.trigger("backgrid:sorted", column, direction, collection);
    }

    column.set("direction", direction);

    return this;
  },

  makeComparator: function (attr, order, func) {

    return function (left, right) {
      // extract the values from the models
      var l = func(left, attr), r = func(right, attr), t;

      // if descending order, swap left and right
      if (order === 1) t = l, l = r, r = t;

      // compare as usual
      if (l === r) return 0;
      else if (l < r) return -1;
      return 1;
    };
  },

  /**
     Moves focus to the next renderable and editable cell and return the
     currently editing cell to display mode.

     Triggers a `backgrid:next` event on the model with the indices of the row
     and column the user *intended* to move to, and whether the intended move
     was going to go out of bounds. Note that *out of bound* always means an
     attempt to go past the end of the last row.

     @param {Backbone.Model} model The originating model
     @param {Backgrid.Column} column The originating model column
     @param {Backgrid.Command} command The Command object constructed from a DOM
     event
  */
  moveToNextCell: function (model, column, command) {
    var i = this.collection.indexOf(model);
    var j = this.columns.indexOf(column);
    var cell, renderable, editable, m, n;

    this.rows[i].cells[j].exitEditMode();

    if (command.moveUp() || command.moveDown() || command.moveLeft() ||
        command.moveRight() || command.save()) {
      var l = this.columns.length;
      var maxOffset = l * this.collection.length;

      if (command.moveUp() || command.moveDown()) {
        m = i + (command.moveUp() ? -1 : 1);
        var row = this.rows[m];
        if (row) {
          cell = row.cells[j];
          if (Backgrid.callByNeed(cell.column.editable(), cell.column, model)) {
            cell.enterEditMode();
            model.trigger("backgrid:next", m, j, false);
          }
        }
        else model.trigger("backgrid:next", m, j, true);
      }
      else if (command.moveLeft() || command.moveRight()) {
        var right = command.moveRight();
        for (var offset = i * l + j + (right ? 1 : -1);
             offset >= 0 && offset < maxOffset;
             right ? offset++ : offset--) {
          m = ~~(offset / l);
          n = offset - m * l;
          cell = this.rows[m].cells[n];
          renderable = Backgrid.callByNeed(cell.column.renderable(), cell.column, cell.model);
          editable = Backgrid.callByNeed(cell.column.editable(), cell.column, model);
          if (renderable && editable) {
            cell.enterEditMode();
            model.trigger("backgrid:next", m, n, false);
            break;
          }
        }

        if (offset == maxOffset) {
          model.trigger("backgrid:next", ~~(offset / l), offset - m * l, true);
        }
      }
    }

    return this;
  }
});

/*
  backgrid
  http://github.com/wyuenho/backgrid

  Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
  Licensed under the MIT license.
*/

/**
   A Footer is a generic class that only defines a default tag `tfoot` and
   number of required parameters in the initializer.

   @abstract
   @class Backgrid.Footer
   @extends Backbone.View
 */
var Footer = Backgrid.Footer = Backbone.View.extend({

  /** @property */
  tagName: "tfoot",

  /**
     Initializer.

     @param {Object} options
     @param {Backbone.Collection.<Backgrid.Column>|Array.<Backgrid.Column>|Array.<Object>} options.columns
     Column metadata.
     @param {Backbone.Collection} options.collection

     @throws {TypeError} If options.columns or options.collection is undefined.
  */
  initialize: function (options) {
    this.columns = options.columns;
    if (!(this.columns instanceof Backbone.Collection)) {
      this.columns = new Backgrid.Columns(this.columns);
    }
  }

});

/*
  backgrid
  http://github.com/wyuenho/backgrid

  Copyright (c) 2013 Jimmy Yuen Ho Wong and contributors
  Licensed under the MIT license.
*/

/**
   Grid represents a data grid that has a header, body and an optional footer.

   By default, a Grid treats each model in a collection as a row, and each
   attribute in a model as a column. To render a grid you must provide a list of
   column metadata and a collection to the Grid constructor. Just like any
   Backbone.View class, the grid is rendered as a DOM node fragment when you
   call render().

       var grid = Backgrid.Grid({
         columns: [{ name: "id", label: "ID", type: "string" },
          // ...
         ],
         collections: books
       });

       $("#table-container").append(grid.render().el);

   Optionally, if you want to customize the rendering of the grid's header and
   footer, you may choose to extend Backgrid.Header and Backgrid.Footer, and
   then supply that class or an instance of that class to the Grid constructor.
   See the documentation for Header and Footer for further details.

       var grid = Backgrid.Grid({
         columns: [{ name: "id", label: "ID", type: "string" }],
         collections: books,
         header: Backgrid.Header.extend({
              //...
         }),
         footer: Backgrid.Paginator
       });

   Finally, if you want to override how the rows are rendered in the table body,
   you can supply a Body subclass as the `body` attribute that uses a different
   Row class.

   @class Backgrid.Grid
   @extends Backbone.View

   See:

   - Backgrid.Column
   - Backgrid.Header
   - Backgrid.Body
   - Backgrid.Row
   - Backgrid.Footer
*/
var Grid = Backgrid.Grid = Backbone.View.extend({

  /** @property */
  tagName: "table",

  /** @property */
  className: "backgrid",

  /** @property */
  header: Header,

  /** @property */
  body: Body,

  /** @property */
  footer: null,

  /**
     Initializes a Grid instance.

     @param {Object} options
     @param {Backbone.Collection.<Backgrid.Columns>|Array.<Backgrid.Column>|Array.<Object>} options.columns Column metadata.
     @param {Backbone.Collection} options.collection The collection of tabular model data to display.
     @param {Backgrid.Header} [options.header=Backgrid.Header] An optional Header class to override the default.
     @param {Backgrid.Body} [options.body=Backgrid.Body] An optional Body class to override the default.
     @param {Backgrid.Row} [options.row=Backgrid.Row] An optional Row class to override the default.
     @param {Backgrid.Footer} [options.footer=Backgrid.Footer] An optional Footer class.
   */
  initialize: function (options) {
    // Convert the list of column objects here first so the subviews don't have
    // to.
    if (!(options.columns instanceof Backbone.Collection)) {
      options.columns = new Columns(options.columns);
    }
    this.columns = options.columns;

    var filteredOptions = _.omit(options, ["el", "id", "attributes",
                                           "className", "tagName", "events"]);

    // must construct body first so it listens to backgrid:sort first
    this.body = options.body || this.body;
    this.body = new this.body(filteredOptions);

    this.header = options.header || this.header;
    if (this.header) {
      this.header = new this.header(filteredOptions);
    }

    this.footer = options.footer || this.footer;
    if (this.footer) {
      this.footer = new this.footer(filteredOptions);
    }

    this.listenTo(this.columns, "reset", function () {
      if (this.header) {
        this.header = new (this.header.remove().constructor)(filteredOptions);
      }
      this.body = new (this.body.remove().constructor)(filteredOptions);
      if (this.footer) {
        this.footer = new (this.footer.remove().constructor)(filteredOptions);
      }
      this.render();
    });
  },

  /**
     Delegates to Backgrid.Body#insertRow.
   */
  insertRow: function () {
    this.body.insertRow.apply(this.body, arguments);
    return this;
  },

  /**
     Delegates to Backgrid.Body#removeRow.
   */
  removeRow: function () {
    this.body.removeRow.apply(this.body, arguments);
    return this;
  },

  /**
     Delegates to Backgrid.Columns#add for adding a column. Subviews can listen
     to the `add` event from their internal `columns` if rerendering needs to
     happen.

     @param {Object} [options] Options for `Backgrid.Columns#add`.
   */
  insertColumn: function () {
    this.columns.add.apply(this.columns, arguments);
    return this;
  },

  /**
     Delegates to Backgrid.Columns#remove for removing a column. Subviews can
     listen to the `remove` event from the internal `columns` if rerendering
     needs to happen.

     @param {Object} [options] Options for `Backgrid.Columns#remove`.
   */
  removeColumn: function () {
    this.columns.remove.apply(this.columns, arguments);
    return this;
  },

  /**
     Delegates to Backgrid.Body#sort.
   */
  sort: function () {
    this.body.sort.apply(this.body, arguments);
    return this;
  },

  /**
     Renders the grid's header, then footer, then finally the body. Triggers a
     Backbone `backgrid:rendered` event along with a reference to the grid when
     the it has successfully been rendered.
   */
  render: function () {
    this.$el.empty();

    if (this.header) {
      this.$el.append(this.header.render().$el);
    }

    if (this.footer) {
      this.$el.append(this.footer.render().$el);
    }

    this.$el.append(this.body.render().$el);

    this.delegateEvents();

    this.trigger("backgrid:rendered", this);

    return this;
  },

  /**
     Clean up this grid and its subviews.

     @chainable
   */
  remove: function () {
    this.header && this.header.remove.apply(this.header, arguments);
    this.body.remove.apply(this.body, arguments);
    this.footer && this.footer.remove.apply(this.footer, arguments);
    return Backbone.View.prototype.remove.apply(this, arguments);
  }

});
  return Backgrid;
}));
},{"backbone":19,"jquery":25,"underscore":24}],24:[function(require,module,exports){
//     Underscore.js 1.5.2
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.5.2';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? void 0 : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed > result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array, using the modern version of the 
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from an array.
  // If **n** is not specified, returns a single random element from the array.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (arguments.length < 2 || guard) {
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, value, context) {
      var result = {};
      var iterator = value == null ? _.identity : lookupIterator(value);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n == null) || guard ? array[0] : slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) {
      return array[array.length - 1];
    } else {
      return slice.call(array, Math.max(array.length - n, 0));
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, "length").concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error("bindAll must be passed function names");
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;
    return function() {
      context = this;
      args = arguments;
      timestamp = new Date();
      var later = function() {
        var last = (new Date()) - timestamp;
        if (last < wait) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) result = func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

},{}],25:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.1.1
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-05-01T17:11Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper window is present,
		// execute the factory and get jQuery
		// For environments that do not inherently posses a window with a document
		// (such as Node.js), expose a jQuery-making factory as module.exports
		// This accentuates the need for the creation of a real window
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Can't do this because several apps including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
// Support: Firefox 18+
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		return !jQuery.isArray( obj ) && obj - parseFloat( obj ) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android < 4.0, iOS < 6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v1.10.19
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-04-18
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + -(new Date()),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	strundefined = typeof undefined,
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf if we can't use a native one
	indexOf = arr.indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {
		return [];
	}

	if ( documentIsHTML && !seed ) {

		// Shortcuts
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType === 9 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== strundefined && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare,
		doc = node ? node.ownerDocument || node : preferredDoc,
		parent = doc.defaultView;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;

	// Support tests
	documentIsHTML = !isXML( doc );

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", function() {
				setDocument();
			}, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", function() {
				setDocument();
			});
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Check if getElementsByClassName can be trusted
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName ) && assert(function( div ) {
		div.innerHTML = "<div class='a'></div><div class='a i'></div>";

		// Support: Safari<4
		// Catch class over-caching
		div.firstChild.className = "i";
		// Support: Opera<10
		// Catch gEBCN failure to find non-leading classes
		return div.getElementsByClassName("i").length === 2;
	});

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== strundefined && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== strundefined ) {
				return context.getElementsByTagName( tag );
			}
		} :
		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select msallowclip=''><option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowclip^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch(e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome<14
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android < 4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Math.random();
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android < 4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



/*
	Implementation Summary

	1. Enforce API surface and semantic compatibility with 1.9.x branch
	2. Improve the module's maintainability by reducing the storage
		paths to a single mechanism.
	3. Use the same single mechanism to support "private" and "user" data.
	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	5. Avoid exposing implementation details on user objects (eg. expando properties)
	6. Provide a clear path for implementation upgrade to WeakMap in 2014
*/
var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// #11217 - WebKit loses check when the name is after the checked attribute
	// Support: Windows Web Apps (WWA)
	// `name` and `type` need .setAttribute for WWA
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3
	// old WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Make sure textarea (and checkbox) defaultValue is properly cloned
	// Support: IE9-IE11+
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome < 28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android < 4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Create "bubbling" focus and blur events
// Support: Firefox, Chrome, Safari
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE 9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE 9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Support: IE >= 9
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Support: IE >= 9
		// Fix Cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit
					// jQuery.merge because push.apply(_, arraylike) throws
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Fixes #12346
					// Support: Webkit, IE
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optmization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') in IE9, see #12537
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due to missing dependency),
				// remove it.
				// Since there are no other hooks for marginRight, remove the whole object.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.

			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {
				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {
				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set. See: #7116
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Fixes #8908, it can be done more correctly by specifying setters in cssHooks,
			// but it would mean to define eight (for every problematic property) identical functions
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// Work around by temporarily setting element display to inline-block
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*
					// Use a string for doubling factor so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur()
				// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// we're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// enable finishing flag on private data
			data.finish = true;

			// empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS 5.1, Android 4.x, Android 2.3
	// Check the default checkbox/radio value ("" on old WebKit; "on" elsewhere)
	support.checkOn = input.value !== "";

	// Must access the parent to make an option select properly
	// Support: IE9, IE10
	support.optSelected = opt.selected;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Check if an input maintains its value after becoming a radio
	// Support: IE9, IE10
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to default in case type is set after value during creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

// Support: IE9+
// Selectedness for an option in an optgroup can be inaccurate
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed "false",
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			// Support: Webkit
			// "" is returned instead of "on" if a value isn't specified
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat("*");

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
if ( window.ActiveXObject ) {
	jQuery( window ).on( "unload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// If we don't have gBCR, just use 0,0 rather than error
		// BlackBerry 5, iOS 3 (original iPhone)
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// We assume that getBoundingClientRect is available when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// getComputedStyle returns percent when specified for top/left/bottom/right
// rather than make the css module depend on the offset module, we just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// if curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],26:[function(require,module,exports){
(function (global){
//! moment.js
//! version : 2.8.4
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (undefined) {
    /************************************
        Constants
    ************************************/

    var moment,
        VERSION = '2.8.4',
        // the global-scope this is NOT the global object in Node.js
        globalScope = typeof global !== 'undefined' ? global : this,
        oldGlobalMoment,
        round = Math.round,
        hasOwnProperty = Object.prototype.hasOwnProperty,
        i,

        YEAR = 0,
        MONTH = 1,
        DATE = 2,
        HOUR = 3,
        MINUTE = 4,
        SECOND = 5,
        MILLISECOND = 6,

        // internal storage for locale config files
        locales = {},

        // extra moment internal properties (plugins register props here)
        momentProperties = [],

        // check for nodeJS
        hasModule = (typeof module !== 'undefined' && module && module.exports),

        // ASP.NET json date format regex
        aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
        aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/,

        // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
        // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
        isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/,

        // format tokens
        formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g,
        localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,

        // parsing token regexes
        parseTokenOneOrTwoDigits = /\d\d?/, // 0 - 99
        parseTokenOneToThreeDigits = /\d{1,3}/, // 0 - 999
        parseTokenOneToFourDigits = /\d{1,4}/, // 0 - 9999
        parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, // -999,999 - 999,999
        parseTokenDigits = /\d+/, // nonzero number of digits
        parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, // any word (or two) characters or numbers including two/three word month in arabic.
        parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
        parseTokenT = /T/i, // T (ISO separator)
        parseTokenOffsetMs = /[\+\-]?\d+/, // 1234567890123
        parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123

        //strict parsing regexes
        parseTokenOneDigit = /\d/, // 0 - 9
        parseTokenTwoDigits = /\d\d/, // 00 - 99
        parseTokenThreeDigits = /\d{3}/, // 000 - 999
        parseTokenFourDigits = /\d{4}/, // 0000 - 9999
        parseTokenSixDigits = /[+-]?\d{6}/, // -999,999 - 999,999
        parseTokenSignedNumber = /[+-]?\d+/, // -inf - inf

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,

        isoFormat = 'YYYY-MM-DDTHH:mm:ssZ',

        isoDates = [
            ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
            ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
            ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
            ['GGGG-[W]WW', /\d{4}-W\d{2}/],
            ['YYYY-DDD', /\d{4}-\d{3}/]
        ],

        // iso time formats and regexes
        isoTimes = [
            ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
            ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
            ['HH:mm', /(T| )\d\d:\d\d/],
            ['HH', /(T| )\d\d/]
        ],

        // timezone chunker '+10:00' > ['10', '00'] or '-1530' > ['-15', '30']
        parseTimezoneChunker = /([\+\-]|\d\d)/gi,

        // getter and setter names
        proxyGettersAndSetters = 'Date|Hours|Minutes|Seconds|Milliseconds'.split('|'),
        unitMillisecondFactors = {
            'Milliseconds' : 1,
            'Seconds' : 1e3,
            'Minutes' : 6e4,
            'Hours' : 36e5,
            'Days' : 864e5,
            'Months' : 2592e6,
            'Years' : 31536e6
        },

        unitAliases = {
            ms : 'millisecond',
            s : 'second',
            m : 'minute',
            h : 'hour',
            d : 'day',
            D : 'date',
            w : 'week',
            W : 'isoWeek',
            M : 'month',
            Q : 'quarter',
            y : 'year',
            DDD : 'dayOfYear',
            e : 'weekday',
            E : 'isoWeekday',
            gg: 'weekYear',
            GG: 'isoWeekYear'
        },

        camelFunctions = {
            dayofyear : 'dayOfYear',
            isoweekday : 'isoWeekday',
            isoweek : 'isoWeek',
            weekyear : 'weekYear',
            isoweekyear : 'isoWeekYear'
        },

        // format function strings
        formatFunctions = {},

        // default relative time thresholds
        relativeTimeThresholds = {
            s: 45,  // seconds to minute
            m: 45,  // minutes to hour
            h: 22,  // hours to day
            d: 26,  // days to month
            M: 11   // months to year
        },

        // tokens to ordinalize and pad
        ordinalizeTokens = 'DDD w W M D d'.split(' '),
        paddedTokens = 'M D H h m s w W'.split(' '),

        formatTokenFunctions = {
            M    : function () {
                return this.month() + 1;
            },
            MMM  : function (format) {
                return this.localeData().monthsShort(this, format);
            },
            MMMM : function (format) {
                return this.localeData().months(this, format);
            },
            D    : function () {
                return this.date();
            },
            DDD  : function () {
                return this.dayOfYear();
            },
            d    : function () {
                return this.day();
            },
            dd   : function (format) {
                return this.localeData().weekdaysMin(this, format);
            },
            ddd  : function (format) {
                return this.localeData().weekdaysShort(this, format);
            },
            dddd : function (format) {
                return this.localeData().weekdays(this, format);
            },
            w    : function () {
                return this.week();
            },
            W    : function () {
                return this.isoWeek();
            },
            YY   : function () {
                return leftZeroFill(this.year() % 100, 2);
            },
            YYYY : function () {
                return leftZeroFill(this.year(), 4);
            },
            YYYYY : function () {
                return leftZeroFill(this.year(), 5);
            },
            YYYYYY : function () {
                var y = this.year(), sign = y >= 0 ? '+' : '-';
                return sign + leftZeroFill(Math.abs(y), 6);
            },
            gg   : function () {
                return leftZeroFill(this.weekYear() % 100, 2);
            },
            gggg : function () {
                return leftZeroFill(this.weekYear(), 4);
            },
            ggggg : function () {
                return leftZeroFill(this.weekYear(), 5);
            },
            GG   : function () {
                return leftZeroFill(this.isoWeekYear() % 100, 2);
            },
            GGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 4);
            },
            GGGGG : function () {
                return leftZeroFill(this.isoWeekYear(), 5);
            },
            e : function () {
                return this.weekday();
            },
            E : function () {
                return this.isoWeekday();
            },
            a    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), true);
            },
            A    : function () {
                return this.localeData().meridiem(this.hours(), this.minutes(), false);
            },
            H    : function () {
                return this.hours();
            },
            h    : function () {
                return this.hours() % 12 || 12;
            },
            m    : function () {
                return this.minutes();
            },
            s    : function () {
                return this.seconds();
            },
            S    : function () {
                return toInt(this.milliseconds() / 100);
            },
            SS   : function () {
                return leftZeroFill(toInt(this.milliseconds() / 10), 2);
            },
            SSS  : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            SSSS : function () {
                return leftZeroFill(this.milliseconds(), 3);
            },
            Z    : function () {
                var a = -this.zone(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + ':' + leftZeroFill(toInt(a) % 60, 2);
            },
            ZZ   : function () {
                var a = -this.zone(),
                    b = '+';
                if (a < 0) {
                    a = -a;
                    b = '-';
                }
                return b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2);
            },
            z : function () {
                return this.zoneAbbr();
            },
            zz : function () {
                return this.zoneName();
            },
            x    : function () {
                return this.valueOf();
            },
            X    : function () {
                return this.unix();
            },
            Q : function () {
                return this.quarter();
            }
        },

        deprecations = {},

        lists = ['months', 'monthsShort', 'weekdays', 'weekdaysShort', 'weekdaysMin'];

    // Pick the first defined of two or three arguments. dfl comes from
    // default.
    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2: return a != null ? a : b;
            case 3: return a != null ? a : b != null ? b : c;
            default: throw new Error('Implement me');
        }
    }

    function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b);
    }

    function defaultParsingFlags() {
        // We need to deep clone this object, and es5 standard is not very
        // helpful.
        return {
            empty : false,
            unusedTokens : [],
            unusedInput : [],
            overflow : -2,
            charsLeftOver : 0,
            nullInput : false,
            invalidMonth : null,
            invalidFormat : false,
            userInvalidated : false,
            iso: false
        };
    }

    function printMsg(msg) {
        if (moment.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
            if (firstTime) {
                printMsg(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            printMsg(msg);
            deprecations[name] = true;
        }
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count);
        };
    }
    function ordinalizeToken(func, period) {
        return function (a) {
            return this.localeData().ordinal(func.call(this, a), period);
        };
    }

    while (ordinalizeTokens.length) {
        i = ordinalizeTokens.pop();
        formatTokenFunctions[i + 'o'] = ordinalizeToken(formatTokenFunctions[i], i);
    }
    while (paddedTokens.length) {
        i = paddedTokens.pop();
        formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    }
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3);


    /************************************
        Constructors
    ************************************/

    function Locale() {
    }

    // Moment prototype object
    function Moment(config, skipOverflow) {
        if (skipOverflow !== false) {
            checkOverflow(config);
        }
        copyConfig(this, config);
        this._d = new Date(+config._d);
    }

    // Duration Constructor
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = moment.localeData();

        this._bubble();
    }

    /************************************
        Helpers
    ************************************/


    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = from._pf;
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    // left zero fill a number
    // see http://jsperf.com/left-zero-filling for performance comparison
    function leftZeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = makeAs(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = moment.duration(val, period);
            addOrSubtractDurationFromMoment(this, dur, direction);
            return this;
        };
    }

    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            rawSetter(mom, 'Date', rawGetter(mom, 'Date') + days * isAdding);
        }
        if (months) {
            rawMonthSetter(mom, rawGetter(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            moment.updateOffset(mom, days || months);
        }
    }

    // check if is an array
    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return Object.prototype.toString.call(input) === '[object Date]' ||
            input instanceof Date;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, '$1');
            units = unitAliases[units] || camelFunctions[lowered] || lowered;
        }
        return units;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeList(field) {
        var count, setter;

        if (field.indexOf('week') === 0) {
            count = 7;
            setter = 'day';
        }
        else if (field.indexOf('month') === 0) {
            count = 12;
            setter = 'month';
        }
        else {
            return;
        }

        moment[field] = function (format, index) {
            var i, getter,
                method = moment._locale[field],
                results = [];

            if (typeof format === 'number') {
                index = format;
                format = undefined;
            }

            getter = function (i) {
                var m = moment().utc().set(setter, i);
                return method.call(moment._locale, m, format || '');
            };

            if (index != null) {
                return getter(index);
            }
            else {
                for (i = 0; i < count; i++) {
                    results.push(getter(i));
                }
                return results;
            }
        };
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    function checkOverflow(m) {
        var overflow;
        if (m._a && m._pf.overflow === -2) {
            overflow =
                m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH :
                m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE :
                m._a[HOUR] < 0 || m._a[HOUR] > 24 ||
                    (m._a[HOUR] === 24 && (m._a[MINUTE] !== 0 ||
                                           m._a[SECOND] !== 0 ||
                                           m._a[MILLISECOND] !== 0)) ? HOUR :
                m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE :
                m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND :
                m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }
    }

    function isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0 &&
                    m._pf.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule) {
            try {
                oldLocale = moment.locale();
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we want to undo that for lazy loaded locales
                moment.locale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function makeAs(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (moment.isMoment(input) || isDate(input) ?
                    +input : +moment(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            moment.updateOffset(res, false);
            return res;
        } else {
            return moment(input).local();
        }
    }

    /************************************
        Locale
    ************************************/


    extend(Locale.prototype, {

        set : function (config) {
            var prop, i;
            for (i in config) {
                prop = config[i];
                if (typeof prop === 'function') {
                    this[i] = prop;
                } else {
                    this['_' + i] = prop;
                }
            }
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _ordinalParseLenient.
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source);
        },

        _months : 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_'),
        months : function (m) {
            return this._months[m.month()];
        },

        _monthsShort : 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_'),
        monthsShort : function (m) {
            return this._monthsShort[m.month()];
        },

        monthsParse : function (monthName, format, strict) {
            var i, mom, regex;

            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }

            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = moment.utc([2000, i]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                    this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
                }
                if (!strict && !this._monthsParse[i]) {
                    regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                    return i;
                } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        },

        _weekdays : 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_'),
        weekdays : function (m) {
            return this._weekdays[m.day()];
        },

        _weekdaysShort : 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
        weekdaysShort : function (m) {
            return this._weekdaysShort[m.day()];
        },

        _weekdaysMin : 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
        weekdaysMin : function (m) {
            return this._weekdaysMin[m.day()];
        },

        weekdaysParse : function (weekdayName) {
            var i, mom, regex;

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                if (!this._weekdaysParse[i]) {
                    mom = moment([2000, 1]).day(i);
                    regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        },

        _longDateFormat : {
            LTS : 'h:mm:ss A',
            LT : 'h:mm A',
            L : 'MM/DD/YYYY',
            LL : 'MMMM D, YYYY',
            LLL : 'MMMM D, YYYY LT',
            LLLL : 'dddd, MMMM D, YYYY LT'
        },
        longDateFormat : function (key) {
            var output = this._longDateFormat[key];
            if (!output && this._longDateFormat[key.toUpperCase()]) {
                output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                    return val.slice(1);
                });
                this._longDateFormat[key] = output;
            }
            return output;
        },

        isPM : function (input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return ((input + '').toLowerCase().charAt(0) === 'p');
        },

        _meridiemParse : /[ap]\.?m?\.?/i,
        meridiem : function (hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        },

        _calendar : {
            sameDay : '[Today at] LT',
            nextDay : '[Tomorrow at] LT',
            nextWeek : 'dddd [at] LT',
            lastDay : '[Yesterday at] LT',
            lastWeek : '[Last] dddd [at] LT',
            sameElse : 'L'
        },
        calendar : function (key, mom, now) {
            var output = this._calendar[key];
            return typeof output === 'function' ? output.apply(mom, [now]) : output;
        },

        _relativeTime : {
            future : 'in %s',
            past : '%s ago',
            s : 'a few seconds',
            m : 'a minute',
            mm : '%d minutes',
            h : 'an hour',
            hh : '%d hours',
            d : 'a day',
            dd : '%d days',
            M : 'a month',
            MM : '%d months',
            y : 'a year',
            yy : '%d years'
        },

        relativeTime : function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return (typeof output === 'function') ?
                output(number, withoutSuffix, string, isFuture) :
                output.replace(/%d/i, number);
        },

        pastFuture : function (diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
        },

        ordinal : function (number) {
            return this._ordinal.replace('%d', number);
        },
        _ordinal : '%d',
        _ordinalParse : /\d{1,2}/,

        preparse : function (string) {
            return string;
        },

        postformat : function (string) {
            return string;
        },

        week : function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        },

        _week : {
            dow : 0, // Sunday is the first day of the week.
            doy : 6  // The week that contains Jan 1st is the first week of the year.
        },

        _invalidDate: 'Invalid date',
        invalidDate: function () {
            return this._invalidDate;
        }
    });

    /************************************
        Formatting
    ************************************/


    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }


    /************************************
        Parsing
    ************************************/


    // get the regex to find the next token
    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
        case 'Q':
            return parseTokenOneDigit;
        case 'DDDD':
            return parseTokenThreeDigits;
        case 'YYYY':
        case 'GGGG':
        case 'gggg':
            return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
        case 'Y':
        case 'G':
        case 'g':
            return parseTokenSignedNumber;
        case 'YYYYYY':
        case 'YYYYY':
        case 'GGGGG':
        case 'ggggg':
            return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
        case 'S':
            if (strict) {
                return parseTokenOneDigit;
            }
            /* falls through */
        case 'SS':
            if (strict) {
                return parseTokenTwoDigits;
            }
            /* falls through */
        case 'SSS':
            if (strict) {
                return parseTokenThreeDigits;
            }
            /* falls through */
        case 'DDD':
            return parseTokenOneToThreeDigits;
        case 'MMM':
        case 'MMMM':
        case 'dd':
        case 'ddd':
        case 'dddd':
            return parseTokenWord;
        case 'a':
        case 'A':
            return config._locale._meridiemParse;
        case 'x':
            return parseTokenOffsetMs;
        case 'X':
            return parseTokenTimestampMs;
        case 'Z':
        case 'ZZ':
            return parseTokenTimezone;
        case 'T':
            return parseTokenT;
        case 'SSSS':
            return parseTokenDigits;
        case 'MM':
        case 'DD':
        case 'YY':
        case 'GG':
        case 'gg':
        case 'HH':
        case 'hh':
        case 'mm':
        case 'ss':
        case 'ww':
        case 'WW':
            return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
        case 'M':
        case 'D':
        case 'd':
        case 'H':
        case 'h':
        case 'm':
        case 's':
        case 'w':
        case 'W':
        case 'e':
        case 'E':
            return parseTokenOneOrTwoDigits;
        case 'Do':
            return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;
        default :
            a = new RegExp(regexpEscape(unescapeFormat(token.replace('\\', '')), 'i'));
            return a;
        }
    }

    function timezoneMinutesFromString(string) {
        string = string || '';
        var possibleTzMatches = (string.match(parseTokenTimezone) || []),
            tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [],
            parts = (tzChunk + '').match(parseTimezoneChunker) || ['-', 0, 0],
            minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? -minutes : minutes;
    }

    // function to convert string input to date
    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;

        switch (token) {
        // QUARTER
        case 'Q':
            if (input != null) {
                datePartArray[MONTH] = (toInt(input) - 1) * 3;
            }
            break;
        // MONTH
        case 'M' : // fall through to MM
        case 'MM' :
            if (input != null) {
                datePartArray[MONTH] = toInt(input) - 1;
            }
            break;
        case 'MMM' : // fall through to MMMM
        case 'MMMM' :
            a = config._locale.monthsParse(input, token, config._strict);
            // if we didn't find a month name, mark the date as invalid.
            if (a != null) {
                datePartArray[MONTH] = a;
            } else {
                config._pf.invalidMonth = input;
            }
            break;
        // DAY OF MONTH
        case 'D' : // fall through to DD
        case 'DD' :
            if (input != null) {
                datePartArray[DATE] = toInt(input);
            }
            break;
        case 'Do' :
            if (input != null) {
                datePartArray[DATE] = toInt(parseInt(
                            input.match(/\d{1,2}/)[0], 10));
            }
            break;
        // DAY OF YEAR
        case 'DDD' : // fall through to DDDD
        case 'DDDD' :
            if (input != null) {
                config._dayOfYear = toInt(input);
            }

            break;
        // YEAR
        case 'YY' :
            datePartArray[YEAR] = moment.parseTwoDigitYear(input);
            break;
        case 'YYYY' :
        case 'YYYYY' :
        case 'YYYYYY' :
            datePartArray[YEAR] = toInt(input);
            break;
        // AM / PM
        case 'a' : // fall through to A
        case 'A' :
            config._isPm = config._locale.isPM(input);
            break;
        // HOUR
        case 'h' : // fall through to hh
        case 'hh' :
            config._pf.bigHour = true;
            /* falls through */
        case 'H' : // fall through to HH
        case 'HH' :
            datePartArray[HOUR] = toInt(input);
            break;
        // MINUTE
        case 'm' : // fall through to mm
        case 'mm' :
            datePartArray[MINUTE] = toInt(input);
            break;
        // SECOND
        case 's' : // fall through to ss
        case 'ss' :
            datePartArray[SECOND] = toInt(input);
            break;
        // MILLISECOND
        case 'S' :
        case 'SS' :
        case 'SSS' :
        case 'SSSS' :
            datePartArray[MILLISECOND] = toInt(('0.' + input) * 1000);
            break;
        // UNIX OFFSET (MILLISECONDS)
        case 'x':
            config._d = new Date(toInt(input));
            break;
        // UNIX TIMESTAMP WITH MS
        case 'X':
            config._d = new Date(parseFloat(input) * 1000);
            break;
        // TIMEZONE
        case 'Z' : // fall through to ZZ
        case 'ZZ' :
            config._useUTC = true;
            config._tzm = timezoneMinutesFromString(input);
            break;
        // WEEKDAY - human
        case 'dd':
        case 'ddd':
        case 'dddd':
            a = config._locale.weekdaysParse(input);
            // if we didn't get a weekday name, mark the date as invalid
            if (a != null) {
                config._w = config._w || {};
                config._w['d'] = a;
            } else {
                config._pf.invalidWeekday = input;
            }
            break;
        // WEEK, WEEK DAY - numeric
        case 'w':
        case 'ww':
        case 'W':
        case 'WW':
        case 'd':
        case 'e':
        case 'E':
            token = token.substr(0, 1);
            /* falls through */
        case 'gggg':
        case 'GGGG':
        case 'GGGGG':
            token = token.substr(0, 2);
            if (input) {
                config._w = config._w || {};
                config._w[token] = toInt(input);
            }
            break;
        case 'gg':
        case 'GG':
            config._w = config._w || {};
            config._w[token] = moment.parseTwoDigitYear(input);
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year);
            week = dfl(w.W, 1);
            weekday = dfl(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year);
            week = dfl(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function dateFromConfig(config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = dfl(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = makeUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input);
        // Apply timezone offset from input. The actual zone can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() + config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dateFromObject(config) {
        var normalizedInput;

        if (config._d) {
            return;
        }

        normalizedInput = normalizeObjectUnits(config._i);
        config._a = [
            normalizedInput.year,
            normalizedInput.month,
            normalizedInput.day || normalizedInput.date,
            normalizedInput.hour,
            normalizedInput.minute,
            normalizedInput.second,
            normalizedInput.millisecond
        ];

        dateFromConfig(config);
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [
                now.getUTCFullYear(),
                now.getUTCMonth(),
                now.getUTCDate()
            ];
        } else {
            return [now.getFullYear(), now.getMonth(), now.getDate()];
        }
    }

    // date from string and format string
    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601) {
            parseISO(config);
            return;
        }

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
            config._pf.bigHour = undefined;
        }
        // handle am pm
        if (config._isPm && config._a[HOUR] < 12) {
            config._a[HOUR] += 12;
        }
        // if is 12 am, change hours to 0
        if (config._isPm === false && config._a[HOUR] === 12) {
            config._a[HOUR] = 0;
        }
        dateFromConfig(config);
        checkOverflow(config);
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        });
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    // date from string and array of format strings
    function makeDateFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            makeDateFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    // date from iso format
    function parseISO(config) {
        var i, l,
            string = config._i,
            match = isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be 'T' or undefined
                    config._f = isoDates[i][0] + (match[6] || ' ');
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(parseTokenTimezone)) {
                config._f += 'Z';
            }
            makeDateFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function makeDateFromString(config) {
        parseISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            moment.createFromInputFallback(config);
        }
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function makeDateFromInput(config) {
        var input = config._i, matched;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if ((matched = aspNetJsonRegex.exec(input)) !== null) {
            config._d = new Date(+matched[1]);
        } else if (typeof input === 'string') {
            makeDateFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            dateFromConfig(config);
        } else if (typeof(input) === 'object') {
            dateFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            moment.createFromInputFallback(config);
        }
    }

    function makeDate(y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    function parseWeekday(input, locale) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = locale.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    /************************************
        Relative Time
    ************************************/


    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(),
            seconds = round(duration.as('s')),
            minutes = round(duration.as('m')),
            hours = round(duration.as('h')),
            days = round(duration.as('d')),
            months = round(duration.as('M')),
            years = round(duration.as('y')),

            args = seconds < relativeTimeThresholds.s && ['s', seconds] ||
                minutes === 1 && ['m'] ||
                minutes < relativeTimeThresholds.m && ['mm', minutes] ||
                hours === 1 && ['h'] ||
                hours < relativeTimeThresholds.h && ['hh', hours] ||
                days === 1 && ['d'] ||
                days < relativeTimeThresholds.d && ['dd', days] ||
                months === 1 && ['M'] ||
                months < relativeTimeThresholds.M && ['MM', months] ||
                years === 1 && ['y'] || ['yy', years];

        args[2] = withoutSuffix;
        args[3] = +posNegDuration > 0;
        args[4] = locale;
        return substituteTimeAgo.apply({}, args);
    }


    /************************************
        Week of Year
    ************************************/


    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = moment(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = makeUTCDate(year, 0, 1).getUTCDay(), daysToAdd, dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ?  dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    /************************************
        Top Level Functions
    ************************************/

    function makeMoment(config) {
        var input = config._i,
            format = config._f,
            res;

        config._locale = config._locale || moment.localeData(config._l);

        if (input === null || (format === undefined && input === '')) {
            return moment.invalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (moment.isMoment(input)) {
            return new Moment(input, true);
        } else if (format) {
            if (isArray(format)) {
                makeDateFromStringAndArray(config);
            } else {
                makeDateFromStringAndFormat(config);
            }
        } else {
            makeDateFromInput(config);
        }

        res = new Moment(config);
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    moment = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._i = input;
        c._f = format;
        c._l = locale;
        c._strict = strict;
        c._isUTC = false;
        c._pf = defaultParsingFlags();

        return makeMoment(c);
    };

    moment.suppressDeprecationWarnings = false;

    moment.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return moment();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    moment.min = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    };

    moment.max = function () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    };

    // creating with utc
    moment.utc = function (input, format, locale, strict) {
        var c;

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c = {};
        c._isAMomentObject = true;
        c._useUTC = true;
        c._isUTC = true;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return makeMoment(c).utc();
    };

    // creating with unix timestamp (in seconds)
    moment.unix = function (input) {
        return moment(input * 1000);
    };

    // duration
    moment.duration = function (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            parseIso,
            diffRes;

        if (moment.isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetTimeSpanJsonRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = isoDurationRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            parseIso = function (inp) {
                // We'd normally use ~~inp for this, but unfortunately it also
                // converts floats to ints.
                // inp may be undefined, so careful calling replace on it.
                var res = inp && parseFloat(inp.replace(',', '.'));
                // apply sign while we're at it
                return (isNaN(res) ? 0 : res) * sign;
            };
            duration = {
                y: parseIso(match[2]),
                M: parseIso(match[3]),
                d: parseIso(match[4]),
                h: parseIso(match[5]),
                m: parseIso(match[6]),
                s: parseIso(match[7]),
                w: parseIso(match[8])
            };
        } else if (typeof duration === 'object' &&
                ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(moment(duration.from), moment(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (moment.isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    };

    // version number
    moment.version = VERSION;

    // default format
    moment.defaultFormat = isoFormat;

    // constant that refers to the ISO standard
    moment.ISO_8601 = function () {};

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    moment.momentProperties = momentProperties;

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    moment.updateOffset = function () {};

    // This function allows you to set a threshold for relative time strings
    moment.relativeTimeThreshold = function (threshold, limit) {
        if (relativeTimeThresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return relativeTimeThresholds[threshold];
        }
        relativeTimeThresholds[threshold] = limit;
        return true;
    };

    moment.lang = deprecate(
        'moment.lang is deprecated. Use moment.locale instead.',
        function (key, value) {
            return moment.locale(key, value);
        }
    );

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    moment.locale = function (key, values) {
        var data;
        if (key) {
            if (typeof(values) !== 'undefined') {
                data = moment.defineLocale(key, values);
            }
            else {
                data = moment.localeData(key);
            }

            if (data) {
                moment.duration._locale = moment._locale = data;
            }
        }

        return moment._locale._abbr;
    };

    moment.defineLocale = function (name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);

            // backwards compat for now: also set the locale
            moment.locale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    };

    moment.langData = deprecate(
        'moment.langData is deprecated. Use moment.localeData instead.',
        function (key) {
            return moment.localeData(key);
        }
    );

    // returns locale data
    moment.localeData = function (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return moment._locale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    };

    // compare moment object
    moment.isMoment = function (obj) {
        return obj instanceof Moment ||
            (obj != null && hasOwnProp(obj, '_isAMomentObject'));
    };

    // for typechecking Duration objects
    moment.isDuration = function (obj) {
        return obj instanceof Duration;
    };

    for (i = lists.length - 1; i >= 0; --i) {
        makeList(lists[i]);
    }

    moment.normalizeUnits = function (units) {
        return normalizeUnits(units);
    };

    moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    };

    moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone();
    };

    moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    /************************************
        Moment Prototype
    ************************************/


    extend(moment.fn = Moment.prototype, {

        clone : function () {
            return moment(this);
        },

        valueOf : function () {
            return +this._d + ((this._offset || 0) * 60000);
        },

        unix : function () {
            return Math.floor(+this / 1000);
        },

        toString : function () {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        },

        toDate : function () {
            return this._offset ? new Date(+this) : this._d;
        },

        toISOString : function () {
            var m = moment(this).utc();
            if (0 < m.year() && m.year() <= 9999) {
                if ('function' === typeof Date.prototype.toISOString) {
                    // native implementation is ~50x faster, use it when we can
                    return this.toDate().toISOString();
                } else {
                    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
                }
            } else {
                return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        },

        toArray : function () {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hours(),
                m.minutes(),
                m.seconds(),
                m.milliseconds()
            ];
        },

        isValid : function () {
            return isValid(this);
        },

        isDSTShifted : function () {
            if (this._a) {
                return this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0;
            }

            return false;
        },

        parsingFlags : function () {
            return extend({}, this._pf);
        },

        invalidAt: function () {
            return this._pf.overflow;
        },

        utc : function (keepLocalTime) {
            return this.zone(0, keepLocalTime);
        },

        local : function (keepLocalTime) {
            if (this._isUTC) {
                this.zone(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.add(this._dateTzOffset(), 'm');
                }
            }
            return this;
        },

        format : function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output);
        },

        add : createAdder(1, 'add'),

        subtract : createAdder(-1, 'subtract'),

        diff : function (input, units, asFloat) {
            var that = makeAs(input, this),
                zoneDiff = (this.zone() - that.zone()) * 6e4,
                diff, output, daysAdjust;

            units = normalizeUnits(units);

            if (units === 'year' || units === 'month') {
                // average number of days in the months in the given dates
                diff = (this.daysInMonth() + that.daysInMonth()) * 432e5; // 24 * 60 * 60 * 1000 / 2
                // difference in months
                output = ((this.year() - that.year()) * 12) + (this.month() - that.month());
                // adjust by taking difference in days, average number of days
                // and dst in the given months.
                daysAdjust = (this - moment(this).startOf('month')) -
                    (that - moment(that).startOf('month'));
                // same as above but with zones, to negate all dst
                daysAdjust -= ((this.zone() - moment(this).startOf('month').zone()) -
                        (that.zone() - moment(that).startOf('month').zone())) * 6e4;
                output += daysAdjust / diff;
                if (units === 'year') {
                    output = output / 12;
                }
            } else {
                diff = (this - that);
                output = units === 'second' ? diff / 1e3 : // 1000
                    units === 'minute' ? diff / 6e4 : // 1000 * 60
                    units === 'hour' ? diff / 36e5 : // 1000 * 60 * 60
                    units === 'day' ? (diff - zoneDiff) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                    units === 'week' ? (diff - zoneDiff) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                    diff;
            }
            return asFloat ? output : absRound(output);
        },

        from : function (time, withoutSuffix) {
            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        },

        fromNow : function (withoutSuffix) {
            return this.from(moment(), withoutSuffix);
        },

        calendar : function (time) {
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're zone'd or not.
            var now = time || moment(),
                sod = makeAs(now, this).startOf('day'),
                diff = this.diff(sod, 'days', true),
                format = diff < -6 ? 'sameElse' :
                    diff < -1 ? 'lastWeek' :
                    diff < 0 ? 'lastDay' :
                    diff < 1 ? 'sameDay' :
                    diff < 2 ? 'nextDay' :
                    diff < 7 ? 'nextWeek' : 'sameElse';
            return this.format(this.localeData().calendar(format, this, moment(now)));
        },

        isLeapYear : function () {
            return isLeapYear(this.year());
        },

        isDST : function () {
            return (this.zone() < this.clone().month(0).zone() ||
                this.zone() < this.clone().month(5).zone());
        },

        day : function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        },

        month : makeAccessor('Month', true),

        startOf : function (units) {
            units = normalizeUnits(units);
            // the following switch intentionally omits break keywords
            // to utilize falling through the cases.
            switch (units) {
            case 'year':
                this.month(0);
                /* falls through */
            case 'quarter':
            case 'month':
                this.date(1);
                /* falls through */
            case 'week':
            case 'isoWeek':
            case 'day':
                this.hours(0);
                /* falls through */
            case 'hour':
                this.minutes(0);
                /* falls through */
            case 'minute':
                this.seconds(0);
                /* falls through */
            case 'second':
                this.milliseconds(0);
                /* falls through */
            }

            // weeks are a special case
            if (units === 'week') {
                this.weekday(0);
            } else if (units === 'isoWeek') {
                this.isoWeekday(1);
            }

            // quarters are also special
            if (units === 'quarter') {
                this.month(Math.floor(this.month() / 3) * 3);
            }

            return this;
        },

        endOf: function (units) {
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond') {
                return this;
            }
            return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
        },

        isAfter: function (input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this > +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return inputMs < +this.clone().startOf(units);
            }
        },

        isBefore: function (input, units) {
            var inputMs;
            units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this < +input;
            } else {
                inputMs = moment.isMoment(input) ? +input : +moment(input);
                return +this.clone().endOf(units) < inputMs;
            }
        },

        isSame: function (input, units) {
            var inputMs;
            units = normalizeUnits(units || 'millisecond');
            if (units === 'millisecond') {
                input = moment.isMoment(input) ? input : moment(input);
                return +this === +input;
            } else {
                inputMs = +moment(input);
                return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
            }
        },

        min: deprecate(
                 'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
                 function (other) {
                     other = moment.apply(null, arguments);
                     return other < this ? this : other;
                 }
         ),

        max: deprecate(
                'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
                function (other) {
                    other = moment.apply(null, arguments);
                    return other > this ? this : other;
                }
        ),

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[zone(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist int zone
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        zone : function (input, keepLocalTime) {
            var offset = this._offset || 0,
                localAdjust;
            if (input != null) {
                if (typeof input === 'string') {
                    input = timezoneMinutesFromString(input);
                }
                if (Math.abs(input) < 16) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = this._dateTzOffset();
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.subtract(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addOrSubtractDurationFromMoment(this,
                                moment.duration(offset - input, 'm'), 1, false);
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        moment.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
            } else {
                return this._isUTC ? offset : this._dateTzOffset();
            }
            return this;
        },

        zoneAbbr : function () {
            return this._isUTC ? 'UTC' : '';
        },

        zoneName : function () {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        },

        parseZone : function () {
            if (this._tzm) {
                this.zone(this._tzm);
            } else if (typeof this._i === 'string') {
                this.zone(this._i);
            }
            return this;
        },

        hasAlignedHourOffset : function (input) {
            if (!input) {
                input = 0;
            }
            else {
                input = moment(input).zone();
            }

            return (this.zone() - input) % 60 === 0;
        },

        daysInMonth : function () {
            return daysInMonth(this.year(), this.month());
        },

        dayOfYear : function (input) {
            var dayOfYear = round((moment(this).startOf('day') - moment(this).startOf('year')) / 864e5) + 1;
            return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
        },

        quarter : function (input) {
            return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
        },

        weekYear : function (input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        isoWeekYear : function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return input == null ? year : this.add((input - year), 'y');
        },

        week : function (input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        isoWeek : function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        },

        weekday : function (input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        },

        isoWeekday : function (input) {
            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.
            return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
        },

        isoWeeksInYear : function () {
            return weeksInYear(this.year(), 1, 4);
        },

        weeksInYear : function () {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units]();
        },

        set : function (units, value) {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                this[units](value);
            }
            return this;
        },

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        locale : function (key) {
            var newLocaleData;

            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = moment.localeData(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        },

        lang : deprecate(
            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        ),

        localeData : function () {
            return this._locale;
        },

        _dateTzOffset : function () {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return Math.round(this._d.getTimezoneOffset() / 15) * 15;
        }
    });

    function rawMonthSetter(mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(),
                daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function rawGetter(mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function rawSetter(mom, unit, value) {
        if (unit === 'Month') {
            return rawMonthSetter(mom, value);
        } else {
            return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            if (value != null) {
                rawSetter(this, unit, value);
                moment.updateOffset(this, keepTime);
                return this;
            } else {
                return rawGetter(this, unit);
            }
        };
    }

    moment.fn.millisecond = moment.fn.milliseconds = makeAccessor('Milliseconds', false);
    moment.fn.second = moment.fn.seconds = makeAccessor('Seconds', false);
    moment.fn.minute = moment.fn.minutes = makeAccessor('Minutes', false);
    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    moment.fn.hour = moment.fn.hours = makeAccessor('Hours', true);
    // moment.fn.month is defined separately
    moment.fn.date = makeAccessor('Date', true);
    moment.fn.dates = deprecate('dates accessor is deprecated. Use date instead.', makeAccessor('Date', true));
    moment.fn.year = makeAccessor('FullYear', true);
    moment.fn.years = deprecate('years accessor is deprecated. Use year instead.', makeAccessor('FullYear', true));

    // add plural methods
    moment.fn.days = moment.fn.day;
    moment.fn.months = moment.fn.month;
    moment.fn.weeks = moment.fn.week;
    moment.fn.isoWeeks = moment.fn.isoWeek;
    moment.fn.quarters = moment.fn.quarter;

    // add aliased format methods
    moment.fn.toJSON = moment.fn.toISOString;

    /************************************
        Duration Prototype
    ************************************/


    function daysToYears (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        return days * 400 / 146097;
    }

    function yearsToDays (years) {
        // years * 365 + absRound(years / 4) -
        //     absRound(years / 100) + absRound(years / 400);
        return years * 146097 / 400;
    }

    extend(moment.duration.fn = Duration.prototype, {

        _bubble : function () {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds, minutes, hours, years = 0;

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absRound(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absRound(seconds / 60);
            data.minutes = minutes % 60;

            hours = absRound(minutes / 60);
            data.hours = hours % 24;

            days += absRound(hours / 24);

            // Accurately convert days to years, assume start from year 0.
            years = absRound(daysToYears(days));
            days -= absRound(yearsToDays(years));

            // 30 days to a month
            // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
            months += absRound(days / 30);
            days %= 30;

            // 12 months -> 1 year
            years += absRound(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;
        },

        abs : function () {
            this._milliseconds = Math.abs(this._milliseconds);
            this._days = Math.abs(this._days);
            this._months = Math.abs(this._months);

            this._data.milliseconds = Math.abs(this._data.milliseconds);
            this._data.seconds = Math.abs(this._data.seconds);
            this._data.minutes = Math.abs(this._data.minutes);
            this._data.hours = Math.abs(this._data.hours);
            this._data.months = Math.abs(this._data.months);
            this._data.years = Math.abs(this._data.years);

            return this;
        },

        weeks : function () {
            return absRound(this.days() / 7);
        },

        valueOf : function () {
            return this._milliseconds +
              this._days * 864e5 +
              (this._months % 12) * 2592e6 +
              toInt(this._months / 12) * 31536e6;
        },

        humanize : function (withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());

            if (withSuffix) {
                output = this.localeData().pastFuture(+this, output);
            }

            return this.localeData().postformat(output);
        },

        add : function (input, val) {
            // supports only 2.0-style add(1, 's') or add(moment)
            var dur = moment.duration(input, val);

            this._milliseconds += dur._milliseconds;
            this._days += dur._days;
            this._months += dur._months;

            this._bubble();

            return this;
        },

        subtract : function (input, val) {
            var dur = moment.duration(input, val);

            this._milliseconds -= dur._milliseconds;
            this._days -= dur._days;
            this._months -= dur._months;

            this._bubble();

            return this;
        },

        get : function (units) {
            units = normalizeUnits(units);
            return this[units.toLowerCase() + 's']();
        },

        as : function (units) {
            var days, months;
            units = normalizeUnits(units);

            if (units === 'month' || units === 'year') {
                days = this._days + this._milliseconds / 864e5;
                months = this._months + daysToYears(days) * 12;
                return units === 'month' ? months : months / 12;
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + Math.round(yearsToDays(this._months / 12));
                switch (units) {
                    case 'week': return days / 7 + this._milliseconds / 6048e5;
                    case 'day': return days + this._milliseconds / 864e5;
                    case 'hour': return days * 24 + this._milliseconds / 36e5;
                    case 'minute': return days * 24 * 60 + this._milliseconds / 6e4;
                    case 'second': return days * 24 * 60 * 60 + this._milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond': return Math.floor(days * 24 * 60 * 60 * 1000) + this._milliseconds;
                    default: throw new Error('Unknown unit ' + units);
                }
            }
        },

        lang : moment.fn.lang,
        locale : moment.fn.locale,

        toIsoString : deprecate(
            'toIsoString() is deprecated. Please use toISOString() instead ' +
            '(notice the capitals)',
            function () {
                return this.toISOString();
            }
        ),

        toISOString : function () {
            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            var years = Math.abs(this.years()),
                months = Math.abs(this.months()),
                days = Math.abs(this.days()),
                hours = Math.abs(this.hours()),
                minutes = Math.abs(this.minutes()),
                seconds = Math.abs(this.seconds() + this.milliseconds() / 1000);

            if (!this.asSeconds()) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            return (this.asSeconds() < 0 ? '-' : '') +
                'P' +
                (years ? years + 'Y' : '') +
                (months ? months + 'M' : '') +
                (days ? days + 'D' : '') +
                ((hours || minutes || seconds) ? 'T' : '') +
                (hours ? hours + 'H' : '') +
                (minutes ? minutes + 'M' : '') +
                (seconds ? seconds + 'S' : '');
        },

        localeData : function () {
            return this._locale;
        }
    });

    moment.duration.fn.toString = moment.duration.fn.toISOString;

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name];
        };
    }

    for (i in unitMillisecondFactors) {
        if (hasOwnProp(unitMillisecondFactors, i)) {
            makeDurationGetter(i.toLowerCase());
        }
    }

    moment.duration.fn.asMilliseconds = function () {
        return this.as('ms');
    };
    moment.duration.fn.asSeconds = function () {
        return this.as('s');
    };
    moment.duration.fn.asMinutes = function () {
        return this.as('m');
    };
    moment.duration.fn.asHours = function () {
        return this.as('h');
    };
    moment.duration.fn.asDays = function () {
        return this.as('d');
    };
    moment.duration.fn.asWeeks = function () {
        return this.as('weeks');
    };
    moment.duration.fn.asMonths = function () {
        return this.as('M');
    };
    moment.duration.fn.asYears = function () {
        return this.as('y');
    };

    /************************************
        Default Locale
    ************************************/


    // Set default locale, other locale will inherit from English.
    moment.locale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    /* EMBED_LOCALES */

    /************************************
        Exposing Moment
    ************************************/

    function makeGlobal(shouldDeprecate) {
        /*global ender:false */
        if (typeof ender !== 'undefined') {
            return;
        }
        oldGlobalMoment = globalScope.moment;
        if (shouldDeprecate) {
            globalScope.moment = deprecate(
                    'Accessing Moment through the global scope is ' +
                    'deprecated, and will be removed in an upcoming ' +
                    'release.',
                    moment);
        } else {
            globalScope.moment = moment;
        }
    }

    // CommonJS module is defined
    if (hasModule) {
        module.exports = moment;
    } else if (typeof define === 'function' && define.amd) {
        define('moment', function (require, exports, module) {
            if (module.config && module.config() && module.config().noGlobal === true) {
                // release the global variable
                globalScope.moment = oldGlobalMoment;
            }

            return moment;
        });
        makeGlobal(true);
    } else {
        makeGlobal();
    }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],27:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Emitter = require('emitter');
var reduce = require('reduce');

/**
 * Root reference for iframes.
 */

var root = 'undefined' == typeof window
  ? this
  : window;

/**
 * Noop.
 */

function noop(){};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * TODO: future proof, move to compoent land
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isHost(obj) {
  var str = {}.toString.call(obj);

  switch (str) {
    case '[object File]':
    case '[object Blob]':
    case '[object FormData]':
      return true;
    default:
      return false;
  }
}

/**
 * Determine XHR.
 */

function getXHR() {
  if (root.XMLHttpRequest
    && ('file:' != root.location.protocol || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  return false;
}

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return obj === Object(obj);
}

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    if (null != obj[key]) {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(obj[key]));
    }
  }
  return pairs.join('&');
}

/**
 * Expose serialization method.
 */

 request.serializeObject = serialize;

 /**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var parts;
  var pair;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    parts = pair.split('=');
    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'application/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

 request.serialize = {
   'application/x-www-form-urlencoded': serialize,
   'application/json': JSON.stringify
 };

 /**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  lines.pop(); // trailing CRLF

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

function type(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function params(str){
  return reduce(str.split(/ *; */), function(obj, str){
    var parts = str.split(/ *= */)
      , key = parts.shift()
      , val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req, options) {
  options = options || {};
  this.req = req;
  this.xhr = this.req.xhr;
  this.text = this.req.method !='HEAD' 
     ? this.xhr.responseText 
     : null;
  this.setStatusProperties(this.xhr.status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this.setHeaderProperties(this.header);
  this.body = this.req.method != 'HEAD'
    ? this.parseBody(this.text)
    : null;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

Response.prototype.get = function(field){
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

Response.prototype.setHeaderProperties = function(header){
  // content-type
  var ct = this.header['content-type'] || '';
  this.type = type(ct);

  // params
  var obj = params(ct);
  for (var key in obj) this[key] = obj[key];
};

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype.parseBody = function(str){
  var parse = request.parse[this.type];
  return parse && str && str.length
    ? parse(str)
    : null;
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

Response.prototype.setStatusProperties = function(status){
  var type = status / 100 | 0;

  // status / class
  this.status = status;
  this.statusType = type;

  // basics
  this.info = 1 == type;
  this.ok = 2 == type;
  this.clientError = 4 == type;
  this.serverError = 5 == type;
  this.error = (4 == type || 5 == type)
    ? this.toError()
    : false;

  // sugar
  this.accepted = 202 == status;
  this.noContent = 204 == status || 1223 == status;
  this.badRequest = 400 == status;
  this.unauthorized = 401 == status;
  this.notAcceptable = 406 == status;
  this.notFound = 404 == status;
  this.forbidden = 403 == status;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  Emitter.call(this);
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {};
  this._header = {};
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self); 
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
    }

    self.callback(err, res);
  });
}

/**
 * Mixin `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Allow for extension
 */

Request.prototype.use = function(fn) {
  fn(this);
  return this;
}

/**
 * Set timeout to `ms`.
 *
 * @param {Number} ms
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.timeout = function(ms){
  this._timeout = ms;
  return this;
};

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.clearTimeout = function(){
  this._timeout = 0;
  clearTimeout(this._timer);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */

Request.prototype.abort = function(){
  if (this.aborted) return;
  this.aborted = true;
  this.xhr.abort();
  this.clearTimeout();
  this.emit('abort');
  return this;
};

/**
 * Set header `field` to `val`, or multiple fields with one object.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Get case-insensitive header `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api private
 */

Request.prototype.getHeader = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} pass
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass){
  var str = btoa(user + ':' + pass);
  this.set('Authorization', 'Basic ' + str);
  return this;
};

/**
* Add query-string `val`.
*
* Examples:
*
*   request.get('/shoes')
*     .query('size=10')
*     .query({ color: 'blue' })
*
* @param {Object|String} val
* @return {Request} for chaining
* @api public
*/

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Write the field `name` and `val` for "multipart/form-data"
 * request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 * ```
 *
 * @param {String} name
 * @param {String|Blob|File} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.field = function(name, val){
  if (!this._formData) this._formData = new FormData();
  this._formData.append(name, val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `filename`.
 *
 * ``` js
 * request.post('/upload')
 *   .attach(new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String} filename
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, filename){
  if (!this._formData) this._formData = new FormData();
  this._formData.append(field, file, filename);
  return this;
};

/**
 * Send `data`, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // querystring
 *       request.get('/search')
 *         .end(callback)
 *
 *       // multiple data "writes"
 *       request.get('/search')
 *         .send({ search: 'query' })
 *         .send({ range: '1..5' })
 *         .send({ order: 'desc' })
 *         .end(callback)
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"})
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
  *      request.post('/user')
  *        .send('name=tobi')
  *        .send('species=ferret')
  *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.send = function(data){
  var obj = isObject(data);
  var type = this.getHeader('Content-Type');

  // merge
  if (obj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    if (!type) this.type('form');
    type = this.getHeader('Content-Type');
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!obj) return this;
  if (!type) this.type('json');
  return this;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  var fn = this._callback;
  this.clearTimeout();
  if (2 == fn.length) return fn(err, res);
  if (err) return this.emit('error', err);
  fn(res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Origin is not allowed by Access-Control-Allow-Origin');
  err.crossDomain = true;
  this.callback(err);
};

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

Request.prototype.timeoutError = function(){
  var timeout = this._timeout;
  var err = new Error('timeout of ' + timeout + 'ms exceeded');
  err.timeout = timeout;
  this.callback(err);
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

Request.prototype.withCredentials = function(){
  this._withCredentials = true;
  return this;
};

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  var self = this;
  var xhr = this.xhr = getXHR();
  var query = this._query.join('&');
  var timeout = this._timeout;
  var data = this._formData || this._data;

  // store callback
  this._callback = fn || noop;

  // state change
  xhr.onreadystatechange = function(){
    if (4 != xhr.readyState) return;
    if (0 == xhr.status) {
      if (self.aborted) return self.timeoutError();
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  if (xhr.upload) {
    xhr.upload.onprogress = function(e){
      e.percent = e.loaded / e.total * 100;
      self.emit('progress', e);
    };
  }

  // timeout
  if (timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self.abort();
    }, timeout);
  }

  // querystring
  if (query) {
    query = request.serializeObject(query);
    this.url += ~this.url.indexOf('?')
      ? '&' + query
      : '?' + query;
  }

  // initiate request
  xhr.open(this.method, this.url, true);

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {
    // serialize stuff
    var serialize = request.serialize[this.getHeader('Content-Type')];
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;
    xhr.setRequestHeader(field, this.header[field]);
  }

  // send stuff
  this.emit('request', this);
  xhr.send(data);
  return this;
};

/**
 * Expose `Request`.
 */

request.Request = Request;

/**
 * Issue a request:
 *
 * Examples:
 *
 *    request('GET', '/users').end(callback)
 *    request('/users').end(callback)
 *    request('/users', callback)
 *
 * @param {String} method
 * @param {String|Function} url or callback
 * @return {Request}
 * @api public
 */

function request(method, url) {
  // callback
  if ('function' == typeof url) {
    return new Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new Request('GET', method);
  }

  return new Request(method, url);
}

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn){
  var req = request('GET', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn){
  var req = request('HEAD', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.del = function(url, fn){
  var req = request('DELETE', url);
  if (fn) req.end(fn);
  return req;
};

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn){
  var req = request('PATCH', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} data
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn){
  var req = request('POST', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} data or fn
 * @param {Function} fn
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn){
  var req = request('PUT', url);
  if ('function' == typeof data) fn = data, data = null;
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * Expose `request`.
 */

module.exports = request;

},{"emitter":28,"reduce":29}],28:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],29:[function(require,module,exports){

/**
 * Reduce `arr` with `fn`.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @param {Mixed} initial
 *
 * TODO: combatible error handling?
 */

module.exports = function(arr, fn, initial){  
  var idx = 0;
  var len = arr.length;
  var curr = arguments.length == 3
    ? initial
    : arr[idx++];

  while (idx < len) {
    curr = fn.call(null, curr, arr[idx], ++idx, arr);
  }
  
  return curr;
};
},{}],30:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18}],31:[function(require,module,exports){
var Backbone = require('backbone')
  , Backgrid = require('backgrid')
  , moment = require('moment')
  , _ = require('underscore')
  , models = require('./models/index.js')
  , views = require('./views.js')
  , Notify = require('./local_modules/notify/notify.js');

var menuData = [
  {
    name: 'Dashboard',
    id: 'dashboard',
    icon: 'tasks',
    url: '/'
  },
  {
    name: 'Subjects',
    id: 'subjects',
    icon: 'tags',
    url: '/subjects'
  }
]

var Router = Backbone.Router.extend({
	initialize: function() {
    this.on("all", this.storeRoute)
    this.history = []
    this.layout = ''
    this.notice = {}
    this.initialized = false
    this.buildMenu()
    this.contextMenu = new models.contextItems()
	},
	routes: {
    '': 'dashboard',
    'subjects': 'subjects',
    'subjects/add': 'subjectAdd',
    'subjects/:id': 'subjectEdit'
	},
  dashboard: function(callback, id) {
    var dashboardGrid = [
      {
        name: 'nodes.document.title',
        label: 'sort by title',
        editable: false,
        cell: views.documentCell
      }
    ];
    this.grid(dashboardGrid, 'documents', 'documentsGrid', callback, id);
  },

  subjects: function(callback, id) {
    Notify.spinner('show');

    var self = this;
        
    self.subjects = new models.subjects()

    self.subjects.fetch().done(function() {
      var subjectsView = new views.subjectsTreeView({ collection: self.subjects, contextMenu: self.contextMenu });
      self.changeLayout(subjectsView, callback, id);
      Notify.spinner('hide');
      Notify.info( 'Data has been loaded' );
    });
  },

  subjectPage: function(id) {
      Notify.spinner('show');

      var self = this,
          model = models.subject.create({_id:id}),
          terms = new models.terms([],{ queryParams: {query: {dictionary: id}}, state: {pageSize: 500}})

      model.fetch().done(function() {
        terms.fetch().done(function() {
          var view = new views.categoryView({ model: model, collection: self.dictionaries, contextMenu: self.contextMenu, layout: self.layout, terms: terms });   
          self.layout.stackView.push(view);
          Notify.spinner('hide');
          Notify.info( 'Data has been loaded' );
        });
      });
  },

  grid: function(grid, colName, viewName, callback, id) {
    Notify.spinner('show');

    var self = this;
        
    self[colName] = new models[colName]()

    self[colName].fetch().done(function(){
      var gridView = new views[viewName]({ collection: self[colName], columns: grid, contextMenu: self.contextMenu });
      self.changeLayout(gridView, callback, id);
      Notify.spinner('hide');
      Notify.info( 'Data has been loaded' );
    });
  },

  edit: function(id, parentName, name, modelName, colName) {
    if(!this.initialized) {
      this[parentName](name, id);
    } else {
      Notify.spinner('show');

      var self = this,
          model = models[modelName].create({_id:id});

      model.fetch().done(function() {
        var view = new views.editPage({ model: model, collection: self[colName], add: false, contextMenu: self.contextMenu, layout: self.layout, sidebarItems: relations });   
        self.layout.stackView.push(view);
        Notify.spinner('hide');
        Notify.info( 'Data has been loaded' );
      });
    }
  },

  add: function(parentName, name, modelName, colName) {
    if(!this.initialized) {
      this[parentName](name);
    } else {

      var self = this,
          model = models[modelName].create();

      var view = new views.editPage({ model: model, collection: self[colName], add: true, contextMenu: self.contextMenu, layout: self.layout });   
      self.layout.stackView.push(view)
    }
  },

  storeRoute: function(e) {
    if(e != 'route') {
      this.history.push(Backbone.history.fragment)
    }
  },
  
  previous: function() {
    if (this.history.length > 1) {
      this.navigate(this.history[this.history.length - 2], false)
      this.history.pop()
    } else {
      this.navigate('/', true)
    }
  },

  changeLayout: function(v, callback, id) {
    if (!this.initialized) {
      this.layout = new views.mainLayout({rootView: v, contextMenu: this.contextMenu}).render()
      this.initialized = true;
      this.buildContextMenu()
    } else {
      this.layout.changeLayout(v);
      this.buildContextMenu()
    }
    if (callback) this[callback](id);
  },

  buildMenu: function() {
    var menuItems = new models.menuItems();
    menuItems.set(menuData);
    var menu = new views.mainMenu({ collection: menuItems, el: $('div.toolbox') });
  },

  buildContextMenu: function() {
    var self = this;
    var contextMenu = new views.contextMenu({ collection: this.contextMenu, layout: this.layout });
    this.layout.addContext(contextMenu);
  }
})

module.exports = Router
},{"./local_modules/notify/notify.js":7,"./models/index.js":11,"./views.js":32,"backbone":19,"backgrid":23,"moment":26,"underscore":30}],32:[function(require,module,exports){
var Backbone = require('backbone'),
    Backgrid = require('backgrid'),
    moment = require('moment'),
    Paginator = require('backbone.paginator'),
    Pageable = require('./local_modules/backgrid-paginator/backgrid-paginator.js'),
    layoutmanager = require('backbone.layoutmanager'),
    forms = require('backbone-forms'),
    parent = require('./local_modules/parent-form/parent.js'),
    bootstrapForms = require('./local_modules/bootstrap-form/bootstrap3.js'),
    bootstrap = require('./local_modules/bootstrap-modal/bootstrap.js'),
    modal = require('./local_modules/backbone.bootstrap-modal'),
    filters = require('backgrid-filter'),
    _ = require('underscore'),
    $ = require('jquery'),
    jstree = require('./local_modules/jstree/dist/jstree.js'),
    request = require('superagent'),
    ObjectId = require('./local_modules/objectid/Objectid.js'),
		Notify = require('./local_modules/notify/notify.js')

var MainGrid = Backbone.Layout.extend({
  icon: '',
  initialize: function() {
    this.grid = new Backgrid.Grid({
      row: ClickableRow,
      columns: this.options.columns,
      collection: this.options.collection
    });
    $(this.$el).append(this.grid.render().$el);
    this.paginator = new Backgrid.Extension.Paginator({
  		columns: this.options.columns,
  		collection: this.options.collection
	  });
	  $(this.$el).append(this.paginator.render().$el);
    this.createContextPanel();
    this.contextMenu.reset(this.panel);
  },
  afterRender: function() {
    $('#' + this.icon).addClass('active');
    this.$el.addClass(this.options.class);
    this.filters();
  },
  filters: function() {},
  createContextPanel: function() {
    var contextPanel = document.createElement("div");
    contextPanel.id = "context-panel";
    contextPanel.className = "context-panel";
    contextPanel.innerHTML = '<div class="context-filters"></div>';
    this.$el.prepend(contextPanel);
  },
  close: function() {
    $('#' + this.icon).removeClass('active');
    this.grid.remove();
    this.remove();
    this.unbind();
  },
  panel: []
})
exports.mainGrid = MainGrid

var EditPage = Backbone.View.extend({
  manage: true,
  template: '#page',
  options_def: {
    class: 'stack-item'
  },
  initialize: function() {
    var self = this;
    if(self.add) {
      self.contextMenu.reset(self.panelAdd);
    } else {
      self.contextMenu.reset(self.panelEdit);
      self.template = '#editpage';
    }
  },
  beforeRender: function() {
    this.form = new Backbone.Form({
      model: this.model
    }).render();
  },
  afterRender: function() {
    var self = this;
    this.$el.addClass(this.options_def.class);
    this.$el.css('background-color', 'rgba(0,0,0,0.8)');
    this.$el.find('.form').append(this.form.el);
  },
  serialize: function() {
    return { model: this.model.attributes };
  },
  close: function() {
    this.remove();
    this.unbind();
  },
  _delete: function() {
    var self = this;
    bootbox.confirm("Вы собираетесь удалить запись из базы данных. Вы уверены?", function(result) {
      if(result) {
        Notify.spinner('show');
        self.collection.remove(self.model);
        self.model.destroy({
          wait: true,
          success: function(model,resp) {
            Notify.spinner('hide');
            Notify.info('Запись удалена');
            self.layout.removeFromStack();
          },
          error: function(model,err) { 
            Notify.spinner('hide');
            Notify.info('Запись не удалена. Произошла ошибка.');
          }
        });
      }
    });
  },
  _save: function() {
    var self = this;
    var errors = self.form.commit();
    if(!errors) {
      Notify.spinner('show');
      self.model.save({}, {
        wait: true,
        success: function(model,resp) { 
          Notify.spinner('hide');
          var notice = Notify.info('Запись сохранена');
          self.layout.removeFromStack();
        },
        error: function(model,err) { 
          Notify.spinner('hide');
          var notice = Notify.info('Запись не сохранилась. Произошла ошибка.');
        }
      });
    }
  },
  _create: function() {
    var self = this;
    var errors = self.form.commit();
    if(!errors) {
      Notify.spinner('show');
      self.collection.create(self.model, {
        wait: true,
        success: function(model,resp) { 
          Notify.spinner('hide');
          var notice = Notify.info('Запись создана');
          self.layout.removeFromStack();
        },
        error: function(model,err) { 
          Notify.spinner('hide');
          var notice = Notify.info('Запись не создана. Произошла ошибка.');
        }
      });
    }
  },
  panelAdd: [
    {
      name: "create",
      icon: "save",
      fn: "_create"
    }
  ],
  panelEdit: [
    {
      name: "save",
      icon: "save",
      fn: "_save"
    },
    {
      name: "remove",
      icon: "remove",
      fn: "_delete"
    }
  ]
});
exports.editPage = EditPage

// ROOT VIEW
var MainLayout = Backbone.Layout.extend({
  el: 'body',

  events: {
    'click #goback, click .close-stack, exit': 'removeFromStack',
    'keyup' : 'keyup',
  },
  
  changeLayout: function(v) {
  	this.stackView.closeStack();
    this.stackView = new StackView();
    this.stackView.setRootView(v);
    this.setView('#stackView', this.stackView).render();
  },

  addContext: function(v) {
    this.stackView.insertView('#context-panel', v).render();
  },
	
	keyup: function(e){
		if (e.which == 27 && $(e.target).is('body') && !$(e.target).hasClass('modal-open')) {
			this.removeFromStack();
		}
	},

  getRoot: function() {
    return this.stackView.getFirst();
  },

  getTop: function() {
    return this.stackView.getLast();
  },
	
  addToStack: function(v) {
    this.stackView.push(v);
  },

  removeFromStack: function() {
    this.stackView.pop();
    this.contextMenu.trigger("restore");
  },

  initialize: function() {
    // Create a new StackView and the root view.
    this.stackView = new StackView();
    this.stackView.setRootView(this.options.rootView);
    this.setView('#stackView', this.stackView);
  }
});
exports.mainLayout = MainLayout

// STACK MANAGER
var StackView = Backbone.Layout.extend({
  hasRootView: false,

  // Define options for transitioning views in and out.
  options_def: {
    inTransitionClass: 'animated fadeInLeft',
    outTransitionClass: 'animated fadeOutRight',
    transitionDelay: 1000,
    class: 'stacks'
  },

  afterRender: function() {
    this.$el.addClass(this.options_def.class);
  },

  // Pop the top-most view off of the stack.
  pop: function() {
    var views = this.getViews().value();

    if (views.length > (this.hasRootView ? 1 : 0)) {
      var view = views.pop();
      this.transitionViewOut(view);
    }
  },

  getFirst: function() {
    var views = this.getViews().value();
    return views[0];
  },

  getLast: function() {
    var views = this.getViews().value();
    return views[views.length - 1];
  },

  // Push a new view onto the stack.
  // The itemClass will be auto-added to the parent element.
  push: function(view) {
    this.insertView(view);
    this.transitionViewIn(view);
  },

  // Trastition the new view in.  This is broken out as a method for convenient
  // overriding of the default transition behavior.  If you only want to change
  // the animation use the trasition class options instead.
  transitionViewIn: function(view) {
    this.trigger('before:transitionIn', this, view);
    view.$el.addClass(this.options_def.inTransitionClass);
		
    view.render();

    setTimeout(function() {
      this.trigger('transitionIn', this, view);
    }.bind(this), this.options_def.transitionDelay);
  },
  
  // Trastition a view out.  This is broken out as a method for convenient
  // overriding of the default transition behavior.  If you only want to change
  // the animation use the trasition class options instead.
  transitionViewOut: function(view) {
    this.trigger('before:transitionOut', this, view);
    view.$el.addClass(this.options_def.outTransitionClass);
    Backbone.middle.trigger("goToPrevious");
    setTimeout(function() {
      view.close();
      this.trigger('transitionOut', this, view);
    }.bind(this), this.options_def.transitionDelay);
  },

  setRootView: function(view) {
    this.hasRootView = true;
  	this.setView(view);
  },

  closeStack: function() {
    var views = this.getViews().value();
    _.each(views, function(view){
      view.close();
    });
    this.remove();
    this.unbind();
  }
});
exports.stackView = StackView

var DocumentsGrid = MainGrid.extend({
  icon: 'dashboard',
  className: 'dashboard',
  initialize: function() {
    this.grid = new Backgrid.Grid({
      row: DocumentRow,
      columns: this.options.columns,
      collection: this.options.collection
    });
    $(this.$el).append(this.grid.render().$el);
    this.paginator = new Backgrid.Extension.Paginator({
      columns: this.options.columns,
      collection: this.options.collection
    });
    $(this.$el).append(this.paginator.render().$el);
    this.createContextPanel();
    this.contextMenu.reset(this.panel);
  },
	filters: function() {
    this.titleFilter = new Filter({
      collection: this.options.collection,
      placeholder: "Enter a title to search",
      name: "nodes.document.title",
    });
    this.$el.find('.context-filters').prepend(this.titleFilter.render().el);
	},
  _add: function() {
    Backbone.middle.trigger("goToExt", 'editor/new')
  },
  panel: [
    {
      name: "Add new document",
      icon: "plus",
      fn: "_add"
    }
  ]
})
exports.documentsGrid = DocumentsGrid


var ListView = Backbone.View.extend({
  tagName: "div",
  className: "list",

  initialize: function (options) {
    var listItems = this.listItems = options.items;

    // add new item to the list
    this.listenTo(listItems, "add", function (item) {
      this.addItem(item);
    })

    this.listenTo(listItems, "change", function (item) {
      this.updateItem(item);
    })

    // remove item from list
    this.listenTo(listItems, "remove", function (item) {
      this.removeItem(item);
    })

    this.listenTo(listItems, "changeParent", function (itemId, parentId) {
      this.changeParent(itemId, parentId);
    })

    this.on("parent:choose", function(child) {
      this.stopListening(this.listItems, "list:getitem");
      listItems.once("list:getitem", function(parent) {
        child.set('parent', parent.get('id'));
        this.registerItemListner();
        this.updateHierarchy();
      }, this);
    })

    this.on("parent:merge", function(child) {
      this.stopListening(this.listItems, "list:getitem");
      listItems.once("list:getitem", function(parent) {
        request
          .get('/api/subjects/merge')
          .query({ one: child.id, into: parent.id })
          .end(function(res){
            if(res.ok) console.log("Merged: " + child.id + " into " + parent.id);
          });
      }, this);
    })

    this.registerItemListner();
  },

  registerItemListner: function() {
    this.listenTo(this.listItems, "list:getitem", function (item, el) {
      $('div.list li.active').removeClass('active');
      el.addClass('active');
      item.trigger("list:edit", item)
    })
  },

  prepareViews: function() {
    this.itemViews = {};
    this.listItems.each(function(item) {
      this.itemViews[item.id] = new ItemView({model: item}).render();
    }, this);
  },

  addItem: function(item) {
    // model creation
    this.itemViews[item.id] = new ItemView({model: item}).render();
    this.updateHierarchy();
  },
 
  // doesnt affect hierarchy
  updateItem: function(item) {
    var isParent = this.listItems.findWhere({parent: item.id}) ? true : false;
    this.itemViews[item.id].render(isParent) // re-render
    this.updateHierarchy(item);
  },

  removeItem: function(item) {
    this.itemViews[item.id].remove()
    this.updateHierarchy();
  },

  changeParent: function(itemId, parentId) {
    var model = this.listItems.get(itemId),
        isParent = this.listItems.findWhere({parent: itemId}) ? true : false;
    model.set('parent', parentId);
    this.updateHierarchy();
  },

  updateHierarchy: function(item) {
    var self = this;
 
    // Build a map of parents referencing their kids
    var map = {};
    _.each(self.itemViews, function(item) {
      var parent = item.model.get('parent') || "root";
      if (!map[parent]) {
        map[parent] = [ item ];
      } else {
        map[parent].push(item);
      }
    });

    //debugger;

    function renderChildren(parent) {
      var listEl = document.createElement('ol');
 
      var items = map[parent];
      if (!items) return listEl; // exit condition      
      
      _.each(items, function(item) {
        var isParent = map.hasOwnProperty(item.model.id);
        var listItemEl = self.itemViews[item.model.id].render(isParent).el;

        var childList = renderChildren(item.model.id);
        listItemEl.appendChild(childList);
        listEl.appendChild(listItemEl);
        if (isParent) item._collapseItem(item.$el);
      });

      return listEl;
    }

    var listEl = item ? renderChildren(item.id) : renderChildren("root");
    if (item) {
      this.itemViews[item.id].$el.append(listEl);
    } else {
      self.$el.append(listEl);
    }
    
  },

  render: function() {
    this.prepareViews();
    this.updateHierarchy();
    this.delegateEvents();
    return this;
  },

  remove: function() {

  }

});


var ItemView = Backbone.View.extend({
  tagName: "li",

  events: {
    'click': 'chooseItem',
    'click .collapse': '_onCollapseItem',
    'click .expand': '_onExpandItem',
    'click .drag-handle': '_dragHandleClick',
    'dragstart': '_onDragStart',
    'dragenter': '_onDragEnter',
    'dragleave': '_onDragLeave',
    'dragover': '_onDragOver',
    'drop': '_onDrop',
    'dragend': '_onDragEnd'
  },

  initialize: function () {
    var model = this.model;

    model.on("change", function () {
      this.render();
    }, this);
  },

  render: function (parent) {
    this.$el.empty();

    var dragHandle = document.createElement('button');
    dragHandle.classList.add("drag-handle");
    dragHandle.innerHTML = '<i class="fa fa-bars"></i>';
    dragHandle.setAttribute("draggable", true);
    this.$el.append(dragHandle);

    var collapseBtn = document.createElement('button');
    collapseBtn.classList.add("collapse");
    collapseBtn.innerHTML = '<i class="fa fa-minus-square-o"></i>';
    collapseBtn.style.display = 'none';
    this.$el.append(collapseBtn);

    var expandBtn = document.createElement('button');
    expandBtn.classList.add("expand");
    expandBtn.innerHTML = '<i class="fa fa-plus-square-o"></i>';
    if(!parent) expandBtn.style.display = 'none';
    this.$el.append(expandBtn);

    var content = document.createElement('span');
    content.textContent = this.model.get('name');
    this.$el.append(content);
    this.delegateEvents();
    return this;
  },

  chooseItem: function(e) {
    var model = this.model;
    model.trigger("list:getitem", model, this.$el);
    e.preventDefault();
    e.stopPropagation();
  },

  remove: function () {

  },

  _dragHandleClick: function(e) {
    e.stopPropagation();
  },

  _collapseItem: function(item) {
    var lists = item.children('ol');
    if (lists.length) {
      item.addClass('collapsed');
      item.children('.collapse').hide();
      item.children('.expand').show();
      item.children('ol').hide();
    }
  },

  _onCollapseItem: function(e) {
    e.stopPropagation();
    var item = $(e.currentTarget).parent();
    this._collapseItem(item);
  },

  _expandItem: function(item) {
    item.removeClass('collapsed');
    item.children('.expand').hide();
    item.children('.collapse').show();
    item.children('ol').show();
  },

  _onExpandItem: function(e) {
    e.stopPropagation();
    var item = $(e.currentTarget).parent();
    this._expandItem(item);
  },

  _onDragStart: function(e) {
    e.stopPropagation();

    var id = this.model.get('_id');

    if (e.originalEvent) e = e.originalEvent
    e.dataTransfer.effectAllowed = "move";
    e.dataTransfer.setData("text/plain", id);
    e.dataTransfer.setDragImage(e.target.parentNode,0,0);
    e.target.style.opacity = '0.5';
    e.target.parentNode.className = 'dragging';
    //e.target.style.display = 'none';
    return true;
  },

  _onDragEnd: function(e) {
    if (e.originalEvent) e = e.originalEvent
    e.target.style.opacity = '1';
    e.target.parentNode.className = '';
  },

  _onDragEnter: function(e) {
    e.stopPropagation();
    if (e.originalEvent) e = e.originalEvent;
    if (e.target.tagName == 'SPAN' && !$(e.target).parents('.dragging').length) {
      this._insertDragPlaceholder(e.target);
    }
  },

  _onDragLeave: function(e) {
    e.stopPropagation();
    if (e.originalEvent) e = e.originalEvent;
    if (e.target.tagName == 'SPAN') {
      this._removeDragPlaceholder();
    }
  },

  _onDragOver: function(e) {
    e.preventDefault();
  },

  _onDrop: function(e) {
    e.stopPropagation();
    if (e.originalEvent) e = e.originalEvent;
    var id = e.dataTransfer.getData("text/plain");
    if(id != this.model.id && !$(e.target).parents('.dragging').length) this.model.trigger('changeParent', id, this.model.id);

    return false;
  },

  _insertDragPlaceholder: function(target) {
    this._removeDragPlaceholder();
    var dropzone = document.createElement('span');
    dropzone.setAttribute('id','dropzone');
    target.nextSibling.insertBefore(dropzone, target.nextSibling.firstChild);
  },

  _removeDragPlaceholder: function() {
    var dropzone = document.getElementById("dropzone");
    if (dropzone) dropzone.parentNode.removeChild(dropzone);
  }

});

// SUBJECT PAGES

var SubjectsView = Backbone.Layout.extend({
  icon: 'subjects',
  className: 'subjects',
  template: '#subjectsLayout',

  events: {
    "click .import": "_runImport",
    "click .cancel": "_cancelImport"
  },

  initialize: function() {
    var self = this;
    this.collection.on('list:edit', function(model) {
      this.editSubject(model);
    }, this);
  },
  beforeRender: function() {

  },
  afterRender: function() {
    var self = this;
    $('#' + this.icon).addClass('active');
    this.contextMenu.reset(this.panel);
    this.list = new ListView({items: self.collection}).render();
    this.$el.append(this.list.el);
  },
  editSubject: function(model) {
    var self = this,
        sidebar = this.$el.find('.sidebar');
    sidebar.empty();
    this.form = new Backbone.Form({
      model: model
    }).render();
    this.form.on('change', function() {
      this.commit();
    });
    this.form.on('parent:edit', function(item) {
      self.list.trigger('parent:choose', item.model);
    })
    this.form.on('parent:merge', function(item) {
      self.list.trigger('parent:merge', item.model);
    })
    this.form.on('parent:add', function(item) {
      self._add(item.model.id);
    })
    this.collection.once('list:itemparent', function(item){
      this.form.trigger("parent:choosed", item);
    }, this);
    sidebar.html(this.form.el);
    this.form.$el.find('input')[0].focus();
    //this.insertView('.sidebar', this.form).render();
    //this.$el.html(this.form.el);
    return this;
    //console.log(e)
    // var subjectId = e.target.parentElement.dataset.id,
    //     termForm = new TermEdit({model: this.terms.get(termId)});

    // var modal = new Backbone.BootstrapModal({ content: termForm, animate: true }).open();
  },
  _runImport: function() {
    var self = this,
        data = $('.import-data').val(),
        lines = data.split('\n'),
        map = [];

    _.each(lines, function(line, i) {
      var indentation = 0;
      while (line[indentation] == '\t') {
          indentation++;
      }
      if(!map[indentation]) map[indentation] = [];
      var name = line.split('\t').join(''),
          id = new ObjectId().toString(),
          parent = indentation > 0 ? map[indentation - 1][map[indentation - 1].length - 1] : '';

      map[indentation].push(id);

      self.collection.add({ _id: id, name: name, parent: parent });
    });
    self.$el.find('.sidebar').empty();
  },
  _cancelImport: function() {
    this.$el.find('.sidebar').empty();
  },
  _save: function() {
    this.collection.saveChanged();
  },
  _add: function(parentId) {
    var id = new ObjectId().toString(),
        parent = parentId ? parentId : '';
    this.collection.add({ _id: id, name: "Untitled", parent: parent });
  },
  _import: function() {
    $('div.list li.active').removeClass('active');
    var sidebar = this.$el.find('.sidebar');
    sidebar.empty();

    var dialog = document.createElement('div');
    dialog.innerHTML = '<textarea class="import-data" style="width: 100%;"></textarea><button class="import btn">Import</button><button class="cancel btn">Cancel</button>';
    sidebar.append(dialog);
  },
  close: function() {
    $('#' + this.icon).removeClass('active');
    this.remove();
    this.unbind();
  },
  panel: [
    {
      name: "save",
      icon: "save",
      fn: "_save"
    },
    {
      name: "Add new subject",
      icon: "plus",
      fn: "_add"
    },
    {
      name: "import",
      icon: "file-text-o",
      fn: "_import"
    }
  ]
})
exports.subjectsView = SubjectsView

var SubjectsTreeView = Backbone.Layout.extend({
  icon: 'subjects',
  className: 'subjects',
  template: '#subjectsTreeLayout',

  initialize: function() {
    $.jstree.currentState = {
      nodeToMerge: null
    };
  },
  beforeRender: function() {

  },
  afterRender: function() {
    var self = this;
    $('#' + this.icon).addClass('active');
    this.contextMenu.reset(this.panel);
    $('.tree')
      .on("move_node.jstree", function(e, data) {
        self._onMoveNode(e, data, self);
      })
      .on("rename_node.jstree", function(e, data) {
        self._onRenameNode(e, data, self);
      })
      .jstree({
        "core" : {
          "animation" : 0,
          "check_callback" : true,
          "themes" : { "stripes" : true },
          "data": self.collection.buildSubjectsTree()
        },
        "contextmenu": {
          "items": function(o, cb) {
            return self.itemsFunc(o, cb, self);
          }
        },
        "types": {
          "default": {"icon": "glyphicon hidden-icon"}
        },
        "plugins" : [ "contextmenu", "dnd", "search", "state", "types", "wholerow", "sort"]
      });
  },
  itemsFunc: function(o, cb, context) {
    var self = this;

    o.model = context.collection.get(o.id);
    o.collection = context.collection;

    var res = $.jstree.defaults.contextmenu.items(o, cb);

    // Edit node
    // -----------

    res.edit = {
      "separator_before"  : false,
      "separator_after" : true,
      "_disabled"     : false,
      "label"       : "Description",
      "action"      : function (data) {
        var inst = $.jstree.reference(data.reference),
            obj = inst.get_node(data.reference),
            subject = obj.model;

        console.log('editing subject...');

        var input = document.createElement("textarea");
        input.id = "description";
        input.placeholder = "Describe subject here...";
        input.innerHTML = subject.get('description');

        var container = document.createElement("div");
        container.appendChild(input);

        var modal = new Backbone.BootstrapModal({ content: container.innerHTML, animate: true }).open(function(){
          var description = document.getElementById("description").value;

          subject.save('description', description, {
            success: function(model, resp) { 
              Notify.spinner('hide');
              var notice = Notify.info('Subject ' + subject.get('name') + ' has been updated');
            },
            error: function(model, err) { 
              Notify.spinner('hide');
              var notice = Notify.info('Sorry, the error occured! Please reload the page and try again.');
              console.log(err);
            }
          })
        });

      }
    };

    // Create a new node
    // -------------------

    res.create = {
      "separator_before"  : false,
      "separator_after" : true,
      "_disabled"     : false,
      "label"       : "Create",
      "action"      : function (data) {
        var inst = $.jstree.reference(data.reference),
          obj = inst.get_node(data.reference);

        console.log('creating a new subject...');

        var id = new ObjectId().toString();

        inst.create_node(obj, {id: id}, "last", function (new_node) {
          //setTimeout(function () { inst.edit(new_node); },0);
          o.collection.create({ _id: new_node.id, name: new_node.text, parent: new_node.parent }, {
            success: function(model,resp) {
              Notify.spinner('hide');
              Notify.info('Subject ' + obj.model.get('name') + ' has been created!');
            },
            error: function(model,err) { 
              Notify.spinner('hide');
              Notify.info('Sorry, the error occured! Please reload the page and try again.');
              console.log(err);
            }
          });
        });
      }
    };

    // No cut and paste for the moment
    delete res.ccp.submenu.copy;

    // Remove a node
    // -------------------

    res.remove = {
      "separator_before"  : false,
      "icon"        : false,
      "separator_after" : false,
      "_disabled"   : function (data) {
        var inst = $.jstree.reference(data.reference),
            obj = inst.get_node(data.reference);
            hasChildren = obj.children.length > 0;
        return hasChildren; // Only leaf nodes can be deleted
      },
      "label"       : "Delete",
      "action"      : function (data, context) {
        var inst = $.jstree.reference(data.reference),
          obj = inst.get_node(data.reference);
        
        console.log('deleting...', obj.id);

        obj.model.destroy({
          success: function(model,resp) {
            Notify.spinner('hide');
            Notify.info('Subject ' + obj.model.get('name') + ' has been removed!');
          },
          error: function(model,err) { 
            Notify.spinner('hide');
            Notify.info('Sorry, the error occured! Please reload the page and try again.');
            console.log(err);
          }
        });

        // ----------------------------------------
        // TODO DANIEL:
        // Call server function deleteSubject
        // ----------------------------------------


        if(inst.is_selected(obj)) {
          inst.delete_node(inst.get_selected());
        }
        else {
          inst.delete_node(obj);
        }
      }
    };

    // Start a merge
    // -------------------

    res.merge = {
      "separator_before"  : true,
      "_disabled"     : false,
      "label"       : "Merge",
      "_disabled"   : function (data) {
        var inst = $.jstree.reference(data.reference),
            obj = inst.get_node(data.reference);
            hasChildren = obj.children.length > 0;
        return hasChildren; // Only leaf nodes can be merged
      },
      "action"      : function (data) {
        var inst = $.jstree.reference(data.reference),
            obj = inst.get_node(data.reference);

        console.log('obj node to merge', data.reference);
        $.jstree.currentState.nodeToMerge = obj.id;
      }
    };

    // Complete a merge
    // -------------------

    res.mergeInto = {
      "separator_before"  : false,
      "separator_after" : true,
      "_disabled"     : function (data) {
        return !$.jstree.currentState.nodeToMerge;
      },
      "label"       : "Merge into",
      "action"      : function (data) {
        var inst = $.jstree.reference(data.reference),
            targetNode = inst.get_node(data.reference),
            nodeToMerge = inst.get_node($.jstree.currentState.nodeToMerge);

        if (!nodeToMerge) {
          console.log('seems like state.nodeToMerge is no longer in the tree. Doing nothing...');
          return;
        }

        if (nodeToMerge === targetNode) {
          Notify.spinner('hide');
          var notice = Notify.info('Can not merge with itself!');
          return;
        }
        
        console.log('completing merge of ', nodeToMerge.id, 'into ', targetNode.id);

        // ----------------------------------------
        // TODO DANIEL:
        // Call server function mergeSubjects
        // ----------------------------------------

        request
          .get('/api/subjects/merge')
          .query({ one: nodeToMerge.id, into: targetNode.id })
          .end(function(res){
            if(res.ok) {
              Notify.spinner('hide');
              Notify.info('Merge has been completed!');
            } else {
              Notify.spinner('hide');
              var notice = Notify.info('Sorry, the error occured! Please reload the page and try again.');
            }
          });

        inst.delete_node(nodeToMerge);
        $.jstree.currentState.nodeToMerge = null;
      }
    };

    return res;
  },
  close: function() {
    $('#' + this.icon).removeClass('active');
    this.remove();
    this.unbind();
  },
  _onMoveNode: function(e, data, context) {
    console.log('node moved yay', e, data);
      
    var movedNode = data.node;
    var newParent = data.parent;
    var oldParent = data.old_parent;

    console.log('changing parent from node', movedNode.id, 'from', oldParent, 'to', newParent);

    // Use backbone stuff to retrieve the model with that id
    var subject = context.collection.get(movedNode.id);

    if(newParent == '#') newParent = '';

    subject.save('parent', newParent, {
      success: function(model, resp) { 
        Notify.spinner('hide');
        var notice = Notify.info('Subject ' + subject.get('name') + ' has been changed');
      },
      error: function(model, err) { 
        Notify.spinner('hide');
        var notice = Notify.info('Sorry, the error occured! Please reload the page and try again.');
        console.log(err);
      }
    })
  },
  _onRenameNode: function(e, data, context) {
    console.log('renamed node moved yay', e, data);
      
    var updatedNode = data.node;
    var newName = data.text;
    var oldName = data.old;

    console.log('changing name of node', updatedNode.id, 'from', oldName, 'to', newName);

    // Use backbone stuff to retrieve the model with that id
    var subject = context.collection.get(updatedNode.id);

    subject.save('name', newName, {
      success: function(model, resp) { 
        Notify.spinner('hide');
        var notice = Notify.info('Subject ' + subject.get('name') + ' has been changed');
      },
      error: function(model, err) { 
        Notify.spinner('hide');
        var notice = Notify.info('Sorry, the error occured! Please reload the page and try again.');
        console.log(err);
      }
    })
  },
  panel: [
    {
      name: "save",
      icon: "save",
      fn: "_save"
    },
    {
      name: "Add new subject",
      icon: "plus",
      fn: "_add"
    },
    {
      name: "import",
      icon: "file-text-o",
      fn: "_import"
    }
  ]
})
exports.subjectsTreeView = SubjectsTreeView

var SubjectsEdit = Backbone.View.extend({
  className: "subject-edit",
  initialize: function () {
    this.bind("ok", this._save);
    this.bind("cancel", this.close);
  },
  render: function() {
    this.form = new Backbone.Form({
      model: this.model
    }).render();
    this.$el.html(this.form.el);
    return this;
  },
  _save: function(modal) {
    modal.preventClose();

    var self = this,
        errors = self.form.commit();

    if(!errors) {
      Notify.spinner('show');
      self.model.save({}, {
        wait: true,
        success: function(model,resp) { 
          Notify.spinner('hide');
          var notice = Notify.info('New subject has been saved');
          modal.close();
          self.remove();
        },
        error: function(model,err) { 
          Notify.spinner('hide');
          var notice = Notify.info('Sorry, the error occured!');
          console.log(err);
        }
      });
    }
  },
  close: function() {
    this.remove();
    this.unbind();
  }
})
exports.subjectsEdit = SubjectsEdit


//MENU

var MainMenu = Backbone.View.extend({
  manage: true,
  events: {
    'click li:not(.active)': 'goToInternal'
  },
  initialize: function() {
    var self = this;
    self.render();
  },
  template: '#mainmenu',
  goToInternal: function(e) {
    e.preventDefault()
    Backbone.middle.trigger("goTo", e.currentTarget.dataset.url)
  },
  serialize: function() {
    return { items: this.collection };
  }
});
exports.mainMenu = MainMenu

// CONTEXT MENU

var ContextMenu = Backbone.View.extend({
  manage: true,
  className: "context-toolbar animate",
  events: {
    'click .btn': '_run'
  },
  initialize: function() {
    var self = this;
    self.render();
    self.collection.on("reset", function(col, prev){
      self.prev = prev.previousModels;
      self.render();
    });
    self.collection.on("restore", self.restore, self);
  },
  template: '#contextmenu',
  serialize: function() {
    return { items: this.collection };
  },
  restore: function() {
    this.collection.reset(this.prev);
  },
  _run: function(e) {
    e.preventDefault();
    var view = this.layout.getRoot(),
        fn = e.currentTarget.dataset.fn;

    view[fn]();
  },
  close: function() {
    this.remove();
    this.unbind();
  }
});
exports.contextMenu = ContextMenu;

// UTILS

var ClickableRow = Backgrid.Row.extend({
  events: {
    "click": "onClick"
  },
  onClick: function (e) {
    e.preventDefault()
    if(e.target.className.indexOf('string-cell') != -1 || e.target.className.indexOf('moment-cell') != -1) {
      var url = this.model.urlRoot.split('/')
      Backbone.middle.trigger("goTo", '/' + url[2] + '/' + this.model.id)
    }
  }
});
exports.clickableRow = ClickableRow

var DocumentRow = Backgrid.Row.extend({
  events: {
    "click": "onClick",
    "click .delete-document": "onRemove"
  },
  onClick: function (e) {
    e.preventDefault();
    Backbone.middle.trigger("goToExt", '/archivist.html#state=composer.main;0.path='+this.model.get('id')+';1.contextId=toc');
  },
  onRemove: function(e) {
    e.preventDefault();
    e.stopPropagation();
    var confirm = window.confirm("Are you sure you want to do this?\nThis action can't be undone. Think twice!");
    if(confirm) {
      this.model.destroy();
    }
  }
});
exports.documentRow = DocumentRow

var DocumentCell = Backgrid.ObjectCell = Backgrid.Cell.extend({
  className: "string-cell document-cell animate",
  render: function () {
    this.$el.empty();
    var formattedValue = this.formatter.fromRaw(this.model.get('nodes'));
    if(_.isNull(formattedValue) || _.isEmpty(formattedValue)){
      this.delegateEvents();
      return this;
    }
    else {
      var metadata = formattedValue.document;

      var markup = '<div class="title">' + metadata.title + '</div> \
                    <span class="delete-document">Delete</span> \
                    <div class="updated-at">updated at ' + moment(metadata.updated_at).fromNow() + '</div>';

      this.$el.append(markup)
      this.delegateEvents()
      return this;
    }
  }
});
exports.documentCell = DocumentCell

var Filter = Backgrid.Extension.ServerSideFilter.extend({
  className: "backgrid-filter form-search animate",
  initialize: function (options) {
      Backgrid.Extension.ServerSideFilter.__super__.initialize.apply(this, arguments);
      this.name = options.name || this.name;
      this.placeholder = options.placeholder || this.placeholder;
      this.template = options.template || this.template;

      // Persist the query on pagination
      var collection = this.collection, self = this;
      if (Backbone.PageableCollection &&
          collection instanceof Backbone.PageableCollection &&
          collection.mode == "server") {
          if(_.isUndefined(collection.queryParams.query)) {
          collection.queryParams.query = {};
        }
          collection.queryParams.query[this.name] = function () {
            var value = self.searchBox().val();
            if(!_.isEmpty(value)){
              return JSON.stringify({ $regex: value, $options: 'i' });
            } else {
              return null;
            }
          };
        }
    },
  search: function (e) {
    if (e) e.preventDefault();

    var data = { query: {} };
    data.query = JSON.stringify({ $regex: this.searchBox().val(), $options: 'i' });

    var collection = this.collection;
    // go back to the first page on search
    if (Backbone.PageableCollection &&
          collection instanceof Backbone.PageableCollection) {
          collection.getFirstPage({data: data, reset: true, fetch: true});
    }
    else collection.fetch({data: data, reset: true});
    },
});
exports.filter = Filter
},{"./local_modules/backbone.bootstrap-modal":2,"./local_modules/backgrid-paginator/backgrid-paginator.js":3,"./local_modules/bootstrap-form/bootstrap3.js":4,"./local_modules/bootstrap-modal/bootstrap.js":5,"./local_modules/jstree/dist/jstree.js":6,"./local_modules/notify/notify.js":7,"./local_modules/objectid/Objectid.js":8,"./local_modules/parent-form/parent.js":9,"backbone":19,"backbone-forms":15,"backbone.layoutmanager":16,"backbone.paginator":17,"backgrid":23,"backgrid-filter":21,"jquery":25,"moment":26,"superagent":27,"underscore":30}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlc1xcYnJvd3NlcmlmeVxcbm9kZV9tb2R1bGVzXFxicm93c2VyLXBhY2tcXF9wcmVsdWRlLmpzIiwiY2xpZW50XFxwbGF0Zm9ybVxcaW5kZXguanMiLCJjbGllbnRcXHBsYXRmb3JtXFxsb2NhbF9tb2R1bGVzXFxiYWNrYm9uZS5ib290c3RyYXAtbW9kYWxcXHNyY1xcYmFja2JvbmUuYm9vdHN0cmFwLW1vZGFsLmpzIiwiY2xpZW50XFxwbGF0Zm9ybVxcbG9jYWxfbW9kdWxlc1xcYmFja2dyaWQtcGFnaW5hdG9yXFxiYWNrZ3JpZC1wYWdpbmF0b3IuanMiLCJjbGllbnRcXHBsYXRmb3JtXFxsb2NhbF9tb2R1bGVzXFxib290c3RyYXAtZm9ybVxcYm9vdHN0cmFwMy5qcyIsImNsaWVudFxccGxhdGZvcm1cXGxvY2FsX21vZHVsZXNcXGJvb3RzdHJhcC1tb2RhbFxcYm9vdHN0cmFwLmpzIiwiY2xpZW50XFxwbGF0Zm9ybVxcbG9jYWxfbW9kdWxlc1xcanN0cmVlXFxkaXN0XFxqc3RyZWUuanMiLCJjbGllbnRcXHBsYXRmb3JtXFxsb2NhbF9tb2R1bGVzXFxub3RpZnlcXG5vdGlmeS5qcyIsImNsaWVudFxccGxhdGZvcm1cXGxvY2FsX21vZHVsZXNcXG9iamVjdGlkXFxPYmplY3RpZC5qcyIsImNsaWVudFxccGxhdGZvcm1cXGxvY2FsX21vZHVsZXNcXHBhcmVudC1mb3JtXFxwYXJlbnQuanMiLCJjbGllbnRcXHBsYXRmb3JtXFxtb2RlbHNcXGRvY3VtZW50LmpzIiwiY2xpZW50XFxwbGF0Zm9ybVxcbW9kZWxzXFxpbmRleC5qcyIsImNsaWVudFxccGxhdGZvcm1cXG1vZGVsc1xcbWVudS5qcyIsImNsaWVudFxccGxhdGZvcm1cXG1vZGVsc1xcc3ViamVjdC5qcyIsImNsaWVudFxccGxhdGZvcm1cXG1vZGVsc1xcdXRpbC5qcyIsImNsaWVudFxccGxhdGZvcm1cXG5vZGVfbW9kdWxlc1xcYmFja2JvbmUtZm9ybXNcXGRpc3RyaWJ1dGlvblxcYmFja2JvbmUtZm9ybXMuanMiLCJjbGllbnRcXHBsYXRmb3JtXFxub2RlX21vZHVsZXNcXGJhY2tib25lLmxheW91dG1hbmFnZXJcXGJhY2tib25lLmxheW91dG1hbmFnZXIuanMiLCJjbGllbnRcXHBsYXRmb3JtXFxub2RlX21vZHVsZXNcXGJhY2tib25lLnBhZ2luYXRvclxcbGliXFxiYWNrYm9uZS5wYWdpbmF0b3IuanMiLCJjbGllbnRcXHBsYXRmb3JtXFxub2RlX21vZHVsZXNcXGJhY2tib25lLnBhZ2luYXRvclxcbm9kZV9tb2R1bGVzXFx1bmRlcnNjb3JlXFx1bmRlcnNjb3JlLmpzIiwiY2xpZW50XFxwbGF0Zm9ybVxcbm9kZV9tb2R1bGVzXFxiYWNrYm9uZVxcYmFja2JvbmUuanMiLCJjbGllbnRcXHBsYXRmb3JtXFxub2RlX21vZHVsZXNcXGJhY2tncmlkLWZpbHRlclxcYmFja2dyaWQtZmlsdGVyLmpzIiwiY2xpZW50XFxwbGF0Zm9ybVxcbm9kZV9tb2R1bGVzXFxiYWNrZ3JpZC1maWx0ZXJcXG5vZGVfbW9kdWxlc1xcbHVuclxcbHVuci5qcyIsImNsaWVudFxccGxhdGZvcm1cXG5vZGVfbW9kdWxlc1xcYmFja2dyaWRcXGxpYlxcYmFja2dyaWQuanMiLCJjbGllbnRcXHBsYXRmb3JtXFxub2RlX21vZHVsZXNcXGJhY2tncmlkXFxub2RlX21vZHVsZXNcXHVuZGVyc2NvcmVcXHVuZGVyc2NvcmUuanMiLCJjbGllbnRcXHBsYXRmb3JtXFxub2RlX21vZHVsZXNcXGpxdWVyeVxcZGlzdFxcanF1ZXJ5LmpzIiwiY2xpZW50XFxwbGF0Zm9ybVxcbm9kZV9tb2R1bGVzXFxtb21lbnRcXG1vbWVudC5qcyIsImNsaWVudFxccGxhdGZvcm1cXG5vZGVfbW9kdWxlc1xcc3VwZXJhZ2VudFxcbGliXFxjbGllbnQuanMiLCJjbGllbnRcXHBsYXRmb3JtXFxub2RlX21vZHVsZXNcXHN1cGVyYWdlbnRcXG5vZGVfbW9kdWxlc1xcY29tcG9uZW50LWVtaXR0ZXJcXGluZGV4LmpzIiwiY2xpZW50XFxwbGF0Zm9ybVxcbm9kZV9tb2R1bGVzXFxzdXBlcmFnZW50XFxub2RlX21vZHVsZXNcXHJlZHVjZS1jb21wb25lbnRcXGluZGV4LmpzIiwiY2xpZW50XFxwbGF0Zm9ybVxccm91dGVyLmpzIiwiY2xpZW50XFxwbGF0Zm9ybVxcdmlld3MuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0a09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDL2dGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3htQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzd5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3Y0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4a0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6dURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjBGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdCtSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4M0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDempDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpLFxyXG5cdFx0XyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSxcclxuICAgIGpxdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpLFxyXG4gICAgcm91dGVyID0gcmVxdWlyZSgnLi9yb3V0ZXIuanMnKTtcclxuXHJcbkJhY2tib25lLiQgPSB3aW5kb3cuJCA9IGpxdWVyeTtcclxuXHJcbnZhciBBcHBTdGFydCA9IGZ1bmN0aW9uKCkge1xyXG4gIEJhY2tib25lLkFwcFJvdXRlciA9IG5ldyByb3V0ZXIoKTtcclxuICBCYWNrYm9uZS5oaXN0b3J5LnN0YXJ0KHsgcHVzaFN0YXRlOiB0cnVlLCByb290OiAnLycgfSk7XHJcbn1cclxuXHJcbkJhY2tib25lLm1pZGRsZSA9IF8uZXh0ZW5kKHtcclxuXHRnb1RvOiBmdW5jdGlvbih1cmwpIHtcclxuICBcdEJhY2tib25lLkFwcFJvdXRlci5uYXZpZ2F0ZSh1cmwsIHt0cmlnZ2VyOiB0cnVlfSk7XHJcblx0fSxcclxuXHRnb1RvUHJldjogZnVuY3Rpb24oKSB7XHJcblx0XHRCYWNrYm9uZS5BcHBSb3V0ZXIucHJldmlvdXMoKTtcclxuXHR9LFxyXG5cdGdvVG9FeHQ6IGZ1bmN0aW9uKHVybCkge1xyXG5cdFx0d2luZG93LmxvY2F0aW9uID0gdXJsO1xyXG5cdH1cclxufSwgQmFja2JvbmUuRXZlbnRzKTtcclxuXHJcbkJhY2tib25lLm1pZGRsZS5vbih7XHJcblx0XCJnb1RvXCI6IEJhY2tib25lLm1pZGRsZS5nb1RvLFxyXG5cdFwiZ29Ub1ByZXZpb3VzXCI6IEJhY2tib25lLm1pZGRsZS5nb1RvUHJldixcclxuXHRcImdvVG9FeHRcIjogQmFja2JvbmUubWlkZGxlLmdvVG9FeHRcclxufSk7XHJcblxyXG5BcHBTdGFydCgpOyIsIi8qKlxyXG4gKiBCb290c3RyYXAgTW9kYWwgd3JhcHBlciBmb3IgdXNlIHdpdGggQmFja2JvbmUuXHJcbiAqXHJcbiAqIFRha2VzIGNhcmUgb2YgaW5zdGFudGlhdGlvbiwgbWFuYWdlcyBtdWx0aXBsZSBtb2RhbHMsXHJcbiAqIGFkZHMgc2V2ZXJhbCBvcHRpb25zIGFuZCByZW1vdmVzIHRoZSBlbGVtZW50IGZyb20gdGhlIERPTSB3aGVuIGNsb3NlZFxyXG4gKlxyXG4gKiBAYXV0aG9yIENoYXJsZXMgRGF2aXNvbiA8Y2hhcmxpZUBwb3dtZWRpYS5jby51az5cclxuICpcclxuICogRXZlbnRzOlxyXG4gKiBzaG93bjogRmlyZWQgd2hlbiB0aGUgbW9kYWwgaGFzIGZpbmlzaGVkIGFuaW1hdGluZyBpblxyXG4gKiBoaWRkZW46IEZpcmVkIHdoZW4gdGhlIG1vZGFsIGhhcyBmaW5pc2hlZCBhbmltYXRpbmcgb3V0XHJcbiAqIGNhbmNlbDogVGhlIHVzZXIgZGlzbWlzc2VkIHRoZSBtb2RhbFxyXG4gKiBvazogVGhlIHVzZXIgY2xpY2tlZCBPS1xyXG4gKi9cclxuXHJcbnZhciBCYWNrYm9uZSA9IHJlcXVpcmUoJ2JhY2tib25lJyksXHJcbiAgICBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpLFxyXG4gICAgJCA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG5cclxuKGZ1bmN0aW9uKCQsIF8sIEJhY2tib25lKSB7XHJcblxyXG4gIC8vU2V0IGN1c3RvbSB0ZW1wbGF0ZSBzZXR0aW5nc1xyXG4gIHZhciBfaW50ZXJwb2xhdGVCYWNrdXAgPSBfLnRlbXBsYXRlU2V0dGluZ3M7XHJcbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xyXG4gICAgaW50ZXJwb2xhdGU6IC9cXHtcXHsoLis/KVxcfVxcfS9nLFxyXG4gICAgZXZhbHVhdGU6IC88JShbXFxzXFxTXSs/KSU+L2dcclxuICB9O1xyXG5cclxuICB2YXIgdGVtcGxhdGUgPSBfLnRlbXBsYXRlKCdcXFxyXG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZ1wiPjxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCI+XFxcclxuICAgIDwlIGlmICh0aXRsZSkgeyAlPlxcXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1oZWFkZXJcIj5cXFxyXG4gICAgICAgIDwlIGlmIChhbGxvd0NhbmNlbCkgeyAlPlxcXHJcbiAgICAgICAgICA8YSBjbGFzcz1cImNsb3NlXCI+JnRpbWVzOzwvYT5cXFxyXG4gICAgICAgIDwlIH0gJT5cXFxyXG4gICAgICAgIDxoND57e3RpdGxlfX08L2g0PlxcXHJcbiAgICAgIDwvZGl2PlxcXHJcbiAgICA8JSB9ICU+XFxcclxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5XCI+e3tjb250ZW50fX08L2Rpdj5cXFxyXG4gICAgPCUgaWYgKHNob3dGb290ZXIpIHsgJT5cXFxyXG4gICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtZm9vdGVyXCI+XFxcclxuICAgICAgICA8JSBpZiAoYWxsb3dDYW5jZWwpIHsgJT5cXFxyXG4gICAgICAgICAgPCUgaWYgKGNhbmNlbFRleHQpIHsgJT5cXFxyXG4gICAgICAgICAgICA8YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuIGNhbmNlbFwiPnt7Y2FuY2VsVGV4dH19PC9hPlxcXHJcbiAgICAgICAgICA8JSB9ICU+XFxcclxuICAgICAgICA8JSB9ICU+XFxcclxuICAgICAgICA8YSBocmVmPVwiI1wiIGNsYXNzPVwiYnRuIG9rIGJ0bi1wcmltYXJ5XCI+e3tva1RleHR9fTwvYT5cXFxyXG4gICAgICA8L2Rpdj5cXFxyXG4gICAgPCUgfSAlPlxcXHJcbiAgICA8L2Rpdj48L2Rpdj5cXFxyXG4gICcpO1xyXG5cclxuICAvL1Jlc2V0IHRvIHVzZXJzJyB0ZW1wbGF0ZSBzZXR0aW5nc1xyXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IF9pbnRlcnBvbGF0ZUJhY2t1cDtcclxuXHJcblxyXG4gIHZhciBNb2RhbCA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuXHJcbiAgICBjbGFzc05hbWU6ICdtb2RhbCcsXHJcblxyXG4gICAgZXZlbnRzOiB7XHJcbiAgICAgICdjbGljayAuY2xvc2UnOiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIHRoaXMudHJpZ2dlcignY2FuY2VsJyk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudCAmJiB0aGlzLm9wdGlvbnMuY29udGVudC50cmlnZ2VyKSB7XHJcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuY29udGVudC50cmlnZ2VyKCdjYW5jZWwnLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgICdjbGljayAuY2FuY2VsJzogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NhbmNlbCcpO1xyXG5cclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvbnRlbnQgJiYgdGhpcy5vcHRpb25zLmNvbnRlbnQudHJpZ2dlcikge1xyXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRlbnQudHJpZ2dlcignY2FuY2VsJywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICAnY2xpY2sgLm9rJzogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ29rJyk7XHJcblxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29udGVudCAmJiB0aGlzLm9wdGlvbnMuY29udGVudC50cmlnZ2VyKSB7XHJcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuY29udGVudC50cmlnZ2VyKCdvaycsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5va0Nsb3Nlcykge1xyXG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgJ2tleXByZXNzJzogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVudGVyVHJpZ2dlcnNPayAmJiBldmVudC53aGljaCA9PSAxMykge1xyXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ29rJyk7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50ICYmIHRoaXMub3B0aW9ucy5jb250ZW50LnRyaWdnZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmNvbnRlbnQudHJpZ2dlcignb2snLCB0aGlzKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9rQ2xvc2VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgQm9vdHN0cmFwIE1vZGFsXHJcbiAgICAgKlxyXG4gICAgICogQHNlZSBodHRwOi8vdHdpdHRlci5naXRodWIuY29tL2Jvb3RzdHJhcC9qYXZhc2NyaXB0Lmh0bWwjbW9kYWxzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfFZpZXd9IFtvcHRpb25zLmNvbnRlbnRdICAgICBNb2RhbCBjb250ZW50LiBEZWZhdWx0OiBub25lXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMudGl0bGVdICAgICAgICAgICAgVGl0bGUuIERlZmF1bHQ6IG5vbmVcclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5va1RleHRdICAgICAgICAgICBUZXh0IGZvciB0aGUgT0sgYnV0dG9uLiBEZWZhdWx0OiAnT0snXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuY2FuY2VsVGV4dF0gICAgICAgVGV4dCBmb3IgdGhlIGNhbmNlbCBidXR0b24uIERlZmF1bHQ6ICdDYW5jZWwnLiBJZiBwYXNzZWQgYSBmYWxzZXkgdmFsdWUsIHRoZSBidXR0b24gd2lsbCBiZSByZW1vdmVkXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93Q2FuY2VsICAgICAgV2hldGhlciB0aGUgbW9kYWwgY2FuIGJlIGNsb3NlZCwgb3RoZXIgdGhhbiBieSBwcmVzc2luZyBPSy4gRGVmYXVsdDogdHJ1ZVxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5lc2NhcGVdICAgICAgICAgIFdoZXRoZXIgdGhlICdlc2MnIGtleSBjYW4gZGlzbWlzcyB0aGUgbW9kYWwuIERlZmF1bHQ6IHRydWUsIGJ1dCBmYWxzZSBpZiBvcHRpb25zLmNhbmNlbGxhYmxlIGlzIHRydWVcclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYW5pbWF0ZV0gICAgICAgICBXaGV0aGVyIHRvIGFuaW1hdGUgaW4vb3V0LiBEZWZhdWx0OiBmYWxzZVxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudGVtcGxhdGVdICAgICAgIENvbXBpbGVkIHVuZGVyc2NvcmUgdGVtcGxhdGUgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb25lXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmVudGVyVHJpZ2dlcnNPa10gV2hldGhlciB0aGUgJ2VudGVyJyBrZXkgd2lsbCB0cmlnZ2VyIE9LLiBEZWZhdWx0OiBmYWxzZVxyXG4gICAgICovXHJcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHtcclxuICAgICAgICB0aXRsZTogbnVsbCxcclxuICAgICAgICBva1RleHQ6ICdPSycsXHJcbiAgICAgICAgZm9jdXNPazogdHJ1ZSxcclxuICAgICAgICBva0Nsb3NlczogdHJ1ZSxcclxuICAgICAgICBjYW5jZWxUZXh0OiAnQ2FuY2VsJyxcclxuICAgICAgICBzaG93Rm9vdGVyOiB0cnVlLFxyXG4gICAgICAgIGFsbG93Q2FuY2VsOiB0cnVlLFxyXG4gICAgICAgIGVzY2FwZTogdHJ1ZSxcclxuICAgICAgICBhbmltYXRlOiBmYWxzZSxcclxuICAgICAgICB0ZW1wbGF0ZTogdGVtcGxhdGUsXHJcbiAgICAgICAgZW50ZXJUcmlnZ2Vyc09rOiBmYWxzZVxyXG4gICAgICB9LCBvcHRpb25zKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIHRoZSBET00gZWxlbWVudFxyXG4gICAgICpcclxuICAgICAqIEBhcGkgcHJpdmF0ZVxyXG4gICAgICovXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgJGVsID0gdGhpcy4kZWwsXHJcbiAgICAgICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gICAgICAgICAgY29udGVudCA9IG9wdGlvbnMuY29udGVudDtcclxuXHJcbiAgICAgIC8vQ3JlYXRlIHRoZSBtb2RhbCBjb250YWluZXJcclxuICAgICAgJGVsLmh0bWwob3B0aW9ucy50ZW1wbGF0ZShvcHRpb25zKSk7XHJcblxyXG4gICAgICB2YXIgJGNvbnRlbnQgPSB0aGlzLiRjb250ZW50ID0gJGVsLmZpbmQoJy5tb2RhbC1ib2R5JylcclxuXHJcbiAgICAgIC8vSW5zZXJ0IHRoZSBtYWluIGNvbnRlbnQgaWYgaXQncyBhIHZpZXdcclxuICAgICAgaWYgKGNvbnRlbnQgJiYgY29udGVudC4kZWwpIHtcclxuICAgICAgICBjb250ZW50LnJlbmRlcigpO1xyXG4gICAgICAgICRlbC5maW5kKCcubW9kYWwtYm9keScpLmh0bWwoY29udGVudC4kZWwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRlKSAkZWwuYWRkQ2xhc3MoJ2ZhZGUnKTtcclxuXHJcbiAgICAgIHRoaXMuaXNSZW5kZXJlZCA9IHRydWU7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXJzIGFuZCBzaG93cyB0aGUgbW9kYWxcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdICAgICBPcHRpb25hbCBjYWxsYmFjayB0aGF0IHJ1bnMgb25seSB3aGVuIE9LIGlzIHByZXNzZWQuXHJcbiAgICAgKi9cclxuICAgIG9wZW46IGZ1bmN0aW9uKGNiKSB7XHJcbiAgICAgIGlmICghdGhpcy5pc1JlbmRlcmVkKSB0aGlzLnJlbmRlcigpO1xyXG5cclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgJGVsID0gdGhpcy4kZWw7XHJcblxyXG4gICAgICAvL0NyZWF0ZSBpdFxyXG4gICAgICAkZWwubW9kYWwoXy5leHRlbmQoe1xyXG4gICAgICAgIGtleWJvYXJkOiB0aGlzLm9wdGlvbnMuYWxsb3dDYW5jZWwsXHJcbiAgICAgICAgYmFja2Ryb3A6IHRoaXMub3B0aW9ucy5hbGxvd0NhbmNlbCA/IHRydWUgOiAnc3RhdGljJ1xyXG4gICAgICB9LCB0aGlzLm9wdGlvbnMubW9kYWxPcHRpb25zKSk7XHJcblxyXG4gICAgICAvL0ZvY3VzIE9LIGJ1dHRvblxyXG4gICAgICAkZWwub25lKCdzaG93bi5icy5tb2RhbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMuZm9jdXNPaykge1xyXG4gICAgICAgICAgJGVsLmZpbmQoJy5idG4ub2snKS5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5jb250ZW50ICYmIHNlbGYub3B0aW9ucy5jb250ZW50LnRyaWdnZXIpIHtcclxuICAgICAgICAgIHNlbGYub3B0aW9ucy5jb250ZW50LnRyaWdnZXIoJ3Nob3duJywgc2VsZik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ3Nob3duJyk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy9BZGp1c3QgdGhlIG1vZGFsIGFuZCBiYWNrZHJvcCB6LWluZGV4OyBmb3IgZGVhbGluZyB3aXRoIG11bHRpcGxlIG1vZGFsc1xyXG4gICAgICB2YXIgbnVtTW9kYWxzID0gTW9kYWwuY291bnQsXHJcbiAgICAgICAgICAkYmFja2Ryb3AgPSAkKCcubW9kYWwtYmFja2Ryb3A6ZXEoJytudW1Nb2RhbHMrJyknKSxcclxuICAgICAgICAgIGJhY2tkcm9wSW5kZXggPSBwYXJzZUludCgkYmFja2Ryb3AuY3NzKCd6LWluZGV4JyksMTApLFxyXG4gICAgICAgICAgZWxJbmRleCA9IHBhcnNlSW50KCRiYWNrZHJvcC5jc3MoJ3otaW5kZXgnKSwgMTApO1xyXG5cclxuICAgICAgJGJhY2tkcm9wLmNzcygnei1pbmRleCcsIGJhY2tkcm9wSW5kZXggKyBudW1Nb2RhbHMpO1xyXG4gICAgICB0aGlzLiRlbC5jc3MoJ3otaW5kZXgnLCBlbEluZGV4ICsgbnVtTW9kYWxzKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWxsb3dDYW5jZWwpIHtcclxuICAgICAgICAkYmFja2Ryb3Aub25lKCdjbGljaycsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5jb250ZW50ICYmIHNlbGYub3B0aW9ucy5jb250ZW50LnRyaWdnZXIpIHtcclxuICAgICAgICAgICAgc2VsZi5vcHRpb25zLmNvbnRlbnQudHJpZ2dlcignY2FuY2VsJywgc2VsZik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCdjYW5jZWwnKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgJChkb2N1bWVudCkub25lKCdrZXl1cC5kaXNtaXNzLm1vZGFsJywgZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgIGUud2hpY2ggPT0gMjcgJiYgc2VsZi50cmlnZ2VyKCdjYW5jZWwnKTtcclxuXHJcbiAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmNvbnRlbnQgJiYgc2VsZi5vcHRpb25zLmNvbnRlbnQudHJpZ2dlcikge1xyXG4gICAgICAgICAgICBlLndoaWNoID09IDI3ICYmIHNlbGYub3B0aW9ucy5jb250ZW50LnRyaWdnZXIoJ3Nob3duJywgc2VsZik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMub24oJ2NhbmNlbCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNlbGYuY2xvc2UoKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBNb2RhbC5jb3VudCsrO1xyXG5cclxuICAgICAgLy9SdW4gY2FsbGJhY2sgb24gT0sgaWYgcHJvdmlkZWRcclxuICAgICAgaWYgKGNiKSB7XHJcbiAgICAgICAgc2VsZi5vbignb2snLCBjYik7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIENsb3NlcyB0aGUgbW9kYWxcclxuICAgICAqL1xyXG4gICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgICAkZWwgPSB0aGlzLiRlbDtcclxuXHJcbiAgICAgIC8vQ2hlY2sgaWYgdGhlIG1vZGFsIHNob3VsZCBzdGF5IG9wZW5cclxuICAgICAgaWYgKHRoaXMuX3ByZXZlbnRDbG9zZSkge1xyXG4gICAgICAgIHRoaXMuX3ByZXZlbnRDbG9zZSA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgJGVsLm9uZSgnaGlkZGVuLmJzLm1vZGFsJywgZnVuY3Rpb24gb25IaWRkZW4oZSkge1xyXG4gICAgICAgIC8vIElnbm9yZSBldmVudHMgcHJvcGFnYXRlZCBmcm9tIGludGVyaW9yIG9iamVjdHMsIGxpa2UgYm9vdHN0cmFwIHRvb2x0aXBzXHJcbiAgICAgICAgaWYoZS50YXJnZXQgIT09IGUuY3VycmVudFRhcmdldCl7XHJcbiAgICAgICAgICByZXR1cm4gJGVsLm9uZSgnaGlkZGVuJywgb25IaWRkZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWxmLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmNvbnRlbnQgJiYgc2VsZi5vcHRpb25zLmNvbnRlbnQudHJpZ2dlcikge1xyXG4gICAgICAgICAgc2VsZi5vcHRpb25zLmNvbnRlbnQudHJpZ2dlcignaGlkZGVuJywgc2VsZik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ2hpZGRlbicpO1xyXG4gICAgICB9KTtcclxuXHJcbiAgICAgICRlbC5tb2RhbCgnaGlkZScpO1xyXG5cclxuICAgICAgTW9kYWwuY291bnQtLTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHRoZSBtb2RhbCBmcm9tIGNsb3NpbmcuXHJcbiAgICAgKiBDYW4gYmUgY2FsbGVkIGZyb20gd2l0aGluIGEgJ2Nsb3NlJyBvciAnb2snIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgICovXHJcbiAgICBwcmV2ZW50Q2xvc2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLl9wcmV2ZW50Q2xvc2UgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH0sIHtcclxuICAgIC8vU1RBVElDU1xyXG5cclxuICAgIC8vVGhlIG51bWJlciBvZiBtb2RhbHMgb24gZGlzcGxheVxyXG4gICAgY291bnQ6IDBcclxuICB9KTtcclxuXHJcblxyXG4gIC8vRVhQT1JUU1xyXG4gIC8vQ29tbW9uSlNcclxuICBpZiAodHlwZW9mIHJlcXVpcmUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBleHBvcnRzKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IE1vZGFsO1xyXG4gIH1cclxuXHJcbiAgLy9BTUQgLyBSZXF1aXJlSlNcclxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICByZXR1cm4gZGVmaW5lKGZ1bmN0aW9uKCkge1xyXG4gICAgICBCYWNrYm9uZS5Cb290c3RyYXBNb2RhbCA9IE1vZGFsO1xyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIC8vUmVndWxhcjsgYWRkIHRvIEJhY2tib25lLkJvb3RzdHJhcC5Nb2RhbFxyXG4gIGVsc2Uge1xyXG4gICAgQmFja2JvbmUuQm9vdHN0cmFwTW9kYWwgPSBNb2RhbDtcclxuICB9XHJcblxyXG59KShqUXVlcnksIF8sIEJhY2tib25lKTtcclxuIiwiLypcclxuICBiYWNrZ3JpZC1wYWdpbmF0b3JcclxuICBodHRwOi8vZ2l0aHViLmNvbS93eXVlbmhvL2JhY2tncmlkXHJcblxyXG4gIENvcHlyaWdodCAoYykgMjAxMyBKaW1teSBZdWVuIEhvIFdvbmcgYW5kIGNvbnRyaWJ1dG9yc1xyXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgQGxpY2Vuc2UuXHJcbiovXHJcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG5cclxuICAvLyBDb21tb25KU1xyXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiKSB7XHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInVuZGVyc2NvcmVcIiksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZShcImJhY2tib25lXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCJiYWNrZ3JpZFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlKFwiYmFja2JvbmUucGFnaW5hdG9yXCIpKTtcclxuICB9XHJcbiAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKFsndW5kZXJzY29yZScsICdiYWNrYm9uZScsICdiYWNrZ3JpZCcsICdiYWNrYm9uZS5wYWdpbmF0b3InXSwgZmFjdG9yeSk7XHJcbiAgfVxyXG4gIC8vIEJyb3dzZXJcclxuICBlbHNlIHtcclxuICAgIGZhY3Rvcnkocm9vdC5fLCByb290LkJhY2tib25lLCByb290LkJhY2tncmlkKTtcclxuICB9XHJcblxyXG59KHRoaXMsIGZ1bmN0aW9uIChfLCBCYWNrYm9uZSwgQmFja2dyaWQpIHtcclxuXHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gIC8qKlxyXG4gICAgIFBhZ2VIYW5kbGUgaXMgYSBjbGFzcyB0aGF0IHJlbmRlcnMgdGhlIGFjdHVhbCBwYWdlIGhhbmRsZXMgYW5kIHJlYWN0cyB0b1xyXG4gICAgIGNsaWNrIGV2ZW50cyBmb3IgcGFnaW5hdGlvbi5cclxuXHJcbiAgICAgVGhpcyBjbGFzcyBhY3RzIGluIHR3byBtb2RlcyAtIGNvbnRyb2wgb3IgZGlzY3JldGUgcGFnZSBoYW5kbGUgbW9kZXMuIElmXHJcbiAgICAgb25lIG9mIHRoZSBgaXMqYCBmbGFncyBpcyBgdHJ1ZWAsIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgdW5kZXJcclxuICAgICBjb250cm9sIHBhZ2UgaGFuZGxlIG1vZGUuIFNldHRpbmcgYSBgcGFnZUluZGV4YCB0byBhbiBpbnN0YW5jZSBvZiB0aGlzXHJcbiAgICAgY2xhc3MgdW5kZXIgY29udHJvbCBtb2RlIGhhcyBubyBlZmZlY3QgYW5kIHRoZSBjb3JyZWN0IHBhZ2UgaW5kZXggd2lsbFxyXG4gICAgIGFsd2F5cyBiZSBpbmZlcnJlZCBmcm9tIHRoZSBgaXMqYCBmbGFnLiBPbmx5IG9uZSBvZiB0aGUgYGlzKmAgZmxhZ3Mgc2hvdWxkXHJcbiAgICAgYmUgc2V0IHRvIGB0cnVlYCBhdCBhIHRpbWUuIEZvciBleGFtcGxlLCBhbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzIGNhbm5vdFxyXG4gICAgIHNpbXVsdGFuZW91c2x5IGJlIGEgcmV3aW5kIGNvbnRyb2wgYW5kIGEgZmFzdCBmb3J3YXJkIGNvbnRyb2wuIEEgYGxhYmVsYFxyXG4gICAgIGFuZCBhIGB0aXRsZWAgZnVuY3Rpb24gb3IgYSBzdHJpbmcgYXJlIHJlcXVpcmVkIHRvIGJlIHBhc3NlZCB0byB0aGVcclxuICAgICBjb25zdHVjdG9yIHVuZGVyIHRoaXMgbW9kZS4gSWYgYSBgdGl0bGVgIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBpdCBfX01VU1RfX1xyXG4gICAgIGFjY2VwdCBhIGhhc2ggcGFyYW1ldGVyIGBkYXRhYCwgd2hpY2ggY29udGFpbnMgYSBrZXkgYGxhYmVsYC4gSXRzIHJlc3VsdFxyXG4gICAgIHdpbGwgYmUgdXNlZCB0byByZW5kZXIgdGhlIGdlbmVyYXRlZCBhbmNob3IncyB0aXRsZSBhdHRyaWJ1dGUuXHJcblxyXG4gICAgIElmIGFsbCBvZiB0aGUgYGlzKmAgZmxhZ3MgaXMgc2V0IHRvIGBmYWxzZWAsIHdoaWNoIGlzIHRoZSBkZWZhdWx0LCBhblxyXG4gICAgIGluc3RhbmNlIG9mIHRoaXMgY2xhc3Mgd2lsbCBiZSBpbiBkaXNjcmV0ZSBwYWdlIGhhbmRsZSBtb2RlLiBBbiBpbnN0YW5jZVxyXG4gICAgIHVuZGVyIHRoaXMgbW9kZSByZXF1aXJlcyB0aGUgYHBhZ2VJbmRleGAgdG8gYmUgcGFzc2VkIGZyb20gdGhlIGNvbnN0cnVjdG9yXHJcbiAgICAgYXMgYW4gb3B0aW9uIGFuZCBpdCBfX01VU1RfXyBiZSBhIDAtYmFzZWQgaW5kZXggb2YgdGhlIGxpc3Qgb2YgcGFnZSBudW1iZXJzXHJcbiAgICAgdG8gcmVuZGVyLiBUaGUgY29uc3R1Y3RvciB3aWxsIG5vcm1hbGl6ZSB0aGUgYmFzZSB0byB0aGUgc2FtZSBiYXNlIHRoZVxyXG4gICAgIHVuZGVybHlpbmcgUGFnZWFibGVDb2xsZWN0aW9uIGNvbGxlY3Rpb24gaW5zdGFuY2UgdXNlcy4gQSBgbGFiZWxgIGlzIG5vdFxyXG4gICAgIHJlcXVpcmVkIHVuZGVyIHRoaXMgbW9kZSwgd2hpY2ggd2lsbCBkZWZhdWx0IHRvIHRoZSBlcXVpdmFsZW50IDEtYmFzZWQgcGFnZVxyXG4gICAgIGluZGV4IGNhbGN1bGF0ZWQgZnJvbSBgcGFnZUluZGV4YCBhbmQgdGhlIHVuZGVybHlpbmcgUGFnZWFibGVDb2xsZWN0aW9uXHJcbiAgICAgaW5zdGFuY2UuIEEgcHJvdmlkZWQgYGxhYmVsYCB3aWxsIHN0aWxsIGJlIGhvbm9yZWQgaG93ZXZlci4gVGhlIGB0aXRsZWBcclxuICAgICBwYXJhbWV0ZXIgaXMgYWxzbyBub3QgcmVxdWlyZWQgdW5kZXIgdGhpcyBtb2RlLCBpbiB3aGljaCBjYXNlIHRoZSBkZWZhdWx0XHJcbiAgICAgYHRpdGxlYCBmdW5jdGlvbiB3aWxsIGJlIHVzZWQuIFlvdSBhcmUgZW5jb3VyYWdlZCB0byBwcm92aWRlIHlvdXIgb3duXHJcbiAgICAgYHRpdGxlYCBmdW5jdGlvbiBob3dldmVyIGlmIHlvdSB3aXNoIHRvIGxvY2FsaXplIHRoZSB0aXRsZSBzdHJpbmdzLlxyXG5cclxuICAgICBJZiB0aGlzIHBhZ2UgaGFuZGxlIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgcGFnZSwgYW4gYGFjdGl2ZWAgY2xhc3Mgd2lsbCBiZVxyXG4gICAgIHBsYWNlZCBvbiB0aGUgcm9vdCBsaXN0IGVsZW1lbnQuXHJcblxyXG4gICAgIElmIHRoaXMgcGFnZSBoYW5kbGUgaXMgYXQgdGhlIGJvcmRlciBvZiB0aGUgbGlzdCBvZiBwYWdlcywgYSBgZGlzYWJsZWRgXHJcbiAgICAgY2xhc3Mgd2lsbCBiZSBwbGFjZWQgb24gdGhlIHJvb3QgbGlzdCBlbGVtZW50LlxyXG5cclxuICAgICBPbmx5IHBhZ2UgaGFuZGxlcyB0aGF0IGFyZSBuZWl0aGVyIGBhY3RpdmVgIG5vciBgZGlzYWJsZWRgIHdpbGwgcmVzcG9uZCB0b1xyXG4gICAgIGNsaWNrIGV2ZW50cyBhbmQgdHJpZ2dlcnMgcGFnaW5hdGlvbi5cclxuXHJcbiAgICAgQGNsYXNzIEJhY2tncmlkLkV4dGVuc2lvbi5QYWdlSGFuZGxlXHJcbiAgKi9cclxuICB2YXIgUGFnZUhhbmRsZSA9IEJhY2tncmlkLkV4dGVuc2lvbi5QYWdlSGFuZGxlID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG5cclxuICAgIC8qKiBAcHJvcGVydHkgKi9cclxuICAgIHRhZ05hbWU6IFwibGlcIixcclxuXHJcbiAgICAvKiogQHByb3BlcnR5ICovXHJcbiAgICBldmVudHM6IHtcclxuICAgICAgXCJjbGljayBhXCI6IFwiY2hhbmdlUGFnZVwiXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgQHByb3BlcnR5IHtzdHJpbmd8ZnVuY3Rpb24oT2JqZWN0LjxzdHJpbmcsIHN0cmluZz4pOiBzdHJpbmd9IHRpdGxlXHJcbiAgICAgICBUaGUgdGl0bGUgdG8gdXNlIGZvciB0aGUgYHRpdGxlYCBhdHRyaWJ1dGUgb2YgdGhlIGdlbmVyYXRlZCBwYWdlIGhhbmRsZVxyXG4gICAgICAgYW5jaG9yIGVsZW1lbnRzLiBJdCBjYW4gYmUgYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgYGRhdGFgXHJcbiAgICAgICBwYXJhbWV0ZXIsIHdoaWNoIGNvbnRhaW5zIGEgbWFuZGF0b3J5IGBsYWJlbGAga2V5IHdoaWNoIHByb3ZpZGVzIHRoZVxyXG4gICAgICAgbGFiZWwgdmFsdWUgdG8gYmUgZGlzcGxheWVkLlxyXG4gICAgKi9cclxuICAgIHRpdGxlOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICByZXR1cm4gJ1BhZ2UgJyArIGRhdGEubGFiZWw7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgQHByb3BlcnR5IHtib29sZWFufSBpc1Jld2luZCBXaGV0aGVyIHRoaXMgaGFuZGxlIHJlcHJlc2VudHMgYSByZXdpbmRcclxuICAgICAgIGNvbnRyb2xcclxuICAgICovXHJcbiAgICBpc1Jld2luZDogZmFsc2UsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBAcHJvcGVydHkge2Jvb2xlYW59IGlzQmFjayBXaGV0aGVyIHRoaXMgaGFuZGxlIHJlcHJlc2VudHMgYSBiYWNrXHJcbiAgICAgICBjb250cm9sXHJcbiAgICAqL1xyXG4gICAgaXNCYWNrOiBmYWxzZSxcclxuXHJcbiAgICAvKipcclxuICAgICAgIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNGb3J3YXJkIFdoZXRoZXIgdGhpcyBoYW5kbGUgcmVwcmVzZW50cyBhIGZvcndhcmRcclxuICAgICAgIGNvbnRyb2xcclxuICAgICovXHJcbiAgICBpc0ZvcndhcmQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgQHByb3BlcnR5IHtib29sZWFufSBpc0Zhc3RGb3J3YXJkIFdoZXRoZXIgdGhpcyBoYW5kbGUgcmVwcmVzZW50cyBhIGZhc3RcclxuICAgICAgIGZvcndhcmQgY29udHJvbFxyXG4gICAgKi9cclxuICAgIGlzRmFzdEZvcndhcmQ6IGZhbHNlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgSW5pdGlhbGl6ZXIuXHJcblxyXG4gICAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAgIEBwYXJhbSB7QmFja2JvbmUuQ29sbGVjdGlvbn0gb3B0aW9ucy5jb2xsZWN0aW9uXHJcbiAgICAgICBAcGFyYW0ge251bWJlcn0gcGFnZUluZGV4IDAtYmFzZWQgaW5kZXggb2YgdGhlIHBhZ2UgbnVtYmVyIHRoaXMgaGFuZGxlXHJcbiAgICAgICBoYW5kbGVzLiBUaGlzIHBhcmFtZXRlciB3aWxsIGJlIG5vcm1hbGl6ZWQgdG8gdGhlIGJhc2UgdGhlIHVuZGVybHlpbmdcclxuICAgICAgIFBhZ2VhYmxlQ29sbGVjdGlvbiB1c2VzLlxyXG4gICAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmxhYmVsXSBJZiBwcm92aWRlZCBpdCBpcyB1c2VkIHRvIHJlbmRlciB0aGVcclxuICAgICAgIGFuY2hvciB0ZXh0LCBvdGhlcndpc2UgdGhlIG5vcm1hbGl6ZWQgcGFnZUluZGV4IHdpbGwgYmUgdXNlZFxyXG4gICAgICAgaW5zdGVhZC4gUmVxdWlyZWQgaWYgYW55IG9mIHRoZSBgaXMqYCBmbGFncyBpcyBzZXQgdG8gYHRydWVgLlxyXG4gICAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRpdGxlXVxyXG4gICAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc1Jld2luZD1mYWxzZV1cclxuICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaXNCYWNrPWZhbHNlXVxyXG4gICAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc0ZvcndhcmQ9ZmFsc2VdXHJcbiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzRmFzdEZvcndhcmQ9ZmFsc2VdXHJcbiAgICAqL1xyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb247XHJcbiAgICAgIHZhciBzdGF0ZSA9IGNvbGxlY3Rpb24uc3RhdGU7XHJcbiAgICAgIHZhciBjdXJyZW50UGFnZSA9IHN0YXRlLmN1cnJlbnRQYWdlO1xyXG4gICAgICB2YXIgZmlyc3RQYWdlID0gc3RhdGUuZmlyc3RQYWdlO1xyXG4gICAgICB2YXIgbGFzdFBhZ2UgPSBzdGF0ZS5sYXN0UGFnZTtcclxuXHJcbiAgICAgIF8uZXh0ZW5kKHRoaXMsIF8ucGljayhvcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW1wiaXNSZXdpbmRcIiwgXCJpc0JhY2tcIiwgXCJpc0ZvcndhcmRcIiwgXCJpc0Zhc3RGb3J3YXJkXCJdKSk7XHJcblxyXG4gICAgICB2YXIgcGFnZUluZGV4O1xyXG4gICAgICBpZiAodGhpcy5pc1Jld2luZCkgcGFnZUluZGV4ID0gZmlyc3RQYWdlO1xyXG4gICAgICBlbHNlIGlmICh0aGlzLmlzQmFjaykgcGFnZUluZGV4ID0gTWF0aC5tYXgoZmlyc3RQYWdlLCBjdXJyZW50UGFnZSAtIDEpO1xyXG4gICAgICBlbHNlIGlmICh0aGlzLmlzRm9yd2FyZCkgcGFnZUluZGV4ID0gTWF0aC5taW4obGFzdFBhZ2UsIGN1cnJlbnRQYWdlICsgMSk7XHJcbiAgICAgIGVsc2UgaWYgKHRoaXMuaXNGYXN0Rm9yd2FyZCkgcGFnZUluZGV4ID0gbGFzdFBhZ2U7XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIHBhZ2VJbmRleCA9ICtvcHRpb25zLnBhZ2VJbmRleDtcclxuICAgICAgICBwYWdlSW5kZXggPSAoZmlyc3RQYWdlID8gcGFnZUluZGV4ICsgMSA6IHBhZ2VJbmRleCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XHJcblxyXG4gICAgICB0aGlzLmxhYmVsID0gKG9wdGlvbnMubGFiZWwgfHwgKGZpcnN0UGFnZSA/IHBhZ2VJbmRleCA6IHBhZ2VJbmRleCArIDEpKSArICcnO1xyXG4gICAgICB2YXIgdGl0bGUgPSBvcHRpb25zLnRpdGxlIHx8IHRoaXMudGl0bGU7XHJcbiAgICAgIHRoaXMudGl0bGUgPSBfLmlzRnVuY3Rpb24odGl0bGUpID8gdGl0bGUoe2xhYmVsOiB0aGlzLmxhYmVsfSkgOiB0aXRsZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBSZW5kZXJzIGEgY2xpY2thYmxlIGFuY2hvciBlbGVtZW50IHVuZGVyIGEgbGlzdCBpdGVtLlxyXG4gICAgKi9cclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLiRlbC5lbXB0eSgpO1xyXG4gICAgICB2YXIgYW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XHJcbiAgICAgIGFuY2hvci5ocmVmID0gJyMnO1xyXG4gICAgICBpZiAodGhpcy50aXRsZSkgYW5jaG9yLnRpdGxlID0gdGhpcy50aXRsZTtcclxuICAgICAgYW5jaG9yLmlubmVySFRNTCA9IHRoaXMubGFiZWw7XHJcbiAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQoYW5jaG9yKTtcclxuXHJcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uO1xyXG4gICAgICB2YXIgc3RhdGUgPSBjb2xsZWN0aW9uLnN0YXRlO1xyXG4gICAgICB2YXIgY3VycmVudFBhZ2UgPSBzdGF0ZS5jdXJyZW50UGFnZTtcclxuICAgICAgdmFyIHBhZ2VJbmRleCA9IHRoaXMucGFnZUluZGV4O1xyXG5cclxuICAgICAgaWYgKHRoaXMuaXNSZXdpbmQgJiYgY3VycmVudFBhZ2UgPT0gc3RhdGUuZmlyc3RQYWdlIHx8XHJcbiAgICAgICAgIHRoaXMuaXNCYWNrICYmICFjb2xsZWN0aW9uLmhhc1ByZXZpb3VzUGFnZSgpIHx8XHJcbiAgICAgICAgIHRoaXMuaXNGb3J3YXJkICYmICFjb2xsZWN0aW9uLmhhc05leHRQYWdlKCkgfHxcclxuICAgICAgICAgdGhpcy5pc0Zhc3RGb3J3YXJkICYmIChjdXJyZW50UGFnZSA9PSBzdGF0ZS5sYXN0UGFnZSB8fCBzdGF0ZS50b3RhbFBhZ2VzIDwgMSkpIHtcclxuICAgICAgICB0aGlzLiRlbC5hZGRDbGFzcyhcImRpc2FibGVkXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKCEodGhpcy5pc1Jld2luZCB8fFxyXG4gICAgICAgICAgICAgICAgIHRoaXMuaXNCYWNrIHx8XHJcbiAgICAgICAgICAgICAgICAgdGhpcy5pc0ZvcndhcmQgfHxcclxuICAgICAgICAgICAgICAgICB0aGlzLmlzRmFzdEZvcndhcmQpICYmXHJcbiAgICAgICAgICAgICAgIHN0YXRlLmN1cnJlbnRQYWdlID09IHBhZ2VJbmRleCkge1xyXG4gICAgICAgIHRoaXMuJGVsLmFkZENsYXNzKFwiYWN0aXZlXCIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAgIGpRdWVyeSBjbGljayBldmVudCBoYW5kbGVyLiBHb2VzIHRvIHRoZSBwYWdlIHRoaXMgUGFnZUhhbmRsZSBpbnN0YW5jZVxyXG4gICAgICAgcmVwcmVzZW50cy4gTm8tb3AgaWYgdGhpcyBwYWdlIGhhbmRsZSBpcyBjdXJyZW50bHkgYWN0aXZlIG9yIGRpc2FibGVkLlxyXG4gICAgKi9cclxuICAgIGNoYW5nZVBhZ2U6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgdmFyICRlbCA9IHRoaXMuJGVsLCBjb2wgPSB0aGlzLmNvbGxlY3Rpb247XHJcbiAgICAgIGlmICghJGVsLmhhc0NsYXNzKFwiYWN0aXZlXCIpICYmICEkZWwuaGFzQ2xhc3MoXCJkaXNhYmxlZFwiKSkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzUmV3aW5kKSBjb2wuZ2V0Rmlyc3RQYWdlKCk7XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0JhY2spIGNvbC5nZXRQcmV2aW91c1BhZ2UoKTtcclxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzRm9yd2FyZCkgY29sLmdldE5leHRQYWdlKCk7XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5pc0Zhc3RGb3J3YXJkKSBjb2wuZ2V0TGFzdFBhZ2UoKTtcclxuICAgICAgICBlbHNlIGNvbC5nZXRQYWdlKHRoaXMucGFnZUluZGV4LCB7cmVzZXQ6IHRydWV9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAgIFBhZ2luYXRvciBpcyBhIEJhY2tncmlkIGV4dGVuc2lvbiB0aGF0IHJlbmRlcnMgYSBzZXJpZXMgb2YgY29uZmlndXJhYmxlXHJcbiAgICAgcGFnaW5hdGlvbiBoYW5kbGVzLiBUaGlzIGV4dGVuc2lvbiBpcyBiZXN0IHVzZWQgZm9yIHNwbGl0dGluZyBhIGxhcmdlIGRhdGFcclxuICAgICBzZXQgYWNyb3NzIG11bHRpcGxlIHBhZ2VzLiBJZiB0aGUgbnVtYmVyIG9mIHBhZ2VzIGlzIGxhcmdlciB0aGVuIGFcclxuICAgICB0aHJlc2hvbGQsIHdoaWNoIGlzIHNldCB0byAxMCBieSBkZWZhdWx0LCB0aGUgcGFnZSBoYW5kbGVzIGFyZSByZW5kZXJlZFxyXG4gICAgIHdpdGhpbiBhIHNsaWRpbmcgd2luZG93LCBwbHVzIHRoZSByZXdpbmQsIGJhY2ssIGZvcndhcmQgYW5kIGZhc3QgZm9yd2FyZFxyXG4gICAgIGNvbnRyb2wgaGFuZGxlcy4gVGhlIGluZGl2aWR1YWwgY29udHJvbCBoYW5kbGVzIGNhbiBiZSB0dXJuZWQgb2ZmLlxyXG5cclxuICAgICBAY2xhc3MgQmFja2dyaWQuRXh0ZW5zaW9uLlBhZ2luYXRvclxyXG4gICovXHJcbiAgdmFyIFBhZ2luYXRvciA9IEJhY2tncmlkLkV4dGVuc2lvbi5QYWdpbmF0b3IgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcblxyXG4gICAgLyoqIEBwcm9wZXJ0eSAqL1xyXG4gICAgY2xhc3NOYW1lOiBcImJhY2tncmlkLXBhZ2luYXRvclwiLFxyXG5cclxuICAgIC8qKiBAcHJvcGVydHkgKi9cclxuICAgIHdpbmRvd1NpemU6IDEwLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgQHByb3BlcnR5IHtudW1iZXJ9IHNsaWRlU2NhbGUgdGhlIG51bWJlciB1c2VkIGJ5ICNzbGlkZUhvd011Y2ggdG8gc2NhbGVcclxuICAgICAgIGB3aW5kb3dTaXplYCB0byB5aWVsZCB0aGUgbnVtYmVyIG9mIHBhZ2VzIHRvIHNsaWRlLiBGb3IgZXhhbXBsZSwgdGhlXHJcbiAgICAgICBkZWZhdWx0IHdpbmRvd1NpemUoMTApICogc2xpZGVTY2FsZSgwLjUpIHlpZWxkcyA1LCB3aGljaCBtZWFucyB0aGUgd2luZG93XHJcbiAgICAgICB3aWxsIHNsaWRlIGZvcndhcmQgNSBwYWdlcyBhcyBzb29uIGFzIHlvdSd2ZSByZWFjaGVkIHBhZ2UgNi4gVGhlIHNtYWxsZXJcclxuICAgICAgIHRoZSBzY2FsZSBmYWN0b3IgdGhlIGxlc3MgcGFnZXMgdG8gc2xpZGUsIGFuZCB2aWNlIHZlcnNhLlxyXG5cclxuICAgICAgIEFsc28gU2VlOlxyXG5cclxuICAgICAgIC0gI3NsaWRlTWF5YmVcclxuICAgICAgIC0gI3NsaWRlSG93TXVjaFxyXG4gICAgKi9cclxuICAgIHNsaWRlU2NhbGU6IDAuNSxcclxuXHJcbiAgICAvKipcclxuICAgICAgIEBwcm9wZXJ0eSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdC48c3RyaW5nLCBzdHJpbmc+Pn0gY29udHJvbHMgWW91IGNhblxyXG4gICAgICAgZGlzYWJsZSBzcGVjaWZpYyBjb250cm9sIGhhbmRsZXMgYnkgc2V0dGluZyB0aGUga2V5cyBpbiBxdWVzdGlvbiB0b1xyXG4gICAgICAgbnVsbC4gVGhlIGRlZmF1bHRzIHdpbGwgYmUgbWVyZ2VkIHdpdGggeW91ciBjb250cm9scyBvYmplY3QsIHdpdGggeW91clxyXG4gICAgICAgY2hhbmdlcyB0YWtpbmcgcHJlY2VkZW50LlxyXG4gICAgKi9cclxuICAgIGNvbnRyb2xzOiB7XHJcbiAgICAgIHJld2luZDoge1xyXG4gICAgICAgIGxhYmVsOiBcIuOAilwiLFxyXG4gICAgICAgIHRpdGxlOiBcIkZpcnN0XCJcclxuICAgICAgfSxcclxuICAgICAgYmFjazoge1xyXG4gICAgICAgIGxhYmVsOiBcIuOAiFwiLFxyXG4gICAgICAgIHRpdGxlOiBcIlByZXZpb3VzXCJcclxuICAgICAgfSxcclxuICAgICAgZm9yd2FyZDoge1xyXG4gICAgICAgIGxhYmVsOiBcIuOAiVwiLFxyXG4gICAgICAgIHRpdGxlOiBcIk5leHRcIlxyXG4gICAgICB9LFxyXG4gICAgICBmYXN0Rm9yd2FyZDoge1xyXG4gICAgICAgIGxhYmVsOiBcIuOAi1wiLFxyXG4gICAgICAgIHRpdGxlOiBcIkxhc3RcIlxyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKiBAcHJvcGVydHkgKi9cclxuICAgIHJlbmRlckluZGV4ZWRQYWdlSGFuZGxlczogdHJ1ZSxcclxuXHJcbiAgICAvKipcclxuICAgICAgIEBwcm9wZXJ0eSB7QmFja2dyaWQuRXh0ZW5zaW9uLlBhZ2VIYW5kbGV9IHBhZ2VIYW5kbGUuIFRoZSBQYWdlSGFuZGxlXHJcbiAgICAgICBjbGFzcyB0byB1c2UgZm9yIHJlbmRlcmluZyBpbmRpdmlkdWFsIGhhbmRsZXNcclxuICAgICovXHJcbiAgICBwYWdlSGFuZGxlOiBQYWdlSGFuZGxlLFxyXG5cclxuICAgIC8qKiBAcHJvcGVydHkgKi9cclxuICAgIGdvQmFja0ZpcnN0T25Tb3J0OiB0cnVlLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgSW5pdGlhbGl6ZXIuXHJcblxyXG4gICAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAgIEBwYXJhbSB7QmFja2JvbmUuQ29sbGVjdGlvbn0gb3B0aW9ucy5jb2xsZWN0aW9uXHJcbiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNvbnRyb2xzXVxyXG4gICAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5wYWdlSGFuZGxlPUJhY2tncmlkLkV4dGVuc2lvbi5QYWdlSGFuZGxlXVxyXG4gICAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5nb0JhY2tGaXJzdE9uU29ydD10cnVlXVxyXG4gICAgKi9cclxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgc2VsZi5jb250cm9scyA9IF8uZGVmYXVsdHMob3B0aW9ucy5jb250cm9scyB8fCB7fSwgc2VsZi5jb250cm9scyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGFnaW5hdG9yLnByb3RvdHlwZS5jb250cm9scyk7XHJcblxyXG4gICAgICBfLmV4dGVuZChzZWxmLCBfLnBpY2sob3B0aW9ucyB8fCB7fSwgXCJ3aW5kb3dTaXplXCIsIFwicGFnZUhhbmRsZVwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzbGlkZVNjYWxlXCIsIFwiZ29CYWNrRmlyc3RPblNvcnRcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicmVuZGVySW5kZXhlZFBhZ2VIYW5kbGVzXCIpKTtcclxuXHJcbiAgICAgIHZhciBjb2wgPSBzZWxmLmNvbGxlY3Rpb247XHJcbiAgICAgIHNlbGYubGlzdGVuVG8oY29sLCBcImFkZFwiLCBzZWxmLnJlbmRlcik7XHJcbiAgICAgIHNlbGYubGlzdGVuVG8oY29sLCBcInJlbW92ZVwiLCBzZWxmLnJlbmRlcik7XHJcbiAgICAgIHNlbGYubGlzdGVuVG8oY29sLCBcInJlc2V0XCIsIHNlbGYucmVuZGVyKTtcclxuICAgICAgc2VsZi5saXN0ZW5Ubyhjb2wsIFwiYmFja2dyaWQ6c29ydGVkXCIsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoc2VsZi5nb0JhY2tGaXJzdE9uU29ydCkgY29sLmdldEZpcnN0UGFnZSh7cmVzZXQ6IHRydWV9KTtcclxuICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICBEZWNpZGVzIHdoZXRoZXIgdGhlIHdpbmRvdyBzaG91bGQgc2xpZGUuIFRoaXMgbWV0aG9kIHNob3VsZCByZXR1cm4gMSBpZlxyXG4gICAgICBzbGlkaW5nIHNob3VsZCBvY2N1ciBhbmQgMCBvdGhlcndpc2UuIFRoZSBkZWZhdWx0IGlzIHNsaWRpbmcgc2hvdWxkIG9jY3VyXHJcbiAgICAgIGlmIGhhbGYgb2YgdGhlIHBhZ2VzIGluIGEgd2luZG93IGhhcyBiZWVuIHJlYWNoZWQuXHJcblxyXG4gICAgICBfX05vdGVfXzogQWxsIHRoZSBwYXJhbWV0ZXJzIGhhdmUgYmVlbiBub3JtYWxpemVkIHRvIGJlIDAtYmFzZWQuXHJcblxyXG4gICAgICBAcGFyYW0ge251bWJlcn0gZmlyc3RQYWdlXHJcbiAgICAgIEBwYXJhbSB7bnVtYmVyfSBsYXN0UGFnZVxyXG4gICAgICBAcGFyYW0ge251bWJlcn0gY3VycmVudFBhZ2VcclxuICAgICAgQHBhcmFtIHtudW1iZXJ9IHdpbmRvd1NpemVcclxuICAgICAgQHBhcmFtIHtudW1iZXJ9IHNsaWRlU2NhbGVcclxuXHJcbiAgICAgIEByZXR1cm4gezB8MX1cclxuICAgICAqL1xyXG4gICAgc2xpZGVNYXliZTogZnVuY3Rpb24gKGZpcnN0UGFnZSwgbGFzdFBhZ2UsIGN1cnJlbnRQYWdlLCB3aW5kb3dTaXplLCBzbGlkZVNjYWxlKSB7XHJcbiAgICAgIHJldHVybiBNYXRoLnJvdW5kKGN1cnJlbnRQYWdlICUgd2luZG93U2l6ZSAvIHdpbmRvd1NpemUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAgRGVjaWRlcyBob3cgbWFueSBwYWdlcyB0byBzbGlkZSB3aGVuIHNsaWRpbmcgc2hvdWxkIG9jY3VyLiBUaGUgZGVmYXVsdFxyXG4gICAgICBzaW1wbHkgc2NhbGVzIHRoZSBgd2luZG93U2l6ZWAgdG8gYXJyaXZlIGF0IGEgZnJhY3Rpb24gb2YgdGhlIGB3aW5kb3dTaXplYFxyXG4gICAgICB0byBpbmNyZW1lbnQuXHJcblxyXG4gICAgICBfX05vdGVfXzogQWxsIHRoZSBwYXJhbWV0ZXJzIGhhdmUgYmVlbiBub3JtYWxpemVkIHRvIGJlIDAtYmFzZWQuXHJcblxyXG4gICAgICBAcGFyYW0ge251bWJlcn0gZmlyc3RQYWdlXHJcbiAgICAgIEBwYXJhbSB7bnVtYmVyfSBsYXN0UGFnZVxyXG4gICAgICBAcGFyYW0ge251bWJlcn0gY3VycmVudFBhZ2VcclxuICAgICAgQHBhcmFtIHtudW1iZXJ9IHdpbmRvd1NpemVcclxuICAgICAgQHBhcmFtIHtudW1iZXJ9IHNsaWRlU2NhbGVcclxuXHJcbiAgICAgIEByZXR1cm4ge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgc2xpZGVUaGlzTXVjaDogZnVuY3Rpb24gKGZpcnN0UGFnZSwgbGFzdFBhZ2UsIGN1cnJlbnRQYWdlLCB3aW5kb3dTaXplLCBzbGlkZVNjYWxlKSB7XHJcbiAgICAgIHJldHVybiB+fih3aW5kb3dTaXplICogc2xpZGVTY2FsZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9jYWxjdWxhdGVXaW5kb3c6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb247XHJcbiAgICAgIHZhciBzdGF0ZSA9IGNvbGxlY3Rpb24uc3RhdGU7XHJcblxyXG4gICAgICAvLyBjb252ZXJ0IGFsbCBpbmRpY2VzIHRvIDAtYmFzZWQgaGVyZVxyXG4gICAgICB2YXIgZmlyc3RQYWdlID0gc3RhdGUuZmlyc3RQYWdlO1xyXG4gICAgICB2YXIgbGFzdFBhZ2UgPSArc3RhdGUubGFzdFBhZ2U7XHJcbiAgICAgIGxhc3RQYWdlID0gTWF0aC5tYXgoMCwgZmlyc3RQYWdlID8gbGFzdFBhZ2UgLSAxIDogbGFzdFBhZ2UpO1xyXG4gICAgICB2YXIgY3VycmVudFBhZ2UgPSBNYXRoLm1heChzdGF0ZS5jdXJyZW50UGFnZSwgc3RhdGUuZmlyc3RQYWdlKTtcclxuICAgICAgY3VycmVudFBhZ2UgPSBmaXJzdFBhZ2UgPyBjdXJyZW50UGFnZSAtIDEgOiBjdXJyZW50UGFnZTtcclxuICAgICAgdmFyIHdpbmRvd1NpemUgPSB0aGlzLndpbmRvd1NpemU7XHJcbiAgICAgIHZhciBzbGlkZVNjYWxlID0gdGhpcy5zbGlkZVNjYWxlO1xyXG4gICAgICB2YXIgd2luZG93U3RhcnQgPSBNYXRoLmZsb29yKGN1cnJlbnRQYWdlIC8gd2luZG93U2l6ZSkgKiB3aW5kb3dTaXplO1xyXG4gICAgICBpZiAoY3VycmVudFBhZ2UgPD0gbGFzdFBhZ2UgLSB0aGlzLnNsaWRlVGhpc011Y2goKSkge1xyXG4gICAgICAgIHdpbmRvd1N0YXJ0ICs9ICh0aGlzLnNsaWRlTWF5YmUoZmlyc3RQYWdlLCBsYXN0UGFnZSwgY3VycmVudFBhZ2UsIHdpbmRvd1NpemUsIHNsaWRlU2NhbGUpICpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zbGlkZVRoaXNNdWNoKGZpcnN0UGFnZSwgbGFzdFBhZ2UsIGN1cnJlbnRQYWdlLCB3aW5kb3dTaXplLCBzbGlkZVNjYWxlKSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIHdpbmRvd0VuZCA9IE1hdGgubWluKGxhc3RQYWdlICsgMSwgd2luZG93U3RhcnQgKyB3aW5kb3dTaXplKTtcclxuICAgICAgcmV0dXJuIFt3aW5kb3dTdGFydCwgd2luZG93RW5kXTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBDcmVhdGVzIGEgbGlzdCBvZiBwYWdlIGhhbmRsZSBvYmplY3RzIGZvciByZW5kZXJpbmcuXHJcblxyXG4gICAgICAgQHJldHVybiB7QXJyYXkuPE9iamVjdD59IGFuIGFycmF5IG9mIHBhZ2UgaGFuZGxlIG9iamVjdHMgaGFzaGVzXHJcbiAgICAqL1xyXG4gICAgbWFrZUhhbmRsZXM6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgIHZhciBoYW5kbGVzID0gW107XHJcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uO1xyXG5cclxuICAgICAgdmFyIHdpbmRvdyA9IHRoaXMuX2NhbGN1bGF0ZVdpbmRvdygpO1xyXG4gICAgICB2YXIgd2luU3RhcnQgPSB3aW5kb3dbMF0sIHdpbkVuZCA9IHdpbmRvd1sxXTtcclxuXHJcbiAgICAgIGlmICh0aGlzLnJlbmRlckluZGV4ZWRQYWdlSGFuZGxlcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSB3aW5TdGFydDsgaSA8IHdpbkVuZDsgaSsrKSB7XHJcbiAgICAgICAgICBoYW5kbGVzLnB1c2gobmV3IHRoaXMucGFnZUhhbmRsZSh7XHJcbiAgICAgICAgICAgIGNvbGxlY3Rpb246IGNvbGxlY3Rpb24sXHJcbiAgICAgICAgICAgIHBhZ2VJbmRleDogaVxyXG4gICAgICAgICAgfSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNvbnRyb2xzID0gdGhpcy5jb250cm9scztcclxuICAgICAgXy5lYWNoKFtcImJhY2tcIiwgXCJyZXdpbmRcIiwgXCJmb3J3YXJkXCIsIFwiZmFzdEZvcndhcmRcIl0sIGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBjb250cm9sc1trZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgdmFyIGhhbmRsZUN0b3JPcHRzID0ge1xyXG4gICAgICAgICAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxyXG4gICAgICAgICAgICB0aXRsZTogdmFsdWUudGl0bGUsXHJcbiAgICAgICAgICAgIGxhYmVsOiB2YWx1ZS5sYWJlbFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGhhbmRsZUN0b3JPcHRzW1wiaXNcIiArIGtleS5zbGljZSgwLCAxKS50b1VwcGVyQ2FzZSgpICsga2V5LnNsaWNlKDEpXSA9IHRydWU7XHJcbiAgICAgICAgICB2YXIgaGFuZGxlID0gbmV3IHRoaXMucGFnZUhhbmRsZShoYW5kbGVDdG9yT3B0cyk7XHJcbiAgICAgICAgICBpZiAoa2V5ID09IFwicmV3aW5kXCIgfHwga2V5ID09IFwiYmFja1wiKSBoYW5kbGVzLnVuc2hpZnQoaGFuZGxlKTtcclxuICAgICAgICAgIGVsc2UgaGFuZGxlcy5wdXNoKGhhbmRsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgIHJldHVybiBoYW5kbGVzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAgIFJlbmRlciB0aGUgcGFnaW5hdG9yIGhhbmRsZXMgaW5zaWRlIGFuIHVub3JkZXJlZCBsaXN0LlxyXG4gICAgKi9cclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLiRlbC5lbXB0eSgpO1xyXG5cclxuICAgICAgaWYgKHRoaXMuaGFuZGxlcykge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5oYW5kbGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgdGhpcy5oYW5kbGVzW2ldLnJlbW92ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGhhbmRsZXMgPSB0aGlzLmhhbmRsZXMgPSB0aGlzLm1ha2VIYW5kbGVzKCk7XHJcblxyXG4gICAgICB2YXIgdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHVsLmFwcGVuZENoaWxkKGhhbmRsZXNbaV0ucmVuZGVyKCkuZWwpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHVsKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbn0pKTtcclxuIiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKSxcclxuICAgIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XHJcblxyXG4vKiogXHJcbiAqIEluY2x1ZGUgdGhpcyB0ZW1wbGF0ZSBmaWxlIGFmdGVyIGJhY2tib25lLWZvcm1zLmFtZC5qcyB0byBvdmVycmlkZSB0aGUgZGVmYXVsdCB0ZW1wbGF0ZXNcclxuICogXHJcbiAqICdkYXRhLSonIGF0dHJpYnV0ZXMgY29udHJvbCB3aGVyZSBlbGVtZW50cyBhcmUgcGxhY2VkXHJcbiAqL1xyXG47KGZ1bmN0aW9uKEZvcm0pIHtcclxuICBcclxuICAvKipcclxuICAgKiBCb290c3RyYXAgMyB0ZW1wbGF0ZXNcclxuICAgKi9cclxuICBGb3JtLnRlbXBsYXRlID0gXy50ZW1wbGF0ZSgnXFxcclxuICAgIDxmb3JtIGNsYXNzPVwiZm9ybS1ob3Jpem9udGFsXCIgcm9sZT1cImZvcm1cIiBkYXRhLWZpZWxkc2V0cz48L2Zvcm0+XFxcclxuICAnKTtcclxuXHJcblxyXG4gIEZvcm0uRmllbGRzZXQudGVtcGxhdGUgPSBfLnRlbXBsYXRlKCdcXFxyXG4gICAgPGZpZWxkc2V0IGRhdGEtZmllbGRzPlxcXHJcbiAgICAgIDwlIGlmIChsZWdlbmQpIHsgJT5cXFxyXG4gICAgICAgIDxsZWdlbmQ+PCU9IGxlZ2VuZCAlPjwvbGVnZW5kPlxcXHJcbiAgICAgIDwlIH0gJT5cXFxyXG4gICAgPC9maWVsZHNldD5cXFxyXG4gICcpO1xyXG5cclxuXHJcbiAgRm9ybS5GaWVsZC50ZW1wbGF0ZSA9IF8udGVtcGxhdGUoJ1xcXHJcbiAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cCBmaWVsZC08JT0ga2V5ICU+XCI+XFxcclxuICAgICAgPGRpdiBjbGFzcz1cImRldGFpbHNcIj5cXFxyXG4gICAgICAgIDxsYWJlbCBjbGFzcz1cImNvbnRyb2wtbGFiZWxcIiBmb3I9XCI8JT0gZWRpdG9ySWQgJT5cIj48JT0gdGl0bGUgJT48L2xhYmVsPlxcXHJcbiAgICAgICAgPHAgY2xhc3M9XCJoZWxwLWJsb2NrXCI+PCU9IGhlbHAgJT48L3A+XFxcclxuICAgICAgPC9kaXY+XFxcclxuICAgICAgPGRpdiBjbGFzcz1cImZpZWxkXCI+XFxcclxuICAgICAgICA8c3BhbiBkYXRhLWVkaXRvcj48L3NwYW4+XFxcclxuICAgICAgICA8cCBjbGFzcz1cImhlbHAtYmxvY2tcIiBkYXRhLWVycm9yPjwvcD5cXFxyXG4gICAgICA8L2Rpdj5cXFxyXG4gICAgPC9kaXY+XFxcclxuICAnKTtcclxuXHJcblxyXG4gIEZvcm0uTmVzdGVkRmllbGQudGVtcGxhdGUgPSBfLnRlbXBsYXRlKCdcXFxyXG4gICAgPGRpdiBjbGFzcz1cImZpZWxkLTwlPSBrZXkgJT4gbmVzdGVkLWl0ZW1cIj5cXFxyXG4gICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQteGxhcmdlXCI+XFxcclxuICAgICAgICA8JSBpZiAoa2V5ID09IFwicGhvbmVzXCIpeyAlPlxcXHJcbiAgICAgICAgICA8bGFiZWw+PCU9IHRpdGxlICU+PC9sYWJlbD5cXFxyXG4gICAgICAgIDwlIH0gJT5cXFxyXG4gICAgICAgIDxzcGFuIGRhdGEtZWRpdG9yPjwvc3Bhbj5cXFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJoZWxwLWlubGluZVwiIGRhdGEtZXJyb3I+PC9kaXY+XFxcclxuICAgICAgPC9kaXY+XFxcclxuICAgICAgPGRpdiBjbGFzcz1cImhlbHAtYmxvY2tcIj48JT0gaGVscCAlPjwvZGl2PlxcXHJcbiAgICA8L2Rpdj5cXFxyXG4gICcpO1xyXG5cclxuICBGb3JtLmVkaXRvcnMuQmFzZS5wcm90b3R5cGUuY2xhc3NOYW1lID0gJ2Zvcm0tY29udHJvbCc7XHJcbiAgRm9ybS5lZGl0b3JzLk9iamVjdC5wcm90b3R5cGUuY2xhc3NOYW1lID0gJyc7XHJcblxyXG4gIEZvcm0uRmllbGQuZXJyb3JDbGFzc05hbWUgPSAnaGFzLWVycm9yJztcclxuXHJcblxyXG4gIGlmIChGb3JtLmVkaXRvcnMuTGlzdCkge1xyXG5cclxuICAgIEZvcm0uZWRpdG9ycy5MaXN0LnRlbXBsYXRlID0gXy50ZW1wbGF0ZSgnXFxcclxuICAgICAgPGRpdiBjbGFzcz1cImJiZi1saXN0XCI+XFxcclxuICAgICAgICA8dWwgY2xhc3M9XCJ1bnN0eWxlZCBjbGVhcmZpeFwiIGRhdGEtaXRlbXM+PC91bD5cXFxyXG4gICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJiZi1hZGRcIiBkYXRhLWFjdGlvbj1cImFkZFwiPisg0LTQvtCx0LDQstC40YLRjDwvYnV0dG9uPlxcXHJcbiAgICAgIDwvZGl2PlxcXHJcbiAgICAnKTtcclxuXHJcblxyXG4gICAgRm9ybS5lZGl0b3JzLkxpc3QuSXRlbS50ZW1wbGF0ZSA9IF8udGVtcGxhdGUoJ1xcXHJcbiAgICAgIDxsaSBjbGFzcz1cImNsZWFyZml4XCI+XFxcclxuICAgICAgICA8ZGl2IGNsYXNzPVwicHVsbC1sZWZ0XCIgZGF0YS1lZGl0b3I+PC9kaXY+XFxcclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBiYmYtZGVsXCIgZGF0YS1hY3Rpb249XCJyZW1vdmVcIj4mdGltZXM7PC9idXR0b24+XFxcclxuICAgICAgPC9saT5cXFxyXG4gICAgJyk7XHJcbiAgICBcclxuXHJcbiAgICBGb3JtLmVkaXRvcnMuTGlzdC5PYmplY3QudGVtcGxhdGUgPSBGb3JtLmVkaXRvcnMuTGlzdC5OZXN0ZWRNb2RlbC50ZW1wbGF0ZSA9IF8udGVtcGxhdGUoJ1xcXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJiYmYtbGlzdC1tb2RhbFwiPjwlPSBzdW1tYXJ5ICU+PC9kaXY+XFxcclxuICAgICcpO1xyXG5cclxuICB9XHJcblxyXG5cclxufSkoQmFja2JvbmUuRm9ybSk7XHJcbiIsIi8qIVxyXG4gKiBCb290c3RyYXAgdjMuMy4yIChodHRwOi8vZ2V0Ym9vdHN0cmFwLmNvbSlcclxuICogQ29weXJpZ2h0IDIwMTEtMjAxNSBUd2l0dGVyLCBJbmMuXHJcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFzdGVyL0xJQ0VOU0UpXHJcbiAqL1xyXG5cclxuLyohXHJcbiAqIEdlbmVyYXRlZCB1c2luZyB0aGUgQm9vdHN0cmFwIEN1c3RvbWl6ZXIgKGh0dHA6Ly9nZXRib290c3RyYXAuY29tL2N1c3RvbWl6ZS8/aWQ9MWVmNGYwMDdjM2MxNjEzMWUzODgpXHJcbiAqIENvbmZpZyBzYXZlZCB0byBjb25maWcuanNvbiBhbmQgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMWVmNGYwMDdjM2MxNjEzMWUzODhcclxuICovXHJcblxyXG52YXIgJCA9IGpRdWVyeSA9IHJlcXVpcmUoJ2pxdWVyeScpO1xyXG5cclxuaWYgKHR5cGVvZiBqUXVlcnkgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgalF1ZXJ5JylcclxufVxyXG4rZnVuY3Rpb24gKCQpIHtcclxuICAndXNlIHN0cmljdCc7XHJcbiAgdmFyIHZlcnNpb24gPSAkLmZuLmpxdWVyeS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJylcclxuICBpZiAoKHZlcnNpb25bMF0gPCAyICYmIHZlcnNpb25bMV0gPCA5KSB8fCAodmVyc2lvblswXSA9PSAxICYmIHZlcnNpb25bMV0gPT0gOSAmJiB2ZXJzaW9uWzJdIDwgMSkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeSB2ZXJzaW9uIDEuOS4xIG9yIGhpZ2hlcicpXHJcbiAgfVxyXG59KGpRdWVyeSk7XHJcblxyXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICogQm9vdHN0cmFwOiBtb2RhbC5qcyB2My4zLjJcclxuICogaHR0cDovL2dldGJvb3RzdHJhcC5jb20vamF2YXNjcmlwdC8jbW9kYWxzXHJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKiBDb3B5cmlnaHQgMjAxMS0yMDE1IFR3aXR0ZXIsIEluYy5cclxuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYXN0ZXIvTElDRU5TRSlcclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXHJcblxyXG5cclxuK2Z1bmN0aW9uICgkKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuICAvLyBNT0RBTCBDTEFTUyBERUZJTklUSU9OXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICB2YXIgTW9kYWwgPSBmdW5jdGlvbiAoZWxlbWVudCwgb3B0aW9ucykge1xyXG4gICAgdGhpcy5vcHRpb25zICAgICAgICA9IG9wdGlvbnNcclxuICAgIHRoaXMuJGJvZHkgICAgICAgICAgPSAkKGRvY3VtZW50LmJvZHkpXHJcbiAgICB0aGlzLiRlbGVtZW50ICAgICAgID0gJChlbGVtZW50KVxyXG4gICAgdGhpcy4kYmFja2Ryb3AgICAgICA9XHJcbiAgICB0aGlzLmlzU2hvd24gICAgICAgID0gbnVsbFxyXG4gICAgdGhpcy5zY3JvbGxiYXJXaWR0aCA9IDBcclxuXHJcbiAgICBpZiAodGhpcy5vcHRpb25zLnJlbW90ZSkge1xyXG4gICAgICB0aGlzLiRlbGVtZW50XHJcbiAgICAgICAgLmZpbmQoJy5tb2RhbC1jb250ZW50JylcclxuICAgICAgICAubG9hZCh0aGlzLm9wdGlvbnMucmVtb3RlLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignbG9hZGVkLmJzLm1vZGFsJylcclxuICAgICAgICB9LCB0aGlzKSlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIE1vZGFsLlZFUlNJT04gID0gJzMuMy4yJ1xyXG5cclxuICBNb2RhbC5UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzAwXHJcbiAgTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTiA9IDE1MFxyXG5cclxuICBNb2RhbC5ERUZBVUxUUyA9IHtcclxuICAgIGJhY2tkcm9wOiB0cnVlLFxyXG4gICAga2V5Ym9hcmQ6IHRydWUsXHJcbiAgICBzaG93OiB0cnVlXHJcbiAgfVxyXG5cclxuICBNb2RhbC5wcm90b3R5cGUudG9nZ2xlID0gZnVuY3Rpb24gKF9yZWxhdGVkVGFyZ2V0KSB7XHJcbiAgICByZXR1cm4gdGhpcy5pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coX3JlbGF0ZWRUYXJnZXQpXHJcbiAgfVxyXG5cclxuICBNb2RhbC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uIChfcmVsYXRlZFRhcmdldCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzXHJcbiAgICB2YXIgZSAgICA9ICQuRXZlbnQoJ3Nob3cuYnMubW9kYWwnLCB7IHJlbGF0ZWRUYXJnZXQ6IF9yZWxhdGVkVGFyZ2V0IH0pXHJcblxyXG4gICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKGUpXHJcblxyXG4gICAgaWYgKHRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cclxuXHJcbiAgICB0aGlzLmlzU2hvd24gPSB0cnVlXHJcblxyXG4gICAgdGhpcy5jaGVja1Njcm9sbGJhcigpXHJcbiAgICB0aGlzLnNldFNjcm9sbGJhcigpXHJcbiAgICB0aGlzLiRib2R5LmFkZENsYXNzKCdtb2RhbC1vcGVuJylcclxuXHJcbiAgICB0aGlzLmVzY2FwZSgpXHJcbiAgICB0aGlzLnJlc2l6ZSgpXHJcblxyXG4gICAgdGhpcy4kZWxlbWVudC5vbignY2xpY2suZGlzbWlzcy5icy5tb2RhbCcsICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nLCAkLnByb3h5KHRoaXMuaGlkZSwgdGhpcykpXHJcblxyXG4gICAgdGhpcy5iYWNrZHJvcChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB0cmFuc2l0aW9uID0gJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhhdC4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpXHJcblxyXG4gICAgICBpZiAoIXRoYXQuJGVsZW1lbnQucGFyZW50KCkubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhhdC4kZWxlbWVudC5hcHBlbmRUbyh0aGF0LiRib2R5KSAvLyBkb24ndCBtb3ZlIG1vZGFscyBkb20gcG9zaXRpb25cclxuICAgICAgfVxyXG5cclxuICAgICAgdGhhdC4kZWxlbWVudFxyXG4gICAgICAgIC5zaG93KClcclxuICAgICAgICAuc2Nyb2xsVG9wKDApXHJcblxyXG4gICAgICBpZiAodGhhdC5vcHRpb25zLmJhY2tkcm9wKSB0aGF0LmFkanVzdEJhY2tkcm9wKClcclxuICAgICAgdGhhdC5hZGp1c3REaWFsb2coKVxyXG5cclxuICAgICAgaWYgKHRyYW5zaXRpb24pIHtcclxuICAgICAgICB0aGF0LiRlbGVtZW50WzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGF0LiRlbGVtZW50XHJcbiAgICAgICAgLmFkZENsYXNzKCdpbicpXHJcbiAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpXHJcblxyXG4gICAgICB0aGF0LmVuZm9yY2VGb2N1cygpXHJcblxyXG4gICAgICB2YXIgZSA9ICQuRXZlbnQoJ3Nob3duLmJzLm1vZGFsJywgeyByZWxhdGVkVGFyZ2V0OiBfcmVsYXRlZFRhcmdldCB9KVxyXG5cclxuICAgICAgdHJhbnNpdGlvbiA/XHJcbiAgICAgICAgdGhhdC4kZWxlbWVudC5maW5kKCcubW9kYWwtZGlhbG9nJykgLy8gd2FpdCBmb3IgbW9kYWwgdG8gc2xpZGUgaW5cclxuICAgICAgICAgIC5vbmUoJ2JzVHJhbnNpdGlvbkVuZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdmb2N1cycpLnRyaWdnZXIoZSlcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxyXG4gICAgICAgIHRoYXQuJGVsZW1lbnQudHJpZ2dlcignZm9jdXMnKS50cmlnZ2VyKGUpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgTW9kYWwucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKVxyXG5cclxuICAgIGUgPSAkLkV2ZW50KCdoaWRlLmJzLm1vZGFsJylcclxuXHJcbiAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoZSlcclxuXHJcbiAgICBpZiAoIXRoaXMuaXNTaG93biB8fCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpKSByZXR1cm5cclxuXHJcbiAgICB0aGlzLmlzU2hvd24gPSBmYWxzZVxyXG5cclxuICAgIHRoaXMuZXNjYXBlKClcclxuICAgIHRoaXMucmVzaXplKClcclxuXHJcbiAgICAkKGRvY3VtZW50KS5vZmYoJ2ZvY3VzaW4uYnMubW9kYWwnKVxyXG5cclxuICAgIHRoaXMuJGVsZW1lbnRcclxuICAgICAgLnJlbW92ZUNsYXNzKCdpbicpXHJcbiAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpXHJcbiAgICAgIC5vZmYoJ2NsaWNrLmRpc21pc3MuYnMubW9kYWwnKVxyXG5cclxuICAgICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/XHJcbiAgICAgIHRoaXMuJGVsZW1lbnRcclxuICAgICAgICAub25lKCdic1RyYW5zaXRpb25FbmQnLCAkLnByb3h5KHRoaXMuaGlkZU1vZGFsLCB0aGlzKSlcclxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuVFJBTlNJVElPTl9EVVJBVElPTikgOlxyXG4gICAgICB0aGlzLmhpZGVNb2RhbCgpXHJcbiAgfVxyXG5cclxuICBNb2RhbC5wcm90b3R5cGUuZW5mb3JjZUZvY3VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgJChkb2N1bWVudClcclxuICAgICAgLm9mZignZm9jdXNpbi5icy5tb2RhbCcpIC8vIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgZm9jdXMgbG9vcFxyXG4gICAgICAub24oJ2ZvY3VzaW4uYnMubW9kYWwnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnRbMF0gIT09IGUudGFyZ2V0ICYmICF0aGlzLiRlbGVtZW50LmhhcyhlLnRhcmdldCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2ZvY3VzJylcclxuICAgICAgICB9XHJcbiAgICAgIH0sIHRoaXMpKVxyXG4gIH1cclxuXHJcbiAgTW9kYWwucHJvdG90eXBlLmVzY2FwZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmlzU2hvd24gJiYgdGhpcy5vcHRpb25zLmtleWJvYXJkKSB7XHJcbiAgICAgIHRoaXMuJGVsZW1lbnQub24oJ2tleWRvd24uZGlzbWlzcy5icy5tb2RhbCcsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBlLndoaWNoID09IDI3ICYmIHRoaXMuaGlkZSgpXHJcbiAgICAgIH0sIHRoaXMpKVxyXG4gICAgfSBlbHNlIGlmICghdGhpcy5pc1Nob3duKSB7XHJcbiAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdrZXlkb3duLmRpc21pc3MuYnMubW9kYWwnKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgTW9kYWwucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLmlzU2hvd24pIHtcclxuICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuYnMubW9kYWwnLCAkLnByb3h5KHRoaXMuaGFuZGxlVXBkYXRlLCB0aGlzKSlcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZS5icy5tb2RhbCcpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBNb2RhbC5wcm90b3R5cGUuaGlkZU1vZGFsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzXHJcbiAgICB0aGlzLiRlbGVtZW50LmhpZGUoKVxyXG4gICAgdGhpcy5iYWNrZHJvcChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoYXQuJGJvZHkucmVtb3ZlQ2xhc3MoJ21vZGFsLW9wZW4nKVxyXG4gICAgICB0aGF0LnJlc2V0QWRqdXN0bWVudHMoKVxyXG4gICAgICB0aGF0LnJlc2V0U2Nyb2xsYmFyKClcclxuICAgICAgdGhhdC4kZWxlbWVudC50cmlnZ2VyKCdoaWRkZW4uYnMubW9kYWwnKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIE1vZGFsLnByb3RvdHlwZS5yZW1vdmVCYWNrZHJvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuJGJhY2tkcm9wICYmIHRoaXMuJGJhY2tkcm9wLnJlbW92ZSgpXHJcbiAgICB0aGlzLiRiYWNrZHJvcCA9IG51bGxcclxuICB9XHJcblxyXG4gIE1vZGFsLnByb3RvdHlwZS5iYWNrZHJvcCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgdmFyIHRoYXQgPSB0aGlzXHJcbiAgICB2YXIgYW5pbWF0ZSA9IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2ZhZGUnKSA/ICdmYWRlJyA6ICcnXHJcblxyXG4gICAgaWYgKHRoaXMuaXNTaG93biAmJiB0aGlzLm9wdGlvbnMuYmFja2Ryb3ApIHtcclxuICAgICAgdmFyIGRvQW5pbWF0ZSA9ICQuc3VwcG9ydC50cmFuc2l0aW9uICYmIGFuaW1hdGVcclxuXHJcbiAgICAgIHRoaXMuJGJhY2tkcm9wID0gJCgnPGRpdiBjbGFzcz1cIm1vZGFsLWJhY2tkcm9wICcgKyBhbmltYXRlICsgJ1wiIC8+JylcclxuICAgICAgICAucHJlcGVuZFRvKHRoaXMuJGVsZW1lbnQpXHJcbiAgICAgICAgLm9uKCdjbGljay5kaXNtaXNzLmJzLm1vZGFsJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgaWYgKGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQpIHJldHVyblxyXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmJhY2tkcm9wID09ICdzdGF0aWMnXHJcbiAgICAgICAgICAgID8gdGhpcy4kZWxlbWVudFswXS5mb2N1cy5jYWxsKHRoaXMuJGVsZW1lbnRbMF0pXHJcbiAgICAgICAgICAgIDogdGhpcy5oaWRlLmNhbGwodGhpcylcclxuICAgICAgICB9LCB0aGlzKSlcclxuXHJcbiAgICAgIGlmIChkb0FuaW1hdGUpIHRoaXMuJGJhY2tkcm9wWzBdLm9mZnNldFdpZHRoIC8vIGZvcmNlIHJlZmxvd1xyXG5cclxuICAgICAgdGhpcy4kYmFja2Ryb3AuYWRkQ2xhc3MoJ2luJylcclxuXHJcbiAgICAgIGlmICghY2FsbGJhY2spIHJldHVyblxyXG5cclxuICAgICAgZG9BbmltYXRlID9cclxuICAgICAgICB0aGlzLiRiYWNrZHJvcFxyXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2spXHJcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxyXG4gICAgICAgIGNhbGxiYWNrKClcclxuXHJcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzU2hvd24gJiYgdGhpcy4kYmFja2Ryb3ApIHtcclxuICAgICAgdGhpcy4kYmFja2Ryb3AucmVtb3ZlQ2xhc3MoJ2luJylcclxuXHJcbiAgICAgIHZhciBjYWxsYmFja1JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGF0LnJlbW92ZUJhY2tkcm9wKClcclxuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpXHJcbiAgICAgIH1cclxuICAgICAgJC5zdXBwb3J0LnRyYW5zaXRpb24gJiYgdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFkZScpID9cclxuICAgICAgICB0aGlzLiRiYWNrZHJvcFxyXG4gICAgICAgICAgLm9uZSgnYnNUcmFuc2l0aW9uRW5kJywgY2FsbGJhY2tSZW1vdmUpXHJcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoTW9kYWwuQkFDS0RST1BfVFJBTlNJVElPTl9EVVJBVElPTikgOlxyXG4gICAgICAgIGNhbGxiYWNrUmVtb3ZlKClcclxuXHJcbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgIGNhbGxiYWNrKClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIHRoZXNlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcclxuXHJcbiAgTW9kYWwucHJvdG90eXBlLmhhbmRsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja2Ryb3ApIHRoaXMuYWRqdXN0QmFja2Ryb3AoKVxyXG4gICAgdGhpcy5hZGp1c3REaWFsb2coKVxyXG4gIH1cclxuXHJcbiAgTW9kYWwucHJvdG90eXBlLmFkanVzdEJhY2tkcm9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy4kYmFja2Ryb3BcclxuICAgICAgLmNzcygnaGVpZ2h0JywgMClcclxuICAgICAgLmNzcygnaGVpZ2h0JywgdGhpcy4kZWxlbWVudFswXS5zY3JvbGxIZWlnaHQpXHJcbiAgfVxyXG5cclxuICBNb2RhbC5wcm90b3R5cGUuYWRqdXN0RGlhbG9nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG1vZGFsSXNPdmVyZmxvd2luZyA9IHRoaXMuJGVsZW1lbnRbMF0uc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxyXG5cclxuICAgIHRoaXMuJGVsZW1lbnQuY3NzKHtcclxuICAgICAgcGFkZGluZ0xlZnQ6ICAhdGhpcy5ib2R5SXNPdmVyZmxvd2luZyAmJiBtb2RhbElzT3ZlcmZsb3dpbmcgPyB0aGlzLnNjcm9sbGJhcldpZHRoIDogJycsXHJcbiAgICAgIHBhZGRpbmdSaWdodDogdGhpcy5ib2R5SXNPdmVyZmxvd2luZyAmJiAhbW9kYWxJc092ZXJmbG93aW5nID8gdGhpcy5zY3JvbGxiYXJXaWR0aCA6ICcnXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgTW9kYWwucHJvdG90eXBlLnJlc2V0QWRqdXN0bWVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLiRlbGVtZW50LmNzcyh7XHJcbiAgICAgIHBhZGRpbmdMZWZ0OiAnJyxcclxuICAgICAgcGFkZGluZ1JpZ2h0OiAnJ1xyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIE1vZGFsLnByb3RvdHlwZS5jaGVja1Njcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcgPSBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcclxuICAgIHRoaXMuc2Nyb2xsYmFyV2lkdGggPSB0aGlzLm1lYXN1cmVTY3JvbGxiYXIoKVxyXG4gIH1cclxuXHJcbiAgTW9kYWwucHJvdG90eXBlLnNldFNjcm9sbGJhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBib2R5UGFkID0gcGFyc2VJbnQoKHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JykgfHwgMCksIDEwKVxyXG4gICAgaWYgKHRoaXMuYm9keUlzT3ZlcmZsb3dpbmcpIHRoaXMuJGJvZHkuY3NzKCdwYWRkaW5nLXJpZ2h0JywgYm9keVBhZCArIHRoaXMuc2Nyb2xsYmFyV2lkdGgpXHJcbiAgfVxyXG5cclxuICBNb2RhbC5wcm90b3R5cGUucmVzZXRTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLiRib2R5LmNzcygncGFkZGluZy1yaWdodCcsICcnKVxyXG4gIH1cclxuXHJcbiAgTW9kYWwucHJvdG90eXBlLm1lYXN1cmVTY3JvbGxiYXIgPSBmdW5jdGlvbiAoKSB7IC8vIHRoeCB3YWxzaFxyXG4gICAgdmFyIHNjcm9sbERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXHJcbiAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gJ21vZGFsLXNjcm9sbGJhci1tZWFzdXJlJ1xyXG4gICAgdGhpcy4kYm9keS5hcHBlbmQoc2Nyb2xsRGl2KVxyXG4gICAgdmFyIHNjcm9sbGJhcldpZHRoID0gc2Nyb2xsRGl2Lm9mZnNldFdpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoXHJcbiAgICB0aGlzLiRib2R5WzBdLnJlbW92ZUNoaWxkKHNjcm9sbERpdilcclxuICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aFxyXG4gIH1cclxuXHJcblxyXG4gIC8vIE1PREFMIFBMVUdJTiBERUZJTklUSU9OXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgZnVuY3Rpb24gUGx1Z2luKG9wdGlvbiwgX3JlbGF0ZWRUYXJnZXQpIHtcclxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgJHRoaXMgICA9ICQodGhpcylcclxuICAgICAgdmFyIGRhdGEgICAgPSAkdGhpcy5kYXRhKCdicy5tb2RhbCcpXHJcbiAgICAgIHZhciBvcHRpb25zID0gJC5leHRlbmQoe30sIE1vZGFsLkRFRkFVTFRTLCAkdGhpcy5kYXRhKCksIHR5cGVvZiBvcHRpb24gPT0gJ29iamVjdCcgJiYgb3B0aW9uKVxyXG5cclxuICAgICAgaWYgKCFkYXRhKSAkdGhpcy5kYXRhKCdicy5tb2RhbCcsIChkYXRhID0gbmV3IE1vZGFsKHRoaXMsIG9wdGlvbnMpKSlcclxuICAgICAgaWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycpIGRhdGFbb3B0aW9uXShfcmVsYXRlZFRhcmdldClcclxuICAgICAgZWxzZSBpZiAob3B0aW9ucy5zaG93KSBkYXRhLnNob3coX3JlbGF0ZWRUYXJnZXQpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgdmFyIG9sZCA9ICQuZm4ubW9kYWxcclxuXHJcbiAgJC5mbi5tb2RhbCAgICAgICAgICAgICA9IFBsdWdpblxyXG4gICQuZm4ubW9kYWwuQ29uc3RydWN0b3IgPSBNb2RhbFxyXG5cclxuXHJcbiAgLy8gTU9EQUwgTk8gQ09ORkxJQ1RcclxuICAvLyA9PT09PT09PT09PT09PT09PVxyXG5cclxuICAkLmZuLm1vZGFsLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAkLmZuLm1vZGFsID0gb2xkXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIE1PREFMIERBVEEtQVBJXHJcbiAgLy8gPT09PT09PT09PT09PT1cclxuXHJcbiAgJChkb2N1bWVudCkub24oJ2NsaWNrLmJzLm1vZGFsLmRhdGEtYXBpJywgJ1tkYXRhLXRvZ2dsZT1cIm1vZGFsXCJdJywgZnVuY3Rpb24gKGUpIHtcclxuICAgIHZhciAkdGhpcyAgID0gJCh0aGlzKVxyXG4gICAgdmFyIGhyZWYgICAgPSAkdGhpcy5hdHRyKCdocmVmJylcclxuICAgIHZhciAkdGFyZ2V0ID0gJCgkdGhpcy5hdHRyKCdkYXRhLXRhcmdldCcpIHx8IChocmVmICYmIGhyZWYucmVwbGFjZSgvLiooPz0jW15cXHNdKyQpLywgJycpKSkgLy8gc3RyaXAgZm9yIGllN1xyXG4gICAgdmFyIG9wdGlvbiAgPSAkdGFyZ2V0LmRhdGEoJ2JzLm1vZGFsJykgPyAndG9nZ2xlJyA6ICQuZXh0ZW5kKHsgcmVtb3RlOiAhLyMvLnRlc3QoaHJlZikgJiYgaHJlZiB9LCAkdGFyZ2V0LmRhdGEoKSwgJHRoaXMuZGF0YSgpKVxyXG5cclxuICAgIGlmICgkdGhpcy5pcygnYScpKSBlLnByZXZlbnREZWZhdWx0KClcclxuXHJcbiAgICAkdGFyZ2V0Lm9uZSgnc2hvdy5icy5tb2RhbCcsIGZ1bmN0aW9uIChzaG93RXZlbnQpIHtcclxuICAgICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgcmV0dXJuIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cclxuICAgICAgJHRhcmdldC5vbmUoJ2hpZGRlbi5icy5tb2RhbCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAkdGhpcy5pcygnOnZpc2libGUnKSAmJiAkdGhpcy50cmlnZ2VyKCdmb2N1cycpXHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG4gICAgUGx1Z2luLmNhbGwoJHRhcmdldCwgb3B0aW9uLCB0aGlzKVxyXG4gIH0pXHJcblxyXG59KGpRdWVyeSk7XHJcbiIsIi8qZ2xvYmFscyBqUXVlcnksIGRlZmluZSwgZXhwb3J0cywgcmVxdWlyZSwgd2luZG93LCBkb2N1bWVudCwgcG9zdE1lc3NhZ2UgKi9cclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblx0aWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG5cdFx0ZGVmaW5lKFsnanF1ZXJ5J10sIGZhY3RvcnkpO1xyXG5cdH1cclxuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0ZmFjdG9yeShyZXF1aXJlKCdqcXVlcnknKSk7XHJcblx0fVxyXG5cdGVsc2Uge1xyXG5cdFx0ZmFjdG9yeShqUXVlcnkpO1xyXG5cdH1cclxufShmdW5jdGlvbiAoJCwgdW5kZWZpbmVkKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIVxyXG4gKiBqc1RyZWUgMy4wLjlcclxuICogaHR0cDovL2pzdHJlZS5jb20vXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxNCBJdmFuIEJvemhhbm92IChodHRwOi8vdmFrYXRhLmNvbSlcclxuICpcclxuICogTGljZW5zZWQgc2FtZSBhcyBqcXVlcnkgLSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlXHJcbiAqICAgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuICovXHJcbi8qIVxyXG4gKiBpZiB1c2luZyBqc2xpbnQgcGxlYXNlIGFsbG93IGZvciB0aGUgalF1ZXJ5IGdsb2JhbCBhbmQgdXNlIGZvbGxvd2luZyBvcHRpb25zOiBcclxuICoganNsaW50OiBicm93c2VyOiB0cnVlLCBhc3M6IHRydWUsIGJpdHdpc2U6IHRydWUsIGNvbnRpbnVlOiB0cnVlLCBub21lbjogdHJ1ZSwgcGx1c3BsdXM6IHRydWUsIHJlZ2V4cDogdHJ1ZSwgdW5wYXJhbTogdHJ1ZSwgdG9kbzogdHJ1ZSwgd2hpdGU6IHRydWVcclxuICovXHJcblxyXG5cdC8vIHByZXZlbnQgYW5vdGhlciBsb2FkPyBtYXliZSB0aGVyZSBpcyBhIGJldHRlciB3YXk/XHJcblx0aWYoJC5qc3RyZWUpIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqICMjIyBqc1RyZWUgY29yZSBmdW5jdGlvbmFsaXR5XHJcblx0ICovXHJcblxyXG5cdC8vIGludGVybmFsIHZhcmlhYmxlc1xyXG5cdHZhciBpbnN0YW5jZV9jb3VudGVyID0gMCxcclxuXHRcdGNjcF9ub2RlID0gZmFsc2UsXHJcblx0XHRjY3BfbW9kZSA9IGZhbHNlLFxyXG5cdFx0Y2NwX2luc3QgPSBmYWxzZSxcclxuXHRcdHRoZW1lc19sb2FkZWQgPSBbXSxcclxuXHRcdHNyYyA9ICQoJ3NjcmlwdDpsYXN0JykuYXR0cignc3JjJyksXHJcblx0XHRfZCA9IGRvY3VtZW50LCBfbm9kZSA9IF9kLmNyZWF0ZUVsZW1lbnQoJ0xJJyksIF90ZW1wMSwgX3RlbXAyO1xyXG5cclxuXHRfbm9kZS5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndHJlZWl0ZW0nKTtcclxuXHRfdGVtcDEgPSBfZC5jcmVhdGVFbGVtZW50KCdJJyk7XHJcblx0X3RlbXAxLmNsYXNzTmFtZSA9ICdqc3RyZWUtaWNvbiBqc3RyZWUtb2NsJztcclxuXHRfdGVtcDEuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xyXG5cdF9ub2RlLmFwcGVuZENoaWxkKF90ZW1wMSk7XHJcblx0X3RlbXAxID0gX2QuY3JlYXRlRWxlbWVudCgnQScpO1xyXG5cdF90ZW1wMS5jbGFzc05hbWUgPSAnanN0cmVlLWFuY2hvcic7XHJcblx0X3RlbXAxLnNldEF0dHJpYnV0ZSgnaHJlZicsJyMnKTtcclxuXHRfdGVtcDEuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsJy0xJyk7XHJcblx0X3RlbXAyID0gX2QuY3JlYXRlRWxlbWVudCgnSScpO1xyXG5cdF90ZW1wMi5jbGFzc05hbWUgPSAnanN0cmVlLWljb24ganN0cmVlLXRoZW1laWNvbic7XHJcblx0X3RlbXAyLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcclxuXHRfdGVtcDEuYXBwZW5kQ2hpbGQoX3RlbXAyKTtcclxuXHRfbm9kZS5hcHBlbmRDaGlsZChfdGVtcDEpO1xyXG5cdF90ZW1wMSA9IF90ZW1wMiA9IG51bGw7XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBob2xkcyBhbGwganN0cmVlIHJlbGF0ZWQgZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMsIGluY2x1ZGluZyB0aGUgYWN0dWFsIGNsYXNzIGFuZCBtZXRob2RzIHRvIGNyZWF0ZSwgYWNjZXNzIGFuZCBtYW5pcHVsYXRlIGluc3RhbmNlcy5cclxuXHQgKiBAbmFtZSAkLmpzdHJlZVxyXG5cdCAqL1xyXG5cdCQuanN0cmVlID0ge1xyXG5cdFx0LyoqIFxyXG5cdFx0ICogc3BlY2lmaWVzIHRoZSBqc3RyZWUgdmVyc2lvbiBpbiB1c2VcclxuXHRcdCAqIEBuYW1lICQuanN0cmVlLnZlcnNpb25cclxuXHRcdCAqL1xyXG5cdFx0dmVyc2lvbiA6ICczLjAuOScsXHJcblx0XHQvKipcclxuXHRcdCAqIGhvbGRzIGFsbCB0aGUgZGVmYXVsdCBvcHRpb25zIHVzZWQgd2hlbiBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXHJcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0c1xyXG5cdFx0ICovXHJcblx0XHRkZWZhdWx0cyA6IHtcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIGNvbmZpZ3VyZSB3aGljaCBwbHVnaW5zIHdpbGwgYmUgYWN0aXZlIG9uIGFuIGluc3RhbmNlLiBTaG91bGQgYmUgYW4gYXJyYXkgb2Ygc3RyaW5ncywgd2hlcmUgZWFjaCBlbGVtZW50IGlzIGEgcGx1Z2luIG5hbWUuIFRoZSBkZWZhdWx0IGlzIGBbXWBcclxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2luc1xyXG5cdFx0XHQgKi9cclxuXHRcdFx0cGx1Z2lucyA6IFtdXHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBzdG9yZXMgYWxsIGxvYWRlZCBqc3RyZWUgcGx1Z2lucyAodXNlZCBpbnRlcm5hbGx5KVxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUucGx1Z2luc1xyXG5cdFx0ICovXHJcblx0XHRwbHVnaW5zIDoge30sXHJcblx0XHRwYXRoIDogc3JjICYmIHNyYy5pbmRleE9mKCcvJykgIT09IC0xID8gc3JjLnJlcGxhY2UoL1xcL1teXFwvXSskLywnJykgOiAnJyxcclxuXHRcdGlkcmVnZXggOiAvW1xcXFw6JiFefCgpXFxbXFxdPD5AKicrfiNcIjsuLD1cXC0gXFwvJHt9JT9gXS9nXHJcblx0fTtcclxuXHQvKipcclxuXHQgKiBjcmVhdGVzIGEganN0cmVlIGluc3RhbmNlXHJcblx0ICogQG5hbWUgJC5qc3RyZWUuY3JlYXRlKGVsIFssIG9wdGlvbnNdKVxyXG5cdCAqIEBwYXJhbSB7RE9NRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBlbCB0aGUgZWxlbWVudCB0byBjcmVhdGUgdGhlIGluc3RhbmNlIG9uLCBjYW4gYmUgalF1ZXJ5IGV4dGVuZGVkIG9yIGEgc2VsZWN0b3JcclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlIChleHRlbmRzIGAkLmpzdHJlZS5kZWZhdWx0c2ApXHJcblx0ICogQHJldHVybiB7anNUcmVlfSB0aGUgbmV3IGluc3RhbmNlXHJcblx0ICovXHJcblx0JC5qc3RyZWUuY3JlYXRlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgdG1wID0gbmV3ICQuanN0cmVlLmNvcmUoKytpbnN0YW5jZV9jb3VudGVyKSxcclxuXHRcdFx0b3B0ID0gb3B0aW9ucztcclxuXHRcdG9wdGlvbnMgPSAkLmV4dGVuZCh0cnVlLCB7fSwgJC5qc3RyZWUuZGVmYXVsdHMsIG9wdGlvbnMpO1xyXG5cdFx0aWYob3B0ICYmIG9wdC5wbHVnaW5zKSB7XHJcblx0XHRcdG9wdGlvbnMucGx1Z2lucyA9IG9wdC5wbHVnaW5zO1xyXG5cdFx0fVxyXG5cdFx0JC5lYWNoKG9wdGlvbnMucGx1Z2lucywgZnVuY3Rpb24gKGksIGspIHtcclxuXHRcdFx0aWYoaSAhPT0gJ2NvcmUnKSB7XHJcblx0XHRcdFx0dG1wID0gdG1wLnBsdWdpbihrLCBvcHRpb25zW2tdKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHR0bXAuaW5pdChlbCwgb3B0aW9ucyk7XHJcblx0XHRyZXR1cm4gdG1wO1xyXG5cdH07XHJcblx0LyoqXHJcblx0ICogcmVtb3ZlIGFsbCB0cmFjZXMgb2YganN0cmVlIGZyb20gdGhlIERPTSBhbmQgZGVzdHJveSBhbGwgaW5zdGFuY2VzXHJcblx0ICogQG5hbWUgJC5qc3RyZWUuZGVzdHJveSgpXHJcblx0ICovXHJcblx0JC5qc3RyZWUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdCQoJy5qc3RyZWU6anN0cmVlJykuanN0cmVlKCdkZXN0cm95Jyk7XHJcblx0XHQkKGRvY3VtZW50KS5vZmYoJy5qc3RyZWUnKTtcclxuXHR9O1xyXG5cdC8qKlxyXG5cdCAqIHRoZSBqc3RyZWUgY2xhc3MgY29uc3RydWN0b3IsIHVzZWQgb25seSBpbnRlcm5hbGx5XHJcblx0ICogQHByaXZhdGVcclxuXHQgKiBAbmFtZSAkLmpzdHJlZS5jb3JlKGlkKVxyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBpZCB0aGlzIGluc3RhbmNlJ3MgaW5kZXhcclxuXHQgKi9cclxuXHQkLmpzdHJlZS5jb3JlID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0XHR0aGlzLl9pZCA9IGlkO1xyXG5cdFx0dGhpcy5fY250ID0gMDtcclxuXHRcdHRoaXMuX3dyayA9IG51bGw7XHJcblx0XHR0aGlzLl9kYXRhID0ge1xyXG5cdFx0XHRjb3JlIDoge1xyXG5cdFx0XHRcdHRoZW1lcyA6IHtcclxuXHRcdFx0XHRcdG5hbWUgOiBmYWxzZSxcclxuXHRcdFx0XHRcdGRvdHMgOiBmYWxzZSxcclxuXHRcdFx0XHRcdGljb25zIDogZmFsc2VcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHNlbGVjdGVkIDogW10sXHJcblx0XHRcdFx0bGFzdF9lcnJvciA6IHt9LFxyXG5cdFx0XHRcdHdvcmtpbmcgOiBmYWxzZSxcclxuXHRcdFx0XHR3b3JrZXJfcXVldWUgOiBbXSxcclxuXHRcdFx0XHRmb2N1c2VkIDogbnVsbFxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdH07XHJcblx0LyoqXHJcblx0ICogZ2V0IGEgcmVmZXJlbmNlIHRvIGFuIGV4aXN0aW5nIGluc3RhbmNlXHJcblx0ICpcclxuXHQgKiBfX0V4YW1wbGVzX19cclxuXHQgKlxyXG5cdCAqXHQvLyBwcm92aWRlZCBhIGNvbnRhaW5lciB3aXRoIGFuIElEIG9mIFwidHJlZVwiLCBhbmQgYSBuZXN0ZWQgbm9kZSB3aXRoIGFuIElEIG9mIFwiYnJhbmNoXCJcclxuXHQgKlx0Ly8gYWxsIG9mIHRoZXJlIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGluc3RhbmNlXHJcblx0ICpcdCQuanN0cmVlLnJlZmVyZW5jZSgndHJlZScpO1xyXG5cdCAqXHQkLmpzdHJlZS5yZWZlcmVuY2UoJyN0cmVlJyk7XHJcblx0ICpcdCQuanN0cmVlLnJlZmVyZW5jZSgkKCcjdHJlZScpKTtcclxuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKGRvY3VtZW50LmdldEVsZW1lbnRCeUlEKCd0cmVlJykpO1xyXG5cdCAqXHQkLmpzdHJlZS5yZWZlcmVuY2UoJ2JyYW5jaCcpO1xyXG5cdCAqXHQkLmpzdHJlZS5yZWZlcmVuY2UoJyNicmFuY2gnKTtcclxuXHQgKlx0JC5qc3RyZWUucmVmZXJlbmNlKCQoJyNicmFuY2gnKSk7XHJcblx0ICpcdCQuanN0cmVlLnJlZmVyZW5jZShkb2N1bWVudC5nZXRFbGVtZW50QnlJRCgnYnJhbmNoJykpO1xyXG5cdCAqXHJcblx0ICogQG5hbWUgJC5qc3RyZWUucmVmZXJlbmNlKG5lZWRsZSlcclxuXHQgKiBAcGFyYW0ge0RPTUVsZW1lbnR8alF1ZXJ5fFN0cmluZ30gbmVlZGxlXHJcblx0ICogQHJldHVybiB7anNUcmVlfG51bGx9IHRoZSBpbnN0YW5jZSBvciBgbnVsbGAgaWYgbm90IGZvdW5kXHJcblx0ICovXHJcblx0JC5qc3RyZWUucmVmZXJlbmNlID0gZnVuY3Rpb24gKG5lZWRsZSkge1xyXG5cdFx0dmFyIHRtcCA9IG51bGwsXHJcblx0XHRcdG9iaiA9IG51bGw7XHJcblx0XHRpZihuZWVkbGUgJiYgbmVlZGxlLmlkKSB7IG5lZWRsZSA9IG5lZWRsZS5pZDsgfVxyXG5cclxuXHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcclxuXHRcdFx0dHJ5IHsgb2JqID0gJChuZWVkbGUpOyB9IGNhdGNoIChpZ25vcmUpIHsgfVxyXG5cdFx0fVxyXG5cdFx0aWYoIW9iaiB8fCAhb2JqLmxlbmd0aCkge1xyXG5cdFx0XHR0cnkgeyBvYmogPSAkKCcjJyArIG5lZWRsZS5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpKTsgfSBjYXRjaCAoaWdub3JlKSB7IH1cclxuXHRcdH1cclxuXHRcdGlmKG9iaiAmJiBvYmoubGVuZ3RoICYmIChvYmogPSBvYmouY2xvc2VzdCgnLmpzdHJlZScpKS5sZW5ndGggJiYgKG9iaiA9IG9iai5kYXRhKCdqc3RyZWUnKSkpIHtcclxuXHRcdFx0dG1wID0gb2JqO1xyXG5cdFx0fVxyXG5cdFx0ZWxzZSB7XHJcblx0XHRcdCQoJy5qc3RyZWUnKS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHR2YXIgaW5zdCA9ICQodGhpcykuZGF0YSgnanN0cmVlJyk7XHJcblx0XHRcdFx0aWYoaW5zdCAmJiBpbnN0Ll9tb2RlbC5kYXRhW25lZWRsZV0pIHtcclxuXHRcdFx0XHRcdHRtcCA9IGluc3Q7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0bXA7XHJcblx0fTtcclxuXHQvKipcclxuXHQgKiBDcmVhdGUgYW4gaW5zdGFuY2UsIGdldCBhbiBpbnN0YW5jZSBvciBpbnZva2UgYSBjb21tYW5kIG9uIGEgaW5zdGFuY2UuIFxyXG5cdCAqIFxyXG5cdCAqIElmIHRoZXJlIGlzIG5vIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBub2RlIGEgbmV3IG9uZSBpcyBjcmVhdGVkIGFuZCBgYXJnYCBpcyB1c2VkIHRvIGV4dGVuZCBgJC5qc3RyZWUuZGVmYXVsdHNgIGZvciB0aGlzIG5ldyBpbnN0YW5jZS4gVGhlcmUgd291bGQgYmUgbm8gcmV0dXJuIHZhbHVlIChjaGFpbmluZyBpcyBub3QgYnJva2VuKS5cclxuXHQgKiBcclxuXHQgKiBJZiB0aGVyZSBpcyBhbiBleGlzdGluZyBpbnN0YW5jZSBhbmQgYGFyZ2AgaXMgYSBzdHJpbmcgdGhlIGNvbW1hbmQgc3BlY2lmaWVkIGJ5IGBhcmdgIGlzIGV4ZWN1dGVkIG9uIHRoZSBpbnN0YW5jZSwgd2l0aCBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSB2YWx1ZSBpdCB3aWxsIGJlIHJldHVybmVkIChjaGFpbmluZyBjb3VsZCBicmVhayBkZXBlbmRpbmcgb24gZnVuY3Rpb24pLlxyXG5cdCAqIFxyXG5cdCAqIElmIHRoZXJlIGlzIGFuIGV4aXN0aW5nIGluc3RhbmNlIGFuZCBgYXJnYCBpcyBub3QgYSBzdHJpbmcgdGhlIGluc3RhbmNlIGl0c2VsZiBpcyByZXR1cm5lZCAoc2ltaWxhciB0byBgJC5qc3RyZWUucmVmZXJlbmNlYCkuXHJcblx0ICogXHJcblx0ICogSW4gYW55IG90aGVyIGNhc2UgLSBub3RoaW5nIGlzIHJldHVybmVkIGFuZCBjaGFpbmluZyBpcyBub3QgYnJva2VuLlxyXG5cdCAqXHJcblx0ICogX19FeGFtcGxlc19fXHJcblx0ICpcclxuXHQgKlx0JCgnI3RyZWUxJykuanN0cmVlKCk7IC8vIGNyZWF0ZXMgYW4gaW5zdGFuY2VcclxuXHQgKlx0JCgnI3RyZWUyJykuanN0cmVlKHsgcGx1Z2lucyA6IFtdIH0pOyAvLyBjcmVhdGUgYW4gaW5zdGFuY2Ugd2l0aCBzb21lIG9wdGlvbnNcclxuXHQgKlx0JCgnI3RyZWUxJykuanN0cmVlKCdvcGVuX25vZGUnLCAnI2JyYW5jaF8xJyk7IC8vIGNhbGwgYSBtZXRob2Qgb24gYW4gZXhpc3RpbmcgaW5zdGFuY2UsIHBhc3NpbmcgYWRkaXRpb25hbCBhcmd1bWVudHNcclxuXHQgKlx0JCgnI3RyZWUyJykuanN0cmVlKCk7IC8vIGdldCBhbiBleGlzdGluZyBpbnN0YW5jZSAob3IgY3JlYXRlIGFuIGluc3RhbmNlKVxyXG5cdCAqXHQkKCcjdHJlZTInKS5qc3RyZWUodHJ1ZSk7IC8vIGdldCBhbiBleGlzdGluZyBpbnN0YW5jZSAod2lsbCBub3QgY3JlYXRlIG5ldyBpbnN0YW5jZSlcclxuXHQgKlx0JCgnI2JyYW5jaF8xJykuanN0cmVlKCkuc2VsZWN0X25vZGUoJyNicmFuY2hfMScpOyAvLyBnZXQgYW4gaW5zdGFuY2UgKHVzaW5nIGEgbmVzdGVkIGVsZW1lbnQgYW5kIGNhbGwgYSBtZXRob2QpXHJcblx0ICpcclxuXHQgKiBAbmFtZSAkKCkuanN0cmVlKFthcmddKVxyXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gYXJnXHJcblx0ICogQHJldHVybiB7TWl4ZWR9XHJcblx0ICovXHJcblx0JC5mbi5qc3RyZWUgPSBmdW5jdGlvbiAoYXJnKSB7XHJcblx0XHQvLyBjaGVjayBmb3Igc3RyaW5nIGFyZ3VtZW50XHJcblx0XHR2YXIgaXNfbWV0aG9kXHQ9ICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJyksXHJcblx0XHRcdGFyZ3NcdFx0PSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxyXG5cdFx0XHRyZXN1bHRcdFx0PSBudWxsO1xyXG5cdFx0aWYoYXJnID09PSB0cnVlICYmICF0aGlzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdC8vIGdldCB0aGUgaW5zdGFuY2UgKGlmIHRoZXJlIGlzIG9uZSkgYW5kIG1ldGhvZCAoaWYgaXQgZXhpc3RzKVxyXG5cdFx0XHR2YXIgaW5zdGFuY2UgPSAkLmpzdHJlZS5yZWZlcmVuY2UodGhpcyksXHJcblx0XHRcdFx0bWV0aG9kID0gaXNfbWV0aG9kICYmIGluc3RhbmNlID8gaW5zdGFuY2VbYXJnXSA6IG51bGw7XHJcblx0XHRcdC8vIGlmIGNhbGxpbmcgYSBtZXRob2QsIGFuZCBtZXRob2QgaXMgYXZhaWxhYmxlIC0gZXhlY3V0ZSBvbiB0aGUgaW5zdGFuY2VcclxuXHRcdFx0cmVzdWx0ID0gaXNfbWV0aG9kICYmIG1ldGhvZCA/XHJcblx0XHRcdFx0bWV0aG9kLmFwcGx5KGluc3RhbmNlLCBhcmdzKSA6XHJcblx0XHRcdFx0bnVsbDtcclxuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgbm8gaW5zdGFuY2UgYW5kIG5vIG1ldGhvZCBpcyBiZWluZyBjYWxsZWQgLSBjcmVhdGUgb25lXHJcblx0XHRcdGlmKCFpbnN0YW5jZSAmJiAhaXNfbWV0aG9kICYmIChhcmcgPT09IHVuZGVmaW5lZCB8fCAkLmlzUGxhaW5PYmplY3QoYXJnKSkpIHtcclxuXHRcdFx0XHQkKHRoaXMpLmRhdGEoJ2pzdHJlZScsIG5ldyAkLmpzdHJlZS5jcmVhdGUodGhpcywgYXJnKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgYW4gaW5zdGFuY2UgYW5kIG5vIG1ldGhvZCBpcyBjYWxsZWQgLSByZXR1cm4gdGhlIGluc3RhbmNlXHJcblx0XHRcdGlmKCAoaW5zdGFuY2UgJiYgIWlzX21ldGhvZCkgfHwgYXJnID09PSB0cnVlICkge1xyXG5cdFx0XHRcdHJlc3VsdCA9IGluc3RhbmNlIHx8IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGlmIHRoZXJlIHdhcyBhIG1ldGhvZCBjYWxsIHdoaWNoIHJldHVybmVkIGEgcmVzdWx0IC0gYnJlYWsgYW5kIHJldHVybiB0aGUgdmFsdWVcclxuXHRcdFx0aWYocmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdC8vIGlmIHRoZXJlIHdhcyBhIG1ldGhvZCBjYWxsIHdpdGggYSB2YWxpZCByZXR1cm4gdmFsdWUgLSByZXR1cm4gdGhhdCwgb3RoZXJ3aXNlIGNvbnRpbnVlIHRoZSBjaGFpblxyXG5cdFx0cmV0dXJuIHJlc3VsdCAhPT0gbnVsbCAmJiByZXN1bHQgIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdHJlc3VsdCA6IHRoaXM7XHJcblx0fTtcclxuXHQvKipcclxuXHQgKiB1c2VkIHRvIGZpbmQgZWxlbWVudHMgY29udGFpbmluZyBhbiBpbnN0YW5jZVxyXG5cdCAqXHJcblx0ICogX19FeGFtcGxlc19fXHJcblx0ICpcclxuXHQgKlx0JCgnZGl2OmpzdHJlZScpLmVhY2goZnVuY3Rpb24gKCkge1xyXG5cdCAqXHRcdCQodGhpcykuanN0cmVlKCdkZXN0cm95Jyk7XHJcblx0ICpcdH0pO1xyXG5cdCAqXHJcblx0ICogQG5hbWUgJCgnOmpzdHJlZScpXHJcblx0ICogQHJldHVybiB7alF1ZXJ5fVxyXG5cdCAqL1xyXG5cdCQuZXhwclsnOiddLmpzdHJlZSA9ICQuZXhwci5jcmVhdGVQc2V1ZG8oZnVuY3Rpb24oc2VhcmNoKSB7XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oYSkge1xyXG5cdFx0XHRyZXR1cm4gJChhKS5oYXNDbGFzcygnanN0cmVlJykgJiZcclxuXHRcdFx0XHQkKGEpLmRhdGEoJ2pzdHJlZScpICE9PSB1bmRlZmluZWQ7XHJcblx0XHR9O1xyXG5cdH0pO1xyXG5cclxuXHQvKipcclxuXHQgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgY29yZVxyXG5cdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmVcclxuXHQgKi9cclxuXHQkLmpzdHJlZS5kZWZhdWx0cy5jb3JlID0ge1xyXG5cdFx0LyoqXHJcblx0XHQgKiBkYXRhIGNvbmZpZ3VyYXRpb25cclxuXHRcdCAqIFxyXG5cdFx0ICogSWYgbGVmdCBhcyBgZmFsc2VgIHRoZSBIVE1MIGluc2lkZSB0aGUganN0cmVlIGNvbnRhaW5lciBlbGVtZW50IGlzIHVzZWQgdG8gcG9wdWxhdGUgdGhlIHRyZWUgKHRoYXQgc2hvdWxkIGJlIGFuIHVub3JkZXJlZCBsaXN0IHdpdGggbGlzdCBpdGVtcykuXHJcblx0XHQgKlxyXG5cdFx0ICogWW91IGNhbiBhbHNvIHBhc3MgaW4gYSBIVE1MIHN0cmluZyBvciBhIEpTT04gYXJyYXkgaGVyZS5cclxuXHRcdCAqIFxyXG5cdFx0ICogSXQgaXMgcG9zc2libGUgdG8gcGFzcyBpbiBhIHN0YW5kYXJkIGpRdWVyeS1saWtlIEFKQVggY29uZmlnIGFuZCBqc3RyZWUgd2lsbCBhdXRvbWF0aWNhbGx5IGRldGVybWluZSBpZiB0aGUgcmVzcG9uc2UgaXMgSlNPTiBvciBIVE1MIGFuZCB1c2UgdGhhdCB0byBwb3B1bGF0ZSB0aGUgdHJlZS4gXHJcblx0XHQgKiBJbiBhZGRpdGlvbiB0byB0aGUgc3RhbmRhcmQgalF1ZXJ5IGFqYXggb3B0aW9ucyBoZXJlIHlvdSBjYW4gc3VwcHkgZnVuY3Rpb25zIGZvciBgZGF0YWAgYW5kIGB1cmxgLCB0aGUgZnVuY3Rpb25zIHdpbGwgYmUgcnVuIGluIHRoZSBjdXJyZW50IGluc3RhbmNlJ3Mgc2NvcGUgYW5kIGEgcGFyYW0gd2lsbCBiZSBwYXNzZWQgaW5kaWNhdGluZyB3aGljaCBub2RlIGlzIGJlaW5nIGxvYWRlZCwgdGhlIHJldHVybiB2YWx1ZSBvZiB0aG9zZSBmdW5jdGlvbnMgd2lsbCBiZSB1c2VkLlxyXG5cdFx0ICogXHJcblx0XHQgKiBUaGUgbGFzdCBvcHRpb24gaXMgdG8gc3BlY2lmeSBhIGZ1bmN0aW9uLCB0aGF0IGZ1bmN0aW9uIHdpbGwgcmVjZWl2ZSB0aGUgbm9kZSBiZWluZyBsb2FkZWQgYXMgYXJndW1lbnQgYW5kIGEgc2Vjb25kIHBhcmFtIHdoaWNoIGlzIGEgZnVuY3Rpb24gd2hpY2ggc2hvdWxkIGJlIGNhbGxlZCB3aXRoIHRoZSByZXN1bHQuXHJcblx0XHQgKlxyXG5cdFx0ICogX19FeGFtcGxlc19fXHJcblx0XHQgKlxyXG5cdFx0ICpcdC8vIEFKQVhcclxuXHRcdCAqXHQkKCcjdHJlZScpLmpzdHJlZSh7XHJcblx0XHQgKlx0XHQnY29yZScgOiB7XHJcblx0XHQgKlx0XHRcdCdkYXRhJyA6IHtcclxuXHRcdCAqXHRcdFx0XHQndXJsJyA6ICcvZ2V0L2NoaWxkcmVuLycsXHJcblx0XHQgKlx0XHRcdFx0J2RhdGEnIDogZnVuY3Rpb24gKG5vZGUpIHtcclxuXHRcdCAqXHRcdFx0XHRcdHJldHVybiB7ICdpZCcgOiBub2RlLmlkIH07XHJcblx0XHQgKlx0XHRcdFx0fVxyXG5cdFx0ICpcdFx0XHR9XHJcblx0XHQgKlx0XHR9KTtcclxuXHRcdCAqXHJcblx0XHQgKlx0Ly8gZGlyZWN0IGRhdGFcclxuXHRcdCAqXHQkKCcjdHJlZScpLmpzdHJlZSh7XHJcblx0XHQgKlx0XHQnY29yZScgOiB7XHJcblx0XHQgKlx0XHRcdCdkYXRhJyA6IFtcclxuXHRcdCAqXHRcdFx0XHQnU2ltcGxlIHJvb3Qgbm9kZScsXHJcblx0XHQgKlx0XHRcdFx0e1xyXG5cdFx0ICpcdFx0XHRcdFx0J2lkJyA6ICdub2RlXzInLFxyXG5cdFx0ICpcdFx0XHRcdFx0J3RleHQnIDogJ1Jvb3Qgbm9kZSB3aXRoIG9wdGlvbnMnLFxyXG5cdFx0ICpcdFx0XHRcdFx0J3N0YXRlJyA6IHsgJ29wZW5lZCcgOiB0cnVlLCAnc2VsZWN0ZWQnIDogdHJ1ZSB9LFxyXG5cdFx0ICpcdFx0XHRcdFx0J2NoaWxkcmVuJyA6IFsgeyAndGV4dCcgOiAnQ2hpbGQgMScgfSwgJ0NoaWxkIDInXVxyXG5cdFx0ICpcdFx0XHRcdH1cclxuXHRcdCAqXHRcdFx0XVxyXG5cdFx0ICpcdFx0fSk7XHJcblx0XHQgKlx0XHJcblx0XHQgKlx0Ly8gZnVuY3Rpb25cclxuXHRcdCAqXHQkKCcjdHJlZScpLmpzdHJlZSh7XHJcblx0XHQgKlx0XHQnY29yZScgOiB7XHJcblx0XHQgKlx0XHRcdCdkYXRhJyA6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XHJcblx0XHQgKlx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBbJ1Jvb3QgMScsICdSb290IDInXSk7XHJcblx0XHQgKlx0XHRcdH1cclxuXHRcdCAqXHRcdH0pO1xyXG5cdFx0ICogXHJcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmRhdGFcclxuXHRcdCAqL1xyXG5cdFx0ZGF0YVx0XHRcdDogZmFsc2UsXHJcblx0XHQvKipcclxuXHRcdCAqIGNvbmZpZ3VyZSB0aGUgdmFyaW91cyBzdHJpbmdzIHVzZWQgdGhyb3VnaG91dCB0aGUgdHJlZVxyXG5cdFx0ICpcclxuXHRcdCAqIFlvdSBjYW4gdXNlIGFuIG9iamVjdCB3aGVyZSB0aGUga2V5IGlzIHRoZSBzdHJpbmcgeW91IG5lZWQgdG8gcmVwbGFjZSBhbmQgdGhlIHZhbHVlIGlzIHlvdXIgcmVwbGFjZW1lbnQuXHJcblx0XHQgKiBBbm90aGVyIG9wdGlvbiBpcyB0byBzcGVjaWZ5IGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgd2l0aCBhbiBhcmd1bWVudCBvZiB0aGUgbmVlZGVkIHN0cmluZyBhbmQgc2hvdWxkIHJldHVybiB0aGUgcmVwbGFjZW1lbnQuXHJcblx0XHQgKiBJZiBsZWZ0IGFzIGBmYWxzZWAgbm8gcmVwbGFjZW1lbnQgaXMgbWFkZS5cclxuXHRcdCAqXHJcblx0XHQgKiBfX0V4YW1wbGVzX19cclxuXHRcdCAqXHJcblx0XHQgKlx0JCgnI3RyZWUnKS5qc3RyZWUoe1xyXG5cdFx0ICpcdFx0J2NvcmUnIDoge1xyXG5cdFx0ICpcdFx0XHQnc3RyaW5ncycgOiB7XHJcblx0XHQgKlx0XHRcdFx0J0xvYWRpbmcgLi4uJyA6ICdQbGVhc2Ugd2FpdCAuLi4nXHJcblx0XHQgKlx0XHRcdH1cclxuXHRcdCAqXHRcdH1cclxuXHRcdCAqXHR9KTtcclxuXHRcdCAqXHJcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnN0cmluZ3NcclxuXHRcdCAqL1xyXG5cdFx0c3RyaW5nc1x0XHRcdDogZmFsc2UsXHJcblx0XHQvKipcclxuXHRcdCAqIGRldGVybWluZXMgd2hhdCBoYXBwZW5zIHdoZW4gYSB1c2VyIHRyaWVzIHRvIG1vZGlmeSB0aGUgc3RydWN0dXJlIG9mIHRoZSB0cmVlXHJcblx0XHQgKiBJZiBsZWZ0IGFzIGBmYWxzZWAgYWxsIG9wZXJhdGlvbnMgbGlrZSBjcmVhdGUsIHJlbmFtZSwgZGVsZXRlLCBtb3ZlIG9yIGNvcHkgYXJlIHByZXZlbnRlZC5cclxuXHRcdCAqIFlvdSBjYW4gc2V0IHRoaXMgdG8gYHRydWVgIHRvIGFsbG93IGFsbCBpbnRlcmFjdGlvbnMgb3IgdXNlIGEgZnVuY3Rpb24gdG8gaGF2ZSBiZXR0ZXIgY29udHJvbC5cclxuXHRcdCAqXHJcblx0XHQgKiBfX0V4YW1wbGVzX19cclxuXHRcdCAqXHJcblx0XHQgKlx0JCgnI3RyZWUnKS5qc3RyZWUoe1xyXG5cdFx0ICpcdFx0J2NvcmUnIDoge1xyXG5cdFx0ICpcdFx0XHQnY2hlY2tfY2FsbGJhY2snIDogZnVuY3Rpb24gKG9wZXJhdGlvbiwgbm9kZSwgbm9kZV9wYXJlbnQsIG5vZGVfcG9zaXRpb24sIG1vcmUpIHtcclxuXHRcdCAqXHRcdFx0XHQvLyBvcGVyYXRpb24gY2FuIGJlICdjcmVhdGVfbm9kZScsICdyZW5hbWVfbm9kZScsICdkZWxldGVfbm9kZScsICdtb3ZlX25vZGUnIG9yICdjb3B5X25vZGUnXHJcblx0XHQgKlx0XHRcdFx0Ly8gaW4gY2FzZSBvZiAncmVuYW1lX25vZGUnIG5vZGVfcG9zaXRpb24gaXMgZmlsbGVkIHdpdGggdGhlIG5ldyBub2RlIG5hbWVcclxuXHRcdCAqXHRcdFx0XHRyZXR1cm4gb3BlcmF0aW9uID09PSAncmVuYW1lX25vZGUnID8gdHJ1ZSA6IGZhbHNlO1xyXG5cdFx0ICpcdFx0XHR9XHJcblx0XHQgKlx0XHR9XHJcblx0XHQgKlx0fSk7XHJcblx0XHQgKiBcclxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuY2hlY2tfY2FsbGJhY2tcclxuXHRcdCAqL1xyXG5cdFx0Y2hlY2tfY2FsbGJhY2tcdDogZmFsc2UsXHJcblx0XHQvKipcclxuXHRcdCAqIGEgY2FsbGJhY2sgY2FsbGVkIHdpdGggYSBzaW5nbGUgb2JqZWN0IHBhcmFtZXRlciBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSB3aGVuIHNvbWV0aGluZyBnb2VzIHdyb25nIChvcGVyYXRpb24gcHJldmVudGVkLCBhamF4IGZhaWxlZCwgZXRjKVxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS5lcnJvclxyXG5cdFx0ICovXHJcblx0XHRlcnJvclx0XHRcdDogJC5ub29wLFxyXG5cdFx0LyoqXHJcblx0XHQgKiB0aGUgb3BlbiAvIGNsb3NlIGFuaW1hdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMgLSBzZXQgdGhpcyB0byBgZmFsc2VgIHRvIGRpc2FibGUgdGhlIGFuaW1hdGlvbiAoZGVmYXVsdCBpcyBgMjAwYClcclxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuYW5pbWF0aW9uXHJcblx0XHQgKi9cclxuXHRcdGFuaW1hdGlvblx0XHQ6IDIwMCxcclxuXHRcdC8qKlxyXG5cdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgbXVsdGlwbGUgbm9kZXMgY2FuIGJlIHNlbGVjdGVkXHJcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLm11bHRpcGxlXHJcblx0XHQgKi9cclxuXHRcdG11bHRpcGxlXHRcdDogdHJ1ZSxcclxuXHRcdC8qKlxyXG5cdFx0ICogdGhlbWUgY29uZmlndXJhdGlvbiBvYmplY3RcclxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzXHJcblx0XHQgKi9cclxuXHRcdHRoZW1lc1x0XHRcdDoge1xyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogdGhlIG5hbWUgb2YgdGhlIHRoZW1lIHRvIHVzZSAoaWYgbGVmdCBhcyBgZmFsc2VgIHRoZSBkZWZhdWx0IHRoZW1lIGlzIHVzZWQpXHJcblx0XHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLm5hbWVcclxuXHRcdFx0ICovXHJcblx0XHRcdG5hbWVcdFx0XHQ6IGZhbHNlLFxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogdGhlIFVSTCBvZiB0aGUgdGhlbWUncyBDU1MgZmlsZSwgbGVhdmUgdGhpcyBhcyBgZmFsc2VgIGlmIHlvdSBoYXZlIG1hbnVhbGx5IGluY2x1ZGVkIHRoZSB0aGVtZSBDU1MgKHJlY29tbWVuZGVkKS4gWW91IGNhbiBzZXQgdGhpcyB0byBgdHJ1ZWAgdG9vIHdoaWNoIHdpbGwgdHJ5IHRvIGF1dG9sb2FkIHRoZSB0aGVtZS5cclxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMudXJsXHJcblx0XHRcdCAqL1xyXG5cdFx0XHR1cmxcdFx0XHRcdDogZmFsc2UsXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB0aGUgbG9jYXRpb24gb2YgYWxsIGpzdHJlZSB0aGVtZXMgLSBvbmx5IHVzZWQgaWYgYHVybGAgaXMgc2V0IHRvIGB0cnVlYFxyXG5cdFx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5kaXJcclxuXHRcdFx0ICovXHJcblx0XHRcdGRpclx0XHRcdFx0OiBmYWxzZSxcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNvbm5lY3RpbmcgZG90cyBhcmUgc2hvd25cclxuXHRcdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29yZS50aGVtZXMuZG90c1xyXG5cdFx0XHQgKi9cclxuXHRcdFx0ZG90c1x0XHRcdDogdHJ1ZSxcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIG5vZGUgaWNvbnMgYXJlIHNob3duXHJcblx0XHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLmljb25zXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRpY29uc1x0XHRcdDogdHJ1ZSxcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSB0cmVlIGJhY2tncm91bmQgaXMgc3RyaXBlZFxyXG5cdFx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5zdHJpcGVzXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRzdHJpcGVzXHRcdFx0OiBmYWxzZSxcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIGEgc3RyaW5nIChvciBib29sZWFuIGBmYWxzZWApIHNwZWNpZnlpbmcgdGhlIHRoZW1lIHZhcmlhbnQgdG8gdXNlIChpZiB0aGUgdGhlbWUgc3VwcG9ydHMgdmFyaWFudHMpXHJcblx0XHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUudGhlbWVzLnZhcmlhbnRcclxuXHRcdFx0ICovXHJcblx0XHRcdHZhcmlhbnRcdFx0XHQ6IGZhbHNlLFxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogYSBib29sZWFuIHNwZWNpZnlpbmcgaWYgYSByZXBvbnNpdmUgdmVyc2lvbiBvZiB0aGUgdGhlbWUgc2hvdWxkIGtpY2sgaW4gb24gc21hbGxlciBzY3JlZW5zIChpZiB0aGUgdGhlbWUgc3VwcG9ydHMgaXQpLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxyXG5cdFx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLnRoZW1lcy5yZXNwb25zaXZlXHJcblx0XHRcdCAqL1xyXG5cdFx0XHRyZXNwb25zaXZlXHRcdDogZmFsc2VcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGlmIGxlZnQgYXMgYHRydWVgIGFsbCBwYXJlbnRzIG9mIGFsbCBzZWxlY3RlZCBub2RlcyB3aWxsIGJlIG9wZW5lZCBvbmNlIHRoZSB0cmVlIGxvYWRzIChzbyB0aGF0IGFsbCBzZWxlY3RlZCBub2RlcyBhcmUgdmlzaWJsZSB0byB0aGUgdXNlcilcclxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuZXhwYW5kX3NlbGVjdGVkX29ubG9hZFxyXG5cdFx0ICovXHJcblx0XHRleHBhbmRfc2VsZWN0ZWRfb25sb2FkIDogdHJ1ZSxcclxuXHRcdC8qKlxyXG5cdFx0ICogaWYgbGVmdCBhcyBgdHJ1ZWAgd2ViIHdvcmtlcnMgd2lsbCBiZSB1c2VkIHRvIHBhcnNlIGluY29taW5nIEpTT04gZGF0YSB3aGVyZSBwb3NzaWJsZSwgc28gdGhhdCB0aGUgVUkgd2lsbCBub3QgYmUgYmxvY2tlZCBieSBsYXJnZSByZXF1ZXN0cy4gV29ya2VycyBhcmUgaG93ZXZlciBhYm91dCAzMCUgc2xvd2VyLiBEZWZhdWx0cyB0byBgdHJ1ZWBcclxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUud29ya2VyXHJcblx0XHQgKi9cclxuXHRcdHdvcmtlciA6IHRydWUsXHJcblx0XHQvKipcclxuXHRcdCAqIEZvcmNlIG5vZGUgdGV4dCB0byBwbGFpbiB0ZXh0IChhbmQgZXNjYXBlIEhUTUwpLiBEZWZhdWx0cyB0byBgZmFsc2VgXHJcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb3JlLmZvcmNlX3RleHRcclxuXHRcdCAqL1xyXG5cdFx0Zm9yY2VfdGV4dCA6IGZhbHNlLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBTaG91bGQgdGhlIG5vZGUgc2hvdWxkIGJlIHRvZ2dsZWQgaWYgdGhlIHRleHQgaXMgZG91YmxlIGNsaWNrZWQgLiBEZWZhdWx0cyB0byBgdHJ1ZWBcclxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNvcmUuZGJsY2xpY2tfdG9nZ2xlXHJcblx0XHQgKi9cclxuXHRcdGRibGNsaWNrX3RvZ2dsZSA6IHRydWVcclxuXHR9O1xyXG5cdCQuanN0cmVlLmNvcmUucHJvdG90eXBlID0ge1xyXG5cdFx0LyoqXHJcblx0XHQgKiB1c2VkIHRvIGRlY29yYXRlIGFuIGluc3RhbmNlIHdpdGggYSBwbHVnaW4uIFVzZWQgaW50ZXJuYWxseS5cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAbmFtZSBwbHVnaW4oZGVjbyBbLCBvcHRzXSlcclxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gZGVjbyB0aGUgcGx1Z2luIHRvIGRlY29yYXRlIHdpdGhcclxuXHRcdCAqIEBwYXJhbSAge09iamVjdH0gb3B0cyBvcHRpb25zIGZvciB0aGUgcGx1Z2luXHJcblx0XHQgKiBAcmV0dXJuIHtqc1RyZWV9XHJcblx0XHQgKi9cclxuXHRcdHBsdWdpbiA6IGZ1bmN0aW9uIChkZWNvLCBvcHRzKSB7XHJcblx0XHRcdHZhciBDaGlsZCA9ICQuanN0cmVlLnBsdWdpbnNbZGVjb107XHJcblx0XHRcdGlmKENoaWxkKSB7XHJcblx0XHRcdFx0dGhpcy5fZGF0YVtkZWNvXSA9IHt9O1xyXG5cdFx0XHRcdENoaWxkLnByb3RvdHlwZSA9IHRoaXM7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBDaGlsZChvcHRzLCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIHVzZWQgdG8gZGVjb3JhdGUgYW4gaW5zdGFuY2Ugd2l0aCBhIHBsdWdpbi4gVXNlZCBpbnRlcm5hbGx5LlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBuYW1lIGluaXQoZWwsIG9wdG9ucylcclxuXHRcdCAqIEBwYXJhbSB7RE9NRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBlbCB0aGUgZWxlbWVudCB3ZSBhcmUgdHJhbnNmb3JtaW5nXHJcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlXHJcblx0XHQgKiBAdHJpZ2dlciBpbml0LmpzdHJlZSwgbG9hZGluZy5qc3RyZWUsIGxvYWRlZC5qc3RyZWUsIHJlYWR5LmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0aW5pdCA6IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xyXG5cdFx0XHR0aGlzLl9tb2RlbCA9IHtcclxuXHRcdFx0XHRkYXRhIDoge1xyXG5cdFx0XHRcdFx0JyMnIDoge1xyXG5cdFx0XHRcdFx0XHRpZCA6ICcjJyxcclxuXHRcdFx0XHRcdFx0cGFyZW50IDogbnVsbCxcclxuXHRcdFx0XHRcdFx0cGFyZW50cyA6IFtdLFxyXG5cdFx0XHRcdFx0XHRjaGlsZHJlbiA6IFtdLFxyXG5cdFx0XHRcdFx0XHRjaGlsZHJlbl9kIDogW10sXHJcblx0XHRcdFx0XHRcdHN0YXRlIDogeyBsb2FkZWQgOiBmYWxzZSB9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRjaGFuZ2VkIDogW10sXHJcblx0XHRcdFx0Zm9yY2VfZnVsbF9yZWRyYXcgOiBmYWxzZSxcclxuXHRcdFx0XHRyZWRyYXdfdGltZW91dCA6IGZhbHNlLFxyXG5cdFx0XHRcdGRlZmF1bHRfc3RhdGUgOiB7XHJcblx0XHRcdFx0XHRsb2FkZWQgOiB0cnVlLFxyXG5cdFx0XHRcdFx0b3BlbmVkIDogZmFsc2UsXHJcblx0XHRcdFx0XHRzZWxlY3RlZCA6IGZhbHNlLFxyXG5cdFx0XHRcdFx0ZGlzYWJsZWQgOiBmYWxzZVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHRoaXMuZWxlbWVudCA9ICQoZWwpLmFkZENsYXNzKCdqc3RyZWUganN0cmVlLScgKyB0aGlzLl9pZCk7XHJcblx0XHRcdHRoaXMuc2V0dGluZ3MgPSBvcHRpb25zO1xyXG5cclxuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnJlYWR5ID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5sb2FkZWQgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnJ0bCA9ICh0aGlzLmVsZW1lbnQuY3NzKFwiZGlyZWN0aW9uXCIpID09PSBcInJ0bFwiKTtcclxuXHRcdFx0dGhpcy5lbGVtZW50W3RoaXMuX2RhdGEuY29yZS5ydGwgPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJ10oXCJqc3RyZWUtcnRsXCIpO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0cigncm9sZScsJ3RyZWUnKTtcclxuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jb3JlLm11bHRpcGxlKSB7XHJcblx0XHRcdFx0dGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtbXVsdGlzZWxlY3RhYmxlJywgdHJ1ZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIXRoaXMuZWxlbWVudC5hdHRyKCd0YWJpbmRleCcpKSB7XHJcblx0XHRcdFx0dGhpcy5lbGVtZW50LmF0dHIoJ3RhYmluZGV4JywnMCcpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmJpbmQoKTtcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIHRyaWdnZXJlZCBhZnRlciBhbGwgZXZlbnRzIGFyZSBib3VuZFxyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgaW5pdC5qc3RyZWVcclxuXHRcdFx0ICovXHJcblx0XHRcdHRoaXMudHJpZ2dlcihcImluaXRcIik7XHJcblxyXG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUub3JpZ2luYWxfY29udGFpbmVyX2h0bWwgPSB0aGlzLmVsZW1lbnQuZmluZChcIiA+IHVsID4gbGlcIikuY2xvbmUodHJ1ZSk7XHJcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbFxyXG5cdFx0XHRcdC5maW5kKFwibGlcIikuYWRkQmFjaygpXHJcblx0XHRcdFx0LmNvbnRlbnRzKCkuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZVR5cGUgPT09IDMgJiYgKCF0aGlzLm5vZGVWYWx1ZSB8fCAvXlxccyskLy50ZXN0KHRoaXMubm9kZVZhbHVlKSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQucmVtb3ZlKCk7XHJcblx0XHRcdHRoaXMuZWxlbWVudC5odG1sKFwiPFwiK1widWwgY2xhc3M9J2pzdHJlZS1jb250YWluZXItdWwganN0cmVlLWNoaWxkcmVuJyByb2xlPSdncm91cCc+PFwiK1wibGkgaWQ9J2pcIit0aGlzLl9pZCtcIl9sb2FkaW5nJyBjbGFzcz0nanN0cmVlLWluaXRpYWwtbm9kZSBqc3RyZWUtbG9hZGluZyBqc3RyZWUtbGVhZiBqc3RyZWUtbGFzdCcgcm9sZT0ndHJlZS1pdGVtJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLW9jbCc+PC9pPjxcIitcImEgY2xhc3M9J2pzdHJlZS1hbmNob3InIGhyZWY9JyMnPjxpIGNsYXNzPSdqc3RyZWUtaWNvbiBqc3RyZWUtdGhlbWVpY29uLWhpZGRlbic+PC9pPlwiICsgdGhpcy5nZXRfc3RyaW5nKFwiTG9hZGluZyAuLi5cIikgKyBcIjwvYT48L2xpPjwvdWw+XCIpO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywnaicgKyB0aGlzLl9pZCArICdfbG9hZGluZycpO1xyXG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUubGlfaGVpZ2h0ID0gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuY2hpbGRyZW4oXCJsaVwiKS5maXJzdCgpLmhlaWdodCgpIHx8IDI0O1xyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogdHJpZ2dlcmVkIGFmdGVyIHRoZSBsb2FkaW5nIHRleHQgaXMgc2hvd24gYW5kIGJlZm9yZSBsb2FkaW5nIHN0YXJ0c1xyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgbG9hZGluZy5qc3RyZWVcclxuXHRcdFx0ICovXHJcblx0XHRcdHRoaXMudHJpZ2dlcihcImxvYWRpbmdcIik7XHJcblx0XHRcdHRoaXMubG9hZF9ub2RlKCcjJyk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBkZXN0cm95IGFuIGluc3RhbmNlXHJcblx0XHQgKiBAbmFtZSBkZXN0cm95KClcclxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IGtlZXBfaHRtbCBpZiBub3Qgc2V0IHRvIGB0cnVlYCB0aGUgY29udGFpbmVyIHdpbGwgYmUgZW1wdGllZCwgb3RoZXJ3aXNlIHRoZSBjdXJyZW50IERPTSBlbGVtZW50cyB3aWxsIGJlIGtlcHQgaW50YWN0XHJcblx0XHQgKi9cclxuXHRcdGRlc3Ryb3kgOiBmdW5jdGlvbiAoa2VlcF9odG1sKSB7XHJcblx0XHRcdGlmKHRoaXMuX3dyaykge1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHR3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTCh0aGlzLl93cmspO1xyXG5cdFx0XHRcdFx0dGhpcy5fd3JrID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Y2F0Y2ggKGlnbm9yZSkgeyB9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIWtlZXBfaHRtbCkgeyB0aGlzLmVsZW1lbnQuZW1wdHkoKTsgfVxyXG5cdFx0XHR0aGlzLnRlYXJkb3duKCk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBwYXJ0IG9mIHRoZSBkZXN0cm95aW5nIG9mIGFuIGluc3RhbmNlLiBVc2VkIGludGVybmFsbHkuXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQG5hbWUgdGVhcmRvd24oKVxyXG5cdFx0ICovXHJcblx0XHR0ZWFyZG93biA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy51bmJpbmQoKTtcclxuXHRcdFx0dGhpcy5lbGVtZW50XHJcblx0XHRcdFx0LnJlbW92ZUNsYXNzKCdqc3RyZWUnKVxyXG5cdFx0XHRcdC5yZW1vdmVEYXRhKCdqc3RyZWUnKVxyXG5cdFx0XHRcdC5maW5kKFwiW2NsYXNzXj0nanN0cmVlJ11cIilcclxuXHRcdFx0XHRcdC5hZGRCYWNrKClcclxuXHRcdFx0XHRcdC5hdHRyKFwiY2xhc3NcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5jbGFzc05hbWUucmVwbGFjZSgvanN0cmVlW14gXSp8JC9pZywnJyk7IH0pO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnQgPSBudWxsO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogYmluZCBhbGwgZXZlbnRzLiBVc2VkIGludGVybmFsbHkuXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQG5hbWUgYmluZCgpXHJcblx0XHQgKi9cclxuXHRcdGJpbmQgOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciB3b3JkID0gJycsXHJcblx0XHRcdFx0dG91dCA9IG51bGwsXHJcblx0XHRcdFx0d2FzX2NsaWNrID0gMDtcclxuXHRcdFx0dGhpcy5lbGVtZW50XHJcblx0XHRcdFx0Lm9uKFwiZGJsY2xpY2suanN0cmVlXCIsIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdFx0aWYoZG9jdW1lbnQuc2VsZWN0aW9uICYmIGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSkge1xyXG5cdFx0XHRcdFx0XHRcdGRvY3VtZW50LnNlbGVjdGlvbi5lbXB0eSgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdGlmKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XHJcblx0XHRcdFx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHNlbC5jb2xsYXBzZSgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoaWdub3JlKSB7IH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwibW91c2Vkb3duLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRcdGlmKGUudGFyZ2V0ID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcclxuXHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7IC8vIHByZXZlbnQgbG9zaW5nIGZvY3VzIHdoZW4gY2xpY2tpbmcgc2Nyb2xsIGFycm93cyAoRkYsIENocm9tZSlcclxuXHRcdFx0XHRcdFx0XHR3YXNfY2xpY2sgPSArKG5ldyBEYXRlKCkpOyAvLyBpZSBkb2VzIG5vdCBhbGxvdyB0byBwcmV2ZW50IGxvc2luZyBmb2N1c1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LCB0aGlzKSlcclxuXHRcdFx0XHQub24oXCJtb3VzZWRvd24uanN0cmVlXCIsIFwiLmpzdHJlZS1vY2xcIiwgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50IGFueSBub2RlIGluc2lkZSBmcm9tIGxvc2luZyBmb2N1cyB3aGVuIGNsaWNraW5nIHRoZSBvcGVuL2Nsb3NlIGljb25cclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwiY2xpY2suanN0cmVlXCIsIFwiLmpzdHJlZS1vY2xcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnRvZ2dsZV9ub2RlKGUudGFyZ2V0KTtcclxuXHRcdFx0XHRcdH0sIHRoaXMpKVxyXG5cdFx0XHRcdC5vbihcImRibGNsaWNrLmpzdHJlZVwiLCBcIi5qc3RyZWUtYW5jaG9yXCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jb3JlLmRibGNsaWNrX3RvZ2dsZSkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMudG9nZ2xlX25vZGUoZS50YXJnZXQpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LCB0aGlzKSlcclxuXHRcdFx0XHQub24oXCJjbGljay5qc3RyZWVcIiwgXCIuanN0cmVlLWFuY2hvclwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRcdFx0aWYoZS5jdXJyZW50VGFyZ2V0ICE9PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7ICQoZS5jdXJyZW50VGFyZ2V0KS5mb2N1cygpOyB9XHJcblx0XHRcdFx0XHRcdHRoaXMuYWN0aXZhdGVfbm9kZShlLmN1cnJlbnRUYXJnZXQsIGUpO1xyXG5cdFx0XHRcdFx0fSwgdGhpcykpXHJcblx0XHRcdFx0Lm9uKCdrZXlkb3duLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdFx0aWYoZS50YXJnZXQudGFnTmFtZSA9PT0gXCJJTlBVVFwiKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdFx0XHRcdHZhciBvID0gbnVsbDtcclxuXHRcdFx0XHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLnJ0bCkge1xyXG5cdFx0XHRcdFx0XHRcdGlmKGUud2hpY2ggPT09IDM3KSB7IGUud2hpY2ggPSAzOTsgfVxyXG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYoZS53aGljaCA9PT0gMzkpIHsgZS53aGljaCA9IDM3OyB9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0c3dpdGNoKGUud2hpY2gpIHtcclxuXHRcdFx0XHRcdFx0XHRjYXNlIDMyOiAvLyBhcmlhIGRlZmluZXMgc3BhY2Ugb25seSB3aXRoIEN0cmxcclxuXHRcdFx0XHRcdFx0XHRcdGlmKGUuY3RybEtleSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRlLnR5cGUgPSBcImNsaWNrXCI7XHJcblx0XHRcdFx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS50cmlnZ2VyKGUpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAxMzogLy8gZW50ZXJcclxuXHRcdFx0XHRcdFx0XHRcdGUudHlwZSA9IFwiY2xpY2tcIjtcclxuXHRcdFx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS50cmlnZ2VyKGUpO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAzNzogLy8gcmlnaHRcclxuXHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKHRoaXMuaXNfb3BlbihlLmN1cnJlbnRUYXJnZXQpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuY2xvc2Vfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG8gPSB0aGlzLmdldF9wYXJlbnQoZS5jdXJyZW50VGFyZ2V0KTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYobyAmJiBvLmlkICE9PSAnIycpIHsgdGhpcy5nZXRfbm9kZShvLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpOyB9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRjYXNlIDM4OiAvLyB1cFxyXG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0byA9IHRoaXMuZ2V0X3ByZXZfZG9tKGUuY3VycmVudFRhcmdldCk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZihvICYmIG8ubGVuZ3RoKSB7IG8uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAzOTogLy8gbGVmdFxyXG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYodGhpcy5pc19jbG9zZWQoZS5jdXJyZW50VGFyZ2V0KSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLm9wZW5fbm9kZShlLmN1cnJlbnRUYXJnZXQsIGZ1bmN0aW9uIChvKSB7IHRoaXMuZ2V0X25vZGUobywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTsgfSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRlbHNlIGlmICh0aGlzLmlzX29wZW4oZS5jdXJyZW50VGFyZ2V0KSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRvID0gdGhpcy5nZXRfbm9kZShlLmN1cnJlbnRUYXJnZXQsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJylbMF07XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKG8pIHsgJCh0aGlzLl9maXJzdENoaWxkKG8pKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpOyB9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRjYXNlIDQwOiAvLyBkb3duXHJcblx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0XHRcdFx0XHRvID0gdGhpcy5nZXRfbmV4dF9kb20oZS5jdXJyZW50VGFyZ2V0KTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKG8gJiYgby5sZW5ndGgpIHsgby5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpOyB9XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRjYXNlIDEwNjogLy8gYXJpYSBkZWZpbmVzICogb24gbnVtcGFkIGFzIG9wZW5fYWxsIC0gbm90IHZlcnkgY29tbW9uXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLm9wZW5fYWxsKCk7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRjYXNlIDM2OiAvLyBob21lXHJcblx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0XHRcdFx0XHRvID0gdGhpcy5fZmlyc3RDaGlsZCh0aGlzLmdldF9jb250YWluZXJfdWwoKVswXSk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZihvKSB7ICQobykuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuZmlsdGVyKCc6dmlzaWJsZScpLmZvY3VzKCk7IH1cclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgMzU6IC8vIGVuZFxyXG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtYW5jaG9yJykuZmlsdGVyKCc6dmlzaWJsZScpLmxhc3QoKS5mb2N1cygpO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0LypcclxuXHRcdFx0XHRcdFx0XHQvLyBkZWxldGVcclxuXHRcdFx0XHRcdFx0XHRjYXNlIDQ2OlxyXG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0byA9IHRoaXMuZ2V0X25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKG8gJiYgby5pZCAmJiBvLmlkICE9PSAnIycpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0byA9IHRoaXMuaXNfc2VsZWN0ZWQobykgPyB0aGlzLmdldF9zZWxlY3RlZCgpIDogbztcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5kZWxldGVfbm9kZShvKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdC8vIGYyXHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAxMTM6XHJcblx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0XHRcdFx0XHRvID0gdGhpcy5nZXRfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYobyAmJiBvLmlkICYmIG8uaWQgIT09ICcjJykge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzLmVkaXQobyk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coZS53aGljaCk7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHQqL1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LCB0aGlzKSlcclxuXHRcdFx0XHQub24oXCJsb2FkX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0aWYoZGF0YS5zdGF0dXMpIHtcclxuXHRcdFx0XHRcdFx0XHRpZihkYXRhLm5vZGUuaWQgPT09ICcjJyAmJiAhdGhpcy5fZGF0YS5jb3JlLmxvYWRlZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxvYWRlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRpZih0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyx0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKS5pZCk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHQvKipcclxuXHRcdFx0XHRcdFx0XHRcdCAqIHRyaWdnZXJlZCBhZnRlciB0aGUgcm9vdCBub2RlIGlzIGxvYWRlZCBmb3IgdGhlIGZpcnN0IHRpbWVcclxuXHRcdFx0XHRcdFx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHRcdFx0XHRcdFx0ICogQG5hbWUgbG9hZGVkLmpzdHJlZVxyXG5cdFx0XHRcdFx0XHRcdFx0ICovXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJsb2FkZWRcIik7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmKCF0aGlzLl9kYXRhLmNvcmUucmVhZHkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoIXRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmZpbmQoJy5qc3RyZWUtbG9hZGluZycpLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5yZWFkeSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jb3JlLmV4cGFuZF9zZWxlY3RlZF9vbmxvYWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHRtcCA9IFtdLCBpLCBqO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gdG1wLmNvbmNhdCh0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFtpXV0ucGFyZW50cyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gJC52YWthdGEuYXJyYXlfdW5pcXVlKHRtcCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLm9wZW5fbm9kZSh0bXBbaV0sIGZhbHNlLCAwKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdyZWFkeScsICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgfSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8qKlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCAqIHRyaWdnZXJlZCBhZnRlciBhbGwgbm9kZXMgYXJlIGZpbmlzaGVkIGxvYWRpbmdcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgKiBAbmFtZSByZWFkeS5qc3RyZWVcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQgKi9cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoXCJyZWFkeVwiKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fSwgdGhpcyksIDApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSwgdGhpcykpXHJcblx0XHRcdFx0Ly8gcXVpY2sgc2VhcmNoaW5nIHdoZW4gdGhlIHRyZWUgaXMgZm9jdXNlZFxyXG5cdFx0XHRcdC5vbigna2V5cHJlc3MuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHRpZihlLnRhcmdldC50YWdOYW1lID09PSBcIklOUFVUXCIpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0XHRcdFx0aWYodG91dCkgeyBjbGVhclRpbWVvdXQodG91dCk7IH1cclxuXHRcdFx0XHRcdFx0dG91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHRcdHdvcmQgPSAnJztcclxuXHRcdFx0XHRcdFx0fSwgNTAwKTtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBjaHIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUud2hpY2gpLnRvTG93ZXJDYXNlKCksXHJcblx0XHRcdFx0XHRcdFx0Y29sID0gdGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtYW5jaG9yJykuZmlsdGVyKCc6dmlzaWJsZScpLFxyXG5cdFx0XHRcdFx0XHRcdGluZCA9IGNvbC5pbmRleChkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB8fCAwLFxyXG5cdFx0XHRcdFx0XHRcdGVuZCA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR3b3JkICs9IGNocjtcclxuXHJcblx0XHRcdFx0XHRcdC8vIG1hdGNoIGZvciB3aG9sZSB3b3JkIGZyb20gY3VycmVudCBub2RlIGRvd24gKGluY2x1ZGluZyB0aGUgY3VycmVudCBub2RlKVxyXG5cdFx0XHRcdFx0XHRpZih3b3JkLmxlbmd0aCA+IDEpIHtcclxuXHRcdFx0XHRcdFx0XHRjb2wuc2xpY2UoaW5kKS5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKCQodikudGV4dCgpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih3b3JkKSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQkKHYpLmZvY3VzKCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGVuZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9LCB0aGlzKSk7XHJcblx0XHRcdFx0XHRcdFx0aWYoZW5kKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBtYXRjaCBmb3Igd2hvbGUgd29yZCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHRyZWVcclxuXHRcdFx0XHRcdFx0XHRjb2wuc2xpY2UoMCwgaW5kKS5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGksIHYpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKCQodikudGV4dCgpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZih3b3JkKSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQkKHYpLmZvY3VzKCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGVuZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9LCB0aGlzKSk7XHJcblx0XHRcdFx0XHRcdFx0aWYoZW5kKSB7IHJldHVybjsgfVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdC8vIGxpc3Qgbm9kZXMgdGhhdCBzdGFydCB3aXRoIHRoYXQgbGV0dGVyIChvbmx5IGlmIHdvcmQgY29uc2lzdHMgb2YgYSBzaW5nbGUgY2hhcilcclxuXHRcdFx0XHRcdFx0aWYobmV3IFJlZ0V4cCgnXicgKyBjaHIgKyAnKyQnKS50ZXN0KHdvcmQpKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gc2VhcmNoIGZvciB0aGUgbmV4dCBub2RlIHN0YXJ0aW5nIHdpdGggdGhhdCBsZXR0ZXJcclxuXHRcdFx0XHRcdFx0XHRjb2wuc2xpY2UoaW5kICsgMSkuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZigkKHYpLnRleHQoKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gY2hyKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdCQodikuZm9jdXMoKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcclxuXHRcdFx0XHRcdFx0XHRpZihlbmQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHNlYXJjaCBmcm9tIHRoZSBiZWdpbm5pbmdcclxuXHRcdFx0XHRcdFx0XHRjb2wuc2xpY2UoMCwgaW5kICsgMSkuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZigkKHYpLnRleHQoKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gY2hyKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdCQodikuZm9jdXMoKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZW5kID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcclxuXHRcdFx0XHRcdFx0XHRpZihlbmQpIHsgcmV0dXJuOyB9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0sIHRoaXMpKVxyXG5cdFx0XHRcdC8vIFRIRU1FIFJFTEFURURcclxuXHRcdFx0XHQub24oXCJpbml0LmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHMgPSB0aGlzLnNldHRpbmdzLmNvcmUudGhlbWVzO1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHNcdFx0XHQ9IHMuZG90cztcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzXHRcdD0gcy5zdHJpcGVzO1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zXHRcdD0gcy5pY29ucztcclxuXHRcdFx0XHRcdFx0dGhpcy5zZXRfdGhlbWUocy5uYW1lIHx8IFwiZGVmYXVsdFwiLCBzLnVybCk7XHJcblx0XHRcdFx0XHRcdHRoaXMuc2V0X3RoZW1lX3ZhcmlhbnQocy52YXJpYW50KTtcclxuXHRcdFx0XHRcdH0sIHRoaXMpKVxyXG5cdFx0XHRcdC5vbihcImxvYWRpbmcuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzWyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHMgPyBcInNob3dfZG90c1wiIDogXCJoaWRlX2RvdHNcIiBdKCk7XHJcblx0XHRcdFx0XHRcdHRoaXNbIHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMgPyBcInNob3dfaWNvbnNcIiA6IFwiaGlkZV9pY29uc1wiIF0oKTtcclxuXHRcdFx0XHRcdFx0dGhpc1sgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzID8gXCJzaG93X3N0cmlwZXNcIiA6IFwiaGlkZV9zdHJpcGVzXCIgXSgpO1xyXG5cdFx0XHRcdFx0fSwgdGhpcykpXHJcblx0XHRcdFx0Lm9uKCdibHVyLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQgPSBudWxsO1xyXG5cdFx0XHRcdFx0XHQkKGUuY3VycmVudFRhcmdldCkuZmlsdGVyKCcuanN0cmVlLWhvdmVyZWQnKS5tb3VzZWxlYXZlKCk7XHJcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsICcwJyk7XHJcblx0XHRcdFx0XHR9LCB0aGlzKSlcclxuXHRcdFx0XHQub24oJ2ZvY3VzLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0X25vZGUoZS5jdXJyZW50VGFyZ2V0KTtcclxuXHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5pZCkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gdG1wLmlkO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWhvdmVyZWQnKS5ub3QoZS5jdXJyZW50VGFyZ2V0KS5tb3VzZWxlYXZlKCk7XHJcblx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS5tb3VzZWVudGVyKCk7XHJcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsICctMScpO1xyXG5cdFx0XHRcdFx0fSwgdGhpcykpXHJcblx0XHRcdFx0Lm9uKCdmb2N1cy5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdFx0aWYoKyhuZXcgRGF0ZSgpKSAtIHdhc19jbGljayA+IDUwMCAmJiAhdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQpIHtcclxuXHRcdFx0XHRcdFx0XHR3YXNfY2xpY2sgPSAwO1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZ2V0X25vZGUodGhpcy5lbGVtZW50LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcpLCB0cnVlKS5maW5kKCc+IC5qc3RyZWUtYW5jaG9yJykuZm9jdXMoKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSwgdGhpcykpXHJcblx0XHRcdFx0Lm9uKCdtb3VzZWVudGVyLmpzdHJlZScsICcuanN0cmVlLWFuY2hvcicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5ob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XHJcblx0XHRcdFx0XHR9LCB0aGlzKSlcclxuXHRcdFx0XHQub24oJ21vdXNlbGVhdmUuanN0cmVlJywgJy5qc3RyZWUtYW5jaG9yJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmRlaG92ZXJfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xyXG5cdFx0XHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogcGFydCBvZiB0aGUgZGVzdHJveWluZyBvZiBhbiBpbnN0YW5jZS4gVXNlZCBpbnRlcm5hbGx5LlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBuYW1lIHVuYmluZCgpXHJcblx0XHQgKi9cclxuXHRcdHVuYmluZCA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5lbGVtZW50Lm9mZignLmpzdHJlZScpO1xyXG5cdFx0XHQkKGRvY3VtZW50KS5vZmYoJy5qc3RyZWUtJyArIHRoaXMuX2lkKTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIHRyaWdnZXIgYW4gZXZlbnQuIFVzZWQgaW50ZXJuYWxseS5cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAbmFtZSB0cmlnZ2VyKGV2IFssIGRhdGFdKVxyXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBldiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJpZ2dlclxyXG5cdFx0ICogQHBhcmFtICB7T2JqZWN0fSBkYXRhIGFkZGl0aW9uYWwgZGF0YSB0byBwYXNzIHdpdGggdGhlIGV2ZW50XHJcblx0XHQgKi9cclxuXHRcdHRyaWdnZXIgOiBmdW5jdGlvbiAoZXYsIGRhdGEpIHtcclxuXHRcdFx0aWYoIWRhdGEpIHtcclxuXHRcdFx0XHRkYXRhID0ge307XHJcblx0XHRcdH1cclxuXHRcdFx0ZGF0YS5pbnN0YW5jZSA9IHRoaXM7XHJcblx0XHRcdHRoaXMuZWxlbWVudC50cmlnZ2VySGFuZGxlcihldi5yZXBsYWNlKCcuanN0cmVlJywnJykgKyAnLmpzdHJlZScsIGRhdGEpO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogcmV0dXJucyB0aGUgalF1ZXJ5IGV4dGVuZGVkIGluc3RhbmNlIGNvbnRhaW5lclxyXG5cdFx0ICogQG5hbWUgZ2V0X2NvbnRhaW5lcigpXHJcblx0XHQgKiBAcmV0dXJuIHtqUXVlcnl9XHJcblx0XHQgKi9cclxuXHRcdGdldF9jb250YWluZXIgOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQ7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiByZXR1cm5zIHRoZSBqUXVlcnkgZXh0ZW5kZWQgbWFpbiBVTCBub2RlIGluc2lkZSB0aGUgaW5zdGFuY2UgY29udGFpbmVyLiBVc2VkIGludGVybmFsbHkuXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQG5hbWUgZ2V0X2NvbnRhaW5lcl91bCgpXHJcblx0XHQgKiBAcmV0dXJuIHtqUXVlcnl9XHJcblx0XHQgKi9cclxuXHRcdGdldF9jb250YWluZXJfdWwgOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQuY2hpbGRyZW4oXCIuanN0cmVlLWNoaWxkcmVuXCIpLmZpcnN0KCk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBnZXRzIHN0cmluZyByZXBsYWNlbWVudHMgKGxvY2FsaXphdGlvbikuIFVzZWQgaW50ZXJuYWxseS5cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAbmFtZSBnZXRfc3RyaW5nKGtleSlcclxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30ga2V5XHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd9XHJcblx0XHQgKi9cclxuXHRcdGdldF9zdHJpbmcgOiBmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHRcdHZhciBhID0gdGhpcy5zZXR0aW5ncy5jb3JlLnN0cmluZ3M7XHJcblx0XHRcdGlmKCQuaXNGdW5jdGlvbihhKSkgeyByZXR1cm4gYS5jYWxsKHRoaXMsIGtleSk7IH1cclxuXHRcdFx0aWYoYSAmJiBhW2tleV0pIHsgcmV0dXJuIGFba2V5XTsgfVxyXG5cdFx0XHRyZXR1cm4ga2V5O1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogZ2V0cyB0aGUgZmlyc3QgY2hpbGQgb2YgYSBET00gbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBuYW1lIF9maXJzdENoaWxkKGRvbSlcclxuXHRcdCAqIEBwYXJhbSAge0RPTUVsZW1lbnR9IGRvbVxyXG5cdFx0ICogQHJldHVybiB7RE9NRWxlbWVudH1cclxuXHRcdCAqL1xyXG5cdFx0X2ZpcnN0Q2hpbGQgOiBmdW5jdGlvbiAoZG9tKSB7XHJcblx0XHRcdGRvbSA9IGRvbSA/IGRvbS5maXJzdENoaWxkIDogbnVsbDtcclxuXHRcdFx0d2hpbGUoZG9tICE9PSBudWxsICYmIGRvbS5ub2RlVHlwZSAhPT0gMSkge1xyXG5cdFx0XHRcdGRvbSA9IGRvbS5uZXh0U2libGluZztcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZG9tO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogZ2V0cyB0aGUgbmV4dCBzaWJsaW5nIG9mIGEgRE9NIG5vZGUuIFVzZWQgaW50ZXJuYWxseS5cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAbmFtZSBfbmV4dFNpYmxpbmcoZG9tKVxyXG5cdFx0ICogQHBhcmFtICB7RE9NRWxlbWVudH0gZG9tXHJcblx0XHQgKiBAcmV0dXJuIHtET01FbGVtZW50fVxyXG5cdFx0ICovXHJcblx0XHRfbmV4dFNpYmxpbmcgOiBmdW5jdGlvbiAoZG9tKSB7XHJcblx0XHRcdGRvbSA9IGRvbSA/IGRvbS5uZXh0U2libGluZyA6IG51bGw7XHJcblx0XHRcdHdoaWxlKGRvbSAhPT0gbnVsbCAmJiBkb20ubm9kZVR5cGUgIT09IDEpIHtcclxuXHRcdFx0XHRkb20gPSBkb20ubmV4dFNpYmxpbmc7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGRvbTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGdldHMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYSBET00gbm9kZS4gVXNlZCBpbnRlcm5hbGx5LlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBuYW1lIF9wcmV2aW91c1NpYmxpbmcoZG9tKVxyXG5cdFx0ICogQHBhcmFtICB7RE9NRWxlbWVudH0gZG9tXHJcblx0XHQgKiBAcmV0dXJuIHtET01FbGVtZW50fVxyXG5cdFx0ICovXHJcblx0XHRfcHJldmlvdXNTaWJsaW5nIDogZnVuY3Rpb24gKGRvbSkge1xyXG5cdFx0XHRkb20gPSBkb20gPyBkb20ucHJldmlvdXNTaWJsaW5nIDogbnVsbDtcclxuXHRcdFx0d2hpbGUoZG9tICE9PSBudWxsICYmIGRvbS5ub2RlVHlwZSAhPT0gMSkge1xyXG5cdFx0XHRcdGRvbSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGRvbTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGdldCB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIG5vZGUgKG9yIHRoZSBhY3R1YWwgalF1ZXJ5IGV4dGVuZGVkIERPTSBub2RlKSBieSB1c2luZyBhbnkgaW5wdXQgKGNoaWxkIERPTSBlbGVtZW50LCBJRCBzdHJpbmcsIHNlbGVjdG9yLCBldGMpXHJcblx0XHQgKiBAbmFtZSBnZXRfbm9kZShvYmogWywgYXNfZG9tXSlcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcclxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IGFzX2RvbVxyXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fGpRdWVyeX1cclxuXHRcdCAqL1xyXG5cdFx0Z2V0X25vZGUgOiBmdW5jdGlvbiAob2JqLCBhc19kb20pIHtcclxuXHRcdFx0aWYob2JqICYmIG9iai5pZCkge1xyXG5cdFx0XHRcdG9iaiA9IG9iai5pZDtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgZG9tO1xyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbb2JqXSkge1xyXG5cdFx0XHRcdFx0b2JqID0gdGhpcy5fbW9kZWwuZGF0YVtvYmpdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIGlmKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIgJiYgdGhpcy5fbW9kZWwuZGF0YVtvYmoucmVwbGFjZSgvXiMvLCAnJyldKSB7XHJcblx0XHRcdFx0XHRvYmogPSB0aGlzLl9tb2RlbC5kYXRhW29iai5yZXBsYWNlKC9eIy8sICcnKV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYodHlwZW9mIG9iaiA9PT0gXCJzdHJpbmdcIiAmJiAoZG9tID0gJCgnIycgKyBvYmoucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKSwgdGhpcy5lbGVtZW50KSkubGVuZ3RoICYmIHRoaXMuX21vZGVsLmRhdGFbZG9tLmNsb3Nlc3QoJy5qc3RyZWUtbm9kZScpLmF0dHIoJ2lkJyldKSB7XHJcblx0XHRcdFx0XHRvYmogPSB0aGlzLl9tb2RlbC5kYXRhW2RvbS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5hdHRyKCdpZCcpXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZigoZG9tID0gJChvYmosIHRoaXMuZWxlbWVudCkpLmxlbmd0aCAmJiB0aGlzLl9tb2RlbC5kYXRhW2RvbS5jbG9zZXN0KCcuanN0cmVlLW5vZGUnKS5hdHRyKCdpZCcpXSkge1xyXG5cdFx0XHRcdFx0b2JqID0gdGhpcy5fbW9kZWwuZGF0YVtkb20uY2xvc2VzdCgnLmpzdHJlZS1ub2RlJykuYXR0cignaWQnKV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYoKGRvbSA9ICQob2JqLCB0aGlzLmVsZW1lbnQpKS5sZW5ndGggJiYgZG9tLmhhc0NsYXNzKCdqc3RyZWUnKSkge1xyXG5cdFx0XHRcdFx0b2JqID0gdGhpcy5fbW9kZWwuZGF0YVsnIyddO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmKGFzX2RvbSkge1xyXG5cdFx0XHRcdFx0b2JqID0gb2JqLmlkID09PSAnIycgPyB0aGlzLmVsZW1lbnQgOiAkKCcjJyArIG9iai5pZC5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpLCB0aGlzLmVsZW1lbnQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gb2JqO1xyXG5cdFx0XHR9IGNhdGNoIChleCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGdldCB0aGUgcGF0aCB0byBhIG5vZGUsIGVpdGhlciBjb25zaXN0aW5nIG9mIG5vZGUgdGV4dHMsIG9yIG9mIG5vZGUgSURzLCBvcHRpb25hbGx5IGdsdWVkIHRvZ2V0aGVyIChvdGhlcndpc2UgYW4gYXJyYXkpXHJcblx0XHQgKiBAbmFtZSBnZXRfcGF0aChvYmogWywgZ2x1ZSwgaWRzXSlcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcclxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gZ2x1ZSBpZiB5b3Ugd2FudCB0aGUgcGF0aCBhcyBhIHN0cmluZyAtIHBhc3MgdGhlIGdsdWUgaGVyZSAoZm9yIGV4YW1wbGUgJy8nKSwgaWYgYSBmYWxzeSB2YWx1ZSBpcyBzdXBwbGllZCBoZXJlLCBhbiBhcnJheSBpcyByZXR1cm5lZFxyXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gaWRzIGlmIHNldCB0byB0cnVlIGJ1aWxkIHRoZSBwYXRoIHVzaW5nIElELCBvdGhlcndpc2Ugbm9kZSB0ZXh0IGlzIHVzZWRcclxuXHRcdCAqIEByZXR1cm4ge21peGVkfVxyXG5cdFx0ICovXHJcblx0XHRnZXRfcGF0aCA6IGZ1bmN0aW9uIChvYmosIGdsdWUsIGlkcykge1xyXG5cdFx0XHRvYmogPSBvYmoucGFyZW50cyA/IG9iaiA6IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICcjJyB8fCAhb2JqLnBhcmVudHMpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGksIGosIHAgPSBbXTtcclxuXHRcdFx0cC5wdXNoKGlkcyA/IG9iai5pZCA6IG9iai50ZXh0KTtcclxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0cC5wdXNoKGlkcyA/IG9iai5wYXJlbnRzW2ldIDogdGhpcy5nZXRfdGV4dChvYmoucGFyZW50c1tpXSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHAgPSBwLnJldmVyc2UoKS5zbGljZSgxKTtcclxuXHRcdFx0cmV0dXJuIGdsdWUgPyBwLmpvaW4oZ2x1ZSkgOiBwO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogZ2V0IHRoZSBuZXh0IHZpc2libGUgbm9kZSB0aGF0IGlzIGJlbG93IHRoZSBgb2JqYCBub2RlLiBJZiBgc3RyaWN0YCBpcyBzZXQgdG8gYHRydWVgIG9ubHkgc2libGluZyBub2RlcyBhcmUgcmV0dXJuZWQuXHJcblx0XHQgKiBAbmFtZSBnZXRfbmV4dF9kb20ob2JqIFssIHN0cmljdF0pXHJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXHJcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBzdHJpY3RcclxuXHRcdCAqIEByZXR1cm4ge2pRdWVyeX1cclxuXHRcdCAqL1xyXG5cdFx0Z2V0X25leHRfZG9tIDogZnVuY3Rpb24gKG9iaiwgc3RyaWN0KSB7XHJcblx0XHRcdHZhciB0bXA7XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcclxuXHRcdFx0aWYob2JqWzBdID09PSB0aGlzLmVsZW1lbnRbMF0pIHtcclxuXHRcdFx0XHR0bXAgPSB0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKTtcclxuXHRcdFx0XHR3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApIHtcclxuXHRcdFx0XHRcdHRtcCA9IHRoaXMuX25leHRTaWJsaW5nKHRtcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0bXAgPyAkKHRtcCkgOiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZighb2JqIHx8ICFvYmoubGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHN0cmljdCkge1xyXG5cdFx0XHRcdHRtcCA9IG9ialswXTtcclxuXHRcdFx0XHRkbyB7XHJcblx0XHRcdFx0XHR0bXAgPSB0aGlzLl9uZXh0U2libGluZyh0bXApO1xyXG5cdFx0XHRcdH0gd2hpbGUgKHRtcCAmJiB0bXAub2Zmc2V0SGVpZ2h0ID09PSAwKTtcclxuXHRcdFx0XHRyZXR1cm4gdG1wID8gJCh0bXApIDogZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYob2JqLmhhc0NsYXNzKFwianN0cmVlLW9wZW5cIikpIHtcclxuXHRcdFx0XHR0bXAgPSB0aGlzLl9maXJzdENoaWxkKG9iai5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpWzBdKTtcclxuXHRcdFx0XHR3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApIHtcclxuXHRcdFx0XHRcdHRtcCA9IHRoaXMuX25leHRTaWJsaW5nKHRtcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHRtcCAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuICQodG1wKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dG1wID0gb2JqWzBdO1xyXG5cdFx0XHRkbyB7XHJcblx0XHRcdFx0dG1wID0gdGhpcy5fbmV4dFNpYmxpbmcodG1wKTtcclxuXHRcdFx0fSB3aGlsZSAodG1wICYmIHRtcC5vZmZzZXRIZWlnaHQgPT09IDApO1xyXG5cdFx0XHRpZih0bXAgIT09IG51bGwpIHtcclxuXHRcdFx0XHRyZXR1cm4gJCh0bXApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBvYmoucGFyZW50c1VudGlsKFwiLmpzdHJlZVwiLFwiLmpzdHJlZS1ub2RlXCIpLm5leHQoXCIuanN0cmVlLW5vZGU6dmlzaWJsZVwiKS5maXJzdCgpO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogZ2V0IHRoZSBwcmV2aW91cyB2aXNpYmxlIG5vZGUgdGhhdCBpcyBhYm92ZSB0aGUgYG9iamAgbm9kZS4gSWYgYHN0cmljdGAgaXMgc2V0IHRvIGB0cnVlYCBvbmx5IHNpYmxpbmcgbm9kZXMgYXJlIHJldHVybmVkLlxyXG5cdFx0ICogQG5hbWUgZ2V0X3ByZXZfZG9tKG9iaiBbLCBzdHJpY3RdKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxyXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gc3RyaWN0XHJcblx0XHQgKiBAcmV0dXJuIHtqUXVlcnl9XHJcblx0XHQgKi9cclxuXHRcdGdldF9wcmV2X2RvbSA6IGZ1bmN0aW9uIChvYmosIHN0cmljdCkge1xyXG5cdFx0XHR2YXIgdG1wO1xyXG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XHJcblx0XHRcdGlmKG9ialswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XHJcblx0XHRcdFx0dG1wID0gdGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0ubGFzdENoaWxkO1xyXG5cdFx0XHRcdHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCkge1xyXG5cdFx0XHRcdFx0dG1wID0gdGhpcy5fcHJldmlvdXNTaWJsaW5nKHRtcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0bXAgPyAkKHRtcCkgOiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZighb2JqIHx8ICFvYmoubGVuZ3RoKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHN0cmljdCkge1xyXG5cdFx0XHRcdHRtcCA9IG9ialswXTtcclxuXHRcdFx0XHRkbyB7XHJcblx0XHRcdFx0XHR0bXAgPSB0aGlzLl9wcmV2aW91c1NpYmxpbmcodG1wKTtcclxuXHRcdFx0XHR9IHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCk7XHJcblx0XHRcdFx0cmV0dXJuIHRtcCA/ICQodG1wKSA6IGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRtcCA9IG9ialswXTtcclxuXHRcdFx0ZG8ge1xyXG5cdFx0XHRcdHRtcCA9IHRoaXMuX3ByZXZpb3VzU2libGluZyh0bXApO1xyXG5cdFx0XHR9IHdoaWxlICh0bXAgJiYgdG1wLm9mZnNldEhlaWdodCA9PT0gMCk7XHJcblx0XHRcdGlmKHRtcCAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdG9iaiA9ICQodG1wKTtcclxuXHRcdFx0XHR3aGlsZShvYmouaGFzQ2xhc3MoXCJqc3RyZWUtb3BlblwiKSkge1xyXG5cdFx0XHRcdFx0b2JqID0gb2JqLmNoaWxkcmVuKFwiLmpzdHJlZS1jaGlsZHJlblwiKS5maXJzdCgpLmNoaWxkcmVuKFwiLmpzdHJlZS1ub2RlOnZpc2libGU6bGFzdFwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIG9iajtcclxuXHRcdFx0fVxyXG5cdFx0XHR0bXAgPSBvYmpbMF0ucGFyZW50Tm9kZS5wYXJlbnROb2RlO1xyXG5cdFx0XHRyZXR1cm4gdG1wICYmIHRtcC5jbGFzc05hbWUgJiYgdG1wLmNsYXNzTmFtZS5pbmRleE9mKCdqc3RyZWUtbm9kZScpICE9PSAtMSA/ICQodG1wKSA6IGZhbHNlO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogZ2V0IHRoZSBwYXJlbnQgSUQgb2YgYSBub2RlXHJcblx0XHQgKiBAbmFtZSBnZXRfcGFyZW50KG9iailcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0X3BhcmVudCA6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBvYmoucGFyZW50O1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogZ2V0IGEgalF1ZXJ5IGNvbGxlY3Rpb24gb2YgYWxsIHRoZSBjaGlsZHJlbiBvZiBhIG5vZGUgKG5vZGUgbXVzdCBiZSByZW5kZXJlZClcclxuXHRcdCAqIEBuYW1lIGdldF9jaGlsZHJlbl9kb20ob2JqKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxyXG5cdFx0ICogQHJldHVybiB7alF1ZXJ5fVxyXG5cdFx0ICovXHJcblx0XHRnZXRfY2hpbGRyZW5fZG9tIDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XHJcblx0XHRcdGlmKG9ialswXSA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmNoaWxkcmVuKFwiLmpzdHJlZS1ub2RlXCIpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCFvYmogfHwgIW9iai5sZW5ndGgpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG9iai5jaGlsZHJlbihcIi5qc3RyZWUtY2hpbGRyZW5cIikuY2hpbGRyZW4oXCIuanN0cmVlLW5vZGVcIik7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBjaGVja3MgaWYgYSBub2RlIGhhcyBjaGlsZHJlblxyXG5cdFx0ICogQG5hbWUgaXNfcGFyZW50KG9iailcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XHJcblx0XHQgKi9cclxuXHRcdGlzX3BhcmVudCA6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRyZXR1cm4gb2JqICYmIChvYmouc3RhdGUubG9hZGVkID09PSBmYWxzZSB8fCBvYmouY2hpbGRyZW4ubGVuZ3RoID4gMCk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBjaGVja3MgaWYgYSBub2RlIGlzIGxvYWRlZCAoaXRzIGNoaWxkcmVuIGFyZSBhdmFpbGFibGUpXHJcblx0XHQgKiBAbmFtZSBpc19sb2FkZWQob2JqKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHRcdCAqL1xyXG5cdFx0aXNfbG9hZGVkIDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XHJcblx0XHRcdHJldHVybiBvYmogJiYgb2JqLnN0YXRlLmxvYWRlZDtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGNoZWNrIGlmIGEgbm9kZSBpcyBjdXJyZW50bHkgbG9hZGluZyAoZmV0Y2hpbmcgY2hpbGRyZW4pXHJcblx0XHQgKiBAbmFtZSBpc19sb2FkaW5nKG9iailcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XHJcblx0XHQgKi9cclxuXHRcdGlzX2xvYWRpbmcgOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0cmV0dXJuIG9iaiAmJiBvYmouc3RhdGUgJiYgb2JqLnN0YXRlLmxvYWRpbmc7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBjaGVjayBpZiBhIG5vZGUgaXMgb3BlbmVkXHJcblx0XHQgKiBAbmFtZSBpc19vcGVuKG9iailcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XHJcblx0XHQgKi9cclxuXHRcdGlzX29wZW4gOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0cmV0dXJuIG9iaiAmJiBvYmouc3RhdGUub3BlbmVkO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogY2hlY2sgaWYgYSBub2RlIGlzIGluIGEgY2xvc2VkIHN0YXRlXHJcblx0XHQgKiBAbmFtZSBpc19jbG9zZWQob2JqKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHRcdCAqL1xyXG5cdFx0aXNfY2xvc2VkIDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XHJcblx0XHRcdHJldHVybiBvYmogJiYgdGhpcy5pc19wYXJlbnQob2JqKSAmJiAhb2JqLnN0YXRlLm9wZW5lZDtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGNoZWNrIGlmIGEgbm9kZSBoYXMgbm8gY2hpbGRyZW5cclxuXHRcdCAqIEBuYW1lIGlzX2xlYWYob2JqKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHRcdCAqL1xyXG5cdFx0aXNfbGVhZiA6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdFx0cmV0dXJuICF0aGlzLmlzX3BhcmVudChvYmopO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogbG9hZHMgYSBub2RlIChmZXRjaGVzIGl0cyBjaGlsZHJlbiB1c2luZyB0aGUgYGNvcmUuZGF0YWAgc2V0dGluZykuIE11bHRpcGxlIG5vZGVzIGNhbiBiZSBwYXNzZWQgdG8gYnkgdXNpbmcgYW4gYXJyYXkuXHJcblx0XHQgKiBAbmFtZSBsb2FkX25vZGUob2JqIFssIGNhbGxiYWNrXSlcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmpcclxuXHRcdCAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9uY2UgbG9hZGluZyBpcyBjb21wbGV0ZSwgdGhlIGZ1bmN0aW9uIGlzIGV4ZWN1dGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIGFuZCByZWNlaXZlcyB0d28gYXJndW1lbnRzIC0gdGhlIG5vZGUgYW5kIGEgYm9vbGVhbiBzdGF0dXNcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XHJcblx0XHQgKiBAdHJpZ2dlciBsb2FkX25vZGUuanN0cmVlXHJcblx0XHQgKi9cclxuXHRcdGxvYWRfbm9kZSA6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XHJcblx0XHRcdHZhciBrLCBsLCBpLCBqLCBjO1xyXG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xyXG5cdFx0XHRcdHRoaXMuX2xvYWRfbm9kZXMob2JqLnNsaWNlKCksIGNhbGxiYWNrKTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XHJcblx0XHRcdGlmKCFvYmopIHtcclxuXHRcdFx0XHRpZihjYWxsYmFjaykgeyBjYWxsYmFjay5jYWxsKHRoaXMsIG9iaiwgZmFsc2UpOyB9XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGlmKG9iai5zdGF0ZS5sb2FkaW5nKSB7IH0gLy8gdGhlIG5vZGUgaXMgYWxyZWFkeSBsb2FkaW5nIC0ganVzdCB3YWl0IGZvciBpdCB0byBsb2FkIGFuZCBpbnZva2UgY2FsbGJhY2s/IGJ1dCBpZiBjYWxsZWQgaW1wbGljaXRseSBpdCBzaG91bGQgYmUgbG9hZGVkIGFnYWluP1xyXG5cdFx0XHRpZihvYmouc3RhdGUubG9hZGVkKSB7XHJcblx0XHRcdFx0b2JqLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdGZvcihrID0gMCwgbCA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xyXG5cdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLCBvYmouY2hpbGRyZW5fZFtrXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2tdXS5zdGF0ZS5zZWxlY3RlZCkge1xyXG5cdFx0XHRcdFx0XHRjID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0odGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCBvYmouY2hpbGRyZW5fZFtrXSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtrXV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG9iai5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0XHRcdG9iai5jaGlsZHJlbl9kID0gW107XHJcblx0XHRcdFx0aWYoYykge1xyXG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdsb2FkX25vZGUnLCAnbm9kZScgOiBvYmosICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdG9iai5zdGF0ZS5sb2FkaW5nID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmFkZENsYXNzKFwianN0cmVlLWxvYWRpbmdcIikuYXR0cignYXJpYS1idXN5Jyx0cnVlKTtcclxuXHRcdFx0dGhpcy5fbG9hZF9ub2RlKG9iaiwgJC5wcm94eShmdW5jdGlvbiAoc3RhdHVzKSB7XHJcblx0XHRcdFx0b2JqID0gdGhpcy5fbW9kZWwuZGF0YVtvYmouaWRdO1xyXG5cdFx0XHRcdG9iai5zdGF0ZS5sb2FkaW5nID0gZmFsc2U7XHJcblx0XHRcdFx0b2JqLnN0YXRlLmxvYWRlZCA9IHN0YXR1cztcclxuXHRcdFx0XHR2YXIgZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xyXG5cdFx0XHRcdGlmKG9iai5zdGF0ZS5sb2FkZWQgJiYgIW9iai5jaGlsZHJlbi5sZW5ndGggJiYgZG9tICYmIGRvbS5sZW5ndGggJiYgIWRvbS5oYXNDbGFzcygnanN0cmVlLWxlYWYnKSkge1xyXG5cdFx0XHRcdFx0ZG9tLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2xvc2VkIGpzdHJlZS1vcGVuJykuYWRkQ2xhc3MoJ2pzdHJlZS1sZWFmJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGRvbS5yZW1vdmVDbGFzcyhcImpzdHJlZS1sb2FkaW5nXCIpLmF0dHIoJ2FyaWEtYnVzeScsZmFsc2UpO1xyXG5cdFx0XHRcdC8qKlxyXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCBhZnRlciBhIG5vZGUgaXMgbG9hZGVkXHJcblx0XHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdFx0ICogQG5hbWUgbG9hZF9ub2RlLmpzdHJlZVxyXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBub2RlIHRoYXQgd2FzIGxvYWRpbmdcclxuXHRcdFx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHN0YXR1cyB3YXMgdGhlIG5vZGUgbG9hZGVkIHN1Y2Nlc3NmdWxseVxyXG5cdFx0XHRcdCAqL1xyXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignbG9hZF9ub2RlJywgeyBcIm5vZGVcIiA6IG9iaiwgXCJzdGF0dXNcIiA6IHN0YXR1cyB9KTtcclxuXHRcdFx0XHRpZihjYWxsYmFjaykge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIHN0YXR1cyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LCB0aGlzKSk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogbG9hZCBhbiBhcnJheSBvZiBub2RlcyAod2lsbCBhbHNvIGxvYWQgdW5hdmFpbGFibGUgbm9kZXMgYXMgc29vbiBhcyB0aGUgYXBwZWFyIGluIHRoZSBzdHJ1Y3R1cmUpLiBVc2VkIGludGVybmFsbHkuXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQG5hbWUgX2xvYWRfbm9kZXMobm9kZXMgWywgY2FsbGJhY2tdKVxyXG5cdFx0ICogQHBhcmFtICB7YXJyYXl9IG5vZGVzXHJcblx0XHQgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlIGxvYWRpbmcgaXMgY29tcGxldGUsIHRoZSBmdW5jdGlvbiBpcyBleGVjdXRlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSBhbmQgcmVjZWl2ZXMgb25lIGFyZ3VtZW50IC0gdGhlIGFycmF5IHBhc3NlZCB0byBfbG9hZF9ub2Rlc1xyXG5cdFx0ICovXHJcblx0XHRfbG9hZF9ub2RlcyA6IGZ1bmN0aW9uIChub2RlcywgY2FsbGJhY2ssIGlzX2NhbGxiYWNrKSB7XHJcblx0XHRcdHZhciByID0gdHJ1ZSxcclxuXHRcdFx0XHRjID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9sb2FkX25vZGVzKG5vZGVzLCBjYWxsYmFjaywgdHJ1ZSk7IH0sXHJcblx0XHRcdFx0bSA9IHRoaXMuX21vZGVsLmRhdGEsIGksIGo7XHJcblx0XHRcdGZvcihpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdGlmKG1bbm9kZXNbaV1dICYmICghbVtub2Rlc1tpXV0uc3RhdGUubG9hZGVkIHx8ICFpc19jYWxsYmFjaykpIHtcclxuXHRcdFx0XHRcdGlmKCF0aGlzLmlzX2xvYWRpbmcobm9kZXNbaV0pKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMubG9hZF9ub2RlKG5vZGVzW2ldLCBjKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHIgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYocikge1xyXG5cdFx0XHRcdGlmKGNhbGxiYWNrICYmICFjYWxsYmFjay5kb25lKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIG5vZGVzKTtcclxuXHRcdFx0XHRcdGNhbGxiYWNrLmRvbmUgPSB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogbG9hZHMgYWxsIHVubG9hZGVkIG5vZGVzXHJcblx0XHQgKiBAbmFtZSBsb2FkX2FsbChbb2JqLCBjYWxsYmFja10pXHJcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gbG9hZCByZWN1cnNpdmVseSwgb21pdCB0byBsb2FkIGFsbCBub2RlcyBpbiB0aGUgdHJlZVxyXG5cdFx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBvbmNlIGxvYWRpbmcgYWxsIHRoZSBub2RlcyBpcyBjb21wbGV0ZSxcclxuXHRcdCAqIEB0cmlnZ2VyIGxvYWRfYWxsLmpzdHJlZVxyXG5cdFx0ICovXHJcblx0XHRsb2FkX2FsbCA6IGZ1bmN0aW9uIChvYmosIGNhbGxiYWNrKSB7XHJcblx0XHRcdGlmKCFvYmopIHsgb2JqID0gJyMnOyB9XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0aWYoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0dmFyIHRvX2xvYWQgPSBbXSxcclxuXHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSxcclxuXHRcdFx0XHRjID0gbVtvYmouaWRdLmNoaWxkcmVuX2QsXHJcblx0XHRcdFx0aSwgajtcclxuXHRcdFx0aWYob2JqLnN0YXRlICYmICFvYmouc3RhdGUubG9hZGVkKSB7XHJcblx0XHRcdFx0dG9fbG9hZC5wdXNoKG9iai5pZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gYy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRpZihtW2NbaV1dICYmIG1bY1tpXV0uc3RhdGUgJiYgIW1bY1tpXV0uc3RhdGUubG9hZGVkKSB7XHJcblx0XHRcdFx0XHR0b19sb2FkLnB1c2goY1tpXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHRvX2xvYWQubGVuZ3RoKSB7XHJcblx0XHRcdFx0dGhpcy5fbG9hZF9ub2Rlcyh0b19sb2FkLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHR0aGlzLmxvYWRfYWxsKG9iaiwgY2FsbGJhY2spO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdC8qKlxyXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCBhZnRlciBhIGxvYWRfYWxsIGNhbGwgY29tcGxldGVzXHJcblx0XHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdFx0ICogQG5hbWUgbG9hZF9hbGwuanN0cmVlXHJcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIHJlY3Vyc2l2ZWx5IGxvYWRlZCBub2RlXHJcblx0XHRcdFx0ICovXHJcblx0XHRcdFx0aWYoY2FsbGJhY2spIHsgY2FsbGJhY2suY2FsbCh0aGlzLCBvYmopOyB9XHJcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdsb2FkX2FsbCcsIHsgXCJub2RlXCIgOiBvYmogfSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGhhbmRsZXMgdGhlIGFjdHVhbCBsb2FkaW5nIG9mIGEgbm9kZS4gVXNlZCBvbmx5IGludGVybmFsbHkuXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQG5hbWUgX2xvYWRfbm9kZShvYmogWywgY2FsbGJhY2tdKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxyXG5cdFx0ICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb25jZSBsb2FkaW5nIGlzIGNvbXBsZXRlLCB0aGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgaW4gdGhlIGluc3RhbmNlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIG9uZSBhcmd1bWVudCAtIGEgYm9vbGVhbiBzdGF0dXNcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XHJcblx0XHQgKi9cclxuXHRcdF9sb2FkX25vZGUgOiBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xyXG5cdFx0XHR2YXIgcyA9IHRoaXMuc2V0dGluZ3MuY29yZS5kYXRhLCB0O1xyXG5cdFx0XHQvLyB1c2Ugb3JpZ2luYWwgSFRNTFxyXG5cdFx0XHRpZighcykge1xyXG5cdFx0XHRcdGlmKG9iai5pZCA9PT0gJyMnKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosIHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbC5jbG9uZSh0cnVlKSwgZnVuY3Rpb24gKHN0YXR1cykge1xyXG5cdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCBmYWxzZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIG9iai5pZCA9PT0gJyMnID8gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosIHRoaXMuX2RhdGEuY29yZS5vcmlnaW5hbF9jb250YWluZXJfaHRtbC5jbG9uZSh0cnVlKSkgOiBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHMpKSB7XHJcblx0XHRcdFx0cmV0dXJuIHMuY2FsbCh0aGlzLCBvYmosICQucHJveHkoZnVuY3Rpb24gKGQpIHtcclxuXHRcdFx0XHRcdGlmKGQgPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhpc1t0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAnX2FwcGVuZF9odG1sX2RhdGEnIDogJ19hcHBlbmRfanNvbl9kYXRhJ10ob2JqLCB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyAkKGQpIDogZCwgZnVuY3Rpb24gKHN0YXR1cykge1xyXG5cdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdC8vIHJldHVybiBkID09PSBmYWxzZSA/IGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpIDogY2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzW3R5cGVvZiBkID09PSAnc3RyaW5nJyA/ICdfYXBwZW5kX2h0bWxfZGF0YScgOiAnX2FwcGVuZF9qc29uX2RhdGEnXShvYmosIHR5cGVvZiBkID09PSAnc3RyaW5nJyA/ICQoZCkgOiBkKSk7XHJcblx0XHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHR5cGVvZiBzID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdGlmKHMudXJsKSB7XHJcblx0XHRcdFx0XHRzID0gJC5leHRlbmQodHJ1ZSwge30sIHMpO1xyXG5cdFx0XHRcdFx0aWYoJC5pc0Z1bmN0aW9uKHMudXJsKSkge1xyXG5cdFx0XHRcdFx0XHRzLnVybCA9IHMudXJsLmNhbGwodGhpcywgb2JqKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKCQuaXNGdW5jdGlvbihzLmRhdGEpKSB7XHJcblx0XHRcdFx0XHRcdHMuZGF0YSA9IHMuZGF0YS5jYWxsKHRoaXMsIG9iaik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gJC5hamF4KHMpXHJcblx0XHRcdFx0XHRcdC5kb25lKCQucHJveHkoZnVuY3Rpb24gKGQsdCx4KSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgdHlwZSA9IHguZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYodHlwZS5pbmRleE9mKCdqc29uJykgIT09IC0xIHx8IHR5cGVvZiBkID09PSBcIm9iamVjdFwiKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzLl9hcHBlbmRfanNvbl9kYXRhKG9iaiwgZCwgZnVuY3Rpb24gKHN0YXR1cykgeyBjYWxsYmFjay5jYWxsKHRoaXMsIHN0YXR1cyk7IH0pO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHQvL3JldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX2FwcGVuZF9qc29uX2RhdGEob2JqLCBkKSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZih0eXBlLmluZGV4T2YoJ2h0bWwnKSAhPT0gLTEgfHwgdHlwZW9mIGQgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCAkKGQpLCBmdW5jdGlvbiAoc3RhdHVzKSB7IGNhbGxiYWNrLmNhbGwodGhpcywgc3RhdHVzKTsgfSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCAkKGQpKSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdhamF4JywgJ3BsdWdpbicgOiAnY29yZScsICdpZCcgOiAnY29yZV8wNCcsICdyZWFzb24nIDogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdpZCcgOiBvYmouaWQsICd4aHInIDogeCB9KSB9O1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwodGhpcywgZmFsc2UpO1xyXG5cdFx0XHRcdFx0XHRcdH0sIHRoaXMpKVxyXG5cdFx0XHRcdFx0XHQuZmFpbCgkLnByb3h5KGZ1bmN0aW9uIChmKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2FqYXgnLCAncGx1Z2luJyA6ICdjb3JlJywgJ2lkJyA6ICdjb3JlXzA0JywgJ3JlYXNvbicgOiAnQ291bGQgbm90IGxvYWQgbm9kZScsICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2lkJyA6IG9iai5pZCwgJ3hocicgOiBmIH0pIH07XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XHJcblx0XHRcdFx0XHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0ID0gKCQuaXNBcnJheShzKSB8fCAkLmlzUGxhaW5PYmplY3QocykpID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShzKSkgOiBzO1xyXG5cdFx0XHRcdGlmKG9iai5pZCA9PT0gJyMnKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fYXBwZW5kX2pzb25fZGF0YShvYmosIHQsIGZ1bmN0aW9uIChzdGF0dXMpIHtcclxuXHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnbm9kYXRhJywgJ3BsdWdpbicgOiAnY29yZScsICdpZCcgOiAnY29yZV8wNScsICdyZWFzb24nIDogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdpZCcgOiBvYmouaWQgfSkgfTtcclxuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcclxuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly9yZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCAob2JqLmlkID09PSBcIiNcIiA/IHRoaXMuX2FwcGVuZF9qc29uX2RhdGEob2JqLCB0KSA6IGZhbHNlKSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHR5cGVvZiBzID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdGlmKG9iai5pZCA9PT0gJyMnKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fYXBwZW5kX2h0bWxfZGF0YShvYmosICQocyksIGZ1bmN0aW9uIChzdGF0dXMpIHtcclxuXHRcdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBzdGF0dXMpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnbm9kYXRhJywgJ3BsdWdpbicgOiAnY29yZScsICdpZCcgOiAnY29yZV8wNicsICdyZWFzb24nIDogJ0NvdWxkIG5vdCBsb2FkIG5vZGUnLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdpZCcgOiBvYmouaWQgfSkgfTtcclxuXHRcdFx0XHRcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcclxuXHRcdFx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly9yZXR1cm4gY2FsbGJhY2suY2FsbCh0aGlzLCAob2JqLmlkID09PSBcIiNcIiA/IHRoaXMuX2FwcGVuZF9odG1sX2RhdGEob2JqLCAkKHMpKSA6IGZhbHNlKSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKHRoaXMsIGZhbHNlKTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGFkZHMgYSBub2RlIHRvIHRoZSBsaXN0IG9mIG5vZGVzIHRvIHJlZHJhdy4gVXNlZCBvbmx5IGludGVybmFsbHkuXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQG5hbWUgX25vZGVfY2hhbmdlZChvYmogWywgY2FsbGJhY2tdKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxyXG5cdFx0ICovXHJcblx0XHRfbm9kZV9jaGFuZ2VkIDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XHJcblx0XHRcdGlmKG9iaikge1xyXG5cdFx0XHRcdHRoaXMuX21vZGVsLmNoYW5nZWQucHVzaChvYmouaWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBhcHBlbmRzIEhUTUwgY29udGVudCB0byB0aGUgdHJlZS4gVXNlZCBpbnRlcm5hbGx5LlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBuYW1lIF9hcHBlbmRfaHRtbF9kYXRhKG9iaiwgZGF0YSlcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUgdG8gYXBwZW5kIHRvXHJcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGRhdGEgdGhlIEhUTUwgc3RyaW5nIHRvIHBhcnNlIGFuZCBhcHBlbmRcclxuXHRcdCAqIEB0cmlnZ2VyIG1vZGVsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0X2FwcGVuZF9odG1sX2RhdGEgOiBmdW5jdGlvbiAoZG9tLCBkYXRhLCBjYikge1xyXG5cdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKGRvbSk7XHJcblx0XHRcdGRvbS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0XHRkb20uY2hpbGRyZW5fZCA9IFtdO1xyXG5cdFx0XHR2YXIgZGF0ID0gZGF0YS5pcygndWwnKSA/IGRhdGEuY2hpbGRyZW4oKSA6IGRhdGEsXHJcblx0XHRcdFx0cGFyID0gZG9tLmlkLFxyXG5cdFx0XHRcdGNoZCA9IFtdLFxyXG5cdFx0XHRcdGRwYyA9IFtdLFxyXG5cdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxyXG5cdFx0XHRcdHAgPSBtW3Bhcl0sXHJcblx0XHRcdFx0cyA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGgsXHJcblx0XHRcdFx0dG1wLCBpLCBqO1xyXG5cdFx0XHRkYXQuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XHJcblx0XHRcdFx0dG1wID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9odG1sKCQodiksIHBhciwgcC5wYXJlbnRzLmNvbmNhdCgpKTtcclxuXHRcdFx0XHRpZih0bXApIHtcclxuXHRcdFx0XHRcdGNoZC5wdXNoKHRtcCk7XHJcblx0XHRcdFx0XHRkcGMucHVzaCh0bXApO1xyXG5cdFx0XHRcdFx0aWYobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdGRwYyA9IGRwYy5jb25jYXQobVt0bXBdLmNoaWxkcmVuX2QpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0XHRwLmNoaWxkcmVuID0gY2hkO1xyXG5cdFx0XHRwLmNoaWxkcmVuX2QgPSBkcGM7XHJcblx0XHRcdGZvcihpID0gMCwgaiA9IHAucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRtW3AucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9IG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLmNvbmNhdChkcGMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBuZXcgZGF0YSBpcyBpbnNlcnRlZCB0byB0aGUgdHJlZSBtb2RlbFxyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgbW9kZWwuanN0cmVlXHJcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IG5vZGVzIGFuIGFycmF5IG9mIG5vZGUgSURzXHJcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCBJRCBvZiB0aGUgbm9kZXNcclxuXHRcdFx0ICovXHJcblx0XHRcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFwibm9kZXNcIiA6IGRwYywgJ3BhcmVudCcgOiBwYXIgfSk7XHJcblx0XHRcdGlmKHBhciAhPT0gJyMnKSB7XHJcblx0XHRcdFx0dGhpcy5fbm9kZV9jaGFuZ2VkKHBhcik7XHJcblx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbignLmpzdHJlZS1pbml0aWFsLW5vZGUnKS5yZW1vdmUoKTtcclxuXHRcdFx0XHR0aGlzLnJlZHJhdyh0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZih0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoICE9PSBzKSB7XHJcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdtb2RlbCcsICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2IuY2FsbCh0aGlzLCB0cnVlKTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGFwcGVuZHMgSlNPTiBjb250ZW50IHRvIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQG5hbWUgX2FwcGVuZF9qc29uX2RhdGEob2JqLCBkYXRhKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBhcHBlbmQgdG9cclxuXHRcdCAqIEBwYXJhbSAge1N0cmluZ30gZGF0YSB0aGUgSlNPTiBvYmplY3QgdG8gcGFyc2UgYW5kIGFwcGVuZFxyXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gZm9yY2VfcHJvY2Vzc2luZyBpbnRlcm5hbCBwYXJhbSAtIGRvIG5vdCBzZXRcclxuXHRcdCAqIEB0cmlnZ2VyIG1vZGVsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0X2FwcGVuZF9qc29uX2RhdGEgOiBmdW5jdGlvbiAoZG9tLCBkYXRhLCBjYiwgZm9yY2VfcHJvY2Vzc2luZykge1xyXG5cdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKGRvbSk7XHJcblx0XHRcdGRvbS5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0XHRkb20uY2hpbGRyZW5fZCA9IFtdO1xyXG5cdFx0XHQvLyAqJSRAISEhXHJcblx0XHRcdGlmKGRhdGEuZCkge1xyXG5cdFx0XHRcdGRhdGEgPSBkYXRhLmQ7XHJcblx0XHRcdFx0aWYodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcclxuXHRcdFx0XHRcdGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZighJC5pc0FycmF5KGRhdGEpKSB7IGRhdGEgPSBbZGF0YV07IH1cclxuXHRcdFx0dmFyIHcgPSBudWxsLFxyXG5cdFx0XHRcdGFyZ3MgPSB7XHJcblx0XHRcdFx0XHQnZGYnXHQ6IHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGUsXHJcblx0XHRcdFx0XHQnZGF0J1x0OiBkYXRhLFxyXG5cdFx0XHRcdFx0J3BhcidcdDogZG9tLmlkLFxyXG5cdFx0XHRcdFx0J20nXHRcdDogdGhpcy5fbW9kZWwuZGF0YSxcclxuXHRcdFx0XHRcdCd0X2lkJ1x0OiB0aGlzLl9pZCxcclxuXHRcdFx0XHRcdCd0X2NudCdcdDogdGhpcy5fY250LFxyXG5cdFx0XHRcdFx0J3NlbCdcdDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkXHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRmdW5jID0gZnVuY3Rpb24gKGRhdGEsIHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0aWYoZGF0YS5kYXRhKSB7IGRhdGEgPSBkYXRhLmRhdGE7IH1cclxuXHRcdFx0XHRcdHZhciBkYXQgPSBkYXRhLmRhdCxcclxuXHRcdFx0XHRcdFx0cGFyID0gZGF0YS5wYXIsXHJcblx0XHRcdFx0XHRcdGNoZCA9IFtdLFxyXG5cdFx0XHRcdFx0XHRkcGMgPSBbXSxcclxuXHRcdFx0XHRcdFx0YWRkID0gW10sXHJcblx0XHRcdFx0XHRcdGRmID0gZGF0YS5kZixcclxuXHRcdFx0XHRcdFx0dF9pZCA9IGRhdGEudF9pZCxcclxuXHRcdFx0XHRcdFx0dF9jbnQgPSBkYXRhLnRfY250LFxyXG5cdFx0XHRcdFx0XHRtID0gZGF0YS5tLFxyXG5cdFx0XHRcdFx0XHRwID0gbVtwYXJdLFxyXG5cdFx0XHRcdFx0XHRzZWwgPSBkYXRhLnNlbCxcclxuXHRcdFx0XHRcdFx0dG1wLCBpLCBqLCByc2x0LFxyXG5cdFx0XHRcdFx0XHRwYXJzZV9mbGF0ID0gZnVuY3Rpb24gKGQsIHAsIHBzKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIXBzKSB7IHBzID0gW107IH1cclxuXHRcdFx0XHRcdFx0XHRlbHNlIHsgcHMgPSBwcy5jb25jYXQoKTsgfVxyXG5cdFx0XHRcdFx0XHRcdGlmKHApIHsgcHMudW5zaGlmdChwKTsgfVxyXG5cdFx0XHRcdFx0XHRcdHZhciB0aWQgPSBkLmlkLnRvU3RyaW5nKCksXHJcblx0XHRcdFx0XHRcdFx0XHRpLCBqLCBjLCBlLFxyXG5cdFx0XHRcdFx0XHRcdFx0dG1wID0ge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZFx0XHRcdDogdGlkLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0ZXh0XHRcdDogZC50ZXh0IHx8ICcnLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpY29uXHRcdDogZC5pY29uICE9PSB1bmRlZmluZWQgPyBkLmljb24gOiB0cnVlLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnRcdFx0OiBwLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXJlbnRzXHRcdDogcHMsXHJcblx0XHRcdFx0XHRcdFx0XHRcdGNoaWxkcmVuXHQ6IGQuY2hpbGRyZW4gfHwgW10sXHJcblx0XHRcdFx0XHRcdFx0XHRcdGNoaWxkcmVuX2RcdDogZC5jaGlsZHJlbl9kIHx8IFtdLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRkYXRhXHRcdDogZC5kYXRhLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGF0ZVx0XHQ6IHsgfSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0bGlfYXR0clx0XHQ6IHsgaWQgOiBmYWxzZSB9LFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRhX2F0dHJcdFx0OiB7IGhyZWYgOiAnIycgfSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxcdDogZmFsc2VcclxuXHRcdFx0XHRcdFx0XHRcdH07XHJcblx0XHRcdFx0XHRcdFx0Zm9yKGkgaW4gZGYpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKGRmLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGRmW2ldO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQuZGF0YSAmJiBkLmRhdGEuanN0cmVlICYmIGQuZGF0YS5qc3RyZWUuaWNvbikge1xyXG5cdFx0XHRcdFx0XHRcdFx0dG1wLmljb24gPSBkLmRhdGEuanN0cmVlLmljb247XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5kYXRhKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0bXAuZGF0YSA9IGQuZGF0YTtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKGQuZGF0YS5qc3RyZWUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKGQuZGF0YS5qc3RyZWUuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuZGF0YS5qc3RyZWVbaV07XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgdHlwZW9mIGQuc3RhdGUgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZihkLnN0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZC5zdGF0ZVtpXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZihkICYmIHR5cGVvZiBkLmxpX2F0dHIgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRmb3IgKGkgaW4gZC5saV9hdHRyKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGQubGlfYXR0ci5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmKCF0bXAubGlfYXR0ci5pZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dG1wLmxpX2F0dHIuaWQgPSB0aWQ7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgdHlwZW9mIGQuYV9hdHRyID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpIGluIGQuYV9hdHRyKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGQuYV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLmFfYXR0cltpXSA9IGQuYV9hdHRyW2ldO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuID09PSB0cnVlKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW4gPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gW107XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdG1bdG1wLmlkXSA9IHRtcDtcclxuXHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjID0gcGFyc2VfZmxhdChtW3RtcC5jaGlsZHJlbltpXV0sIHRtcC5pZCwgcHMpO1xyXG5cdFx0XHRcdFx0XHRcdFx0ZSA9IG1bY107XHJcblx0XHRcdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW5fZC5wdXNoKGMpO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW5fZCA9IHRtcC5jaGlsZHJlbl9kLmNvbmNhdChlLmNoaWxkcmVuX2QpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRkZWxldGUgZC5kYXRhO1xyXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBkLmNoaWxkcmVuO1xyXG5cdFx0XHRcdFx0XHRcdG1bdG1wLmlkXS5vcmlnaW5hbCA9IGQ7XHJcblx0XHRcdFx0XHRcdFx0aWYodG1wLnN0YXRlLnNlbGVjdGVkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRhZGQucHVzaCh0bXAuaWQpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdG1wLmlkO1xyXG5cdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0XHRwYXJzZV9uZXN0ID0gZnVuY3Rpb24gKGQsIHAsIHBzKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIXBzKSB7IHBzID0gW107IH1cclxuXHRcdFx0XHRcdFx0XHRlbHNlIHsgcHMgPSBwcy5jb25jYXQoKTsgfVxyXG5cdFx0XHRcdFx0XHRcdGlmKHApIHsgcHMudW5zaGlmdChwKTsgfVxyXG5cdFx0XHRcdFx0XHRcdHZhciB0aWQgPSBmYWxzZSwgaSwgaiwgYywgZSwgdG1wO1xyXG5cdFx0XHRcdFx0XHRcdGRvIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRpZCA9ICdqJyArIHRfaWQgKyAnXycgKyAoKyt0X2NudCk7XHJcblx0XHRcdFx0XHRcdFx0fSB3aGlsZShtW3RpZF0pO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR0bXAgPSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZFx0XHRcdDogZmFsc2UsXHJcblx0XHRcdFx0XHRcdFx0XHR0ZXh0XHRcdDogdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gZCA6ICcnLFxyXG5cdFx0XHRcdFx0XHRcdFx0aWNvblx0XHQ6IHR5cGVvZiBkID09PSAnb2JqZWN0JyAmJiBkLmljb24gIT09IHVuZGVmaW5lZCA/IGQuaWNvbiA6IHRydWUsXHJcblx0XHRcdFx0XHRcdFx0XHRwYXJlbnRcdFx0OiBwLFxyXG5cdFx0XHRcdFx0XHRcdFx0cGFyZW50c1x0XHQ6IHBzLFxyXG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW5cdDogW10sXHJcblx0XHRcdFx0XHRcdFx0XHRjaGlsZHJlbl9kXHQ6IFtdLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YVx0XHQ6IG51bGwsXHJcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZVx0XHQ6IHsgfSxcclxuXHRcdFx0XHRcdFx0XHRcdGxpX2F0dHJcdFx0OiB7IGlkIDogZmFsc2UgfSxcclxuXHRcdFx0XHRcdFx0XHRcdGFfYXR0clx0XHQ6IHsgaHJlZiA6ICcjJyB9LFxyXG5cdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxcdDogZmFsc2VcclxuXHRcdFx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdFx0XHRcdGZvcihpIGluIGRmKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZihkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBkZltpXTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkLmlkKSB7IHRtcC5pZCA9IGQuaWQudG9TdHJpbmcoKTsgfVxyXG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC50ZXh0KSB7IHRtcC50ZXh0ID0gZC50ZXh0OyB9XHJcblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkLmRhdGEgJiYgZC5kYXRhLmpzdHJlZSAmJiBkLmRhdGEuanN0cmVlLmljb24pIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRtcC5pY29uID0gZC5kYXRhLmpzdHJlZS5pY29uO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZihkICYmIGQuZGF0YSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dG1wLmRhdGEgPSBkLmRhdGE7XHJcblx0XHRcdFx0XHRcdFx0XHRpZihkLmRhdGEuanN0cmVlKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGZvcihpIGluIGQuZGF0YS5qc3RyZWUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBkLmRhdGEuanN0cmVlW2ldO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZihkICYmIHR5cGVvZiBkLnN0YXRlID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpIGluIGQuc3RhdGUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZC5zdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuc3RhdGVbaV07XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5saV9hdHRyID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZihkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAubGlfYXR0cltpXSA9IGQubGlfYXR0cltpXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZih0bXAubGlfYXR0ci5pZCAmJiAhdG1wLmlkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0bXAuaWQgPSB0bXAubGlfYXR0ci5pZC50b1N0cmluZygpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZighdG1wLmlkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0bXAuaWQgPSB0aWQ7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmKCF0bXAubGlfYXR0ci5pZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dG1wLmxpX2F0dHIuaWQgPSB0bXAuaWQ7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgdHlwZW9mIGQuYV9hdHRyID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpIGluIGQuYV9hdHRyKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGQuYV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG1wLmFfYXR0cltpXSA9IGQuYV9hdHRyW2ldO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZC5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YyA9IHBhcnNlX25lc3QoZC5jaGlsZHJlbltpXSwgdG1wLmlkLCBwcyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGUgPSBtW2NdO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW4ucHVzaChjKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KGUuY2hpbGRyZW5fZCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KHRtcC5jaGlsZHJlbik7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5jaGlsZHJlbiAmJiBkLmNoaWxkcmVuID09PSB0cnVlKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0XHR0bXAuY2hpbGRyZW4gPSBbXTtcclxuXHRcdFx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gW107XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBkLmRhdGE7XHJcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGQuY2hpbGRyZW47XHJcblx0XHRcdFx0XHRcdFx0dG1wLm9yaWdpbmFsID0gZDtcclxuXHRcdFx0XHRcdFx0XHRtW3RtcC5pZF0gPSB0bXA7XHJcblx0XHRcdFx0XHRcdFx0aWYodG1wLnN0YXRlLnNlbGVjdGVkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRhZGQucHVzaCh0bXAuaWQpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdG1wLmlkO1xyXG5cdFx0XHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRcdGlmKGRhdC5sZW5ndGggJiYgZGF0WzBdLmlkICE9PSB1bmRlZmluZWQgJiYgZGF0WzBdLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdC8vIEZsYXQgSlNPTiBzdXBwb3J0IChmb3IgZWFzeSBpbXBvcnQgZnJvbSBEQik6XHJcblx0XHRcdFx0XHRcdC8vIDEpIGNvbnZlcnQgdG8gb2JqZWN0IChmb3JlYWNoKVxyXG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkYXQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoIWRhdFtpXS5jaGlsZHJlbikge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0W2ldLmNoaWxkcmVuID0gW107XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdG1bZGF0W2ldLmlkLnRvU3RyaW5nKCldID0gZGF0W2ldO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdC8vIDIpIHBvcHVsYXRlIGNoaWxkcmVuIChmb3JlYWNoKVxyXG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkYXQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0bVtkYXRbaV0ucGFyZW50LnRvU3RyaW5nKCldLmNoaWxkcmVuLnB1c2goZGF0W2ldLmlkLnRvU3RyaW5nKCkpO1xyXG5cdFx0XHRcdFx0XHRcdC8vIHBvcHVsYXRlIHBhcmVudC5jaGlsZHJlbl9kXHJcblx0XHRcdFx0XHRcdFx0cC5jaGlsZHJlbl9kLnB1c2goZGF0W2ldLmlkLnRvU3RyaW5nKCkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdC8vIDMpIG5vcm1hbGl6ZSAmJiBwb3B1bGF0ZSBwYXJlbnRzIGFuZCBjaGlsZHJlbl9kIHdpdGggcmVjdXJzaW9uXHJcblx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0dG1wID0gcGFyc2VfZmxhdChtW3AuY2hpbGRyZW5baV1dLCBwYXIsIHAucGFyZW50cy5jb25jYXQoKSk7XHJcblx0XHRcdFx0XHRcdFx0ZHBjLnB1c2godG1wKTtcclxuXHRcdFx0XHRcdFx0XHRpZihtW3RtcF0uY2hpbGRyZW5fZC5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGRwYyA9IGRwYy5jb25jYXQobVt0bXBdLmNoaWxkcmVuX2QpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0bVtwLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSBtW3AucGFyZW50c1tpXV0uY2hpbGRyZW5fZC5jb25jYXQoZHBjKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHQvLyA/KSB0aHJlZV9zdGF0ZSBzZWxlY3Rpb24gLSBwLnN0YXRlLnNlbGVjdGVkICYmIHQgLSAoaWYgdGhyZWVfc3RhdGUgZm9yZWFjaChkYXQgPT4gY2gpIC0+IGZvcmVhY2gocGFyZW50cykgaWYocGFyZW50LnNlbGVjdGVkKSBjaGlsZC5zZWxlY3RlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRcdHJzbHQgPSB7XHJcblx0XHRcdFx0XHRcdFx0J2NudCcgOiB0X2NudCxcclxuXHRcdFx0XHRcdFx0XHQnbW9kJyA6IG0sXHJcblx0XHRcdFx0XHRcdFx0J3NlbCcgOiBzZWwsXHJcblx0XHRcdFx0XHRcdFx0J3BhcicgOiBwYXIsXHJcblx0XHRcdFx0XHRcdFx0J2RwYycgOiBkcGMsXHJcblx0XHRcdFx0XHRcdFx0J2FkZCcgOiBhZGRcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkYXQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0dG1wID0gcGFyc2VfbmVzdChkYXRbaV0sIHBhciwgcC5wYXJlbnRzLmNvbmNhdCgpKTtcclxuXHRcdFx0XHRcdFx0XHRpZih0bXApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGNoZC5wdXNoKHRtcCk7XHJcblx0XHRcdFx0XHRcdFx0XHRkcGMucHVzaCh0bXApO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYobVt0bXBdLmNoaWxkcmVuX2QubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGRwYyA9IGRwYy5jb25jYXQobVt0bXBdLmNoaWxkcmVuX2QpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRwLmNoaWxkcmVuID0gY2hkO1xyXG5cdFx0XHRcdFx0XHRwLmNoaWxkcmVuX2QgPSBkcGM7XHJcblx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRtW3AucGFyZW50c1tpXV0uY2hpbGRyZW5fZCA9IG1bcC5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLmNvbmNhdChkcGMpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHJzbHQgPSB7XHJcblx0XHRcdFx0XHRcdFx0J2NudCcgOiB0X2NudCxcclxuXHRcdFx0XHRcdFx0XHQnbW9kJyA6IG0sXHJcblx0XHRcdFx0XHRcdFx0J3NlbCcgOiBzZWwsXHJcblx0XHRcdFx0XHRcdFx0J3BhcicgOiBwYXIsXHJcblx0XHRcdFx0XHRcdFx0J2RwYycgOiBkcGMsXHJcblx0XHRcdFx0XHRcdFx0J2FkZCcgOiBhZGRcclxuXHRcdFx0XHRcdFx0fTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdHBvc3RNZXNzYWdlKHJzbHQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiByc2x0O1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0cnNsdCA9IGZ1bmN0aW9uIChyc2x0LCB3b3JrZXIpIHtcclxuXHRcdFx0XHRcdHRoaXMuX2NudCA9IHJzbHQuY250O1xyXG5cdFx0XHRcdFx0dGhpcy5fbW9kZWwuZGF0YSA9IHJzbHQubW9kOyAvLyBicmVha3MgdGhlIHJlZmVyZW5jZSBpbiBsb2FkX25vZGUgLSBjYXJlZnVsXHJcblxyXG5cdFx0XHRcdFx0aWYod29ya2VyKSB7XHJcblx0XHRcdFx0XHRcdHZhciBpLCBqLCBhID0gcnNsdC5hZGQsIHIgPSByc2x0LnNlbCwgcyA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5zbGljZSgpLCBtID0gdGhpcy5fbW9kZWwuZGF0YTtcclxuXHRcdFx0XHRcdFx0Ly8gaWYgc2VsZWN0aW9uIHdhcyBjaGFuZ2VkIHdoaWxlIGNhbGN1bGF0aW5nIGluIHdvcmtlclxyXG5cdFx0XHRcdFx0XHRpZihyLmxlbmd0aCAhPT0gcy5sZW5ndGggfHwgJC52YWthdGEuYXJyYXlfdW5pcXVlKHIuY29uY2F0KHMpKS5sZW5ndGggIT09IHIubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gZGVzZWxlY3Qgbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHNlbGVjdGVkXHJcblx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gci5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKCQuaW5BcnJheShyW2ldLCBhKSA9PT0gLTEgJiYgJC5pbkFycmF5KHJbaV0sIHMpID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRtW3JbaV1dLnN0YXRlLnNlbGVjdGVkID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdC8vIHNlbGVjdCBub2RlcyB0aGF0IHdlcmUgc2VsZWN0ZWQgaW4gdGhlIG1lYW4gdGltZVxyXG5cdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZigkLmluQXJyYXkoc1tpXSwgcikgPT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG1bc1tpXV0uc3RhdGUuc2VsZWN0ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYocnNsdC5hZGQubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5jb25jYXQocnNsdC5hZGQpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFwibm9kZXNcIiA6IHJzbHQuZHBjLCAncGFyZW50JyA6IHJzbHQucGFyIH0pO1xyXG5cclxuXHRcdFx0XHRcdGlmKHJzbHQucGFyICE9PSAnIycpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5fbm9kZV9jaGFuZ2VkKHJzbHQucGFyKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHQvLyB0aGlzLmdldF9jb250YWluZXJfdWwoKS5jaGlsZHJlbignLmpzdHJlZS1pbml0aWFsLW5vZGUnKS5yZW1vdmUoKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5yZWRyYXcodHJ1ZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihyc2x0LmFkZC5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdtb2RlbCcsICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgfSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRjYi5jYWxsKHRoaXMsIHRydWUpO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY29yZS53b3JrZXIgJiYgd2luZG93LkJsb2IgJiYgd2luZG93LlVSTCAmJiB3aW5kb3cuV29ya2VyKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGlmKHRoaXMuX3dyayA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLl93cmsgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChcclxuXHRcdFx0XHRcdFx0XHRuZXcgd2luZG93LkJsb2IoXHJcblx0XHRcdFx0XHRcdFx0XHRbJ3NlbGYub25tZXNzYWdlID0gJyArIGZ1bmMudG9TdHJpbmcoKV0sXHJcblx0XHRcdFx0XHRcdFx0XHR7dHlwZTpcInRleHQvamF2YXNjcmlwdFwifVxyXG5cdFx0XHRcdFx0XHRcdClcclxuXHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKCF0aGlzLl9kYXRhLmNvcmUud29ya2luZyB8fCBmb3JjZV9wcm9jZXNzaW5nKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS53b3JraW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0dyA9IG5ldyB3aW5kb3cuV29ya2VyKHRoaXMuX3dyayk7XHJcblx0XHRcdFx0XHRcdHcub25tZXNzYWdlID0gJC5wcm94eShmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHRcdHJzbHQuY2FsbCh0aGlzLCBlLmRhdGEsIHRydWUpO1xyXG5cdFx0XHRcdFx0XHRcdHRyeSB7IHcudGVybWluYXRlKCk7IHcgPSBudWxsOyB9IGNhdGNoKGlnbm9yZSkgeyB9XHJcblx0XHRcdFx0XHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2FwcGVuZF9qc29uX2RhdGEuYXBwbHkodGhpcywgdGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5zaGlmdCgpKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUud29ya2luZyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSwgdGhpcyk7XHJcblx0XHRcdFx0XHRcdGlmKCFhcmdzLnBhcikge1xyXG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9hcHBlbmRfanNvbl9kYXRhLmFwcGx5KHRoaXMsIHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUuc2hpZnQoKSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLndvcmtpbmcgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0dy5wb3N0TWVzc2FnZShhcmdzKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS53b3JrZXJfcXVldWUucHVzaChbZG9tLCBkYXRhLCBjYiwgdHJ1ZV0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYXRjaChlKSB7XHJcblx0XHRcdFx0XHRyc2x0LmNhbGwodGhpcywgZnVuYyhhcmdzKSwgZmFsc2UpO1xyXG5cdFx0XHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLndvcmtlcl9xdWV1ZS5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5fYXBwZW5kX2pzb25fZGF0YS5hcHBseSh0aGlzLCB0aGlzLl9kYXRhLmNvcmUud29ya2VyX3F1ZXVlLnNoaWZ0KCkpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS53b3JraW5nID0gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHJzbHQuY2FsbCh0aGlzLCBmdW5jKGFyZ3MpLCBmYWxzZSk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIGpRdWVyeSBvYmplY3QgYW5kIGFwcGVuZHMgdGhlbSB0byB0aGUgaW4gbWVtb3J5IHRyZWUgbW9kZWwuIFVzZWQgaW50ZXJuYWxseS5cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAbmFtZSBfcGFyc2VfbW9kZWxfZnJvbV9odG1sKGQgWywgcCwgcHNdKVxyXG5cdFx0ICogQHBhcmFtICB7alF1ZXJ5fSBkIHRoZSBqUXVlcnkgb2JqZWN0IHRvIHBhcnNlXHJcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHAgdGhlIHBhcmVudCBJRFxyXG5cdFx0ICogQHBhcmFtICB7QXJyYXl9IHBzIGxpc3Qgb2YgYWxsIHBhcmVudHNcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXHJcblx0XHQgKi9cclxuXHRcdF9wYXJzZV9tb2RlbF9mcm9tX2h0bWwgOiBmdW5jdGlvbiAoZCwgcCwgcHMpIHtcclxuXHRcdFx0aWYoIXBzKSB7IHBzID0gW107IH1cclxuXHRcdFx0ZWxzZSB7IHBzID0gW10uY29uY2F0KHBzKTsgfVxyXG5cdFx0XHRpZihwKSB7IHBzLnVuc2hpZnQocCk7IH1cclxuXHRcdFx0dmFyIGMsIGUsIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxyXG5cdFx0XHRcdGRhdGEgPSB7XHJcblx0XHRcdFx0XHRpZFx0XHRcdDogZmFsc2UsXHJcblx0XHRcdFx0XHR0ZXh0XHRcdDogZmFsc2UsXHJcblx0XHRcdFx0XHRpY29uXHRcdDogdHJ1ZSxcclxuXHRcdFx0XHRcdHBhcmVudFx0XHQ6IHAsXHJcblx0XHRcdFx0XHRwYXJlbnRzXHRcdDogcHMsXHJcblx0XHRcdFx0XHRjaGlsZHJlblx0OiBbXSxcclxuXHRcdFx0XHRcdGNoaWxkcmVuX2RcdDogW10sXHJcblx0XHRcdFx0XHRkYXRhXHRcdDogbnVsbCxcclxuXHRcdFx0XHRcdHN0YXRlXHRcdDogeyB9LFxyXG5cdFx0XHRcdFx0bGlfYXR0clx0XHQ6IHsgaWQgOiBmYWxzZSB9LFxyXG5cdFx0XHRcdFx0YV9hdHRyXHRcdDogeyBocmVmIDogJyMnIH0sXHJcblx0XHRcdFx0XHRvcmlnaW5hbFx0OiBmYWxzZVxyXG5cdFx0XHRcdH0sIGksIHRtcCwgdGlkO1xyXG5cdFx0XHRmb3IoaSBpbiB0aGlzLl9tb2RlbC5kZWZhdWx0X3N0YXRlKSB7XHJcblx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG5cdFx0XHRcdFx0ZGF0YS5zdGF0ZVtpXSA9IHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGVbaV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRtcCA9ICQudmFrYXRhLmF0dHJpYnV0ZXMoZCwgdHJ1ZSk7XHJcblx0XHRcdCQuZWFjaCh0bXAsIGZ1bmN0aW9uIChpLCB2KSB7XHJcblx0XHRcdFx0diA9ICQudHJpbSh2KTtcclxuXHRcdFx0XHRpZighdi5sZW5ndGgpIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0XHRkYXRhLmxpX2F0dHJbaV0gPSB2O1xyXG5cdFx0XHRcdGlmKGkgPT09ICdpZCcpIHtcclxuXHRcdFx0XHRcdGRhdGEuaWQgPSB2LnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0dG1wID0gZC5jaGlsZHJlbignYScpLmZpcnN0KCk7XHJcblx0XHRcdGlmKHRtcC5sZW5ndGgpIHtcclxuXHRcdFx0XHR0bXAgPSAkLnZha2F0YS5hdHRyaWJ1dGVzKHRtcCwgdHJ1ZSk7XHJcblx0XHRcdFx0JC5lYWNoKHRtcCwgZnVuY3Rpb24gKGksIHYpIHtcclxuXHRcdFx0XHRcdHYgPSAkLnRyaW0odik7XHJcblx0XHRcdFx0XHRpZih2Lmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRkYXRhLmFfYXR0cltpXSA9IHY7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dG1wID0gZC5jaGlsZHJlbihcImFcIikuZmlyc3QoKS5sZW5ndGggPyBkLmNoaWxkcmVuKFwiYVwiKS5maXJzdCgpLmNsb25lKCkgOiBkLmNsb25lKCk7XHJcblx0XHRcdHRtcC5jaGlsZHJlbihcImlucywgaSwgdWxcIikucmVtb3ZlKCk7XHJcblx0XHRcdHRtcCA9IHRtcC5odG1sKCk7XHJcblx0XHRcdHRtcCA9ICQoJzxkaXYgLz4nKS5odG1sKHRtcCk7XHJcblx0XHRcdGRhdGEudGV4dCA9IHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0ID8gdG1wLnRleHQoKSA6IHRtcC5odG1sKCk7XHJcblx0XHRcdHRtcCA9IGQuZGF0YSgpO1xyXG5cdFx0XHRkYXRhLmRhdGEgPSB0bXAgPyAkLmV4dGVuZCh0cnVlLCB7fSwgdG1wKSA6IG51bGw7XHJcblx0XHRcdGRhdGEuc3RhdGUub3BlbmVkID0gZC5oYXNDbGFzcygnanN0cmVlLW9wZW4nKTtcclxuXHRcdFx0ZGF0YS5zdGF0ZS5zZWxlY3RlZCA9IGQuY2hpbGRyZW4oJ2EnKS5oYXNDbGFzcygnanN0cmVlLWNsaWNrZWQnKTtcclxuXHRcdFx0ZGF0YS5zdGF0ZS5kaXNhYmxlZCA9IGQuY2hpbGRyZW4oJ2EnKS5oYXNDbGFzcygnanN0cmVlLWRpc2FibGVkJyk7XHJcblx0XHRcdGlmKGRhdGEuZGF0YSAmJiBkYXRhLmRhdGEuanN0cmVlKSB7XHJcblx0XHRcdFx0Zm9yKGkgaW4gZGF0YS5kYXRhLmpzdHJlZSkge1xyXG5cdFx0XHRcdFx0aWYoZGF0YS5kYXRhLmpzdHJlZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG5cdFx0XHRcdFx0XHRkYXRhLnN0YXRlW2ldID0gZGF0YS5kYXRhLmpzdHJlZVtpXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dG1wID0gZC5jaGlsZHJlbihcImFcIikuY2hpbGRyZW4oXCIuanN0cmVlLXRoZW1laWNvblwiKTtcclxuXHRcdFx0aWYodG1wLmxlbmd0aCkge1xyXG5cdFx0XHRcdGRhdGEuaWNvbiA9IHRtcC5oYXNDbGFzcygnanN0cmVlLXRoZW1laWNvbi1oaWRkZW4nKSA/IGZhbHNlIDogdG1wLmF0dHIoJ3JlbCcpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGRhdGEuc3RhdGUuaWNvbikge1xyXG5cdFx0XHRcdGRhdGEuaWNvbiA9IGRhdGEuc3RhdGUuaWNvbjtcclxuXHRcdFx0fVxyXG5cdFx0XHR0bXAgPSBkLmNoaWxkcmVuKFwidWxcIikuY2hpbGRyZW4oXCJsaVwiKTtcclxuXHRcdFx0ZG8ge1xyXG5cdFx0XHRcdHRpZCA9ICdqJyArIHRoaXMuX2lkICsgJ18nICsgKCsrdGhpcy5fY250KTtcclxuXHRcdFx0fSB3aGlsZShtW3RpZF0pO1xyXG5cdFx0XHRkYXRhLmlkID0gZGF0YS5saV9hdHRyLmlkID8gZGF0YS5saV9hdHRyLmlkLnRvU3RyaW5nKCkgOiB0aWQ7XHJcblx0XHRcdGlmKHRtcC5sZW5ndGgpIHtcclxuXHRcdFx0XHR0bXAuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XHJcblx0XHRcdFx0XHRjID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9odG1sKCQodiksIGRhdGEuaWQsIHBzKTtcclxuXHRcdFx0XHRcdGUgPSB0aGlzLl9tb2RlbC5kYXRhW2NdO1xyXG5cdFx0XHRcdFx0ZGF0YS5jaGlsZHJlbi5wdXNoKGMpO1xyXG5cdFx0XHRcdFx0aWYoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRkYXRhLmNoaWxkcmVuX2QgPSBkYXRhLmNoaWxkcmVuX2QuY29uY2F0KGUuY2hpbGRyZW5fZCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0XHRcdGRhdGEuY2hpbGRyZW5fZCA9IGRhdGEuY2hpbGRyZW5fZC5jb25jYXQoZGF0YS5jaGlsZHJlbik7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0aWYoZC5oYXNDbGFzcygnanN0cmVlLWNsb3NlZCcpKSB7XHJcblx0XHRcdFx0XHRkYXRhLnN0YXRlLmxvYWRlZCA9IGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZihkYXRhLmxpX2F0dHJbJ2NsYXNzJ10pIHtcclxuXHRcdFx0XHRkYXRhLmxpX2F0dHJbJ2NsYXNzJ10gPSBkYXRhLmxpX2F0dHJbJ2NsYXNzJ10ucmVwbGFjZSgnanN0cmVlLWNsb3NlZCcsJycpLnJlcGxhY2UoJ2pzdHJlZS1vcGVuJywnJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoZGF0YS5hX2F0dHJbJ2NsYXNzJ10pIHtcclxuXHRcdFx0XHRkYXRhLmFfYXR0clsnY2xhc3MnXSA9IGRhdGEuYV9hdHRyWydjbGFzcyddLnJlcGxhY2UoJ2pzdHJlZS1jbGlja2VkJywnJykucmVwbGFjZSgnanN0cmVlLWRpc2FibGVkJywnJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0bVtkYXRhLmlkXSA9IGRhdGE7XHJcblx0XHRcdGlmKGRhdGEuc3RhdGUuc2VsZWN0ZWQpIHtcclxuXHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQucHVzaChkYXRhLmlkKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZGF0YS5pZDtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIEpTT04gb2JqZWN0ICh1c2VkIHdoZW4gZGVhbGluZyB3aXRoIGZsYXQgZGF0YSwgd2hpY2ggaGFzIG5vIG5lc3Rpbmcgb2YgY2hpbGRyZW4sIGJ1dCBoYXMgaWQgYW5kIHBhcmVudCBwcm9wZXJ0aWVzKSBhbmQgYXBwZW5kcyBpdCB0byB0aGUgaW4gbWVtb3J5IHRyZWUgbW9kZWwuIFVzZWQgaW50ZXJuYWxseS5cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAbmFtZSBfcGFyc2VfbW9kZWxfZnJvbV9mbGF0X2pzb24oZCBbLCBwLCBwc10pXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9IGQgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlXHJcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHAgdGhlIHBhcmVudCBJRFxyXG5cdFx0ICogQHBhcmFtICB7QXJyYXl9IHBzIGxpc3Qgb2YgYWxsIHBhcmVudHNcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXHJcblx0XHQgKi9cclxuXHRcdF9wYXJzZV9tb2RlbF9mcm9tX2ZsYXRfanNvbiA6IGZ1bmN0aW9uIChkLCBwLCBwcykge1xyXG5cdFx0XHRpZighcHMpIHsgcHMgPSBbXTsgfVxyXG5cdFx0XHRlbHNlIHsgcHMgPSBwcy5jb25jYXQoKTsgfVxyXG5cdFx0XHRpZihwKSB7IHBzLnVuc2hpZnQocCk7IH1cclxuXHRcdFx0dmFyIHRpZCA9IGQuaWQudG9TdHJpbmcoKSxcclxuXHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSxcclxuXHRcdFx0XHRkZiA9IHRoaXMuX21vZGVsLmRlZmF1bHRfc3RhdGUsXHJcblx0XHRcdFx0aSwgaiwgYywgZSxcclxuXHRcdFx0XHR0bXAgPSB7XHJcblx0XHRcdFx0XHRpZFx0XHRcdDogdGlkLFxyXG5cdFx0XHRcdFx0dGV4dFx0XHQ6IGQudGV4dCB8fCAnJyxcclxuXHRcdFx0XHRcdGljb25cdFx0OiBkLmljb24gIT09IHVuZGVmaW5lZCA/IGQuaWNvbiA6IHRydWUsXHJcblx0XHRcdFx0XHRwYXJlbnRcdFx0OiBwLFxyXG5cdFx0XHRcdFx0cGFyZW50c1x0XHQ6IHBzLFxyXG5cdFx0XHRcdFx0Y2hpbGRyZW5cdDogZC5jaGlsZHJlbiB8fCBbXSxcclxuXHRcdFx0XHRcdGNoaWxkcmVuX2RcdDogZC5jaGlsZHJlbl9kIHx8IFtdLFxyXG5cdFx0XHRcdFx0ZGF0YVx0XHQ6IGQuZGF0YSxcclxuXHRcdFx0XHRcdHN0YXRlXHRcdDogeyB9LFxyXG5cdFx0XHRcdFx0bGlfYXR0clx0XHQ6IHsgaWQgOiBmYWxzZSB9LFxyXG5cdFx0XHRcdFx0YV9hdHRyXHRcdDogeyBocmVmIDogJyMnIH0sXHJcblx0XHRcdFx0XHRvcmlnaW5hbFx0OiBmYWxzZVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdGZvcihpIGluIGRmKSB7XHJcblx0XHRcdFx0aWYoZGYuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuXHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGRmW2ldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZihkICYmIGQuZGF0YSAmJiBkLmRhdGEuanN0cmVlICYmIGQuZGF0YS5qc3RyZWUuaWNvbikge1xyXG5cdFx0XHRcdHRtcC5pY29uID0gZC5kYXRhLmpzdHJlZS5pY29uO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGQgJiYgZC5kYXRhKSB7XHJcblx0XHRcdFx0dG1wLmRhdGEgPSBkLmRhdGE7XHJcblx0XHRcdFx0aWYoZC5kYXRhLmpzdHJlZSkge1xyXG5cdFx0XHRcdFx0Zm9yKGkgaW4gZC5kYXRhLmpzdHJlZSkge1xyXG5cdFx0XHRcdFx0XHRpZihkLmRhdGEuanN0cmVlLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZC5kYXRhLmpzdHJlZVtpXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZihkICYmIHR5cGVvZiBkLnN0YXRlID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdGZvciAoaSBpbiBkLnN0YXRlKSB7XHJcblx0XHRcdFx0XHRpZihkLnN0YXRlLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuc3RhdGVbaV07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGQgJiYgdHlwZW9mIGQubGlfYXR0ciA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHRmb3IgKGkgaW4gZC5saV9hdHRyKSB7XHJcblx0XHRcdFx0XHRpZihkLmxpX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuXHRcdFx0XHRcdFx0dG1wLmxpX2F0dHJbaV0gPSBkLmxpX2F0dHJbaV07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCF0bXAubGlfYXR0ci5pZCkge1xyXG5cdFx0XHRcdHRtcC5saV9hdHRyLmlkID0gdGlkO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGQgJiYgdHlwZW9mIGQuYV9hdHRyID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdGZvciAoaSBpbiBkLmFfYXR0cikge1xyXG5cdFx0XHRcdFx0aWYoZC5hX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuXHRcdFx0XHRcdFx0dG1wLmFfYXR0cltpXSA9IGQuYV9hdHRyW2ldO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZihkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbiA9PT0gdHJ1ZSkge1xyXG5cdFx0XHRcdHRtcC5zdGF0ZS5sb2FkZWQgPSBmYWxzZTtcclxuXHRcdFx0XHR0bXAuY2hpbGRyZW4gPSBbXTtcclxuXHRcdFx0XHR0bXAuY2hpbGRyZW5fZCA9IFtdO1xyXG5cdFx0XHR9XHJcblx0XHRcdG1bdG1wLmlkXSA9IHRtcDtcclxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gdG1wLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdGMgPSB0aGlzLl9wYXJzZV9tb2RlbF9mcm9tX2ZsYXRfanNvbihtW3RtcC5jaGlsZHJlbltpXV0sIHRtcC5pZCwgcHMpO1xyXG5cdFx0XHRcdGUgPSBtW2NdO1xyXG5cdFx0XHRcdHRtcC5jaGlsZHJlbl9kLnB1c2goYyk7XHJcblx0XHRcdFx0aWYoZS5jaGlsZHJlbl9kLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0dG1wLmNoaWxkcmVuX2QgPSB0bXAuY2hpbGRyZW5fZC5jb25jYXQoZS5jaGlsZHJlbl9kKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZGVsZXRlIGQuZGF0YTtcclxuXHRcdFx0ZGVsZXRlIGQuY2hpbGRyZW47XHJcblx0XHRcdG1bdG1wLmlkXS5vcmlnaW5hbCA9IGQ7XHJcblx0XHRcdGlmKHRtcC5zdGF0ZS5zZWxlY3RlZCkge1xyXG5cdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5wdXNoKHRtcC5pZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRtcC5pZDtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIHBhcnNlcyBhIG5vZGUgZnJvbSBhIEpTT04gb2JqZWN0IGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBpbiBtZW1vcnkgdHJlZSBtb2RlbC4gVXNlZCBpbnRlcm5hbGx5LlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBuYW1lIF9wYXJzZV9tb2RlbF9mcm9tX2pzb24oZCBbLCBwLCBwc10pXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9IGQgdGhlIEpTT04gb2JqZWN0IHRvIHBhcnNlXHJcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHAgdGhlIHBhcmVudCBJRFxyXG5cdFx0ICogQHBhcmFtICB7QXJyYXl9IHBzIGxpc3Qgb2YgYWxsIHBhcmVudHNcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ30gdGhlIElEIG9mIHRoZSBvYmplY3QgYWRkZWQgdG8gdGhlIG1vZGVsXHJcblx0XHQgKi9cclxuXHRcdF9wYXJzZV9tb2RlbF9mcm9tX2pzb24gOiBmdW5jdGlvbiAoZCwgcCwgcHMpIHtcclxuXHRcdFx0aWYoIXBzKSB7IHBzID0gW107IH1cclxuXHRcdFx0ZWxzZSB7IHBzID0gcHMuY29uY2F0KCk7IH1cclxuXHRcdFx0aWYocCkgeyBwcy51bnNoaWZ0KHApOyB9XHJcblx0XHRcdHZhciB0aWQgPSBmYWxzZSwgaSwgaiwgYywgZSwgbSA9IHRoaXMuX21vZGVsLmRhdGEsIGRmID0gdGhpcy5fbW9kZWwuZGVmYXVsdF9zdGF0ZSwgdG1wO1xyXG5cdFx0XHRkbyB7XHJcblx0XHRcdFx0dGlkID0gJ2onICsgdGhpcy5faWQgKyAnXycgKyAoKyt0aGlzLl9jbnQpO1xyXG5cdFx0XHR9IHdoaWxlKG1bdGlkXSk7XHJcblxyXG5cdFx0XHR0bXAgPSB7XHJcblx0XHRcdFx0aWRcdFx0XHQ6IGZhbHNlLFxyXG5cdFx0XHRcdHRleHRcdFx0OiB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyBkIDogJycsXHJcblx0XHRcdFx0aWNvblx0XHQ6IHR5cGVvZiBkID09PSAnb2JqZWN0JyAmJiBkLmljb24gIT09IHVuZGVmaW5lZCA/IGQuaWNvbiA6IHRydWUsXHJcblx0XHRcdFx0cGFyZW50XHRcdDogcCxcclxuXHRcdFx0XHRwYXJlbnRzXHRcdDogcHMsXHJcblx0XHRcdFx0Y2hpbGRyZW5cdDogW10sXHJcblx0XHRcdFx0Y2hpbGRyZW5fZFx0OiBbXSxcclxuXHRcdFx0XHRkYXRhXHRcdDogbnVsbCxcclxuXHRcdFx0XHRzdGF0ZVx0XHQ6IHsgfSxcclxuXHRcdFx0XHRsaV9hdHRyXHRcdDogeyBpZCA6IGZhbHNlIH0sXHJcblx0XHRcdFx0YV9hdHRyXHRcdDogeyBocmVmIDogJyMnIH0sXHJcblx0XHRcdFx0b3JpZ2luYWxcdDogZmFsc2VcclxuXHRcdFx0fTtcclxuXHRcdFx0Zm9yKGkgaW4gZGYpIHtcclxuXHRcdFx0XHRpZihkZi5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG5cdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gZGZbaV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGQgJiYgZC5pZCkgeyB0bXAuaWQgPSBkLmlkLnRvU3RyaW5nKCk7IH1cclxuXHRcdFx0aWYoZCAmJiBkLnRleHQpIHsgdG1wLnRleHQgPSBkLnRleHQ7IH1cclxuXHRcdFx0aWYoZCAmJiBkLmRhdGEgJiYgZC5kYXRhLmpzdHJlZSAmJiBkLmRhdGEuanN0cmVlLmljb24pIHtcclxuXHRcdFx0XHR0bXAuaWNvbiA9IGQuZGF0YS5qc3RyZWUuaWNvbjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihkICYmIGQuZGF0YSkge1xyXG5cdFx0XHRcdHRtcC5kYXRhID0gZC5kYXRhO1xyXG5cdFx0XHRcdGlmKGQuZGF0YS5qc3RyZWUpIHtcclxuXHRcdFx0XHRcdGZvcihpIGluIGQuZGF0YS5qc3RyZWUpIHtcclxuXHRcdFx0XHRcdFx0aWYoZC5kYXRhLmpzdHJlZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG5cdFx0XHRcdFx0XHRcdHRtcC5zdGF0ZVtpXSA9IGQuZGF0YS5qc3RyZWVbaV07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoZCAmJiB0eXBlb2YgZC5zdGF0ZSA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHRmb3IgKGkgaW4gZC5zdGF0ZSkge1xyXG5cdFx0XHRcdFx0aWYoZC5zdGF0ZS5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG5cdFx0XHRcdFx0XHR0bXAuc3RhdGVbaV0gPSBkLnN0YXRlW2ldO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZihkICYmIHR5cGVvZiBkLmxpX2F0dHIgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdFx0Zm9yIChpIGluIGQubGlfYXR0cikge1xyXG5cdFx0XHRcdFx0aWYoZC5saV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0XHRcdFx0XHRcdHRtcC5saV9hdHRyW2ldID0gZC5saV9hdHRyW2ldO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZih0bXAubGlfYXR0ci5pZCAmJiAhdG1wLmlkKSB7XHJcblx0XHRcdFx0dG1wLmlkID0gdG1wLmxpX2F0dHIuaWQudG9TdHJpbmcoKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZighdG1wLmlkKSB7XHJcblx0XHRcdFx0dG1wLmlkID0gdGlkO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCF0bXAubGlfYXR0ci5pZCkge1xyXG5cdFx0XHRcdHRtcC5saV9hdHRyLmlkID0gdG1wLmlkO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGQgJiYgdHlwZW9mIGQuYV9hdHRyID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRcdGZvciAoaSBpbiBkLmFfYXR0cikge1xyXG5cdFx0XHRcdFx0aWYoZC5hX2F0dHIuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuXHRcdFx0XHRcdFx0dG1wLmFfYXR0cltpXSA9IGQuYV9hdHRyW2ldO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZihkICYmIGQuY2hpbGRyZW4gJiYgZC5jaGlsZHJlbi5sZW5ndGgpIHtcclxuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0YyA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21fanNvbihkLmNoaWxkcmVuW2ldLCB0bXAuaWQsIHBzKTtcclxuXHRcdFx0XHRcdGUgPSBtW2NdO1xyXG5cdFx0XHRcdFx0dG1wLmNoaWxkcmVuLnB1c2goYyk7XHJcblx0XHRcdFx0XHRpZihlLmNoaWxkcmVuX2QubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KGUuY2hpbGRyZW5fZCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRtcC5jaGlsZHJlbl9kID0gdG1wLmNoaWxkcmVuX2QuY29uY2F0KHRtcC5jaGlsZHJlbik7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoZCAmJiBkLmNoaWxkcmVuICYmIGQuY2hpbGRyZW4gPT09IHRydWUpIHtcclxuXHRcdFx0XHR0bXAuc3RhdGUubG9hZGVkID0gZmFsc2U7XHJcblx0XHRcdFx0dG1wLmNoaWxkcmVuID0gW107XHJcblx0XHRcdFx0dG1wLmNoaWxkcmVuX2QgPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRkZWxldGUgZC5kYXRhO1xyXG5cdFx0XHRkZWxldGUgZC5jaGlsZHJlbjtcclxuXHRcdFx0dG1wLm9yaWdpbmFsID0gZDtcclxuXHRcdFx0bVt0bXAuaWRdID0gdG1wO1xyXG5cdFx0XHRpZih0bXAuc3RhdGUuc2VsZWN0ZWQpIHtcclxuXHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQucHVzaCh0bXAuaWQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0bXAuaWQ7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiByZWRyYXdzIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVkcmF3bi4gVXNlZCBpbnRlcm5hbGx5LlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBuYW1lIF9yZWRyYXcoKVxyXG5cdFx0ICogQHRyaWdnZXIgcmVkcmF3LmpzdHJlZVxyXG5cdFx0ICovXHJcblx0XHRfcmVkcmF3IDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgbm9kZXMgPSB0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA/IHRoaXMuX21vZGVsLmRhdGFbJyMnXS5jaGlsZHJlbi5jb25jYXQoW10pIDogdGhpcy5fbW9kZWwuY2hhbmdlZC5jb25jYXQoW10pLFxyXG5cdFx0XHRcdGYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdVTCcpLCB0bXAsIGksIGosIGZlID0gdGhpcy5fZGF0YS5jb3JlLmZvY3VzZWQ7XHJcblx0XHRcdGZvcihpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdHRtcCA9IHRoaXMucmVkcmF3X25vZGUobm9kZXNbaV0sIHRydWUsIHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3KTtcclxuXHRcdFx0XHRpZih0bXAgJiYgdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcclxuXHRcdFx0XHRcdGYuYXBwZW5kQ2hpbGQodG1wKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcclxuXHRcdFx0XHRmLmNsYXNzTmFtZSA9IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdLmNsYXNzTmFtZTtcclxuXHRcdFx0XHRmLnNldEF0dHJpYnV0ZSgncm9sZScsJ2dyb3VwJyk7XHJcblx0XHRcdFx0dGhpcy5lbGVtZW50LmVtcHR5KCkuYXBwZW5kKGYpO1xyXG5cdFx0XHRcdC8vdGhpcy5nZXRfY29udGFpbmVyX3VsKClbMF0uYXBwZW5kQ2hpbGQoZik7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoZmUgIT09IG51bGwpIHtcclxuXHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKGZlLCB0cnVlKTtcclxuXHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCAmJiB0bXAuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJylbMF0gIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcclxuXHRcdFx0XHRcdHRtcC5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5mb2N1cygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID0gbnVsbDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5fbW9kZWwuY2hhbmdlZCA9IFtdO1xyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogdHJpZ2dlcmVkIGFmdGVyIG5vZGVzIGFyZSByZWRyYXduXHJcblx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHQgKiBAbmFtZSByZWRyYXcuanN0cmVlXHJcblx0XHRcdCAqIEBwYXJhbSB7YXJyYXl9IG5vZGVzIHRoZSByZWRyYXduIG5vZGVzXHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3JlZHJhdycsIHsgXCJub2Rlc1wiIDogbm9kZXMgfSk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiByZWRyYXdzIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVkcmF3biBvciBvcHRpb25hbGx5IC0gdGhlIHdob2xlIHRyZWVcclxuXHRcdCAqIEBuYW1lIHJlZHJhdyhbZnVsbF0pXHJcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCBhbGwgbm9kZXMgYXJlIHJlZHJhd24uXHJcblx0XHQgKi9cclxuXHRcdHJlZHJhdyA6IGZ1bmN0aW9uIChmdWxsKSB7XHJcblx0XHRcdGlmKGZ1bGwpIHtcclxuXHRcdFx0XHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly9pZih0aGlzLl9tb2RlbC5yZWRyYXdfdGltZW91dCkge1xyXG5cdFx0XHQvL1x0Y2xlYXJUaW1lb3V0KHRoaXMuX21vZGVsLnJlZHJhd190aW1lb3V0KTtcclxuXHRcdFx0Ly99XHJcblx0XHRcdC8vdGhpcy5fbW9kZWwucmVkcmF3X3RpbWVvdXQgPSBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5fcmVkcmF3LCB0aGlzKSwwKTtcclxuXHRcdFx0dGhpcy5fcmVkcmF3KCk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiByZWRyYXdzIGEgc2luZ2xlIG5vZGUncyBjaGlsZHJlbi4gVXNlZCBpbnRlcm5hbGx5LlxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBuYW1lIGRyYXdfY2hpbGRyZW4obm9kZSlcclxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG5vZGUgdGhlIG5vZGUgd2hvc2UgY2hpbGRyZW4gd2lsbCBiZSByZWRyYXduXHJcblx0XHQgKi9cclxuXHRcdGRyYXdfY2hpbGRyZW4gOiBmdW5jdGlvbiAobm9kZSkge1xyXG5cdFx0XHR2YXIgb2JqID0gdGhpcy5nZXRfbm9kZShub2RlKSxcclxuXHRcdFx0XHRpID0gZmFsc2UsXHJcblx0XHRcdFx0aiA9IGZhbHNlLFxyXG5cdFx0XHRcdGsgPSBmYWxzZSxcclxuXHRcdFx0XHRkID0gZG9jdW1lbnQ7XHJcblx0XHRcdGlmKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdGlmKG9iai5pZCA9PT0gJyMnKSB7IHJldHVybiB0aGlzLnJlZHJhdyh0cnVlKTsgfVxyXG5cdFx0XHRub2RlID0gdGhpcy5nZXRfbm9kZShub2RlLCB0cnVlKTtcclxuXHRcdFx0aWYoIW5vZGUgfHwgIW5vZGUubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfSAvLyBUT0RPOiBxdWljayB0b2dnbGVcclxuXHJcblx0XHRcdG5vZGUuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKS5yZW1vdmUoKTtcclxuXHRcdFx0bm9kZSA9IG5vZGVbMF07XHJcblx0XHRcdGlmKG9iai5jaGlsZHJlbi5sZW5ndGggJiYgb2JqLnN0YXRlLmxvYWRlZCkge1xyXG5cdFx0XHRcdGsgPSBkLmNyZWF0ZUVsZW1lbnQoJ1VMJyk7XHJcblx0XHRcdFx0ay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcclxuXHRcdFx0XHRrLmNsYXNzTmFtZSA9ICdqc3RyZWUtY2hpbGRyZW4nO1xyXG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRcdGsuYXBwZW5kQ2hpbGQodGhpcy5yZWRyYXdfbm9kZShvYmouY2hpbGRyZW5baV0sIHRydWUsIHRydWUpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChrKTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogcmVkcmF3cyBhIHNpbmdsZSBub2RlLiBVc2VkIGludGVybmFsbHkuXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQG5hbWUgcmVkcmF3X25vZGUobm9kZSwgZGVlcCwgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbmRlcilcclxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG5vZGUgdGhlIG5vZGUgdG8gcmVkcmF3XHJcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZXAgc2hvdWxkIGNoaWxkIG5vZGVzIGJlIHJlZHJhd24gdG9vXHJcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IGlzX2NhbGxiYWNrIGlzIHRoaXMgYSByZWN1cnNpb24gY2FsbFxyXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBmb3JjZV9yZW5kZXIgc2hvdWxkIGNoaWxkcmVuIG9mIGNsb3NlZCBwYXJlbnRzIGJlIGRyYXduIGFueXdheVxyXG5cdFx0ICovXHJcblx0XHRyZWRyYXdfbm9kZSA6IGZ1bmN0aW9uIChub2RlLCBkZWVwLCBpc19jYWxsYmFjaywgZm9yY2VfcmVuZGVyKSB7XHJcblx0XHRcdHZhciBvYmogPSB0aGlzLmdldF9ub2RlKG5vZGUpLFxyXG5cdFx0XHRcdHBhciA9IGZhbHNlLFxyXG5cdFx0XHRcdGluZCA9IGZhbHNlLFxyXG5cdFx0XHRcdG9sZCA9IGZhbHNlLFxyXG5cdFx0XHRcdGkgPSBmYWxzZSxcclxuXHRcdFx0XHRqID0gZmFsc2UsXHJcblx0XHRcdFx0ayA9IGZhbHNlLFxyXG5cdFx0XHRcdGMgPSAnJyxcclxuXHRcdFx0XHRkID0gZG9jdW1lbnQsXHJcblx0XHRcdFx0bSA9IHRoaXMuX21vZGVsLmRhdGEsXHJcblx0XHRcdFx0ZiA9IGZhbHNlLFxyXG5cdFx0XHRcdHMgPSBmYWxzZSxcclxuXHRcdFx0XHR0bXAgPSBudWxsLFxyXG5cdFx0XHRcdHQgPSAwLFxyXG5cdFx0XHRcdGwgPSAwO1xyXG5cdFx0XHRpZighb2JqKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRpZihvYmouaWQgPT09ICcjJykgeyAgcmV0dXJuIHRoaXMucmVkcmF3KHRydWUpOyB9XHJcblx0XHRcdGRlZXAgPSBkZWVwIHx8IG9iai5jaGlsZHJlbi5sZW5ndGggPT09IDA7XHJcblx0XHRcdG5vZGUgPSAhZG9jdW1lbnQucXVlcnlTZWxlY3RvciA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9iai5pZCkgOiB0aGlzLmVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvcignIycgKyAoXCIwMTIzNDU2Nzg5XCIuaW5kZXhPZihvYmouaWRbMF0pICE9PSAtMSA/ICdcXFxcMycgKyBvYmouaWRbMF0gKyAnICcgKyBvYmouaWQuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJykgOiBvYmouaWQucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKSkgKTsgLy8sIHRoaXMuZWxlbWVudCk7XHJcblx0XHRcdGlmKCFub2RlKSB7XHJcblx0XHRcdFx0ZGVlcCA9IHRydWU7XHJcblx0XHRcdFx0Ly9ub2RlID0gZC5jcmVhdGVFbGVtZW50KCdMSScpO1xyXG5cdFx0XHRcdGlmKCFpc19jYWxsYmFjaykge1xyXG5cdFx0XHRcdFx0cGFyID0gb2JqLnBhcmVudCAhPT0gJyMnID8gJCgnIycgKyBvYmoucGFyZW50LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJyksIHRoaXMuZWxlbWVudClbMF0gOiBudWxsO1xyXG5cdFx0XHRcdFx0aWYocGFyICE9PSBudWxsICYmICghcGFyIHx8ICFtW29iai5wYXJlbnRdLnN0YXRlLm9wZW5lZCkpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aW5kID0gJC5pbkFycmF5KG9iai5pZCwgcGFyID09PSBudWxsID8gbVsnIyddLmNoaWxkcmVuIDogbVtvYmoucGFyZW50XS5jaGlsZHJlbik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdG5vZGUgPSAkKG5vZGUpO1xyXG5cdFx0XHRcdGlmKCFpc19jYWxsYmFjaykge1xyXG5cdFx0XHRcdFx0cGFyID0gbm9kZS5wYXJlbnQoKS5wYXJlbnQoKVswXTtcclxuXHRcdFx0XHRcdGlmKHBhciA9PT0gdGhpcy5lbGVtZW50WzBdKSB7XHJcblx0XHRcdFx0XHRcdHBhciA9IG51bGw7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpbmQgPSBub2RlLmluZGV4KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIG1bb2JqLmlkXS5kYXRhID0gbm9kZS5kYXRhKCk7IC8vIHVzZSBvbmx5IG5vZGUncyBkYXRhLCBubyBuZWVkIHRvIHRvdWNoIGpxdWVyeSBzdG9yYWdlXHJcblx0XHRcdFx0aWYoIWRlZXAgJiYgb2JqLmNoaWxkcmVuLmxlbmd0aCAmJiAhbm9kZS5jaGlsZHJlbignLmpzdHJlZS1jaGlsZHJlbicpLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0ZGVlcCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCFkZWVwKSB7XHJcblx0XHRcdFx0XHRvbGQgPSBub2RlLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJylbMF07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGYgPSBub2RlLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpWzBdID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG5cdFx0XHRcdG5vZGUucmVtb3ZlKCk7XHJcblx0XHRcdFx0Ly9ub2RlID0gZC5jcmVhdGVFbGVtZW50KCdMSScpO1xyXG5cdFx0XHRcdC8vbm9kZSA9IG5vZGVbMF07XHJcblx0XHRcdH1cclxuXHRcdFx0bm9kZSA9IF9ub2RlLmNsb25lTm9kZSh0cnVlKTtcclxuXHRcdFx0Ly8gbm9kZSBpcyBET00sIGRlZXAgaXMgYm9vbGVhblxyXG5cclxuXHRcdFx0YyA9ICdqc3RyZWUtbm9kZSAnO1xyXG5cdFx0XHRmb3IoaSBpbiBvYmoubGlfYXR0cikge1xyXG5cdFx0XHRcdGlmKG9iai5saV9hdHRyLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0XHRcdFx0XHRpZihpID09PSAnaWQnKSB7IGNvbnRpbnVlOyB9XHJcblx0XHRcdFx0XHRpZihpICE9PSAnY2xhc3MnKSB7XHJcblx0XHRcdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKGksIG9iai5saV9hdHRyW2ldKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjICs9IG9iai5saV9hdHRyW2ldO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZighb2JqLmFfYXR0ci5pZCkge1xyXG5cdFx0XHRcdG9iai5hX2F0dHIuaWQgPSBvYmouaWQgKyAnX2FuY2hvcic7XHJcblx0XHRcdH1cclxuXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCAhIW9iai5zdGF0ZS5zZWxlY3RlZCk7XHJcblx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdhcmlhLWxldmVsJywgb2JqLnBhcmVudHMubGVuZ3RoKTtcclxuXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScsIG9iai5hX2F0dHIuaWQpO1xyXG5cdFx0XHRpZihvYmouc3RhdGUuZGlzYWJsZWQpIHtcclxuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1kaXNhYmxlZCcsIHRydWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihvYmouc3RhdGUubG9hZGVkICYmICFvYmouY2hpbGRyZW4ubGVuZ3RoKSB7XHJcblx0XHRcdFx0YyArPSAnIGpzdHJlZS1sZWFmJztcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRjICs9IG9iai5zdGF0ZS5vcGVuZWQgJiYgb2JqLnN0YXRlLmxvYWRlZCA/ICcganN0cmVlLW9wZW4nIDogJyBqc3RyZWUtY2xvc2VkJztcclxuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIChvYmouc3RhdGUub3BlbmVkICYmIG9iai5zdGF0ZS5sb2FkZWQpICk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYob2JqLnBhcmVudCAhPT0gbnVsbCAmJiBtW29iai5wYXJlbnRdLmNoaWxkcmVuW21bb2JqLnBhcmVudF0uY2hpbGRyZW4ubGVuZ3RoIC0gMV0gPT09IG9iai5pZCkge1xyXG5cdFx0XHRcdGMgKz0gJyBqc3RyZWUtbGFzdCc7XHJcblx0XHRcdH1cclxuXHRcdFx0bm9kZS5pZCA9IG9iai5pZDtcclxuXHRcdFx0bm9kZS5jbGFzc05hbWUgPSBjO1xyXG5cdFx0XHRjID0gKCBvYmouc3RhdGUuc2VsZWN0ZWQgPyAnIGpzdHJlZS1jbGlja2VkJyA6ICcnKSArICggb2JqLnN0YXRlLmRpc2FibGVkID8gJyBqc3RyZWUtZGlzYWJsZWQnIDogJycpO1xyXG5cdFx0XHRmb3IoaiBpbiBvYmouYV9hdHRyKSB7XHJcblx0XHRcdFx0aWYob2JqLmFfYXR0ci5oYXNPd25Qcm9wZXJ0eShqKSkge1xyXG5cdFx0XHRcdFx0aWYoaiA9PT0gJ2hyZWYnICYmIG9iai5hX2F0dHJbal0gPT09ICcjJykgeyBjb250aW51ZTsgfVxyXG5cdFx0XHRcdFx0aWYoaiAhPT0gJ2NsYXNzJykge1xyXG5cdFx0XHRcdFx0XHRub2RlLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKGosIG9iai5hX2F0dHJbal0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdGMgKz0gJyAnICsgb2JqLmFfYXR0cltqXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoYy5sZW5ndGgpIHtcclxuXHRcdFx0XHRub2RlLmNoaWxkTm9kZXNbMV0uY2xhc3NOYW1lID0gJ2pzdHJlZS1hbmNob3IgJyArIGM7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoKG9iai5pY29uICYmIG9iai5pY29uICE9PSB0cnVlKSB8fCBvYmouaWNvbiA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHRpZihvYmouaWNvbiA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLmNsYXNzTmFtZSArPSAnIGpzdHJlZS10aGVtZWljb24taGlkZGVuJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZihvYmouaWNvbi5pbmRleE9mKCcvJykgPT09IC0xICYmIG9iai5pY29uLmluZGV4T2YoJy4nKSA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLmNsYXNzTmFtZSArPSAnICcgKyBvYmouaWNvbiArICcganN0cmVlLXRoZW1laWNvbi1jdXN0b20nO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICd1cmwoJytvYmouaWNvbisnKSc7XHJcblx0XHRcdFx0XHRub2RlLmNoaWxkTm9kZXNbMV0uY2hpbGROb2Rlc1swXS5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSAnY2VudGVyIGNlbnRlcic7XHJcblx0XHRcdFx0XHRub2RlLmNoaWxkTm9kZXNbMV0uY2hpbGROb2Rlc1swXS5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9ICdhdXRvJztcclxuXHRcdFx0XHRcdG5vZGUuY2hpbGROb2Rlc1sxXS5jaGlsZE5vZGVzWzBdLmNsYXNzTmFtZSArPSAnIGpzdHJlZS10aGVtZWljb24tY3VzdG9tJztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0KSB7XHJcblx0XHRcdFx0bm9kZS5jaGlsZE5vZGVzWzFdLmFwcGVuZENoaWxkKGQuY3JlYXRlVGV4dE5vZGUob2JqLnRleHQpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRub2RlLmNoaWxkTm9kZXNbMV0uaW5uZXJIVE1MICs9IG9iai50ZXh0O1xyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0aWYoZGVlcCAmJiBvYmouY2hpbGRyZW4ubGVuZ3RoICYmIChvYmouc3RhdGUub3BlbmVkIHx8IGZvcmNlX3JlbmRlcikgJiYgb2JqLnN0YXRlLmxvYWRlZCkge1xyXG5cdFx0XHRcdGsgPSBkLmNyZWF0ZUVsZW1lbnQoJ1VMJyk7XHJcblx0XHRcdFx0ay5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZ3JvdXAnKTtcclxuXHRcdFx0XHRrLmNsYXNzTmFtZSA9ICdqc3RyZWUtY2hpbGRyZW4nO1xyXG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRcdGsuYXBwZW5kQ2hpbGQodGhpcy5yZWRyYXdfbm9kZShvYmouY2hpbGRyZW5baV0sIGRlZXAsIHRydWUpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChrKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihvbGQpIHtcclxuXHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKG9sZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIWlzX2NhbGxiYWNrKSB7XHJcblx0XHRcdFx0Ly8gYXBwZW5kIGJhY2sgdXNpbmcgcGFyIC8gaW5kXHJcblx0XHRcdFx0aWYoIXBhcikge1xyXG5cdFx0XHRcdFx0cGFyID0gdGhpcy5lbGVtZW50WzBdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwYXIuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmKHBhci5jaGlsZE5vZGVzW2ldICYmIHBhci5jaGlsZE5vZGVzW2ldLmNsYXNzTmFtZSAmJiBwYXIuY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUuaW5kZXhPZignanN0cmVlLWNoaWxkcmVuJykgIT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdHRtcCA9IHBhci5jaGlsZE5vZGVzW2ldO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIXRtcCkge1xyXG5cdFx0XHRcdFx0dG1wID0gZC5jcmVhdGVFbGVtZW50KCdVTCcpO1xyXG5cdFx0XHRcdFx0dG1wLnNldEF0dHJpYnV0ZSgncm9sZScsICdncm91cCcpO1xyXG5cdFx0XHRcdFx0dG1wLmNsYXNzTmFtZSA9ICdqc3RyZWUtY2hpbGRyZW4nO1xyXG5cdFx0XHRcdFx0cGFyLmFwcGVuZENoaWxkKHRtcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHBhciA9IHRtcDtcclxuXHJcblx0XHRcdFx0aWYoaW5kIDwgcGFyLmNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRwYXIuaW5zZXJ0QmVmb3JlKG5vZGUsIHBhci5jaGlsZE5vZGVzW2luZF0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdHBhci5hcHBlbmRDaGlsZChub2RlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoZikge1xyXG5cdFx0XHRcdFx0dCA9IHRoaXMuZWxlbWVudFswXS5zY3JvbGxUb3A7XHJcblx0XHRcdFx0XHRsID0gdGhpcy5lbGVtZW50WzBdLnNjcm9sbExlZnQ7XHJcblx0XHRcdFx0XHRub2RlLmNoaWxkTm9kZXNbMV0uZm9jdXMoKTtcclxuXHRcdFx0XHRcdHRoaXMuZWxlbWVudFswXS5zY3JvbGxUb3AgPSB0O1xyXG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50WzBdLnNjcm9sbExlZnQgPSBsO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZihvYmouc3RhdGUub3BlbmVkICYmICFvYmouc3RhdGUubG9hZGVkKSB7XHJcblx0XHRcdFx0b2JqLnN0YXRlLm9wZW5lZCA9IGZhbHNlO1xyXG5cdFx0XHRcdHNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHR0aGlzLm9wZW5fbm9kZShvYmouaWQsIGZhbHNlLCAwKTtcclxuXHRcdFx0XHR9LCB0aGlzKSwgMCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG5vZGU7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBvcGVucyBhIG5vZGUsIHJldmFsaW5nIGl0cyBjaGlsZHJlbi4gSWYgdGhlIG5vZGUgaXMgbm90IGxvYWRlZCBpdCB3aWxsIGJlIGxvYWRlZCBhbmQgb3BlbmVkIG9uY2UgcmVhZHkuXHJcblx0XHQgKiBAbmFtZSBvcGVuX25vZGUob2JqIFssIGNhbGxiYWNrLCBhbmltYXRpb25dKVxyXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIG9wZW5cclxuXHRcdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBub2RlIGlzIG9wZW5lZFxyXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuaW1hdGlvbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB3aGVuIG9wZW5pbmcgdGhlIG5vZGUgKG92ZXJyaWRlcyB0aGUgYGNvcmUuYW5pbWF0aW9uYCBzZXR0aW5nKS4gVXNlIGBmYWxzZWAgZm9yIG5vIGFuaW1hdGlvbi5cclxuXHRcdCAqIEB0cmlnZ2VyIG9wZW5fbm9kZS5qc3RyZWUsIGFmdGVyX29wZW4uanN0cmVlLCBiZWZvcmVfb3Blbi5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0b3Blbl9ub2RlIDogZnVuY3Rpb24gKG9iaiwgY2FsbGJhY2ssIGFuaW1hdGlvbikge1xyXG5cdFx0XHR2YXIgdDEsIHQyLCBkLCB0O1xyXG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xyXG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xyXG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xyXG5cdFx0XHRcdFx0dGhpcy5vcGVuX25vZGUob2JqW3QxXSwgY2FsbGJhY2ssIGFuaW1hdGlvbik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICcjJykge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRhbmltYXRpb24gPSBhbmltYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuc2V0dGluZ3MuY29yZS5hbmltYXRpb24gOiBhbmltYXRpb247XHJcblx0XHRcdGlmKCF0aGlzLmlzX2Nsb3NlZChvYmopKSB7XHJcblx0XHRcdFx0aWYoY2FsbGJhY2spIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCBmYWxzZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZighdGhpcy5pc19sb2FkZWQob2JqKSkge1xyXG5cdFx0XHRcdGlmKHRoaXMuaXNfbG9hZGluZyhvYmopKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5vcGVuX25vZGUob2JqLCBjYWxsYmFjaywgYW5pbWF0aW9uKTtcclxuXHRcdFx0XHRcdH0sIHRoaXMpLCA1MDApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLmxvYWRfbm9kZShvYmosIGZ1bmN0aW9uIChvLCBvaykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG9rID8gdGhpcy5vcGVuX25vZGUobywgY2FsbGJhY2ssIGFuaW1hdGlvbikgOiAoY2FsbGJhY2sgPyBjYWxsYmFjay5jYWxsKHRoaXMsIG8sIGZhbHNlKSA6IGZhbHNlKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRkID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xyXG5cdFx0XHRcdHQgPSB0aGlzO1xyXG5cdFx0XHRcdGlmKGQubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRpZihhbmltYXRpb24gJiYgZC5jaGlsZHJlbihcIi5qc3RyZWUtY2hpbGRyZW5cIikubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdGQuY2hpbGRyZW4oXCIuanN0cmVlLWNoaWxkcmVuXCIpLnN0b3AodHJ1ZSwgdHJ1ZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihvYmouY2hpbGRyZW4ubGVuZ3RoICYmICF0aGlzLl9maXJzdENoaWxkKGQuY2hpbGRyZW4oJy5qc3RyZWUtY2hpbGRyZW4nKVswXSkpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5kcmF3X2NoaWxkcmVuKG9iaik7XHJcblx0XHRcdFx0XHRcdC8vZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKCFhbmltYXRpb24pIHtcclxuXHRcdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdiZWZvcmVfb3BlbicsIHsgXCJub2RlXCIgOiBvYmogfSk7XHJcblx0XHRcdFx0XHRcdGRbMF0uY2xhc3NOYW1lID0gZFswXS5jbGFzc05hbWUucmVwbGFjZSgnanN0cmVlLWNsb3NlZCcsICdqc3RyZWUtb3BlbicpO1xyXG5cdFx0XHRcdFx0XHRkWzBdLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgdHJ1ZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdiZWZvcmVfb3BlbicsIHsgXCJub2RlXCIgOiBvYmogfSk7XHJcblx0XHRcdFx0XHRcdGRcclxuXHRcdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCIuanN0cmVlLWNoaWxkcmVuXCIpLmNzcyhcImRpc3BsYXlcIixcIm5vbmVcIikuZW5kKClcclxuXHRcdFx0XHRcdFx0XHQucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtY2xvc2VkXCIpLmFkZENsYXNzKFwianN0cmVlLW9wZW5cIikuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwgdHJ1ZSlcclxuXHRcdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCIuanN0cmVlLWNoaWxkcmVuXCIpLnN0b3AodHJ1ZSwgdHJ1ZSlcclxuXHRcdFx0XHRcdFx0XHRcdC5zbGlkZURvd24oYW5pbWF0aW9uLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuc3R5bGUuZGlzcGxheSA9IFwiXCI7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHQudHJpZ2dlcihcImFmdGVyX29wZW5cIiwgeyBcIm5vZGVcIiA6IG9iaiB9KTtcclxuXHRcdFx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRvYmouc3RhdGUub3BlbmVkID0gdHJ1ZTtcclxuXHRcdFx0XHRpZihjYWxsYmFjaykge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh0aGlzLCBvYmosIHRydWUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZighZC5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdC8qKlxyXG5cdFx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIGFib3V0IHRvIGJlIG9wZW5lZCAoaWYgdGhlIG5vZGUgaXMgc3VwcG9zZWQgdG8gYmUgaW4gdGhlIERPTSwgaXQgd2lsbCBiZSwgYnV0IGl0IHdvbid0IGJlIHZpc2libGUgeWV0KVxyXG5cdFx0XHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdFx0XHQgKiBAbmFtZSBiZWZvcmVfb3Blbi5qc3RyZWVcclxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBvcGVuZWQgbm9kZVxyXG5cdFx0XHRcdFx0ICovXHJcblx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2JlZm9yZV9vcGVuJywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0LyoqXHJcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIG9wZW5lZCAoaWYgdGhlcmUgaXMgYW4gYW5pbWF0aW9uIGl0IHdpbGwgbm90IGJlIGNvbXBsZXRlZCB5ZXQpXHJcblx0XHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdFx0ICogQG5hbWUgb3Blbl9ub2RlLmpzdHJlZVxyXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBvcGVuZWQgbm9kZVxyXG5cdFx0XHRcdCAqL1xyXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignb3Blbl9ub2RlJywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcclxuXHRcdFx0XHRpZighYW5pbWF0aW9uIHx8ICFkLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0LyoqXHJcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgb3BlbmVkIGFuZCB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXHJcblx0XHRcdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0XHRcdCAqIEBuYW1lIGFmdGVyX29wZW4uanN0cmVlXHJcblx0XHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgb3BlbmVkIG5vZGVcclxuXHRcdFx0XHRcdCAqL1xyXG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKFwiYWZ0ZXJfb3BlblwiLCB7IFwibm9kZVwiIDogb2JqIH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogb3BlbnMgZXZlcnkgcGFyZW50IG9mIGEgbm9kZSAobm9kZSBzaG91bGQgYmUgbG9hZGVkKVxyXG5cdFx0ICogQG5hbWUgX29wZW5fdG8ob2JqKVxyXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIHJldmVhbFxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqL1xyXG5cdFx0X29wZW5fdG8gOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICcjJykge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgaSwgaiwgcCA9IG9iai5wYXJlbnRzO1xyXG5cdFx0XHRmb3IoaSA9IDAsIGogPSBwLmxlbmd0aDsgaSA8IGo7IGkrPTEpIHtcclxuXHRcdFx0XHRpZihpICE9PSAnIycpIHtcclxuXHRcdFx0XHRcdHRoaXMub3Blbl9ub2RlKHBbaV0sIGZhbHNlLCAwKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuICQoJyMnICsgb2JqLmlkLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJyksIHRoaXMuZWxlbWVudCk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBjbG9zZXMgYSBub2RlLCBoaWRpbmcgaXRzIGNoaWxkcmVuXHJcblx0XHQgKiBAbmFtZSBjbG9zZV9ub2RlKG9iaiBbLCBhbmltYXRpb25dKVxyXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGNsb3NlXHJcblx0XHQgKiBAcGFyYW0ge051bWJlcn0gYW5pbWF0aW9uIHRoZSBhbmltYXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHdoZW4gY2xvc2luZyB0aGUgbm9kZSAob3ZlcnJpZGVzIHRoZSBgY29yZS5hbmltYXRpb25gIHNldHRpbmcpLiBVc2UgYGZhbHNlYCBmb3Igbm8gYW5pbWF0aW9uLlxyXG5cdFx0ICogQHRyaWdnZXIgY2xvc2Vfbm9kZS5qc3RyZWUsIGFmdGVyX2Nsb3NlLmpzdHJlZVxyXG5cdFx0ICovXHJcblx0XHRjbG9zZV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgYW5pbWF0aW9uKSB7XHJcblx0XHRcdHZhciB0MSwgdDIsIHQsIGQ7XHJcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XHJcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XHJcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNsb3NlX25vZGUob2JqW3QxXSwgYW5pbWF0aW9uKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHRoaXMuaXNfY2xvc2VkKG9iaikpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLnNldHRpbmdzLmNvcmUuYW5pbWF0aW9uIDogYW5pbWF0aW9uO1xyXG5cdFx0XHR0ID0gdGhpcztcclxuXHRcdFx0ZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcclxuXHRcdFx0aWYoZC5sZW5ndGgpIHtcclxuXHRcdFx0XHRpZighYW5pbWF0aW9uKSB7XHJcblx0XHRcdFx0XHRkWzBdLmNsYXNzTmFtZSA9IGRbMF0uY2xhc3NOYW1lLnJlcGxhY2UoJ2pzdHJlZS1vcGVuJywgJ2pzdHJlZS1jbG9zZWQnKTtcclxuXHRcdFx0XHRcdGQuYXR0cihcImFyaWEtZXhwYW5kZWRcIiwgZmFsc2UpLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykucmVtb3ZlKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0ZFxyXG5cdFx0XHRcdFx0XHQuY2hpbGRyZW4oXCIuanN0cmVlLWNoaWxkcmVuXCIpLmF0dHIoXCJzdHlsZVwiLFwiZGlzcGxheTpibG9jayAhaW1wb3J0YW50XCIpLmVuZCgpXHJcblx0XHRcdFx0XHRcdC5yZW1vdmVDbGFzcyhcImpzdHJlZS1vcGVuXCIpLmFkZENsYXNzKFwianN0cmVlLWNsb3NlZFwiKS5hdHRyKFwiYXJpYS1leHBhbmRlZFwiLCBmYWxzZSlcclxuXHRcdFx0XHRcdFx0LmNoaWxkcmVuKFwiLmpzdHJlZS1jaGlsZHJlblwiKS5zdG9wKHRydWUsIHRydWUpLnNsaWRlVXAoYW5pbWF0aW9uLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcclxuXHRcdFx0XHRcdFx0XHRkLmNoaWxkcmVuKCcuanN0cmVlLWNoaWxkcmVuJykucmVtb3ZlKCk7XHJcblx0XHRcdFx0XHRcdFx0dC50cmlnZ2VyKFwiYWZ0ZXJfY2xvc2VcIiwgeyBcIm5vZGVcIiA6IG9iaiB9KTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdG9iai5zdGF0ZS5vcGVuZWQgPSBmYWxzZTtcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjbG9zZWQgKGlmIHRoZXJlIGlzIGFuIGFuaW1hdGlvbiBpdCB3aWxsIG5vdCBiZSBjb21wbGV0ZSB5ZXQpXHJcblx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHQgKiBAbmFtZSBjbG9zZV9ub2RlLmpzdHJlZVxyXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgY2xvc2VkIG5vZGVcclxuXHRcdFx0ICovXHJcblx0XHRcdHRoaXMudHJpZ2dlcignY2xvc2Vfbm9kZScseyBcIm5vZGVcIiA6IG9iaiB9KTtcclxuXHRcdFx0aWYoIWFuaW1hdGlvbiB8fCAhZC5sZW5ndGgpIHtcclxuXHRcdFx0XHQvKipcclxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgY2xvc2VkIGFuZCB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlXHJcblx0XHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdFx0ICogQG5hbWUgYWZ0ZXJfY2xvc2UuanN0cmVlXHJcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGNsb3NlZCBub2RlXHJcblx0XHRcdFx0ICovXHJcblx0XHRcdFx0dGhpcy50cmlnZ2VyKFwiYWZ0ZXJfY2xvc2VcIiwgeyBcIm5vZGVcIiA6IG9iaiB9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogdG9nZ2xlcyBhIG5vZGUgLSBjbG9zaW5nIGl0IGlmIGl0IGlzIG9wZW4sIG9wZW5pbmcgaXQgaWYgaXQgaXMgY2xvc2VkXHJcblx0XHQgKiBAbmFtZSB0b2dnbGVfbm9kZShvYmopXHJcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gdG9nZ2xlXHJcblx0XHQgKi9cclxuXHRcdHRvZ2dsZV9ub2RlIDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0XHR2YXIgdDEsIHQyO1xyXG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xyXG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xyXG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xyXG5cdFx0XHRcdFx0dGhpcy50b2dnbGVfbm9kZShvYmpbdDFdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodGhpcy5pc19jbG9zZWQob2JqKSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm9wZW5fbm9kZShvYmopO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHRoaXMuaXNfb3BlbihvYmopKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2xvc2Vfbm9kZShvYmopO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBvcGVucyBhbGwgbm9kZXMgd2l0aGluIGEgbm9kZSAob3IgdGhlIHRyZWUpLCByZXZhbGluZyB0aGVpciBjaGlsZHJlbi4gSWYgdGhlIG5vZGUgaXMgbm90IGxvYWRlZCBpdCB3aWxsIGJlIGxvYWRlZCBhbmQgb3BlbmVkIG9uY2UgcmVhZHkuXHJcblx0XHQgKiBAbmFtZSBvcGVuX2FsbChbb2JqLCBhbmltYXRpb24sIG9yaWdpbmFsX29ial0pXHJcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gb3BlbiByZWN1cnNpdmVseSwgb21pdCB0byBvcGVuIGFsbCBub2RlcyBpbiB0aGUgdHJlZVxyXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuaW1hdGlvbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB3aGVuIG9wZW5pbmcgdGhlIG5vZGVzLCB0aGUgZGVmYXVsdCBpcyBubyBhbmltYXRpb25cclxuXHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSByZWZlcmVuY2UgdG8gdGhlIG5vZGUgdGhhdCBzdGFydGVkIHRoZSBwcm9jZXNzIChpbnRlcm5hbCB1c2UpXHJcblx0XHQgKiBAdHJpZ2dlciBvcGVuX2FsbC5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0b3Blbl9hbGwgOiBmdW5jdGlvbiAob2JqLCBhbmltYXRpb24sIG9yaWdpbmFsX29iaikge1xyXG5cdFx0XHRpZighb2JqKSB7IG9iaiA9ICcjJzsgfVxyXG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XHJcblx0XHRcdGlmKCFvYmopIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdHZhciBkb20gPSBvYmouaWQgPT09ICcjJyA/IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpIDogdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLCBpLCBqLCBfdGhpcztcclxuXHRcdFx0aWYoIWRvbS5sZW5ndGgpIHtcclxuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmKHRoaXMuaXNfY2xvc2VkKHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dKSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXS5zdGF0ZS5vcGVuZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdGhpcy50cmlnZ2VyKCdvcGVuX2FsbCcsIHsgXCJub2RlXCIgOiBvYmogfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0b3JpZ2luYWxfb2JqID0gb3JpZ2luYWxfb2JqIHx8IGRvbTtcclxuXHRcdFx0X3RoaXMgPSB0aGlzO1xyXG5cdFx0XHRkb20gPSB0aGlzLmlzX2Nsb3NlZChvYmopID8gZG9tLmZpbmQoJy5qc3RyZWUtY2xvc2VkJykuYWRkQmFjaygpIDogZG9tLmZpbmQoJy5qc3RyZWUtY2xvc2VkJyk7XHJcblx0XHRcdGRvbS5lYWNoKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRfdGhpcy5vcGVuX25vZGUoXHJcblx0XHRcdFx0XHR0aGlzLFxyXG5cdFx0XHRcdFx0ZnVuY3Rpb24obm9kZSwgc3RhdHVzKSB7IGlmKHN0YXR1cyAmJiB0aGlzLmlzX3BhcmVudChub2RlKSkgeyB0aGlzLm9wZW5fYWxsKG5vZGUsIGFuaW1hdGlvbiwgb3JpZ2luYWxfb2JqKTsgfSB9LFxyXG5cdFx0XHRcdFx0YW5pbWF0aW9uIHx8IDBcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYob3JpZ2luYWxfb2JqLmZpbmQoJy5qc3RyZWUtY2xvc2VkJykubGVuZ3RoID09PSAwKSB7XHJcblx0XHRcdFx0LyoqXHJcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gYG9wZW5fYWxsYCBjYWxsIGNvbXBsZXRlc1xyXG5cdFx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHRcdCAqIEBuYW1lIG9wZW5fYWxsLmpzdHJlZVxyXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBvcGVuZWQgbm9kZVxyXG5cdFx0XHRcdCAqL1xyXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignb3Blbl9hbGwnLCB7IFwibm9kZVwiIDogdGhpcy5nZXRfbm9kZShvcmlnaW5hbF9vYmopIH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBjbG9zZXMgYWxsIG5vZGVzIHdpdGhpbiBhIG5vZGUgKG9yIHRoZSB0cmVlKSwgcmV2YWxpbmcgdGhlaXIgY2hpbGRyZW5cclxuXHRcdCAqIEBuYW1lIGNsb3NlX2FsbChbb2JqLCBhbmltYXRpb25dKVxyXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGNsb3NlIHJlY3Vyc2l2ZWx5LCBvbWl0IHRvIGNsb3NlIGFsbCBub2RlcyBpbiB0aGUgdHJlZVxyXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IGFuaW1hdGlvbiB0aGUgYW5pbWF0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB3aGVuIGNsb3NpbmcgdGhlIG5vZGVzLCB0aGUgZGVmYXVsdCBpcyBubyBhbmltYXRpb25cclxuXHRcdCAqIEB0cmlnZ2VyIGNsb3NlX2FsbC5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0Y2xvc2VfYWxsIDogZnVuY3Rpb24gKG9iaiwgYW5pbWF0aW9uKSB7XHJcblx0XHRcdGlmKCFvYmopIHsgb2JqID0gJyMnOyB9XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0aWYoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0dmFyIGRvbSA9IG9iai5pZCA9PT0gJyMnID8gdGhpcy5nZXRfY29udGFpbmVyX3VsKCkgOiB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXHJcblx0XHRcdFx0X3RoaXMgPSB0aGlzLCBpLCBqO1xyXG5cdFx0XHRpZighZG9tLmxlbmd0aCkge1xyXG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0dGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0uc3RhdGUub3BlbmVkID0gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0aGlzLnRyaWdnZXIoJ2Nsb3NlX2FsbCcsIHsgXCJub2RlXCIgOiBvYmogfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZG9tID0gdGhpcy5pc19vcGVuKG9iaikgPyBkb20uZmluZCgnLmpzdHJlZS1vcGVuJykuYWRkQmFjaygpIDogZG9tLmZpbmQoJy5qc3RyZWUtb3BlbicpO1xyXG5cdFx0XHQkKGRvbS5nZXQoKS5yZXZlcnNlKCkpLmVhY2goZnVuY3Rpb24gKCkgeyBfdGhpcy5jbG9zZV9ub2RlKHRoaXMsIGFuaW1hdGlvbiB8fCAwKTsgfSk7XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBgY2xvc2VfYWxsYCBjYWxsIGNvbXBsZXRlc1xyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgY2xvc2VfYWxsLmpzdHJlZVxyXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgY2xvc2VkIG5vZGVcclxuXHRcdFx0ICovXHJcblx0XHRcdHRoaXMudHJpZ2dlcignY2xvc2VfYWxsJywgeyBcIm5vZGVcIiA6IG9iaiB9KTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGNoZWNrcyBpZiBhIG5vZGUgaXMgZGlzYWJsZWQgKG5vdCBzZWxlY3RhYmxlKVxyXG5cdFx0ICogQG5hbWUgaXNfZGlzYWJsZWQob2JqKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHRcdCAqL1xyXG5cdFx0aXNfZGlzYWJsZWQgOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0cmV0dXJuIG9iaiAmJiBvYmouc3RhdGUgJiYgb2JqLnN0YXRlLmRpc2FibGVkO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogZW5hYmxlcyBhIG5vZGUgLSBzbyB0aGF0IGl0IGNhbiBiZSBzZWxlY3RlZFxyXG5cdFx0ICogQG5hbWUgZW5hYmxlX25vZGUob2JqKVxyXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGVuYWJsZVxyXG5cdFx0ICogQHRyaWdnZXIgZW5hYmxlX25vZGUuanN0cmVlXHJcblx0XHQgKi9cclxuXHRcdGVuYWJsZV9ub2RlIDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0XHR2YXIgdDEsIHQyO1xyXG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xyXG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xyXG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xyXG5cdFx0XHRcdFx0dGhpcy5lbmFibGVfbm9kZShvYmpbdDFdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdG9iai5zdGF0ZS5kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmdldF9ub2RlKG9iaix0cnVlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcygnanN0cmVlLWRpc2FibGVkJykuYXR0cignYXJpYS1kaXNhYmxlZCcsIGZhbHNlKTtcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgZW5hYmxlZFxyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgZW5hYmxlX25vZGUuanN0cmVlXHJcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBlbmFibGVkIG5vZGVcclxuXHRcdFx0ICovXHJcblx0XHRcdHRoaXMudHJpZ2dlcignZW5hYmxlX25vZGUnLCB7ICdub2RlJyA6IG9iaiB9KTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGRpc2FibGVzIGEgbm9kZSAtIHNvIHRoYXQgaXQgY2FuIG5vdCBiZSBzZWxlY3RlZFxyXG5cdFx0ICogQG5hbWUgZGlzYWJsZV9ub2RlKG9iailcclxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBkaXNhYmxlXHJcblx0XHQgKiBAdHJpZ2dlciBkaXNhYmxlX25vZGUuanN0cmVlXHJcblx0XHQgKi9cclxuXHRcdGRpc2FibGVfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdFx0dmFyIHQxLCB0MjtcclxuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcclxuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcclxuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcclxuXHRcdFx0XHRcdHRoaXMuZGlzYWJsZV9ub2RlKG9ialt0MV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XHJcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0b2JqLnN0YXRlLmRpc2FibGVkID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5nZXRfbm9kZShvYmosdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1kaXNhYmxlZCcpLmF0dHIoJ2FyaWEtZGlzYWJsZWQnLCB0cnVlKTtcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgZGlzYWJsZWRcclxuXHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdCAqIEBuYW1lIGRpc2FibGVfbm9kZS5qc3RyZWVcclxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGUgdGhlIGRpc2FibGVkIG5vZGVcclxuXHRcdFx0ICovXHJcblx0XHRcdHRoaXMudHJpZ2dlcignZGlzYWJsZV9ub2RlJywgeyAnbm9kZScgOiBvYmogfSk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBjYWxsZWQgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWQgYnkgdGhlIHVzZXIuIFVzZWQgaW50ZXJuYWxseS5cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAbmFtZSBhY3RpdmF0ZV9ub2RlKG9iaiwgZSlcclxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGUgdGhlIHJlbGF0ZWQgZXZlbnRcclxuXHRcdCAqIEB0cmlnZ2VyIGFjdGl2YXRlX25vZGUuanN0cmVlLCBjaGFuZ2VkLmpzdHJlZVxyXG5cdFx0ICovXHJcblx0XHRhY3RpdmF0ZV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgZSkge1xyXG5cdFx0XHRpZih0aGlzLmlzX2Rpc2FibGVkKG9iaikpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGVuc3VyZSBsYXN0X2NsaWNrZWQgaXMgc3RpbGwgaW4gdGhlIERPTSwgbWFrZSBpdCBmcmVzaCAobWF5YmUgaXQgd2FzIG1vdmVkPykgYW5kIG1ha2Ugc3VyZSBpdCBpcyBzdGlsbCBzZWxlY3RlZCwgaWYgbm90IC0gbWFrZSBsYXN0X2NsaWNrZWQgdGhlIGxhc3Qgc2VsZWN0ZWQgbm9kZVxyXG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkLmlkICE9PSB1bmRlZmluZWQgPyB0aGlzLmdldF9ub2RlKHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQuaWQpIDogbnVsbDtcclxuXHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiAhdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5zdGF0ZS5zZWxlY3RlZCkgeyB0aGlzLl9kYXRhLmNvcmUubGFzdF9jbGlja2VkID0gbnVsbDsgfVxyXG5cdFx0XHRpZighdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCAmJiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoKSB7IHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgPSB0aGlzLmdldF9ub2RlKHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQubGVuZ3RoIC0gMV0pOyB9XHJcblxyXG5cdFx0XHRpZighdGhpcy5zZXR0aW5ncy5jb3JlLm11bHRpcGxlIHx8ICghZS5tZXRhS2V5ICYmICFlLmN0cmxLZXkgJiYgIWUuc2hpZnRLZXkpIHx8IChlLnNoaWZ0S2V5ICYmICghdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZCB8fCAhdGhpcy5nZXRfcGFyZW50KG9iaikgfHwgdGhpcy5nZXRfcGFyZW50KG9iaikgIT09IHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQucGFyZW50ICkgKSkge1xyXG5cdFx0XHRcdGlmKCF0aGlzLnNldHRpbmdzLmNvcmUubXVsdGlwbGUgJiYgKGUubWV0YUtleSB8fCBlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSkgJiYgdGhpcy5pc19zZWxlY3RlZChvYmopKSB7XHJcblx0XHRcdFx0XHR0aGlzLmRlc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5kZXNlbGVjdF9hbGwodHJ1ZSk7XHJcblx0XHRcdFx0XHR0aGlzLnNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIGZhbHNlLCBlKTtcclxuXHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2NsaWNrZWQgPSB0aGlzLmdldF9ub2RlKG9iaik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdGlmKGUuc2hpZnRLZXkpIHtcclxuXHRcdFx0XHRcdHZhciBvID0gdGhpcy5nZXRfbm9kZShvYmopLmlkLFxyXG5cdFx0XHRcdFx0XHRsID0gdGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5pZCxcclxuXHRcdFx0XHRcdFx0cCA9IHRoaXMuZ2V0X25vZGUodGhpcy5fZGF0YS5jb3JlLmxhc3RfY2xpY2tlZC5wYXJlbnQpLmNoaWxkcmVuLFxyXG5cdFx0XHRcdFx0XHRjID0gZmFsc2UsXHJcblx0XHRcdFx0XHRcdGksIGo7XHJcblx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLmxlbmd0aDsgaSA8IGo7IGkgKz0gMSkge1xyXG5cdFx0XHRcdFx0XHQvLyBzZXBhcmF0ZSBJRnMgd29yayB3aGVtIG8gYW5kIGwgYXJlIHRoZSBzYW1lXHJcblx0XHRcdFx0XHRcdGlmKHBbaV0gPT09IG8pIHtcclxuXHRcdFx0XHRcdFx0XHRjID0gIWM7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYocFtpXSA9PT0gbCkge1xyXG5cdFx0XHRcdFx0XHRcdGMgPSAhYztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZihjIHx8IHBbaV0gPT09IG8gfHwgcFtpXSA9PT0gbCkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0X25vZGUocFtpXSwgdHJ1ZSwgZmFsc2UsIGUpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZGVzZWxlY3Rfbm9kZShwW2ldLCB0cnVlLCBlKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdzZWxlY3Rfbm9kZScsICdub2RlJyA6IHRoaXMuZ2V0X25vZGUob2JqKSwgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ2V2ZW50JyA6IGUgfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYoIXRoaXMuaXNfc2VsZWN0ZWQob2JqKSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIGZhbHNlLCBlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmRlc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIGNsaWNrZWQgb3IgaW50ZXJjYXRlZCB3aXRoIGJ5IHRoZSB1c2VyXHJcblx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHQgKiBAbmFtZSBhY3RpdmF0ZV9ub2RlLmpzdHJlZVxyXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0dGhpcy50cmlnZ2VyKCdhY3RpdmF0ZV9ub2RlJywgeyAnbm9kZScgOiB0aGlzLmdldF9ub2RlKG9iaikgfSk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBhcHBsaWVzIHRoZSBob3ZlciBzdGF0ZSBvbiBhIG5vZGUsIGNhbGxlZCB3aGVuIGEgbm9kZSBpcyBob3ZlcmVkIGJ5IHRoZSB1c2VyLiBVc2VkIGludGVybmFsbHkuXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQG5hbWUgaG92ZXJfbm9kZShvYmopXHJcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmpcclxuXHRcdCAqIEB0cmlnZ2VyIGhvdmVyX25vZGUuanN0cmVlXHJcblx0XHQgKi9cclxuXHRcdGhvdmVyX25vZGUgOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcclxuXHRcdFx0aWYoIW9iaiB8fCAhb2JqLmxlbmd0aCB8fCBvYmouY2hpbGRyZW4oJy5qc3RyZWUtaG92ZXJlZCcpLmxlbmd0aCkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgbyA9IHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLWhvdmVyZWQnKSwgdCA9IHRoaXMuZWxlbWVudDtcclxuXHRcdFx0aWYobyAmJiBvLmxlbmd0aCkgeyB0aGlzLmRlaG92ZXJfbm9kZShvKTsgfVxyXG5cclxuXHRcdFx0b2JqLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKCdqc3RyZWUtaG92ZXJlZCcpO1xyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYW4gbm9kZSBpcyBob3ZlcmVkXHJcblx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHQgKiBAbmFtZSBob3Zlcl9ub2RlLmpzdHJlZVxyXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0dGhpcy50cmlnZ2VyKCdob3Zlcl9ub2RlJywgeyAnbm9kZScgOiB0aGlzLmdldF9ub2RlKG9iaikgfSk7XHJcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyB0LmF0dHIoJ2FyaWEtYWN0aXZlZGVzY2VuZGFudCcsIG9ialswXS5pZCk7IH0sIDApO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogcmVtb3ZlcyB0aGUgaG92ZXIgc3RhdGUgZnJvbSBhIG5vZGVjYWxsZWQgd2hlbiBhIG5vZGUgaXMgbm8gbG9uZ2VyIGhvdmVyZWQgYnkgdGhlIHVzZXIuIFVzZWQgaW50ZXJuYWxseS5cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAbmFtZSBkZWhvdmVyX25vZGUob2JqKVxyXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqXHJcblx0XHQgKiBAdHJpZ2dlciBkZWhvdmVyX25vZGUuanN0cmVlXHJcblx0XHQgKi9cclxuXHRcdGRlaG92ZXJfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xyXG5cdFx0XHRpZighb2JqIHx8ICFvYmoubGVuZ3RoIHx8ICFvYmouY2hpbGRyZW4oJy5qc3RyZWUtaG92ZXJlZCcpLmxlbmd0aCkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvYmouY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1ob3ZlcmVkJyk7XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIG5vIGxvbmdlciBob3ZlcmVkXHJcblx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHQgKiBAbmFtZSBkZWhvdmVyX25vZGUuanN0cmVlXHJcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2RlaG92ZXJfbm9kZScsIHsgJ25vZGUnIDogdGhpcy5nZXRfbm9kZShvYmopIH0pO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogc2VsZWN0IGEgbm9kZVxyXG5cdFx0ICogQG5hbWUgc2VsZWN0X25vZGUob2JqIFssIHN1cHJlc3NfZXZlbnQsIHByZXZlbnRfb3Blbl0pXHJcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG8gc2VsZWN0IG11bHRpcGxlIG5vZGVzXHJcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcclxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcHJldmVudF9vcGVuIGlmIHNldCB0byBgdHJ1ZWAgcGFyZW50cyBvZiB0aGUgc2VsZWN0ZWQgbm9kZSB3b24ndCBiZSBvcGVuZWRcclxuXHRcdCAqIEB0cmlnZ2VyIHNlbGVjdF9ub2RlLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0c2VsZWN0X25vZGUgOiBmdW5jdGlvbiAob2JqLCBzdXByZXNzX2V2ZW50LCBwcmV2ZW50X29wZW4sIGUpIHtcclxuXHRcdFx0dmFyIGRvbSwgdDEsIHQyLCB0aDtcclxuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcclxuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcclxuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcclxuXHRcdFx0XHRcdHRoaXMuc2VsZWN0X25vZGUob2JqW3QxXSwgc3VwcmVzc19ldmVudCwgcHJldmVudF9vcGVuLCBlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcclxuXHRcdFx0aWYoIW9iai5zdGF0ZS5zZWxlY3RlZCkge1xyXG5cdFx0XHRcdG9iai5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XHJcblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLnB1c2gob2JqLmlkKTtcclxuXHRcdFx0XHRpZighcHJldmVudF9vcGVuKSB7XHJcblx0XHRcdFx0XHRkb20gPSB0aGlzLl9vcGVuX3RvKG9iaik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKGRvbSAmJiBkb20ubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRkb20uYXR0cignYXJpYS1zZWxlY3RlZCcsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKCdqc3RyZWUtY2xpY2tlZCcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvKipcclxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIHNlbGVjdGVkXHJcblx0XHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdFx0ICogQG5hbWUgc2VsZWN0X25vZGUuanN0cmVlXHJcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcclxuXHRcdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cclxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgc2VsZWN0X25vZGVcclxuXHRcdFx0XHQgKi9cclxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ3NlbGVjdF9ub2RlJywgeyAnbm9kZScgOiBvYmosICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdldmVudCcgOiBlIH0pO1xyXG5cdFx0XHRcdGlmKCFzdXByZXNzX2V2ZW50KSB7XHJcblx0XHRcdFx0XHQvKipcclxuXHRcdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIHNlbGVjdGlvbiBjaGFuZ2VzXHJcblx0XHRcdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0XHRcdCAqIEBuYW1lIGNoYW5nZWQuanN0cmVlXHJcblx0XHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxyXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IGFjdGlvbiB0aGUgYWN0aW9uIHRoYXQgY2F1c2VkIHRoZSBzZWxlY3Rpb24gdG8gY2hhbmdlXHJcblx0XHRcdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cclxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyBjaGFuZ2VkIGV2ZW50XHJcblx0XHRcdFx0XHQgKi9cclxuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbicgOiAnc2VsZWN0X25vZGUnLCAnbm9kZScgOiBvYmosICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdldmVudCcgOiBlIH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogZGVzZWxlY3QgYSBub2RlXHJcblx0XHQgKiBAbmFtZSBkZXNlbGVjdF9ub2RlKG9iaiBbLCBzdXByZXNzX2V2ZW50XSlcclxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byBkZXNlbGVjdCBtdWx0aXBsZSBub2Rlc1xyXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBzdXByZXNzX2V2ZW50IGlmIHNldCB0byBgdHJ1ZWAgdGhlIGBjaGFuZ2VkLmpzdHJlZWAgZXZlbnQgd29uJ3QgYmUgdHJpZ2dlcmVkXHJcblx0XHQgKiBAdHJpZ2dlciBkZXNlbGVjdF9ub2RlLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0ZGVzZWxlY3Rfbm9kZSA6IGZ1bmN0aW9uIChvYmosIHN1cHJlc3NfZXZlbnQsIGUpIHtcclxuXHRcdFx0dmFyIHQxLCB0MiwgZG9tO1xyXG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xyXG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xyXG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xyXG5cdFx0XHRcdFx0dGhpcy5kZXNlbGVjdF9ub2RlKG9ialt0MV0sIHN1cHJlc3NfZXZlbnQsIGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XHJcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xyXG5cdFx0XHRpZihvYmouc3RhdGUuc2VsZWN0ZWQpIHtcclxuXHRcdFx0XHRvYmouc3RhdGUuc2VsZWN0ZWQgPSBmYWxzZTtcclxuXHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsIG9iai5pZCk7XHJcblx0XHRcdFx0aWYoZG9tLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0ZG9tLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8qKlxyXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgZGVzZWxlY3RlZFxyXG5cdFx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHRcdCAqIEBuYW1lIGRlc2VsZWN0X25vZGUuanN0cmVlXHJcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcclxuXHRcdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cclxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZGVzZWxlY3Rfbm9kZVxyXG5cdFx0XHRcdCAqL1xyXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignZGVzZWxlY3Rfbm9kZScsIHsgJ25vZGUnIDogb2JqLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnZXZlbnQnIDogZSB9KTtcclxuXHRcdFx0XHRpZighc3VwcmVzc19ldmVudCkge1xyXG5cdFx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdkZXNlbGVjdF9ub2RlJywgJ25vZGUnIDogb2JqLCAnc2VsZWN0ZWQnIDogdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAnZXZlbnQnIDogZSB9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIHNlbGVjdCBhbGwgbm9kZXMgaW4gdGhlIHRyZWVcclxuXHRcdCAqIEBuYW1lIHNlbGVjdF9hbGwoW3N1cHJlc3NfZXZlbnRdKVxyXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBzdXByZXNzX2V2ZW50IGlmIHNldCB0byBgdHJ1ZWAgdGhlIGBjaGFuZ2VkLmpzdHJlZWAgZXZlbnQgd29uJ3QgYmUgdHJpZ2dlcmVkXHJcblx0XHQgKiBAdHJpZ2dlciBzZWxlY3RfYWxsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0c2VsZWN0X2FsbCA6IGZ1bmN0aW9uIChzdXByZXNzX2V2ZW50KSB7XHJcblx0XHRcdHZhciB0bXAgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KFtdKSwgaSwgajtcclxuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkID0gdGhpcy5fbW9kZWwuZGF0YVsnIyddLmNoaWxkcmVuX2QuY29uY2F0KCk7XHJcblx0XHRcdGZvcihpID0gMCwgaiA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY29yZS5zZWxlY3RlZFtpXV0pIHtcclxuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXS5zdGF0ZS5zZWxlY3RlZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMucmVkcmF3KHRydWUpO1xyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYWxsIG5vZGVzIGFyZSBzZWxlY3RlZFxyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgc2VsZWN0X2FsbC5qc3RyZWVcclxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3NlbGVjdF9hbGwnLCB7ICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQgfSk7XHJcblx0XHRcdGlmKCFzdXByZXNzX2V2ZW50KSB7XHJcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyAnYWN0aW9uJyA6ICdzZWxlY3RfYWxsJywgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCwgJ29sZF9zZWxlY3Rpb24nIDogdG1wIH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBkZXNlbGVjdCBhbGwgc2VsZWN0ZWQgbm9kZXNcclxuXHRcdCAqIEBuYW1lIGRlc2VsZWN0X2FsbChbc3VwcmVzc19ldmVudF0pXHJcblx0XHQgKiBAcGFyYW0ge0Jvb2xlYW59IHN1cHJlc3NfZXZlbnQgaWYgc2V0IHRvIGB0cnVlYCB0aGUgYGNoYW5nZWQuanN0cmVlYCBldmVudCB3b24ndCBiZSB0cmlnZ2VyZWRcclxuXHRcdCAqIEB0cmlnZ2VyIGRlc2VsZWN0X2FsbC5qc3RyZWUsIGNoYW5nZWQuanN0cmVlXHJcblx0XHQgKi9cclxuXHRcdGRlc2VsZWN0X2FsbCA6IGZ1bmN0aW9uIChzdXByZXNzX2V2ZW50KSB7XHJcblx0XHRcdHZhciB0bXAgPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KFtdKSwgaSwgajtcclxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldXSkge1xyXG5cdFx0XHRcdFx0dGhpcy5fbW9kZWwuZGF0YVt0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWRbaV1dLnN0YXRlLnNlbGVjdGVkID0gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCA9IFtdO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1jbGlja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJykucGFyZW50KCkuYXR0cignYXJpYS1zZWxlY3RlZCcsIGZhbHNlKTtcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFsbCBub2RlcyBhcmUgZGVzZWxlY3RlZFxyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgZGVzZWxlY3RfYWxsLmpzdHJlZVxyXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uXHJcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxyXG5cdFx0XHQgKi9cclxuXHRcdFx0dGhpcy50cmlnZ2VyKCdkZXNlbGVjdF9hbGwnLCB7ICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdub2RlJyA6IHRtcCB9KTtcclxuXHRcdFx0aWYoIXN1cHJlc3NfZXZlbnQpIHtcclxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7ICdhY3Rpb24nIDogJ2Rlc2VsZWN0X2FsbCcsICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdvbGRfc2VsZWN0aW9uJyA6IHRtcCB9KTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogY2hlY2tzIGlmIGEgbm9kZSBpcyBzZWxlY3RlZFxyXG5cdFx0ICogQG5hbWUgaXNfc2VsZWN0ZWQob2JqKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICBvYmpcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XHJcblx0XHQgKi9cclxuXHRcdGlzX3NlbGVjdGVkIDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XHJcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG9iai5zdGF0ZS5zZWxlY3RlZDtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGdldCBhbiBhcnJheSBvZiBhbGwgc2VsZWN0ZWQgbm9kZXNcclxuXHRcdCAqIEBuYW1lIGdldF9zZWxlY3RlZChbZnVsbF0pXHJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gIGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb25zaXN0IG9mIHRoZSBmdWxsIG5vZGUgb2JqZWN0cywgb3RoZXJ3aXNlIC0gb25seSBJRHMgd2lsbCBiZSByZXR1cm5lZFxyXG5cdFx0ICogQHJldHVybiB7QXJyYXl9XHJcblx0XHQgKi9cclxuXHRcdGdldF9zZWxlY3RlZCA6IGZ1bmN0aW9uIChmdWxsKSB7XHJcblx0XHRcdHJldHVybiBmdWxsID8gJC5tYXAodGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLmdldF9ub2RlKGkpOyB9LCB0aGlzKSkgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuc2xpY2UoKTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGdldCBhbiBhcnJheSBvZiBhbGwgdG9wIGxldmVsIHNlbGVjdGVkIG5vZGVzIChpZ25vcmluZyBjaGlsZHJlbiBvZiBzZWxlY3RlZCBub2RlcylcclxuXHRcdCAqIEBuYW1lIGdldF90b3Bfc2VsZWN0ZWQoW2Z1bGxdKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICBmdWxsIGlmIHNldCB0byBgdHJ1ZWAgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29uc2lzdCBvZiB0aGUgZnVsbCBub2RlIG9iamVjdHMsIG90aGVyd2lzZSAtIG9ubHkgSURzIHdpbGwgYmUgcmV0dXJuZWRcclxuXHRcdCAqIEByZXR1cm4ge0FycmF5fVxyXG5cdFx0ICovXHJcblx0XHRnZXRfdG9wX3NlbGVjdGVkIDogZnVuY3Rpb24gKGZ1bGwpIHtcclxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0X3NlbGVjdGVkKHRydWUpLFxyXG5cdFx0XHRcdG9iaiA9IHt9LCBpLCBqLCBrLCBsO1xyXG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0b2JqW3RtcFtpXS5pZF0gPSB0bXBbaV07XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gdG1wLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdGZvcihrID0gMCwgbCA9IHRtcFtpXS5jaGlsZHJlbl9kLmxlbmd0aDsgayA8IGw7IGsrKykge1xyXG5cdFx0XHRcdFx0aWYob2JqW3RtcFtpXS5jaGlsZHJlbl9kW2tdXSkge1xyXG5cdFx0XHRcdFx0XHRkZWxldGUgb2JqW3RtcFtpXS5jaGlsZHJlbl9kW2tdXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dG1wID0gW107XHJcblx0XHRcdGZvcihpIGluIG9iaikge1xyXG5cdFx0XHRcdGlmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xyXG5cdFx0XHRcdFx0dG1wLnB1c2goaSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmdWxsID8gJC5tYXAodG1wLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLmdldF9ub2RlKGkpOyB9LCB0aGlzKSkgOiB0bXA7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBnZXQgYW4gYXJyYXkgb2YgYWxsIGJvdHRvbSBsZXZlbCBzZWxlY3RlZCBub2RlcyAoaWdub3Jpbmcgc2VsZWN0ZWQgcGFyZW50cylcclxuXHRcdCAqIEBuYW1lIGdldF9ib3R0b21fc2VsZWN0ZWQoW2Z1bGxdKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICBmdWxsIGlmIHNldCB0byBgdHJ1ZWAgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29uc2lzdCBvZiB0aGUgZnVsbCBub2RlIG9iamVjdHMsIG90aGVyd2lzZSAtIG9ubHkgSURzIHdpbGwgYmUgcmV0dXJuZWRcclxuXHRcdCAqIEByZXR1cm4ge0FycmF5fVxyXG5cdFx0ICovXHJcblx0XHRnZXRfYm90dG9tX3NlbGVjdGVkIDogZnVuY3Rpb24gKGZ1bGwpIHtcclxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0X3NlbGVjdGVkKHRydWUpLFxyXG5cdFx0XHRcdG9iaiA9IFtdLCBpLCBqO1xyXG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0aWYoIXRtcFtpXS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdG9iai5wdXNoKHRtcFtpXS5pZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmdWxsID8gJC5tYXAob2JqLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLmdldF9ub2RlKGkpOyB9LCB0aGlzKSkgOiBvYmo7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBnZXRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB0cmVlIHNvIHRoYXQgaXQgY2FuIGJlIHJlc3RvcmVkIGxhdGVyIHdpdGggYHNldF9zdGF0ZShzdGF0ZSlgLiBVc2VkIGludGVybmFsbHkuXHJcblx0XHQgKiBAbmFtZSBnZXRfc3RhdGUoKVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEByZXR1cm4ge09iamVjdH1cclxuXHRcdCAqL1xyXG5cdFx0Z2V0X3N0YXRlIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgc3RhdGVcdD0ge1xyXG5cdFx0XHRcdCdjb3JlJyA6IHtcclxuXHRcdFx0XHRcdCdvcGVuJyA6IFtdLFxyXG5cdFx0XHRcdFx0J3Njcm9sbCcgOiB7XHJcblx0XHRcdFx0XHRcdCdsZWZ0JyA6IHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0KCksXHJcblx0XHRcdFx0XHRcdCd0b3AnIDogdGhpcy5lbGVtZW50LnNjcm9sbFRvcCgpXHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0LyohXHJcblx0XHRcdFx0XHQndGhlbWVzJyA6IHtcclxuXHRcdFx0XHRcdFx0J25hbWUnIDogdGhpcy5nZXRfdGhlbWUoKSxcclxuXHRcdFx0XHRcdFx0J2ljb25zJyA6IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuaWNvbnMsXHJcblx0XHRcdFx0XHRcdCdkb3RzJyA6IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90c1xyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdCovXHJcblx0XHRcdFx0XHQnc2VsZWN0ZWQnIDogW11cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sIGk7XHJcblx0XHRcdGZvcihpIGluIHRoaXMuX21vZGVsLmRhdGEpIHtcclxuXHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kYXRhLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0XHRcdFx0XHRpZihpICE9PSAnIycpIHtcclxuXHRcdFx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YVtpXS5zdGF0ZS5vcGVuZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRzdGF0ZS5jb3JlLm9wZW4ucHVzaChpKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kYXRhW2ldLnN0YXRlLnNlbGVjdGVkKSB7XHJcblx0XHRcdFx0XHRcdFx0c3RhdGUuY29yZS5zZWxlY3RlZC5wdXNoKGkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBzdGF0ZTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIHNldHMgdGhlIHN0YXRlIG9mIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXHJcblx0XHQgKiBAbmFtZSBzZXRfc3RhdGUoc3RhdGUgWywgY2FsbGJhY2tdKVxyXG5cdFx0ICogQHByaXZhdGVcclxuXHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSB0aGUgc3RhdGUgdG8gcmVzdG9yZVxyXG5cdFx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYW4gb3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBzdGF0ZSBpcyByZXN0b3JlZC5cclxuXHRcdCAqIEB0cmlnZ2VyIHNldF9zdGF0ZS5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0c2V0X3N0YXRlIDogZnVuY3Rpb24gKHN0YXRlLCBjYWxsYmFjaykge1xyXG5cdFx0XHRpZihzdGF0ZSkge1xyXG5cdFx0XHRcdGlmKHN0YXRlLmNvcmUpIHtcclxuXHRcdFx0XHRcdHZhciByZXMsIG4sIHQsIF90aGlzO1xyXG5cdFx0XHRcdFx0aWYoc3RhdGUuY29yZS5vcGVuKSB7XHJcblx0XHRcdFx0XHRcdGlmKCEkLmlzQXJyYXkoc3RhdGUuY29yZS5vcGVuKSkge1xyXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZS5jb3JlLm9wZW47XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cmVzID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0biA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR0ID0gdGhpcztcclxuXHRcdFx0XHRcdFx0JC5lYWNoKHN0YXRlLmNvcmUub3Blbi5jb25jYXQoW10pLCBmdW5jdGlvbiAoaSwgdikge1xyXG5cdFx0XHRcdFx0XHRcdG4gPSB0LmdldF9ub2RlKHYpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKG4pIHtcclxuXHRcdFx0XHRcdFx0XHRcdGlmKHQuaXNfbG9hZGVkKHYpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHQuaXNfY2xvc2VkKHYpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dC5vcGVuX25vZGUodiwgZmFsc2UsIDApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHN0YXRlICYmIHN0YXRlLmNvcmUgJiYgc3RhdGUuY29yZS5vcGVuKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0JC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0oc3RhdGUuY29yZS5vcGVuLCB2KTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCF0LmlzX2xvYWRpbmcodikpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0Lm9wZW5fbm9kZSh2LCAkLnByb3h5KGZ1bmN0aW9uIChvLCBzKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZighcyAmJiBzdGF0ZSAmJiBzdGF0ZS5jb3JlICYmIHN0YXRlLmNvcmUub3Blbikge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbShzdGF0ZS5jb3JlLm9wZW4sIG8uaWQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LCB0KSwgMCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdGhlcmUgd2lsbCBiZSBzb21lIGFzeW5jIGFjdGl2aXR5IC0gc28gd2FpdCBmb3IgaXRcclxuXHRcdFx0XHRcdFx0XHRcdFx0cmVzID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0aWYocmVzKSB7XHJcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHN0YXRlLmNvcmUub3BlbjtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmKHN0YXRlLmNvcmUuc2Nyb2xsKSB7XHJcblx0XHRcdFx0XHRcdGlmKHN0YXRlLmNvcmUuc2Nyb2xsICYmIHN0YXRlLmNvcmUuc2Nyb2xsLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0KHN0YXRlLmNvcmUuc2Nyb2xsLmxlZnQpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKHN0YXRlLmNvcmUuc2Nyb2xsICYmIHN0YXRlLmNvcmUuc2Nyb2xsLnRvcCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LnNjcm9sbFRvcChzdGF0ZS5jb3JlLnNjcm9sbC50b3ApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZS5jb3JlLnNjcm9sbDtcclxuXHRcdFx0XHRcdFx0dGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0LyohXHJcblx0XHRcdFx0XHRpZihzdGF0ZS5jb3JlLnRoZW1lcykge1xyXG5cdFx0XHRcdFx0XHRpZihzdGF0ZS5jb3JlLnRoZW1lcy5uYW1lKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRfdGhlbWUoc3RhdGUuY29yZS50aGVtZXMubmFtZSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYodHlwZW9mIHN0YXRlLmNvcmUudGhlbWVzLmRvdHMgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpc1sgc3RhdGUuY29yZS50aGVtZXMuZG90cyA/IFwic2hvd19kb3RzXCIgOiBcImhpZGVfZG90c1wiIF0oKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZih0eXBlb2Ygc3RhdGUuY29yZS50aGVtZXMuaWNvbnMgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpc1sgc3RhdGUuY29yZS50aGVtZXMuaWNvbnMgPyBcInNob3dfaWNvbnNcIiA6IFwiaGlkZV9pY29uc1wiIF0oKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRkZWxldGUgc3RhdGUuY29yZS50aGVtZXM7XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZS5jb3JlLm9wZW47XHJcblx0XHRcdFx0XHRcdHRoaXMuc2V0X3N0YXRlKHN0YXRlLCBjYWxsYmFjayk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdCovXHJcblx0XHRcdFx0XHRpZihzdGF0ZS5jb3JlLnNlbGVjdGVkKSB7XHJcblx0XHRcdFx0XHRcdF90aGlzID0gdGhpcztcclxuXHRcdFx0XHRcdFx0dGhpcy5kZXNlbGVjdF9hbGwoKTtcclxuXHRcdFx0XHRcdFx0JC5lYWNoKHN0YXRlLmNvcmUuc2VsZWN0ZWQsIGZ1bmN0aW9uIChpLCB2KSB7XHJcblx0XHRcdFx0XHRcdFx0X3RoaXMuc2VsZWN0X25vZGUodik7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRkZWxldGUgc3RhdGUuY29yZS5zZWxlY3RlZDtcclxuXHRcdFx0XHRcdFx0dGhpcy5zZXRfc3RhdGUoc3RhdGUsIGNhbGxiYWNrKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoJC5pc0VtcHR5T2JqZWN0KHN0YXRlLmNvcmUpKSB7XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSBzdGF0ZS5jb3JlO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnNldF9zdGF0ZShzdGF0ZSwgY2FsbGJhY2spO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCQuaXNFbXB0eU9iamVjdChzdGF0ZSkpIHtcclxuXHRcdFx0XHRcdHN0YXRlID0gbnVsbDtcclxuXHRcdFx0XHRcdGlmKGNhbGxiYWNrKSB7IGNhbGxiYWNrLmNhbGwodGhpcyk7IH1cclxuXHRcdFx0XHRcdC8qKlxyXG5cdFx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBgc2V0X3N0YXRlYCBjYWxsIGNvbXBsZXRlc1xyXG5cdFx0XHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdFx0XHQgKiBAbmFtZSBzZXRfc3RhdGUuanN0cmVlXHJcblx0XHRcdFx0XHQgKi9cclxuXHRcdFx0XHRcdHRoaXMudHJpZ2dlcignc2V0X3N0YXRlJyk7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIHJlZnJlc2hlcyB0aGUgdHJlZSAtIGFsbCBub2RlcyBhcmUgcmVsb2FkZWQgd2l0aCBjYWxscyB0byBgbG9hZF9ub2RlYC5cclxuXHRcdCAqIEBuYW1lIHJlZnJlc2goKVxyXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBza2lwX2xvYWRpbmcgYW4gb3B0aW9uIHRvIHNraXAgc2hvd2luZyB0aGUgbG9hZGluZyBpbmRpY2F0b3JcclxuXHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGZvcmdldF9zdGF0ZSBpZiBzZXQgdG8gYHRydWVgIHN0YXRlIHdpbGwgbm90IGJlIHJlYXBwbGllZCwgaWYgc2V0IHRvIGEgZnVuY3Rpb24gKHJlY2VpdmluZyB0aGUgY3VycmVudCBzdGF0ZSBhcyBhcmd1bWVudCkgdGhlIHJlc3VsdCBvZiB0aGF0IGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCBhcyBzdGF0ZVxyXG5cdFx0ICogQHRyaWdnZXIgcmVmcmVzaC5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0cmVmcmVzaCA6IGZ1bmN0aW9uIChza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSkge1xyXG5cdFx0XHR0aGlzLl9kYXRhLmNvcmUuc3RhdGUgPSBmb3JnZXRfc3RhdGUgPT09IHRydWUgPyB7fSA6IHRoaXMuZ2V0X3N0YXRlKCk7XHJcblx0XHRcdGlmKGZvcmdldF9zdGF0ZSAmJiAkLmlzRnVuY3Rpb24oZm9yZ2V0X3N0YXRlKSkgeyB0aGlzLl9kYXRhLmNvcmUuc3RhdGUgPSBmb3JnZXRfc3RhdGUuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUuc3RhdGUpOyB9XHJcblx0XHRcdHRoaXMuX2NudCA9IDA7XHJcblx0XHRcdHRoaXMuX21vZGVsLmRhdGEgPSB7XHJcblx0XHRcdFx0JyMnIDoge1xyXG5cdFx0XHRcdFx0aWQgOiAnIycsXHJcblx0XHRcdFx0XHRwYXJlbnQgOiBudWxsLFxyXG5cdFx0XHRcdFx0cGFyZW50cyA6IFtdLFxyXG5cdFx0XHRcdFx0Y2hpbGRyZW4gOiBbXSxcclxuXHRcdFx0XHRcdGNoaWxkcmVuX2QgOiBbXSxcclxuXHRcdFx0XHRcdHN0YXRlIDogeyBsb2FkZWQgOiBmYWxzZSB9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHR2YXIgYyA9IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdLmNsYXNzTmFtZTtcclxuXHRcdFx0aWYoIXNraXBfbG9hZGluZykge1xyXG5cdFx0XHRcdHRoaXMuZWxlbWVudC5odG1sKFwiPFwiK1widWwgY2xhc3M9J1wiK2MrXCInIHJvbGU9J2dyb3VwJz48XCIrXCJsaSBjbGFzcz0nanN0cmVlLWluaXRpYWwtbm9kZSBqc3RyZWUtbG9hZGluZyBqc3RyZWUtbGVhZiBqc3RyZWUtbGFzdCcgcm9sZT0ndHJlZWl0ZW0nIGlkPSdqXCIrdGhpcy5faWQrXCJfbG9hZGluZyc+PGkgY2xhc3M9J2pzdHJlZS1pY29uIGpzdHJlZS1vY2wnPjwvaT48XCIrXCJhIGNsYXNzPSdqc3RyZWUtYW5jaG9yJyBocmVmPScjJz48aSBjbGFzcz0nanN0cmVlLWljb24ganN0cmVlLXRoZW1laWNvbi1oaWRkZW4nPjwvaT5cIiArIHRoaXMuZ2V0X3N0cmluZyhcIkxvYWRpbmcgLi4uXCIpICsgXCI8L2E+PC9saT48L3VsPlwiKTtcclxuXHRcdFx0XHR0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywnaicrdGhpcy5faWQrJ19sb2FkaW5nJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5sb2FkX25vZGUoJyMnLCBmdW5jdGlvbiAobywgcykge1xyXG5cdFx0XHRcdGlmKHMpIHtcclxuXHRcdFx0XHRcdHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdLmNsYXNzTmFtZSA9IGM7XHJcblx0XHRcdFx0XHRpZih0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50Jyx0aGlzLl9maXJzdENoaWxkKHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpWzBdKS5pZCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR0aGlzLnNldF9zdGF0ZSgkLmV4dGVuZCh0cnVlLCB7fSwgdGhpcy5fZGF0YS5jb3JlLnN0YXRlKSwgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHQvKipcclxuXHRcdFx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBgcmVmcmVzaGAgY2FsbCBjb21wbGV0ZXNcclxuXHRcdFx0XHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdFx0XHRcdCAqIEBuYW1lIHJlZnJlc2guanN0cmVlXHJcblx0XHRcdFx0XHRcdCAqL1xyXG5cdFx0XHRcdFx0XHR0aGlzLnRyaWdnZXIoJ3JlZnJlc2gnKTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUuc3RhdGUgPSBudWxsO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIHJlZnJlc2hlcyBhIG5vZGUgaW4gdGhlIHRyZWUgKHJlbG9hZCBpdHMgY2hpbGRyZW4pIGFsbCBvcGVuZWQgbm9kZXMgaW5zaWRlIHRoYXQgbm9kZSBhcmUgcmVsb2FkZWQgd2l0aCBjYWxscyB0byBgbG9hZF9ub2RlYC5cclxuXHRcdCAqIEBuYW1lIHJlZnJlc2hfbm9kZShvYmopXHJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXHJcblx0XHQgKiBAdHJpZ2dlciByZWZyZXNoX25vZGUuanN0cmVlXHJcblx0XHQgKi9cclxuXHRcdHJlZnJlc2hfbm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHR2YXIgb3BlbmVkID0gW10sIHRvX2xvYWQgPSBbXSwgcyA9IHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZC5jb25jYXQoW10pO1xyXG5cdFx0XHR0b19sb2FkLnB1c2gob2JqLmlkKTtcclxuXHRcdFx0aWYob2JqLnN0YXRlLm9wZW5lZCA9PT0gdHJ1ZSkgeyBvcGVuZWQucHVzaChvYmouaWQpOyB9XHJcblx0XHRcdHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5maW5kKCcuanN0cmVlLW9wZW4nKS5lYWNoKGZ1bmN0aW9uKCkgeyBvcGVuZWQucHVzaCh0aGlzLmlkKTsgfSk7XHJcblx0XHRcdHRoaXMuX2xvYWRfbm9kZXModG9fbG9hZCwgJC5wcm94eShmdW5jdGlvbiAobm9kZXMpIHtcclxuXHRcdFx0XHR0aGlzLm9wZW5fbm9kZShvcGVuZWQsIGZhbHNlLCAwKTtcclxuXHRcdFx0XHR0aGlzLnNlbGVjdF9ub2RlKHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCk7XHJcblx0XHRcdFx0LyoqXHJcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIHJlZnJlc2hlZFxyXG5cdFx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHRcdCAqIEBuYW1lIHJlZnJlc2hfbm9kZS5qc3RyZWVcclxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSAtIHRoZSByZWZyZXNoZWQgbm9kZVxyXG5cdFx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IG5vZGVzIC0gYW4gYXJyYXkgb2YgdGhlIElEcyBvZiB0aGUgbm9kZXMgdGhhdCB3ZXJlIHJlbG9hZGVkXHJcblx0XHRcdFx0ICovXHJcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCdyZWZyZXNoX25vZGUnLCB7ICdub2RlJyA6IG9iaiwgJ25vZGVzJyA6IG5vZGVzIH0pO1xyXG5cdFx0XHR9LCB0aGlzKSk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBzZXQgKGNoYW5nZSkgdGhlIElEIG9mIGEgbm9kZVxyXG5cdFx0ICogQG5hbWUgc2V0X2lkKG9iaiwgaWQpXHJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlXHJcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IGlkIHRoZSBuZXcgSURcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XHJcblx0XHQgKi9cclxuXHRcdHNldF9pZCA6IGZ1bmN0aW9uIChvYmosIGlkKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICcjJykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0dmFyIGksIGosIG0gPSB0aGlzLl9tb2RlbC5kYXRhO1xyXG5cdFx0XHRpZCA9IGlkLnRvU3RyaW5nKCk7XHJcblx0XHRcdC8vIHVwZGF0ZSBwYXJlbnRzIChyZXBsYWNlIGN1cnJlbnQgSUQgd2l0aCBuZXcgb25lIGluIGNoaWxkcmVuIGFuZCBjaGlsZHJlbl9kKVxyXG5cdFx0XHRtW29iai5wYXJlbnRdLmNoaWxkcmVuWyQuaW5BcnJheShvYmouaWQsIG1bb2JqLnBhcmVudF0uY2hpbGRyZW4pXSA9IGlkO1xyXG5cdFx0XHRmb3IoaSA9IDAsIGogPSBvYmoucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRtW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kWyQuaW5BcnJheShvYmouaWQsIG1bb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QpXSA9IGlkO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIHVwZGF0ZSBjaGlsZHJlbiAocmVwbGFjZSBjdXJyZW50IElEIHdpdGggbmV3IG9uZSBpbiBwYXJlbnQgYW5kIHBhcmVudHMpXHJcblx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRtW29iai5jaGlsZHJlbltpXV0ucGFyZW50ID0gaWQ7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkcmVuX2QubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0bVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50c1skLmluQXJyYXkob2JqLmlkLCBtW29iai5jaGlsZHJlbl9kW2ldXS5wYXJlbnRzKV0gPSBpZDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpID0gJC5pbkFycmF5KG9iai5pZCwgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkKTtcclxuXHRcdFx0aWYoaSAhPT0gLTEpIHsgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkW2ldID0gaWQ7IH1cclxuXHRcdFx0Ly8gdXBkYXRlIG1vZGVsIGFuZCBvYmogaXRzZWxmIChvYmouaWQsIHRoaXMuX21vZGVsLmRhdGFbS0VZXSlcclxuXHRcdFx0aSA9IHRoaXMuZ2V0X25vZGUob2JqLmlkLCB0cnVlKTtcclxuXHRcdFx0aWYoaSkge1xyXG5cdFx0XHRcdGkuYXR0cignaWQnLCBpZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGVsZXRlIG1bb2JqLmlkXTtcclxuXHRcdFx0b2JqLmlkID0gaWQ7XHJcblx0XHRcdG1baWRdID0gb2JqO1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGdldCB0aGUgdGV4dCB2YWx1ZSBvZiBhIG5vZGVcclxuXHRcdCAqIEBuYW1lIGdldF90ZXh0KG9iailcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0X3RleHQgOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0cmV0dXJuICghb2JqIHx8IG9iai5pZCA9PT0gJyMnKSA/IGZhbHNlIDogb2JqLnRleHQ7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBzZXQgdGhlIHRleHQgdmFsdWUgb2YgYSBub2RlLiBVc2VkIGludGVybmFsbHksIHBsZWFzZSB1c2UgYHJlbmFtZV9ub2RlKG9iaiwgdmFsKWAuXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQG5hbWUgc2V0X3RleHQob2JqLCB2YWwpXHJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIHRoZSBub2RlLCB5b3UgY2FuIHBhc3MgYW4gYXJyYXkgdG8gc2V0IHRoZSB0ZXh0IG9uIG11bHRpcGxlIG5vZGVzXHJcblx0XHQgKiBAcGFyYW0gIHtTdHJpbmd9IHZhbCB0aGUgbmV3IHRleHQgdmFsdWVcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XHJcblx0XHQgKiBAdHJpZ2dlciBzZXRfdGV4dC5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0c2V0X3RleHQgOiBmdW5jdGlvbiAob2JqLCB2YWwpIHtcclxuXHRcdFx0dmFyIHQxLCB0MjtcclxuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcclxuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcclxuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcclxuXHRcdFx0XHRcdHRoaXMuc2V0X3RleHQob2JqW3QxXSwgdmFsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRvYmoudGV4dCA9IHZhbDtcclxuXHRcdFx0aWYodGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmxlbmd0aCkge1xyXG5cdFx0XHRcdHRoaXMucmVkcmF3X25vZGUob2JqLmlkKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIHRleHQgdmFsdWUgaXMgY2hhbmdlZFxyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgc2V0X3RleHQuanN0cmVlXHJcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHRleHQgdGhlIG5ldyB2YWx1ZVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0dGhpcy50cmlnZ2VyKCdzZXRfdGV4dCcseyBcIm9ialwiIDogb2JqLCBcInRleHRcIiA6IHZhbCB9KTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBnZXRzIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIG5vZGUgKG9yIHRoZSB3aG9sZSB0cmVlKVxyXG5cdFx0ICogQG5hbWUgZ2V0X2pzb24oW29iaiwgb3B0aW9uc10pXHJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXHJcblx0XHQgKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcclxuXHRcdCAqIEBwYXJhbSAge0Jvb2xlYW59IG9wdGlvbnMubm9fc3RhdGUgZG8gbm90IHJldHVybiBzdGF0ZSBpbmZvcm1hdGlvblxyXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gb3B0aW9ucy5ub19pZCBkbyBub3QgcmV0dXJuIElEXHJcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX2NoaWxkcmVuIGRvIG5vdCBpbmNsdWRlIGNoaWxkcmVuXHJcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLm5vX2RhdGEgZG8gbm90IGluY2x1ZGUgbm9kZSBkYXRhXHJcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBvcHRpb25zLmZsYXQgcmV0dXJuIGZsYXQgSlNPTiBpbnN0ZWFkIG9mIG5lc3RlZFxyXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxyXG5cdFx0ICovXHJcblx0XHRnZXRfanNvbiA6IGZ1bmN0aW9uIChvYmosIG9wdGlvbnMsIGZsYXQpIHtcclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmogfHwgJyMnKTtcclxuXHRcdFx0aWYoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLmZsYXQgJiYgIWZsYXQpIHsgZmxhdCA9IFtdOyB9XHJcblx0XHRcdHZhciB0bXAgPSB7XHJcblx0XHRcdFx0J2lkJyA6IG9iai5pZCxcclxuXHRcdFx0XHQndGV4dCcgOiBvYmoudGV4dCxcclxuXHRcdFx0XHQnaWNvbicgOiB0aGlzLmdldF9pY29uKG9iaiksXHJcblx0XHRcdFx0J2xpX2F0dHInIDogJC5leHRlbmQodHJ1ZSwge30sIG9iai5saV9hdHRyKSxcclxuXHRcdFx0XHQnYV9hdHRyJyA6ICQuZXh0ZW5kKHRydWUsIHt9LCBvYmouYV9hdHRyKSxcclxuXHRcdFx0XHQnc3RhdGUnIDoge30sXHJcblx0XHRcdFx0J2RhdGEnIDogb3B0aW9ucyAmJiBvcHRpb25zLm5vX2RhdGEgPyBmYWxzZSA6ICQuZXh0ZW5kKHRydWUsIHt9LCBvYmouZGF0YSlcclxuXHRcdFx0XHQvLyggdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmxlbmd0aCA/IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5kYXRhKCkgOiBvYmouZGF0YSApLFxyXG5cdFx0XHR9LCBpLCBqO1xyXG5cdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMuZmxhdCkge1xyXG5cdFx0XHRcdHRtcC5wYXJlbnQgPSBvYmoucGFyZW50O1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdHRtcC5jaGlsZHJlbiA9IFtdO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCFvcHRpb25zIHx8ICFvcHRpb25zLm5vX3N0YXRlKSB7XHJcblx0XHRcdFx0Zm9yKGkgaW4gb2JqLnN0YXRlKSB7XHJcblx0XHRcdFx0XHRpZihvYmouc3RhdGUuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuXHRcdFx0XHRcdFx0dG1wLnN0YXRlW2ldID0gb2JqLnN0YXRlW2ldO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMubm9faWQpIHtcclxuXHRcdFx0XHRkZWxldGUgdG1wLmlkO1xyXG5cdFx0XHRcdGlmKHRtcC5saV9hdHRyICYmIHRtcC5saV9hdHRyLmlkKSB7XHJcblx0XHRcdFx0XHRkZWxldGUgdG1wLmxpX2F0dHIuaWQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHRtcC5hX2F0dHIgJiYgdG1wLmFfYXR0ci5pZCkge1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHRtcC5hX2F0dHIuaWQ7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0ICYmIG9iai5pZCAhPT0gJyMnKSB7XHJcblx0XHRcdFx0ZmxhdC5wdXNoKHRtcCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIW9wdGlvbnMgfHwgIW9wdGlvbnMubm9fY2hpbGRyZW4pIHtcclxuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMuZmxhdCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmdldF9qc29uKG9iai5jaGlsZHJlbltpXSwgb3B0aW9ucywgZmxhdCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuLnB1c2godGhpcy5nZXRfanNvbihvYmouY2hpbGRyZW5baV0sIG9wdGlvbnMpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5mbGF0ID8gZmxhdCA6IChvYmouaWQgPT09ICcjJyA/IHRtcC5jaGlsZHJlbiA6IHRtcCk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBjcmVhdGUgYSBuZXcgbm9kZSAoZG8gbm90IGNvbmZ1c2Ugd2l0aCBsb2FkX25vZGUpXHJcblx0XHQgKiBAbmFtZSBjcmVhdGVfbm9kZShbb2JqLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWRdKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICAgcGFyICAgICAgIHRoZSBwYXJlbnQgbm9kZSAodG8gY3JlYXRlIGEgcm9vdCBub2RlIHVzZSBlaXRoZXIgXCIjXCIgKHN0cmluZykgb3IgYG51bGxgKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICAgbm9kZSAgICAgIHRoZSBkYXRhIGZvciB0aGUgbmV3IG5vZGUgKGEgdmFsaWQgSlNPTiBvYmplY3QsIG9yIGEgc2ltcGxlIHN0cmluZyB3aXRoIHRoZSBuYW1lKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICAgcG9zICAgICAgIHRoZSBpbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIG5vZGUsIFwiZmlyc3RcIiBhbmQgXCJsYXN0XCIgYXJlIGFsc28gc3VwcG9ydGVkLCBkZWZhdWx0IGlzIFwibGFzdFwiXHJcblx0XHQgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSB0aGUgbm9kZSBpcyBjcmVhdGVkXHJcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBpc19sb2FkZWQgaW50ZXJuYWwgYXJndW1lbnQgaW5kaWNhdGluZyBpZiB0aGUgcGFyZW50IG5vZGUgd2FzIHN1Y2Nlc2Z1bGx5IGxvYWRlZFxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfSAgICAgICAgICAgIHRoZSBJRCBvZiB0aGUgbmV3bHkgY3JlYXRlIG5vZGVcclxuXHRcdCAqIEB0cmlnZ2VyIG1vZGVsLmpzdHJlZSwgY3JlYXRlX25vZGUuanN0cmVlXHJcblx0XHQgKi9cclxuXHRcdGNyZWF0ZV9ub2RlIDogZnVuY3Rpb24gKHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKSB7XHJcblx0XHRcdGlmKHBhciA9PT0gbnVsbCkgeyBwYXIgPSBcIiNcIjsgfVxyXG5cdFx0XHRwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XHJcblx0XHRcdGlmKCFwYXIpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdHBvcyA9IHBvcyA9PT0gdW5kZWZpbmVkID8gXCJsYXN0XCIgOiBwb3M7XHJcblx0XHRcdGlmKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pICYmICFpc19sb2FkZWQgJiYgIXRoaXMuaXNfbG9hZGVkKHBhcikpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5sb2FkX25vZGUocGFyLCBmdW5jdGlvbiAoKSB7IHRoaXMuY3JlYXRlX25vZGUocGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCB0cnVlKTsgfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIW5vZGUpIHsgbm9kZSA9IHsgXCJ0ZXh0XCIgOiB0aGlzLmdldF9zdHJpbmcoJ05ldyBub2RlJykgfTsgfVxyXG5cdFx0XHRpZih0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikgeyBub2RlID0geyBcInRleHRcIiA6IG5vZGUgfTsgfVxyXG5cdFx0XHRpZihub2RlLnRleHQgPT09IHVuZGVmaW5lZCkgeyBub2RlLnRleHQgPSB0aGlzLmdldF9zdHJpbmcoJ05ldyBub2RlJyk7IH1cclxuXHRcdFx0dmFyIHRtcCwgZHBjLCBpLCBqO1xyXG5cclxuXHRcdFx0aWYocGFyLmlkID09PSAnIycpIHtcclxuXHRcdFx0XHRpZihwb3MgPT09IFwiYmVmb3JlXCIpIHsgcG9zID0gXCJmaXJzdFwiOyB9XHJcblx0XHRcdFx0aWYocG9zID09PSBcImFmdGVyXCIpIHsgcG9zID0gXCJsYXN0XCI7IH1cclxuXHRcdFx0fVxyXG5cdFx0XHRzd2l0Y2gocG9zKSB7XHJcblx0XHRcdFx0Y2FzZSBcImJlZm9yZVwiOlxyXG5cdFx0XHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcclxuXHRcdFx0XHRcdHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIHRtcC5jaGlsZHJlbik7XHJcblx0XHRcdFx0XHRwYXIgPSB0bXA7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFwiYWZ0ZXJcIiA6XHJcblx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xyXG5cdFx0XHRcdFx0cG9zID0gJC5pbkFycmF5KHBhci5pZCwgdG1wLmNoaWxkcmVuKSArIDE7XHJcblx0XHRcdFx0XHRwYXIgPSB0bXA7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFwiaW5zaWRlXCI6XHJcblx0XHRcdFx0Y2FzZSBcImZpcnN0XCI6XHJcblx0XHRcdFx0XHRwb3MgPSAwO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBcImxhc3RcIjpcclxuXHRcdFx0XHRcdHBvcyA9IHBhci5jaGlsZHJlbi5sZW5ndGg7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0aWYoIXBvcykgeyBwb3MgPSAwOyB9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihwb3MgPiBwYXIuY2hpbGRyZW4ubGVuZ3RoKSB7IHBvcyA9IHBhci5jaGlsZHJlbi5sZW5ndGg7IH1cclxuXHRcdFx0aWYoIW5vZGUuaWQpIHsgbm9kZS5pZCA9IHRydWU7IH1cclxuXHRcdFx0aWYoIXRoaXMuY2hlY2soXCJjcmVhdGVfbm9kZVwiLCBub2RlLCBwYXIsIHBvcykpIHtcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKG5vZGUuaWQgPT09IHRydWUpIHsgZGVsZXRlIG5vZGUuaWQ7IH1cclxuXHRcdFx0bm9kZSA9IHRoaXMuX3BhcnNlX21vZGVsX2Zyb21fanNvbihub2RlLCBwYXIuaWQsIHBhci5wYXJlbnRzLmNvbmNhdCgpKTtcclxuXHRcdFx0aWYoIW5vZGUpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUobm9kZSk7XHJcblx0XHRcdGRwYyA9IFtdO1xyXG5cdFx0XHRkcGMucHVzaChub2RlKTtcclxuXHRcdFx0ZHBjID0gZHBjLmNvbmNhdCh0bXAuY2hpbGRyZW5fZCk7XHJcblx0XHRcdHRoaXMudHJpZ2dlcignbW9kZWwnLCB7IFwibm9kZXNcIiA6IGRwYywgXCJwYXJlbnRcIiA6IHBhci5pZCB9KTtcclxuXHJcblx0XHRcdHBhci5jaGlsZHJlbl9kID0gcGFyLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XHJcblx0XHRcdGZvcihpID0gMCwgaiA9IHBhci5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSB0aGlzLl9tb2RlbC5kYXRhW3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kLmNvbmNhdChkcGMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUgPSB0bXA7XHJcblx0XHRcdHRtcCA9IFtdO1xyXG5cdFx0XHRmb3IoaSA9IDAsIGogPSBwYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0dG1wW2kgPj0gcG9zID8gaSsxIDogaV0gPSBwYXIuY2hpbGRyZW5baV07XHJcblx0XHRcdH1cclxuXHRcdFx0dG1wW3Bvc10gPSBub2RlLmlkO1xyXG5cdFx0XHRwYXIuY2hpbGRyZW4gPSB0bXA7XHJcblxyXG5cdFx0XHR0aGlzLnJlZHJhd19ub2RlKHBhciwgdHJ1ZSk7XHJcblx0XHRcdGlmKGNhbGxiYWNrKSB7IGNhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5nZXRfbm9kZShub2RlKSk7IH1cclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGEgbm9kZSBpcyBjcmVhdGVkXHJcblx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHQgKiBAbmFtZSBjcmVhdGVfbm9kZS5qc3RyZWVcclxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcclxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcclxuXHRcdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBvZiB0aGUgbmV3IG5vZGUgYW1vbmcgdGhlIHBhcmVudCdzIGNoaWxkcmVuXHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2NyZWF0ZV9ub2RlJywgeyBcIm5vZGVcIiA6IHRoaXMuZ2V0X25vZGUobm9kZSksIFwicGFyZW50XCIgOiBwYXIuaWQsIFwicG9zaXRpb25cIiA6IHBvcyB9KTtcclxuXHRcdFx0cmV0dXJuIG5vZGUuaWQ7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBzZXQgdGhlIHRleHQgdmFsdWUgb2YgYSBub2RlXHJcblx0XHQgKiBAbmFtZSByZW5hbWVfbm9kZShvYmosIHZhbClcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUsIHlvdSBjYW4gcGFzcyBhbiBhcnJheSB0byByZW5hbWUgbXVsdGlwbGUgbm9kZXMgdG8gdGhlIHNhbWUgbmFtZVxyXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSB2YWwgdGhlIG5ldyB0ZXh0IHZhbHVlXHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdFx0ICogQHRyaWdnZXIgcmVuYW1lX25vZGUuanN0cmVlXHJcblx0XHQgKi9cclxuXHRcdHJlbmFtZV9ub2RlIDogZnVuY3Rpb24gKG9iaiwgdmFsKSB7XHJcblx0XHRcdHZhciB0MSwgdDIsIG9sZDtcclxuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcclxuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcclxuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcclxuXHRcdFx0XHRcdHRoaXMucmVuYW1lX25vZGUob2JqW3QxXSwgdmFsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRvbGQgPSBvYmoudGV4dDtcclxuXHRcdFx0aWYoIXRoaXMuY2hlY2soXCJyZW5hbWVfbm9kZVwiLCBvYmosIHRoaXMuZ2V0X3BhcmVudChvYmopLCB2YWwpKSB7XHJcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnNldF90ZXh0KG9iaiwgdmFsKTsgLy8gLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgcmVuYW1lZFxyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgcmVuYW1lX25vZGUuanN0cmVlXHJcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXHJcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0ZXh0IHRoZSBuZXcgdmFsdWVcclxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IG9sZCB0aGUgb2xkIHZhbHVlXHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3JlbmFtZV9ub2RlJywgeyBcIm5vZGVcIiA6IG9iaiwgXCJ0ZXh0XCIgOiB2YWwsIFwib2xkXCIgOiBvbGQgfSk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogcmVtb3ZlIGEgbm9kZVxyXG5cdFx0ICogQG5hbWUgZGVsZXRlX25vZGUob2JqKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSwgeW91IGNhbiBwYXNzIGFuIGFycmF5IHRvIGRlbGV0ZSBtdWx0aXBsZSBub2Rlc1xyXG5cdFx0ICogQHJldHVybiB7Qm9vbGVhbn1cclxuXHRcdCAqIEB0cmlnZ2VyIGRlbGV0ZV9ub2RlLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0ZGVsZXRlX25vZGUgOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRcdHZhciB0MSwgdDIsIHBhciwgcG9zLCB0bXAsIGksIGosIGssIGwsIGM7XHJcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XHJcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XHJcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XHJcblx0XHRcdFx0XHR0aGlzLmRlbGV0ZV9ub2RlKG9ialt0MV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XHJcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdHBhciA9IHRoaXMuZ2V0X25vZGUob2JqLnBhcmVudCk7XHJcblx0XHRcdHBvcyA9ICQuaW5BcnJheShvYmouaWQsIHBhci5jaGlsZHJlbik7XHJcblx0XHRcdGMgPSBmYWxzZTtcclxuXHRcdFx0aWYoIXRoaXMuY2hlY2soXCJkZWxldGVfbm9kZVwiLCBvYmosIHBhciwgcG9zKSkge1xyXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MuY29yZS5lcnJvci5jYWxsKHRoaXMsIHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yKTtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYocG9zICE9PSAtMSkge1xyXG5cdFx0XHRcdHBhci5jaGlsZHJlbiA9ICQudmFrYXRhLmFycmF5X3JlbW92ZShwYXIuY2hpbGRyZW4sIHBvcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0dG1wID0gb2JqLmNoaWxkcmVuX2QuY29uY2F0KFtdKTtcclxuXHRcdFx0dG1wLnB1c2gob2JqLmlkKTtcclxuXHRcdFx0Zm9yKGsgPSAwLCBsID0gdG1wLmxlbmd0aDsgayA8IGw7IGsrKykge1xyXG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0cG9zID0gJC5pbkFycmF5KHRtcFtrXSwgdGhpcy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZCk7XHJcblx0XHRcdFx0XHRpZihwb3MgIT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSAkLnZha2F0YS5hcnJheV9yZW1vdmUodGhpcy5fbW9kZWwuZGF0YVtvYmoucGFyZW50c1tpXV0uY2hpbGRyZW5fZCwgcG9zKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodGhpcy5fbW9kZWwuZGF0YVt0bXBba11dLnN0YXRlLnNlbGVjdGVkKSB7XHJcblx0XHRcdFx0XHRjID0gdHJ1ZTtcclxuXHRcdFx0XHRcdHBvcyA9ICQuaW5BcnJheSh0bXBba10sIHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCk7XHJcblx0XHRcdFx0XHRpZihwb3MgIT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X3JlbW92ZSh0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsIHBvcyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgZGVsZXRlZFxyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgZGVsZXRlX25vZGUuanN0cmVlXHJcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXHJcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCdzIElEXHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2RlbGV0ZV9ub2RlJywgeyBcIm5vZGVcIiA6IG9iaiwgXCJwYXJlbnRcIiA6IHBhci5pZCB9KTtcclxuXHRcdFx0aWYoYykge1xyXG5cdFx0XHRcdHRoaXMudHJpZ2dlcignY2hhbmdlZCcsIHsgJ2FjdGlvbicgOiAnZGVsZXRlX25vZGUnLCAnbm9kZScgOiBvYmosICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQsICdwYXJlbnQnIDogcGFyLmlkIH0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcihrID0gMCwgbCA9IHRtcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcclxuXHRcdFx0XHRkZWxldGUgdGhpcy5fbW9kZWwuZGF0YVt0bXBba11dO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMucmVkcmF3X25vZGUocGFyLCB0cnVlKTtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBjaGVjayBpZiBhbiBvcGVyYXRpb24gaXMgcHJlbWl0dGVkIG9uIHRoZSB0cmVlLiBVc2VkIGludGVybmFsbHkuXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQG5hbWUgY2hlY2soY2hrLCBvYmosIHBhciwgcG9zKVxyXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBjaGsgdGhlIG9wZXJhdGlvbiB0byBjaGVjaywgY2FuIGJlIFwiY3JlYXRlX25vZGVcIiwgXCJyZW5hbWVfbm9kZVwiLCBcImRlbGV0ZV9ub2RlXCIsIFwiY29weV9ub2RlXCIgb3IgXCJtb3ZlX25vZGVcIlxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IHBhciB0aGUgcGFyZW50XHJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gcG9zIHRoZSBwb3NpdGlvbiB0byBpbnNlcnQgYXQsIG9yIGlmIFwicmVuYW1lX25vZGVcIiAtIHRoZSBuZXcgbmFtZVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG1vcmUgc29tZSB2YXJpb3VzIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24sIGZvciBleGFtcGxlIGlmIGEgXCJtb3ZlX25vZGVcIiBvcGVyYXRpb25zIGlzIHRyaWdnZXJlZCBieSBETkQgdGhpcyB3aWxsIGJlIHRoZSBob3ZlcmVkIG5vZGVcclxuXHRcdCAqIEByZXR1cm4ge0Jvb2xlYW59XHJcblx0XHQgKi9cclxuXHRcdGNoZWNrIDogZnVuY3Rpb24gKGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkge1xyXG5cdFx0XHRvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRwYXIgPSBwYXIgJiYgcGFyLmlkID8gcGFyIDogdGhpcy5nZXRfbm9kZShwYXIpO1xyXG5cdFx0XHR2YXIgdG1wID0gY2hrLm1hdGNoKC9ebW92ZV9ub2RlfGNvcHlfbm9kZXxjcmVhdGVfbm9kZSQvaSkgPyBwYXIgOiBvYmosXHJcblx0XHRcdFx0Y2hjID0gdGhpcy5zZXR0aW5ncy5jb3JlLmNoZWNrX2NhbGxiYWNrO1xyXG5cdFx0XHRpZihjaGsgPT09IFwibW92ZV9ub2RlXCIgfHwgY2hrID09PSBcImNvcHlfbm9kZVwiKSB7XHJcblx0XHRcdFx0aWYoKCFtb3JlIHx8ICFtb3JlLmlzX211bHRpKSAmJiAob2JqLmlkID09PSBwYXIuaWQgfHwgJC5pbkFycmF5KG9iai5pZCwgcGFyLmNoaWxkcmVuKSA9PT0gcG9zIHx8ICQuaW5BcnJheShwYXIuaWQsIG9iai5jaGlsZHJlbl9kKSAhPT0gLTEpKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdjaGVjaycsICdwbHVnaW4nIDogJ2NvcmUnLCAnaWQnIDogJ2NvcmVfMDEnLCAncmVhc29uJyA6ICdNb3ZpbmcgcGFyZW50IGluc2lkZSBjaGlsZCcsICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodG1wICYmIHRtcC5kYXRhKSB7IHRtcCA9IHRtcC5kYXRhOyB9XHJcblx0XHRcdGlmKHRtcCAmJiB0bXAuZnVuY3Rpb25zICYmICh0bXAuZnVuY3Rpb25zW2Noa10gPT09IGZhbHNlIHx8IHRtcC5mdW5jdGlvbnNbY2hrXSA9PT0gdHJ1ZSkpIHtcclxuXHRcdFx0XHRpZih0bXAuZnVuY3Rpb25zW2Noa10gPT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdjaGVjaycsICdwbHVnaW4nIDogJ2NvcmUnLCAnaWQnIDogJ2NvcmVfMDInLCAncmVhc29uJyA6ICdOb2RlIGRhdGEgcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRtcC5mdW5jdGlvbnNbY2hrXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihjaGMgPT09IGZhbHNlIHx8ICgkLmlzRnVuY3Rpb24oY2hjKSAmJiBjaGMuY2FsbCh0aGlzLCBjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpID09PSBmYWxzZSkgfHwgKGNoYyAmJiBjaGNbY2hrXSA9PT0gZmFsc2UpKSB7XHJcblx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICdjb3JlJywgJ2lkJyA6ICdjb3JlXzAzJywgJ3JlYXNvbicgOiAnVXNlciBjb25maWcgZm9yIGNvcmUuY2hlY2tfY2FsbGJhY2sgcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBnZXQgdGhlIGxhc3QgZXJyb3JcclxuXHRcdCAqIEBuYW1lIGxhc3RfZXJyb3IoKVxyXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxyXG5cdFx0ICovXHJcblx0XHRsYXN0X2Vycm9yIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3I7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBtb3ZlIGEgbm9kZSB0byBhIG5ldyBwYXJlbnRcclxuXHRcdCAqIEBuYW1lIG1vdmVfbm9kZShvYmosIHBhciBbLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWRdKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbm9kZSB0byBtb3ZlLCBwYXNzIGFuIGFycmF5IHRvIG1vdmUgbXVsdGlwbGUgbm9kZXNcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBwYXIgdGhlIG5ldyBwYXJlbnRcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBwb3MgdGhlIHBvc2l0aW9uIHRvIGluc2VydCBhdCAoYmVzaWRlcyBpbnRlZ2VyIHZhbHVlcywgXCJmaXJzdFwiIGFuZCBcImxhc3RcIiBhcmUgc3VwcG9ydGVkLCBhcyB3ZWxsIGFzIFwiYmVmb3JlXCIgYW5kIFwiYWZ0ZXJcIiksIGRlZmF1bHRzIHRvIGludGVnZXIgYDBgXHJcblx0XHQgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgYSBmdW5jdGlvbiB0byBjYWxsIG9uY2UgdGhlIG1vdmUgaXMgY29tcGxldGVkLCByZWNlaXZlcyAzIGFyZ3VtZW50cyAtIHRoZSBub2RlLCB0aGUgbmV3IHBhcmVudCBhbmQgdGhlIHBvc2l0aW9uXHJcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgcGFyZW50IG5vZGUgaGFzIGJlZW4gbG9hZGVkXHJcblx0XHQgKiBAcGFyYW0gIHtCb29sZWFufSBpbnRlcm5hbCBwYXJhbWV0ZXIgaW5kaWNhdGluZyBpZiB0aGUgdHJlZSBzaG91bGQgYmUgcmVkcmF3blxyXG5cdFx0ICogQHRyaWdnZXIgbW92ZV9ub2RlLmpzdHJlZVxyXG5cdFx0ICovXHJcblx0XHRtb3ZlX25vZGUgOiBmdW5jdGlvbiAob2JqLCBwYXIsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCwgc2tpcF9yZWRyYXcpIHtcclxuXHRcdFx0dmFyIHQxLCB0Miwgb2xkX3Bhciwgb2xkX3BvcywgbmV3X3Bhciwgb2xkX2lucywgaXNfbXVsdGksIGRwYywgdG1wLCBpLCBqLCBrLCBsLCBwO1xyXG5cclxuXHRcdFx0cGFyID0gdGhpcy5nZXRfbm9kZShwYXIpO1xyXG5cdFx0XHRwb3MgPSBwb3MgPT09IHVuZGVmaW5lZCA/IDAgOiBwb3M7XHJcblx0XHRcdGlmKCFwYXIpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdGlmKCFwb3MudG9TdHJpbmcoKS5tYXRjaCgvXihiZWZvcmV8YWZ0ZXIpJC8pICYmICFpc19sb2FkZWQgJiYgIXRoaXMuaXNfbG9hZGVkKHBhcikpIHtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5sb2FkX25vZGUocGFyLCBmdW5jdGlvbiAoKSB7IHRoaXMubW92ZV9ub2RlKG9iaiwgcGFyLCBwb3MsIGNhbGxiYWNrLCB0cnVlKTsgfSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XHJcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XHJcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XHJcblx0XHRcdFx0XHRpZih0aGlzLm1vdmVfbm9kZShvYmpbdDFdLCBwYXIsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCwgdHJ1ZSkpIHtcclxuXHRcdFx0XHRcdFx0cGFyID0gb2JqW3QxXTtcclxuXHRcdFx0XHRcdFx0cG9zID0gXCJhZnRlclwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdG9iaiA9IG9iaiAmJiBvYmouaWQgPyBvYmogOiB0aGlzLmdldF9ub2RlKG9iaik7XHJcblxyXG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdFx0b2xkX3BhciA9IChvYmoucGFyZW50IHx8ICcjJykudG9TdHJpbmcoKTtcclxuXHRcdFx0bmV3X3BhciA9ICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSB8fCBwYXIuaWQgPT09ICcjJykgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xyXG5cdFx0XHRvbGRfaW5zID0gb2JqLmluc3RhbmNlID8gb2JqLmluc3RhbmNlIDogKHRoaXMuX21vZGVsLmRhdGFbb2JqLmlkXSA/IHRoaXMgOiAkLmpzdHJlZS5yZWZlcmVuY2Uob2JqLmlkKSk7XHJcblx0XHRcdGlzX211bHRpID0gIW9sZF9pbnMgfHwgIW9sZF9pbnMuX2lkIHx8ICh0aGlzLl9pZCAhPT0gb2xkX2lucy5faWQpO1xyXG5cdFx0XHRvbGRfcG9zID0gb2xkX2lucyAmJiBvbGRfaW5zLl9pZCAmJiBvbGRfcGFyICYmIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0gJiYgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXS5jaGlsZHJlbiA/ICQuaW5BcnJheShvYmouaWQsIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4pIDogLTE7XHJcblx0XHRcdGlmKGlzX211bHRpKSB7XHJcblx0XHRcdFx0aWYodGhpcy5jb3B5X25vZGUob2JqLCBwYXIsIHBvcywgY2FsbGJhY2ssIGlzX2xvYWRlZCkpIHtcclxuXHRcdFx0XHRcdGlmKG9sZF9pbnMpIHsgb2xkX2lucy5kZWxldGVfbm9kZShvYmopOyB9XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vdmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhO1xyXG5cdFx0XHRpZihwYXIuaWQgPT09ICcjJykge1xyXG5cdFx0XHRcdGlmKHBvcyA9PT0gXCJiZWZvcmVcIikgeyBwb3MgPSBcImZpcnN0XCI7IH1cclxuXHRcdFx0XHRpZihwb3MgPT09IFwiYWZ0ZXJcIikgeyBwb3MgPSBcImxhc3RcIjsgfVxyXG5cdFx0XHR9XHJcblx0XHRcdHN3aXRjaChwb3MpIHtcclxuXHRcdFx0XHRjYXNlIFwiYmVmb3JlXCI6XHJcblx0XHRcdFx0XHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgXCJhZnRlclwiIDpcclxuXHRcdFx0XHRcdHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIG5ld19wYXIuY2hpbGRyZW4pICsgMTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgXCJpbnNpZGVcIjpcclxuXHRcdFx0XHRjYXNlIFwiZmlyc3RcIjpcclxuXHRcdFx0XHRcdHBvcyA9IDA7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFwibGFzdFwiOlxyXG5cdFx0XHRcdFx0cG9zID0gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGg7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0aWYoIXBvcykgeyBwb3MgPSAwOyB9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihwb3MgPiBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aCkgeyBwb3MgPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDsgfVxyXG5cdFx0XHRpZighdGhpcy5jaGVjayhcIm1vdmVfbm9kZVwiLCBvYmosIG5ld19wYXIsIHBvcywgeyAnY29yZScgOiB0cnVlLCAnaXNfbXVsdGknIDogKG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX2lucy5faWQgIT09IHRoaXMuX2lkKSwgJ2lzX2ZvcmVpZ24nIDogKCFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCkgfSkpIHtcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKG9iai5wYXJlbnQgPT09IG5ld19wYXIuaWQpIHtcclxuXHRcdFx0XHRkcGMgPSBuZXdfcGFyLmNoaWxkcmVuLmNvbmNhdCgpO1xyXG5cdFx0XHRcdHRtcCA9ICQuaW5BcnJheShvYmouaWQsIGRwYyk7XHJcblx0XHRcdFx0aWYodG1wICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0ZHBjID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlKGRwYywgdG1wKTtcclxuXHRcdFx0XHRcdGlmKHBvcyA+IHRtcCkgeyBwb3MtLTsgfVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0bXAgPSBbXTtcclxuXHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkcGMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHR0bXBbaSA+PSBwb3MgPyBpKzEgOiBpXSA9IGRwY1tpXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dG1wW3Bvc10gPSBvYmouaWQ7XHJcblx0XHRcdFx0bmV3X3Bhci5jaGlsZHJlbiA9IHRtcDtcclxuXHRcdFx0XHR0aGlzLl9ub2RlX2NoYW5nZWQobmV3X3Bhci5pZCk7XHJcblx0XHRcdFx0dGhpcy5yZWRyYXcobmV3X3Bhci5pZCA9PT0gJyMnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHQvLyBjbGVhbiBvbGQgcGFyZW50IGFuZCB1cFxyXG5cdFx0XHRcdHRtcCA9IG9iai5jaGlsZHJlbl9kLmNvbmNhdCgpO1xyXG5cdFx0XHRcdHRtcC5wdXNoKG9iai5pZCk7XHJcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRkcGMgPSBbXTtcclxuXHRcdFx0XHRcdHAgPSBvbGRfaW5zLl9tb2RlbC5kYXRhW29iai5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kO1xyXG5cdFx0XHRcdFx0Zm9yKGsgPSAwLCBsID0gcC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0aWYoJC5pbkFycmF5KHBba10sIHRtcCkgPT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdFx0ZHBjLnB1c2gocFtrXSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdG9sZF9pbnMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QgPSBkcGM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4gPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbShvbGRfaW5zLl9tb2RlbC5kYXRhW29sZF9wYXJdLmNoaWxkcmVuLCBvYmouaWQpO1xyXG5cclxuXHRcdFx0XHQvLyBpbnNlcnQgaW50byBuZXcgcGFyZW50IGFuZCB1cFxyXG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG5ld19wYXIucGFyZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbbmV3X3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtuZXdfcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KHRtcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGRwYyA9IFtdO1xyXG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRkcGNbaSA+PSBwb3MgPyBpKzEgOiBpXSA9IG5ld19wYXIuY2hpbGRyZW5baV07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGRwY1twb3NdID0gb2JqLmlkO1xyXG5cdFx0XHRcdG5ld19wYXIuY2hpbGRyZW4gPSBkcGM7XHJcblx0XHRcdFx0bmV3X3Bhci5jaGlsZHJlbl9kLnB1c2gob2JqLmlkKTtcclxuXHRcdFx0XHRuZXdfcGFyLmNoaWxkcmVuX2QgPSBuZXdfcGFyLmNoaWxkcmVuX2QuY29uY2F0KG9iai5jaGlsZHJlbl9kKTtcclxuXHJcblx0XHRcdFx0Ly8gdXBkYXRlIG9iamVjdFxyXG5cdFx0XHRcdG9iai5wYXJlbnQgPSBuZXdfcGFyLmlkO1xyXG5cdFx0XHRcdHRtcCA9IG5ld19wYXIucGFyZW50cy5jb25jYXQoKTtcclxuXHRcdFx0XHR0bXAudW5zaGlmdChuZXdfcGFyLmlkKTtcclxuXHRcdFx0XHRwID0gb2JqLnBhcmVudHMubGVuZ3RoO1xyXG5cdFx0XHRcdG9iai5wYXJlbnRzID0gdG1wO1xyXG5cclxuXHRcdFx0XHQvLyB1cGRhdGUgb2JqZWN0IGNoaWxkcmVuXHJcblx0XHRcdFx0dG1wID0gdG1wLmNvbmNhdCgpO1xyXG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0dGhpcy5fbW9kZWwuZGF0YVtvYmouY2hpbGRyZW5fZFtpXV0ucGFyZW50cyA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMuc2xpY2UoMCxwKi0xKTtcclxuXHRcdFx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHRoaXMuX21vZGVsLmRhdGFbb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMsIHRtcCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZihvbGRfcGFyID09PSAnIycgfHwgbmV3X3Bhci5pZCA9PT0gJyMnKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdyA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCF0aGlzLl9tb2RlbC5mb3JjZV9mdWxsX3JlZHJhdykge1xyXG5cdFx0XHRcdFx0dGhpcy5fbm9kZV9jaGFuZ2VkKG9sZF9wYXIpO1xyXG5cdFx0XHRcdFx0dGhpcy5fbm9kZV9jaGFuZ2VkKG5ld19wYXIuaWQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZighc2tpcF9yZWRyYXcpIHtcclxuXHRcdFx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKGNhbGxiYWNrKSB7IGNhbGxiYWNrLmNhbGwodGhpcywgb2JqLCBuZXdfcGFyLCBwb3MpOyB9XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIG5vZGUgaXMgbW92ZWRcclxuXHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdCAqIEBuYW1lIG1vdmVfbm9kZS5qc3RyZWVcclxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcclxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGFyZW50J3MgSURcclxuXHRcdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBhbW9uZyB0aGUgcGFyZW50J3MgY2hpbGRyZW5cclxuXHRcdFx0ICogQHBhcmFtIHtTdHJpbmd9IG9sZF9wYXJlbnQgdGhlIG9sZCBwYXJlbnQgb2YgdGhlIG5vZGVcclxuXHRcdFx0ICogQHBhcmFtIHtOdW1iZXJ9IG9sZF9wb3NpdGlvbiB0aGUgb2xkIHBvc2l0aW9uIG9mIHRoZSBub2RlXHJcblx0XHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNfbXVsdGkgZG8gdGhlIG5vZGUgYW5kIG5ldyBwYXJlbnQgYmVsb25nIHRvIGRpZmZlcmVudCBpbnN0YW5jZXNcclxuXHRcdFx0ICogQHBhcmFtIHtqc1RyZWV9IG9sZF9pbnN0YW5jZSB0aGUgaW5zdGFuY2UgdGhlIG5vZGUgY2FtZSBmcm9tXHJcblx0XHRcdCAqIEBwYXJhbSB7anNUcmVlfSBuZXdfaW5zdGFuY2UgdGhlIGluc3RhbmNlIG9mIHRoZSBuZXcgcGFyZW50XHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ21vdmVfbm9kZScsIHsgXCJub2RlXCIgOiBvYmosIFwicGFyZW50XCIgOiBuZXdfcGFyLmlkLCBcInBvc2l0aW9uXCIgOiBwb3MsIFwib2xkX3BhcmVudFwiIDogb2xkX3BhciwgXCJvbGRfcG9zaXRpb25cIiA6IG9sZF9wb3MsICdpc19tdWx0aScgOiAob2xkX2lucyAmJiBvbGRfaW5zLl9pZCAmJiBvbGRfaW5zLl9pZCAhPT0gdGhpcy5faWQpLCAnaXNfZm9yZWlnbicgOiAoIW9sZF9pbnMgfHwgIW9sZF9pbnMuX2lkKSwgJ29sZF9pbnN0YW5jZScgOiBvbGRfaW5zLCAnbmV3X2luc3RhbmNlJyA6IHRoaXMgfSk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogY29weSBhIG5vZGUgdG8gYSBuZXcgcGFyZW50XHJcblx0XHQgKiBAbmFtZSBjb3B5X25vZGUob2JqLCBwYXIgWywgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkXSlcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY29weSwgcGFzcyBhbiBhcnJheSB0byBjb3B5IG11bHRpcGxlIG5vZGVzXHJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gcGFyIHRoZSBuZXcgcGFyZW50XHJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gcG9zIHRoZSBwb3NpdGlvbiB0byBpbnNlcnQgYXQgKGJlc2lkZXMgaW50ZWdlciB2YWx1ZXMsIFwiZmlyc3RcIiBhbmQgXCJsYXN0XCIgYXJlIHN1cHBvcnRlZCwgYXMgd2VsbCBhcyBcImJlZm9yZVwiIGFuZCBcImFmdGVyXCIpLCBkZWZhdWx0cyB0byBpbnRlZ2VyIGAwYFxyXG5cdFx0ICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIGEgZnVuY3Rpb24gdG8gY2FsbCBvbmNlIHRoZSBtb3ZlIGlzIGNvbXBsZXRlZCwgcmVjZWl2ZXMgMyBhcmd1bWVudHMgLSB0aGUgbm9kZSwgdGhlIG5ldyBwYXJlbnQgYW5kIHRoZSBwb3NpdGlvblxyXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gaW50ZXJuYWwgcGFyYW1ldGVyIGluZGljYXRpbmcgaWYgdGhlIHBhcmVudCBub2RlIGhhcyBiZWVuIGxvYWRlZFxyXG5cdFx0ICogQHBhcmFtICB7Qm9vbGVhbn0gaW50ZXJuYWwgcGFyYW1ldGVyIGluZGljYXRpbmcgaWYgdGhlIHRyZWUgc2hvdWxkIGJlIHJlZHJhd25cclxuXHRcdCAqIEB0cmlnZ2VyIG1vZGVsLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlXHJcblx0XHQgKi9cclxuXHRcdGNvcHlfbm9kZSA6IGZ1bmN0aW9uIChvYmosIHBhciwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkLCBza2lwX3JlZHJhdykge1xyXG5cdFx0XHR2YXIgdDEsIHQyLCBkcGMsIHRtcCwgaSwgaiwgbm9kZSwgb2xkX3BhciwgbmV3X3Bhciwgb2xkX2lucywgaXNfbXVsdGk7XHJcblxyXG5cdFx0XHRwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XHJcblx0XHRcdHBvcyA9IHBvcyA9PT0gdW5kZWZpbmVkID8gMCA6IHBvcztcclxuXHRcdFx0aWYoIXBhcikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0aWYoIXBvcy50b1N0cmluZygpLm1hdGNoKC9eKGJlZm9yZXxhZnRlcikkLykgJiYgIWlzX2xvYWRlZCAmJiAhdGhpcy5pc19sb2FkZWQocGFyKSkge1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmxvYWRfbm9kZShwYXIsIGZ1bmN0aW9uICgpIHsgdGhpcy5jb3B5X25vZGUob2JqLCBwYXIsIHBvcywgY2FsbGJhY2ssIHRydWUpOyB9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcclxuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcclxuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcclxuXHRcdFx0XHRcdHRtcCA9IHRoaXMuY29weV9ub2RlKG9ialt0MV0sIHBhciwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkLCB0cnVlKTtcclxuXHRcdFx0XHRcdGlmKHRtcCkge1xyXG5cdFx0XHRcdFx0XHRwYXIgPSB0bXA7XHJcblx0XHRcdFx0XHRcdHBvcyA9IFwiYWZ0ZXJcIjtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdFx0b2xkX3BhciA9IChvYmoucGFyZW50IHx8ICcjJykudG9TdHJpbmcoKTtcclxuXHRcdFx0bmV3X3BhciA9ICghcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSB8fCBwYXIuaWQgPT09ICcjJykgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhci5wYXJlbnQpO1xyXG5cdFx0XHRvbGRfaW5zID0gb2JqLmluc3RhbmNlID8gb2JqLmluc3RhbmNlIDogKHRoaXMuX21vZGVsLmRhdGFbb2JqLmlkXSA/IHRoaXMgOiAkLmpzdHJlZS5yZWZlcmVuY2Uob2JqLmlkKSk7XHJcblx0XHRcdGlzX211bHRpID0gIW9sZF9pbnMgfHwgIW9sZF9pbnMuX2lkIHx8ICh0aGlzLl9pZCAhPT0gb2xkX2lucy5faWQpO1xyXG5cdFx0XHRpZihwYXIuaWQgPT09ICcjJykge1xyXG5cdFx0XHRcdGlmKHBvcyA9PT0gXCJiZWZvcmVcIikgeyBwb3MgPSBcImZpcnN0XCI7IH1cclxuXHRcdFx0XHRpZihwb3MgPT09IFwiYWZ0ZXJcIikgeyBwb3MgPSBcImxhc3RcIjsgfVxyXG5cdFx0XHR9XHJcblx0XHRcdHN3aXRjaChwb3MpIHtcclxuXHRcdFx0XHRjYXNlIFwiYmVmb3JlXCI6XHJcblx0XHRcdFx0XHRwb3MgPSAkLmluQXJyYXkocGFyLmlkLCBuZXdfcGFyLmNoaWxkcmVuKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgXCJhZnRlclwiIDpcclxuXHRcdFx0XHRcdHBvcyA9ICQuaW5BcnJheShwYXIuaWQsIG5ld19wYXIuY2hpbGRyZW4pICsgMTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgXCJpbnNpZGVcIjpcclxuXHRcdFx0XHRjYXNlIFwiZmlyc3RcIjpcclxuXHRcdFx0XHRcdHBvcyA9IDA7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFwibGFzdFwiOlxyXG5cdFx0XHRcdFx0cG9zID0gbmV3X3Bhci5jaGlsZHJlbi5sZW5ndGg7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdFx0aWYoIXBvcykgeyBwb3MgPSAwOyB9XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihwb3MgPiBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aCkgeyBwb3MgPSBuZXdfcGFyLmNoaWxkcmVuLmxlbmd0aDsgfVxyXG5cdFx0XHRpZighdGhpcy5jaGVjayhcImNvcHlfbm9kZVwiLCBvYmosIG5ld19wYXIsIHBvcywgeyAnY29yZScgOiB0cnVlLCAnaXNfbXVsdGknIDogKG9sZF9pbnMgJiYgb2xkX2lucy5faWQgJiYgb2xkX2lucy5faWQgIT09IHRoaXMuX2lkKSwgJ2lzX2ZvcmVpZ24nIDogKCFvbGRfaW5zIHx8ICFvbGRfaW5zLl9pZCkgfSkpIHtcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdG5vZGUgPSBvbGRfaW5zID8gb2xkX2lucy5nZXRfanNvbihvYmosIHsgbm9faWQgOiB0cnVlLCBub19kYXRhIDogdHJ1ZSwgbm9fc3RhdGUgOiB0cnVlIH0pIDogb2JqO1xyXG5cdFx0XHRpZighbm9kZSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0aWYobm9kZS5pZCA9PT0gdHJ1ZSkgeyBkZWxldGUgbm9kZS5pZDsgfVxyXG5cdFx0XHRub2RlID0gdGhpcy5fcGFyc2VfbW9kZWxfZnJvbV9qc29uKG5vZGUsIG5ld19wYXIuaWQsIG5ld19wYXIucGFyZW50cy5jb25jYXQoKSk7XHJcblx0XHRcdGlmKCFub2RlKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKG5vZGUpO1xyXG5cdFx0XHRpZihvYmogJiYgb2JqLnN0YXRlICYmIG9iai5zdGF0ZS5sb2FkZWQgPT09IGZhbHNlKSB7IHRtcC5zdGF0ZS5sb2FkZWQgPSBmYWxzZTsgfVxyXG5cdFx0XHRkcGMgPSBbXTtcclxuXHRcdFx0ZHBjLnB1c2gobm9kZSk7XHJcblx0XHRcdGRwYyA9IGRwYy5jb25jYXQodG1wLmNoaWxkcmVuX2QpO1xyXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ21vZGVsJywgeyBcIm5vZGVzXCIgOiBkcGMsIFwicGFyZW50XCIgOiBuZXdfcGFyLmlkIH0pO1xyXG5cclxuXHRcdFx0Ly8gaW5zZXJ0IGludG8gbmV3IHBhcmVudCBhbmQgdXBcclxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gbmV3X3Bhci5wYXJlbnRzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbbmV3X3Bhci5wYXJlbnRzW2ldXS5jaGlsZHJlbl9kID0gdGhpcy5fbW9kZWwuZGF0YVtuZXdfcGFyLnBhcmVudHNbaV1dLmNoaWxkcmVuX2QuY29uY2F0KGRwYyk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZHBjID0gW107XHJcblx0XHRcdGZvcihpID0gMCwgaiA9IG5ld19wYXIuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0ZHBjW2kgPj0gcG9zID8gaSsxIDogaV0gPSBuZXdfcGFyLmNoaWxkcmVuW2ldO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRwY1twb3NdID0gdG1wLmlkO1xyXG5cdFx0XHRuZXdfcGFyLmNoaWxkcmVuID0gZHBjO1xyXG5cdFx0XHRuZXdfcGFyLmNoaWxkcmVuX2QucHVzaCh0bXAuaWQpO1xyXG5cdFx0XHRuZXdfcGFyLmNoaWxkcmVuX2QgPSBuZXdfcGFyLmNoaWxkcmVuX2QuY29uY2F0KHRtcC5jaGlsZHJlbl9kKTtcclxuXHJcblx0XHRcdGlmKG5ld19wYXIuaWQgPT09ICcjJykge1xyXG5cdFx0XHRcdHRoaXMuX21vZGVsLmZvcmNlX2Z1bGxfcmVkcmF3ID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZighdGhpcy5fbW9kZWwuZm9yY2VfZnVsbF9yZWRyYXcpIHtcclxuXHRcdFx0XHR0aGlzLl9ub2RlX2NoYW5nZWQobmV3X3Bhci5pZCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIXNraXBfcmVkcmF3KSB7XHJcblx0XHRcdFx0dGhpcy5yZWRyYXcobmV3X3Bhci5pZCA9PT0gJyMnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihjYWxsYmFjaykgeyBjYWxsYmFjay5jYWxsKHRoaXMsIHRtcCwgbmV3X3BhciwgcG9zKTsgfVxyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYSBub2RlIGlzIGNvcGllZFxyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgY29weV9ub2RlLmpzdHJlZVxyXG5cdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZSB0aGUgY29waWVkIG5vZGVcclxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG9yaWdpbmFsIHRoZSBvcmlnaW5hbCBub2RlXHJcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIHBhcmVudCdzIElEXHJcblx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiB0aGUgcG9zaXRpb24gb2YgdGhlIG5vZGUgYW1vbmcgdGhlIHBhcmVudCdzIGNoaWxkcmVuXHJcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBvbGRfcGFyZW50IHRoZSBvbGQgcGFyZW50IG9mIHRoZSBub2RlXHJcblx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBvbGRfcG9zaXRpb24gdGhlIHBvc2l0aW9uIG9mIHRoZSBvcmlnaW5hbCBub2RlXHJcblx0XHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNfbXVsdGkgZG8gdGhlIG5vZGUgYW5kIG5ldyBwYXJlbnQgYmVsb25nIHRvIGRpZmZlcmVudCBpbnN0YW5jZXNcclxuXHRcdFx0ICogQHBhcmFtIHtqc1RyZWV9IG9sZF9pbnN0YW5jZSB0aGUgaW5zdGFuY2UgdGhlIG5vZGUgY2FtZSBmcm9tXHJcblx0XHRcdCAqIEBwYXJhbSB7anNUcmVlfSBuZXdfaW5zdGFuY2UgdGhlIGluc3RhbmNlIG9mIHRoZSBuZXcgcGFyZW50XHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2NvcHlfbm9kZScsIHsgXCJub2RlXCIgOiB0bXAsIFwib3JpZ2luYWxcIiA6IG9iaiwgXCJwYXJlbnRcIiA6IG5ld19wYXIuaWQsIFwicG9zaXRpb25cIiA6IHBvcywgXCJvbGRfcGFyZW50XCIgOiBvbGRfcGFyLCBcIm9sZF9wb3NpdGlvblwiIDogb2xkX2lucyAmJiBvbGRfaW5zLl9pZCAmJiBvbGRfcGFyICYmIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0gJiYgb2xkX2lucy5fbW9kZWwuZGF0YVtvbGRfcGFyXS5jaGlsZHJlbiA/ICQuaW5BcnJheShvYmouaWQsIG9sZF9pbnMuX21vZGVsLmRhdGFbb2xkX3Bhcl0uY2hpbGRyZW4pIDogLTEsJ2lzX211bHRpJyA6IChvbGRfaW5zICYmIG9sZF9pbnMuX2lkICYmIG9sZF9pbnMuX2lkICE9PSB0aGlzLl9pZCksICdpc19mb3JlaWduJyA6ICghb2xkX2lucyB8fCAhb2xkX2lucy5faWQpLCAnb2xkX2luc3RhbmNlJyA6IG9sZF9pbnMsICduZXdfaW5zdGFuY2UnIDogdGhpcyB9KTtcclxuXHRcdFx0cmV0dXJuIHRtcC5pZDtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGN1dCBhIG5vZGUgKGEgbGF0ZXIgY2FsbCB0byBgcGFzdGUob2JqKWAgd291bGQgbW92ZSB0aGUgbm9kZSlcclxuXHRcdCAqIEBuYW1lIGN1dChvYmopXHJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqIG11bHRpcGxlIG9iamVjdHMgY2FuIGJlIHBhc3NlZCB1c2luZyBhbiBhcnJheVxyXG5cdFx0ICogQHRyaWdnZXIgY3V0LmpzdHJlZVxyXG5cdFx0ICovXHJcblx0XHRjdXQgOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRcdGlmKCFvYmopIHsgb2JqID0gdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkLmNvbmNhdCgpOyB9XHJcblx0XHRcdGlmKCEkLmlzQXJyYXkob2JqKSkgeyBvYmogPSBbb2JqXTsgfVxyXG5cdFx0XHRpZighb2JqLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0dmFyIHRtcCA9IFtdLCBvLCB0MSwgdDI7XHJcblx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xyXG5cdFx0XHRcdG8gPSB0aGlzLmdldF9ub2RlKG9ialt0MV0pO1xyXG5cdFx0XHRcdGlmKG8gJiYgby5pZCAmJiBvLmlkICE9PSAnIycpIHsgdG1wLnB1c2gobyk7IH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZighdG1wLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0Y2NwX25vZGUgPSB0bXA7XHJcblx0XHRcdGNjcF9pbnN0ID0gdGhpcztcclxuXHRcdFx0Y2NwX21vZGUgPSAnbW92ZV9ub2RlJztcclxuXHRcdFx0LyoqXHJcblx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIG5vZGVzIGFyZSBhZGRlZCB0byB0aGUgYnVmZmVyIGZvciBtb3ZpbmdcclxuXHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdCAqIEBuYW1lIGN1dC5qc3RyZWVcclxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gbm9kZVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0dGhpcy50cmlnZ2VyKCdjdXQnLCB7IFwibm9kZVwiIDogb2JqIH0pO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogY29weSBhIG5vZGUgKGEgbGF0ZXIgY2FsbCB0byBgcGFzdGUob2JqKWAgd291bGQgY29weSB0aGUgbm9kZSlcclxuXHRcdCAqIEBuYW1lIGNvcHkob2JqKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiBtdWx0aXBsZSBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdXNpbmcgYW4gYXJyYXlcclxuXHRcdCAqIEB0cmlnZ2VyIGNvcHkuanN0cmVcclxuXHRcdCAqL1xyXG5cdFx0Y29weSA6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdFx0aWYoIW9iaikgeyBvYmogPSB0aGlzLl9kYXRhLmNvcmUuc2VsZWN0ZWQuY29uY2F0KCk7IH1cclxuXHRcdFx0aWYoISQuaXNBcnJheShvYmopKSB7IG9iaiA9IFtvYmpdOyB9XHJcblx0XHRcdGlmKCFvYmoubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHR2YXIgdG1wID0gW10sIG8sIHQxLCB0MjtcclxuXHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XHJcblx0XHRcdFx0byA9IHRoaXMuZ2V0X25vZGUob2JqW3QxXSk7XHJcblx0XHRcdFx0aWYobyAmJiBvLmlkICYmIG8uaWQgIT09ICcjJykgeyB0bXAucHVzaChvKTsgfVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCF0bXAubGVuZ3RoKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRjY3Bfbm9kZSA9IHRtcDtcclxuXHRcdFx0Y2NwX2luc3QgPSB0aGlzO1xyXG5cdFx0XHRjY3BfbW9kZSA9ICdjb3B5X25vZGUnO1xyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gbm9kZXMgYXJlIGFkZGVkIHRvIHRoZSBidWZmZXIgZm9yIGNvcHlpbmdcclxuXHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdCAqIEBuYW1lIGNvcHkuanN0cmVlXHJcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IG5vZGVcclxuXHRcdFx0ICovXHJcblx0XHRcdHRoaXMudHJpZ2dlcignY29weScsIHsgXCJub2RlXCIgOiBvYmogfSk7XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBnZXQgdGhlIGN1cnJlbnQgYnVmZmVyIChhbnkgbm9kZXMgdGhhdCBhcmUgd2FpdGluZyBmb3IgYSBwYXN0ZSBvcGVyYXRpb24pXHJcblx0XHQgKiBAbmFtZSBnZXRfYnVmZmVyKClcclxuXHRcdCAqIEByZXR1cm4ge09iamVjdH0gYW4gb2JqZWN0IGNvbnNpc3Rpbmcgb2YgYG1vZGVgIChcImNvcHlfbm9kZVwiIG9yIFwibW92ZV9ub2RlXCIpLCBgbm9kZWAgKGFuIGFycmF5IG9mIG9iamVjdHMpIGFuZCBgaW5zdGAgKHRoZSBpbnN0YW5jZSlcclxuXHRcdCAqL1xyXG5cdFx0Z2V0X2J1ZmZlciA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cmV0dXJuIHsgJ21vZGUnIDogY2NwX21vZGUsICdub2RlJyA6IGNjcF9ub2RlLCAnaW5zdCcgOiBjY3BfaW5zdCB9O1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogY2hlY2sgaWYgdGhlcmUgaXMgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgdG8gcGFzdGVcclxuXHRcdCAqIEBuYW1lIGNhbl9wYXN0ZSgpXHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdFx0ICovXHJcblx0XHRjYW5fcGFzdGUgOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiBjY3BfbW9kZSAhPT0gZmFsc2UgJiYgY2NwX25vZGUgIT09IGZhbHNlOyAvLyAmJiBjY3BfaW5zdC5fbW9kZWwuZGF0YVtjY3Bfbm9kZV07XHJcblx0XHR9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBjb3B5IG9yIG1vdmUgdGhlIHByZXZpb3VzbHkgY3V0IG9yIGNvcGllZCBub2RlcyB0byBhIG5ldyBwYXJlbnRcclxuXHRcdCAqIEBuYW1lIHBhc3RlKG9iaiBbLCBwb3NdKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9iaiB0aGUgbmV3IHBhcmVudFxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IHBvcyB0aGUgcG9zaXRpb24gdG8gaW5zZXJ0IGF0IChiZXNpZGVzIGludGVnZXIsIFwiZmlyc3RcIiBhbmQgXCJsYXN0XCIgYXJlIHN1cHBvcnRlZCksIGRlZmF1bHRzIHRvIGludGVnZXIgYDBgXHJcblx0XHQgKiBAdHJpZ2dlciBwYXN0ZS5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0cGFzdGUgOiBmdW5jdGlvbiAob2JqLCBwb3MpIHtcclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZighb2JqIHx8ICFjY3BfbW9kZSB8fCAhY2NwX21vZGUubWF0Y2goL14oY29weV9ub2RlfG1vdmVfbm9kZSkkLykgfHwgIWNjcF9ub2RlKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRpZih0aGlzW2NjcF9tb2RlXShjY3Bfbm9kZSwgb2JqLCBwb3MpKSB7XHJcblx0XHRcdFx0LyoqXHJcblx0XHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gcGFzdGUgaXMgaW52b2tlZFxyXG5cdFx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHRcdCAqIEBuYW1lIHBhc3RlLmpzdHJlZVxyXG5cdFx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnQgdGhlIElEIG9mIHRoZSByZWNlaXZpbmcgbm9kZVxyXG5cdFx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IG5vZGUgdGhlIG5vZGVzIGluIHRoZSBidWZmZXJcclxuXHRcdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSB0aGUgcGVyZm9ybWVkIG9wZXJhdGlvbiAtIFwiY29weV9ub2RlXCIgb3IgXCJtb3ZlX25vZGVcIlxyXG5cdFx0XHRcdCAqL1xyXG5cdFx0XHRcdHRoaXMudHJpZ2dlcigncGFzdGUnLCB7IFwicGFyZW50XCIgOiBvYmouaWQsIFwibm9kZVwiIDogY2NwX25vZGUsIFwibW9kZVwiIDogY2NwX21vZGUgfSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2NwX25vZGUgPSBmYWxzZTtcclxuXHRcdFx0Y2NwX21vZGUgPSBmYWxzZTtcclxuXHRcdFx0Y2NwX2luc3QgPSBmYWxzZTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGNsZWFyIHRoZSBidWZmZXIgb2YgcHJldmlvdXNseSBjb3BpZWQgb3IgY3V0IG5vZGVzXHJcblx0XHQgKiBAbmFtZSBjbGVhcl9idWZmZXIoKVxyXG5cdFx0ICogQHRyaWdnZXIgY2xlYXJfYnVmZmVyLmpzdHJlZVxyXG5cdFx0ICovXHJcblx0XHRjbGVhcl9idWZmZXIgOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGNjcF9ub2RlID0gZmFsc2U7XHJcblx0XHRcdGNjcF9tb2RlID0gZmFsc2U7XHJcblx0XHRcdGNjcF9pbnN0ID0gZmFsc2U7XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiB0aGUgY29weSAvIGN1dCBidWZmZXIgaXMgY2xlYXJlZFxyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgY2xlYXJfYnVmZmVyLmpzdHJlZVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0dGhpcy50cmlnZ2VyKCdjbGVhcl9idWZmZXInKTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIHB1dCBhIG5vZGUgaW4gZWRpdCBtb2RlIChpbnB1dCBmaWVsZCB0byByZW5hbWUgdGhlIG5vZGUpXHJcblx0XHQgKiBAbmFtZSBlZGl0KG9iaiBbLCBkZWZhdWx0X3RleHRdKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9IG9ialxyXG5cdFx0ICogQHBhcmFtICB7U3RyaW5nfSBkZWZhdWx0X3RleHQgdGhlIHRleHQgdG8gcG9wdWxhdGUgdGhlIGlucHV0IHdpdGggKGlmIG9taXR0ZWQgdGhlIG5vZGUgdGV4dCB2YWx1ZSBpcyB1c2VkKVxyXG5cdFx0ICovXHJcblx0XHRlZGl0IDogZnVuY3Rpb24gKG9iaiwgZGVmYXVsdF90ZXh0KSB7XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0aWYoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jb3JlLmNoZWNrX2NhbGxiYWNrID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2NoZWNrJywgJ3BsdWdpbicgOiAnY29yZScsICdpZCcgOiAnY29yZV8wNycsICdyZWFzb24nIDogJ0NvdWxkIG5vdCBlZGl0IG5vZGUgYmVjYXVzZSBvZiBjaGVja19jYWxsYmFjaycgfTtcclxuXHRcdFx0XHR0aGlzLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCB0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvcik7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRlZmF1bHRfdGV4dCA9IHR5cGVvZiBkZWZhdWx0X3RleHQgPT09ICdzdHJpbmcnID8gZGVmYXVsdF90ZXh0IDogb2JqLnRleHQ7XHJcblx0XHRcdHRoaXMuc2V0X3RleHQob2JqLCBcIlwiKTtcclxuXHRcdFx0b2JqID0gdGhpcy5fb3Blbl90byhvYmopO1xyXG5cclxuXHRcdFx0dmFyIHJ0bCA9IHRoaXMuX2RhdGEuY29yZS5ydGwsXHJcblx0XHRcdFx0dyAgPSB0aGlzLmVsZW1lbnQud2lkdGgoKSxcclxuXHRcdFx0XHRhICA9IG9iai5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKSxcclxuXHRcdFx0XHRzICA9ICQoJzxzcGFuPicpLFxyXG5cdFx0XHRcdC8qIVxyXG5cdFx0XHRcdG9pID0gb2JqLmNoaWxkcmVuKFwiaTp2aXNpYmxlXCIpLFxyXG5cdFx0XHRcdGFpID0gYS5jaGlsZHJlbihcImk6dmlzaWJsZVwiKSxcclxuXHRcdFx0XHR3MSA9IG9pLndpZHRoKCkgKiBvaS5sZW5ndGgsXHJcblx0XHRcdFx0dzIgPSBhaS53aWR0aCgpICogYWkubGVuZ3RoLFxyXG5cdFx0XHRcdCovXHJcblx0XHRcdFx0dCAgPSBkZWZhdWx0X3RleHQsXHJcblx0XHRcdFx0aDEgPSAkKFwiPFwiK1wiZGl2IC8+XCIsIHsgY3NzIDogeyBcInBvc2l0aW9uXCIgOiBcImFic29sdXRlXCIsIFwidG9wXCIgOiBcIi0yMDBweFwiLCBcImxlZnRcIiA6IChydGwgPyBcIjBweFwiIDogXCItMTAwMHB4XCIpLCBcInZpc2liaWxpdHlcIiA6IFwiaGlkZGVuXCIgfSB9KS5hcHBlbmRUbyhcImJvZHlcIiksXHJcblx0XHRcdFx0aDIgPSAkKFwiPFwiK1wiaW5wdXQgLz5cIiwge1xyXG5cdFx0XHRcdFx0XHRcInZhbHVlXCIgOiB0LFxyXG5cdFx0XHRcdFx0XHRcImNsYXNzXCIgOiBcImpzdHJlZS1yZW5hbWUtaW5wdXRcIixcclxuXHRcdFx0XHRcdFx0Ly8gXCJzaXplXCIgOiB0Lmxlbmd0aCxcclxuXHRcdFx0XHRcdFx0XCJjc3NcIiA6IHtcclxuXHRcdFx0XHRcdFx0XHRcInBhZGRpbmdcIiA6IFwiMFwiLFxyXG5cdFx0XHRcdFx0XHRcdFwiYm9yZGVyXCIgOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcclxuXHRcdFx0XHRcdFx0XHRcImJveC1zaXppbmdcIiA6IFwiYm9yZGVyLWJveFwiLFxyXG5cdFx0XHRcdFx0XHRcdFwiZGlzcGxheVwiIDogXCJpbmxpbmUtYmxvY2tcIixcclxuXHRcdFx0XHRcdFx0XHRcImhlaWdodFwiIDogKHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQpICsgXCJweFwiLFxyXG5cdFx0XHRcdFx0XHRcdFwibGluZUhlaWdodFwiIDogKHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQpICsgXCJweFwiLFxyXG5cdFx0XHRcdFx0XHRcdFwid2lkdGhcIiA6IFwiMTUwcHhcIiAvLyB3aWxsIGJlIHNldCBhIGJpdCBmdXJ0aGVyIGRvd25cclxuXHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdFx0XCJibHVyXCIgOiAkLnByb3h5KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgaSA9IHMuY2hpbGRyZW4oXCIuanN0cmVlLXJlbmFtZS1pbnB1dFwiKSxcclxuXHRcdFx0XHRcdFx0XHRcdHYgPSBpLnZhbCgpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKHYgPT09IFwiXCIpIHsgdiA9IHQ7IH1cclxuXHRcdFx0XHRcdFx0XHRoMS5yZW1vdmUoKTtcclxuXHRcdFx0XHRcdFx0XHRzLnJlcGxhY2VXaXRoKGEpO1xyXG5cdFx0XHRcdFx0XHRcdHMucmVtb3ZlKCk7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXRfdGV4dChvYmosIHQpO1xyXG5cdFx0XHRcdFx0XHRcdGlmKHRoaXMucmVuYW1lX25vZGUob2JqLCAkKCc8ZGl2PjwvZGl2PicpLnRleHQodilbdGhpcy5zZXR0aW5ncy5jb3JlLmZvcmNlX3RleHQgPyAndGV4dCcgOiAnaHRtbCddKCkpID09PSBmYWxzZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZXRfdGV4dChvYmosIHQpOyAvLyBtb3ZlIHRoaXMgdXA/IGFuZCBmaXggIzQ4M1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSwgdGhpcyksXHJcblx0XHRcdFx0XHRcdFwia2V5ZG93blwiIDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIGtleSA9IGV2ZW50LndoaWNoO1xyXG5cdFx0XHRcdFx0XHRcdGlmKGtleSA9PT0gMjcpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMudmFsdWUgPSB0O1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZihrZXkgPT09IDI3IHx8IGtleSA9PT0gMTMgfHwga2V5ID09PSAzNyB8fCBrZXkgPT09IDM4IHx8IGtleSA9PT0gMzkgfHwga2V5ID09PSA0MCB8fCBrZXkgPT09IDMyKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0aWYoa2V5ID09PSAyNyB8fCBrZXkgPT09IDEzKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5ibHVyKCk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0XHRcImNsaWNrXCIgOiBmdW5jdGlvbiAoZSkgeyBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpOyB9LFxyXG5cdFx0XHRcdFx0XHRcIm1vdXNlZG93blwiIDogZnVuY3Rpb24gKGUpIHsgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTsgfSxcclxuXHRcdFx0XHRcdFx0XCJrZXl1cFwiIDogZnVuY3Rpb24gKGV2ZW50KSB7XHJcblx0XHRcdFx0XHRcdFx0aDIud2lkdGgoTWF0aC5taW4oaDEudGV4dChcInBXXCIgKyB0aGlzLnZhbHVlKS53aWR0aCgpLHcpKTtcclxuXHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdFx0XCJrZXlwcmVzc1wiIDogZnVuY3Rpb24oZXZlbnQpIHtcclxuXHRcdFx0XHRcdFx0XHRpZihldmVudC53aGljaCA9PT0gMTMpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pLFxyXG5cdFx0XHRcdGZuID0ge1xyXG5cdFx0XHRcdFx0XHRmb250RmFtaWx5XHRcdDogYS5jc3MoJ2ZvbnRGYW1pbHknKVx0XHR8fCAnJyxcclxuXHRcdFx0XHRcdFx0Zm9udFNpemVcdFx0OiBhLmNzcygnZm9udFNpemUnKVx0XHRcdHx8ICcnLFxyXG5cdFx0XHRcdFx0XHRmb250V2VpZ2h0XHRcdDogYS5jc3MoJ2ZvbnRXZWlnaHQnKVx0XHR8fCAnJyxcclxuXHRcdFx0XHRcdFx0Zm9udFN0eWxlXHRcdDogYS5jc3MoJ2ZvbnRTdHlsZScpXHRcdHx8ICcnLFxyXG5cdFx0XHRcdFx0XHRmb250U3RyZXRjaFx0XHQ6IGEuY3NzKCdmb250U3RyZXRjaCcpXHRcdHx8ICcnLFxyXG5cdFx0XHRcdFx0XHRmb250VmFyaWFudFx0XHQ6IGEuY3NzKCdmb250VmFyaWFudCcpXHRcdHx8ICcnLFxyXG5cdFx0XHRcdFx0XHRsZXR0ZXJTcGFjaW5nXHQ6IGEuY3NzKCdsZXR0ZXJTcGFjaW5nJylcdHx8ICcnLFxyXG5cdFx0XHRcdFx0XHR3b3JkU3BhY2luZ1x0XHQ6IGEuY3NzKCd3b3JkU3BhY2luZycpXHRcdHx8ICcnXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0cy5hdHRyKCdjbGFzcycsIGEuYXR0cignY2xhc3MnKSkuYXBwZW5kKGEuY29udGVudHMoKS5jbG9uZSgpKS5hcHBlbmQoaDIpO1xyXG5cdFx0XHRhLnJlcGxhY2VXaXRoKHMpO1xyXG5cdFx0XHRoMS5jc3MoZm4pO1xyXG5cdFx0XHRoMi5jc3MoZm4pLndpZHRoKE1hdGgubWluKGgxLnRleHQoXCJwV1wiICsgaDJbMF0udmFsdWUpLndpZHRoKCksdykpWzBdLnNlbGVjdCgpO1xyXG5cdFx0fSxcclxuXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBjaGFuZ2VzIHRoZSB0aGVtZVxyXG5cdFx0ICogQG5hbWUgc2V0X3RoZW1lKHRoZW1lX25hbWUgWywgdGhlbWVfdXJsXSlcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSB0aGVtZV9uYW1lIHRoZSBuYW1lIG9mIHRoZSBuZXcgdGhlbWUgdG8gYXBwbHlcclxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IHRoZW1lX3VybCAgdGhlIGxvY2F0aW9uIG9mIHRoZSBDU1MgZmlsZSBmb3IgdGhpcyB0aGVtZS4gT21pdCBvciBzZXQgdG8gYGZhbHNlYCBpZiB5b3UgbWFudWFsbHkgaW5jbHVkZWQgdGhlIGZpbGUuIFNldCB0byBgdHJ1ZWAgdG8gYXV0b2xvYWQgZnJvbSB0aGUgYGNvcmUudGhlbWVzLmRpcmAgZGlyZWN0b3J5LlxyXG5cdFx0ICogQHRyaWdnZXIgc2V0X3RoZW1lLmpzdHJlZVxyXG5cdFx0ICovXHJcblx0XHRzZXRfdGhlbWUgOiBmdW5jdGlvbiAodGhlbWVfbmFtZSwgdGhlbWVfdXJsKSB7XHJcblx0XHRcdGlmKCF0aGVtZV9uYW1lKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRpZih0aGVtZV91cmwgPT09IHRydWUpIHtcclxuXHRcdFx0XHR2YXIgZGlyID0gdGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5kaXI7XHJcblx0XHRcdFx0aWYoIWRpcikgeyBkaXIgPSAkLmpzdHJlZS5wYXRoICsgJy90aGVtZXMnOyB9XHJcblx0XHRcdFx0dGhlbWVfdXJsID0gZGlyICsgJy8nICsgdGhlbWVfbmFtZSArICcvc3R5bGUuY3NzJztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZih0aGVtZV91cmwgJiYgJC5pbkFycmF5KHRoZW1lX3VybCwgdGhlbWVzX2xvYWRlZCkgPT09IC0xKSB7XHJcblx0XHRcdFx0JCgnaGVhZCcpLmFwcGVuZCgnPCcrJ2xpbmsgcmVsPVwic3R5bGVzaGVldFwiIGhyZWY9XCInICsgdGhlbWVfdXJsICsgJ1wiIHR5cGU9XCJ0ZXh0L2Nzc1wiIC8+Jyk7XHJcblx0XHRcdFx0dGhlbWVzX2xvYWRlZC5wdXNoKHRoZW1lX3VybCk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lKSB7XHJcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCdqc3RyZWUtJyArIHRoaXMuX2RhdGEuY29yZS50aGVtZXMubmFtZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lID0gdGhlbWVfbmFtZTtcclxuXHRcdFx0dGhpcy5lbGVtZW50LmFkZENsYXNzKCdqc3RyZWUtJyArIHRoZW1lX25hbWUpO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRbdGhpcy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5yZXNwb25zaXZlID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcycgXSgnanN0cmVlLScgKyB0aGVtZV9uYW1lICsgJy1yZXNwb25zaXZlJyk7XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhIHRoZW1lIGlzIHNldFxyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgc2V0X3RoZW1lLmpzdHJlZVxyXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdGhlbWUgdGhlIG5ldyB0aGVtZVxyXG5cdFx0XHQgKi9cclxuXHRcdFx0dGhpcy50cmlnZ2VyKCdzZXRfdGhlbWUnLCB7ICd0aGVtZScgOiB0aGVtZV9uYW1lIH0pO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogZ2V0cyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGFwcGxpZWQgdGhlbWUgbmFtZVxyXG5cdFx0ICogQG5hbWUgZ2V0X3RoZW1lKClcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0X3RoZW1lIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lOyB9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBjaGFuZ2VzIHRoZSB0aGVtZSB2YXJpYW50IChpZiB0aGUgdGhlbWUgaGFzIHZhcmlhbnRzKVxyXG5cdFx0ICogQG5hbWUgc2V0X3RoZW1lX3ZhcmlhbnQodmFyaWFudF9uYW1lKVxyXG5cdFx0ICogQHBhcmFtIHtTdHJpbmd8Qm9vbGVhbn0gdmFyaWFudF9uYW1lIHRoZSB2YXJpYW50IHRvIGFwcGx5IChpZiBgZmFsc2VgIGlzIHVzZWQgdGhlIGN1cnJlbnQgdmFyaWFudCBpcyByZW1vdmVkKVxyXG5cdFx0ICovXHJcblx0XHRzZXRfdGhlbWVfdmFyaWFudCA6IGZ1bmN0aW9uICh2YXJpYW50X25hbWUpIHtcclxuXHRcdFx0aWYodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50KSB7XHJcblx0XHRcdFx0dGhpcy5lbGVtZW50LnJlbW92ZUNsYXNzKCdqc3RyZWUtJyArIHRoaXMuX2RhdGEuY29yZS50aGVtZXMubmFtZSArICctJyArIHRoaXMuX2RhdGEuY29yZS50aGVtZXMudmFyaWFudCk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50ID0gdmFyaWFudF9uYW1lO1xyXG5cdFx0XHRpZih2YXJpYW50X25hbWUpIHtcclxuXHRcdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5uYW1lICsgJy0nICsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy52YXJpYW50KTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogZ2V0cyB0aGUgbmFtZSBvZiB0aGUgY3VycmVudGx5IGFwcGxpZWQgdGhlbWUgdmFyaWFudFxyXG5cdFx0ICogQG5hbWUgZ2V0X3RoZW1lKClcclxuXHRcdCAqIEByZXR1cm4ge1N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0X3RoZW1lX3ZhcmlhbnQgOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLnZhcmlhbnQ7IH0sXHJcblx0XHQvKipcclxuXHRcdCAqIHNob3dzIGEgc3RyaXBlZCBiYWNrZ3JvdW5kIG9uIHRoZSBjb250YWluZXIgKGlmIHRoZSB0aGVtZSBzdXBwb3J0cyBpdClcclxuXHRcdCAqIEBuYW1lIHNob3dfc3RyaXBlcygpXHJcblx0XHQgKi9cclxuXHRcdHNob3dfc3RyaXBlcyA6IGZ1bmN0aW9uICgpIHsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzID0gdHJ1ZTsgdGhpcy5nZXRfY29udGFpbmVyX3VsKCkuYWRkQ2xhc3MoXCJqc3RyZWUtc3RyaXBlZFwiKTsgfSxcclxuXHRcdC8qKlxyXG5cdFx0ICogaGlkZXMgdGhlIHN0cmlwZWQgYmFja2dyb3VuZCBvbiB0aGUgY29udGFpbmVyXHJcblx0XHQgKiBAbmFtZSBoaWRlX3N0cmlwZXMoKVxyXG5cdFx0ICovXHJcblx0XHRoaWRlX3N0cmlwZXMgOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuc3RyaXBlcyA9IGZhbHNlOyB0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1zdHJpcGVkXCIpOyB9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiB0b2dnbGVzIHRoZSBzdHJpcGVkIGJhY2tncm91bmQgb24gdGhlIGNvbnRhaW5lclxyXG5cdFx0ICogQG5hbWUgdG9nZ2xlX3N0cmlwZXMoKVxyXG5cdFx0ICovXHJcblx0XHR0b2dnbGVfc3RyaXBlcyA6IGZ1bmN0aW9uICgpIHsgaWYodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5zdHJpcGVzKSB7IHRoaXMuaGlkZV9zdHJpcGVzKCk7IH0gZWxzZSB7IHRoaXMuc2hvd19zdHJpcGVzKCk7IH0gfSxcclxuXHRcdC8qKlxyXG5cdFx0ICogc2hvd3MgdGhlIGNvbm5lY3RpbmcgZG90cyAoaWYgdGhlIHRoZW1lIHN1cHBvcnRzIGl0KVxyXG5cdFx0ICogQG5hbWUgc2hvd19kb3RzKClcclxuXHRcdCAqL1xyXG5cdFx0c2hvd19kb3RzIDogZnVuY3Rpb24gKCkgeyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmRvdHMgPSB0cnVlOyB0aGlzLmdldF9jb250YWluZXJfdWwoKS5yZW1vdmVDbGFzcyhcImpzdHJlZS1uby1kb3RzXCIpOyB9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiBoaWRlcyB0aGUgY29ubmVjdGluZyBkb3RzXHJcblx0XHQgKiBAbmFtZSBoaWRlX2RvdHMoKVxyXG5cdFx0ICovXHJcblx0XHRoaWRlX2RvdHMgOiBmdW5jdGlvbiAoKSB7IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90cyA9IGZhbHNlOyB0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcImpzdHJlZS1uby1kb3RzXCIpOyB9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiB0b2dnbGVzIHRoZSBjb25uZWN0aW5nIGRvdHNcclxuXHRcdCAqIEBuYW1lIHRvZ2dsZV9kb3RzKClcclxuXHRcdCAqL1xyXG5cdFx0dG9nZ2xlX2RvdHMgOiBmdW5jdGlvbiAoKSB7IGlmKHRoaXMuX2RhdGEuY29yZS50aGVtZXMuZG90cykgeyB0aGlzLmhpZGVfZG90cygpOyB9IGVsc2UgeyB0aGlzLnNob3dfZG90cygpOyB9IH0sXHJcblx0XHQvKipcclxuXHRcdCAqIHNob3cgdGhlIG5vZGUgaWNvbnNcclxuXHRcdCAqIEBuYW1lIHNob3dfaWNvbnMoKVxyXG5cdFx0ICovXHJcblx0XHRzaG93X2ljb25zIDogZnVuY3Rpb24gKCkgeyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zID0gdHJ1ZTsgdGhpcy5nZXRfY29udGFpbmVyX3VsKCkucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbm8taWNvbnNcIik7IH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGhpZGUgdGhlIG5vZGUgaWNvbnNcclxuXHRcdCAqIEBuYW1lIGhpZGVfaWNvbnMoKVxyXG5cdFx0ICovXHJcblx0XHRoaWRlX2ljb25zIDogZnVuY3Rpb24gKCkgeyB0aGlzLl9kYXRhLmNvcmUudGhlbWVzLmljb25zID0gZmFsc2U7IHRoaXMuZ2V0X2NvbnRhaW5lcl91bCgpLmFkZENsYXNzKFwianN0cmVlLW5vLWljb25zXCIpOyB9LFxyXG5cdFx0LyoqXHJcblx0XHQgKiB0b2dnbGUgdGhlIG5vZGUgaWNvbnNcclxuXHRcdCAqIEBuYW1lIHRvZ2dsZV9pY29ucygpXHJcblx0XHQgKi9cclxuXHRcdHRvZ2dsZV9pY29ucyA6IGZ1bmN0aW9uICgpIHsgaWYodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5pY29ucykgeyB0aGlzLmhpZGVfaWNvbnMoKTsgfSBlbHNlIHsgdGhpcy5zaG93X2ljb25zKCk7IH0gfSxcclxuXHRcdC8qKlxyXG5cdFx0ICogc2V0IHRoZSBub2RlIGljb24gZm9yIGEgbm9kZVxyXG5cdFx0ICogQG5hbWUgc2V0X2ljb24ob2JqLCBpY29uKVxyXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gaWNvbiB0aGUgbmV3IGljb24gLSBjYW4gYmUgYSBwYXRoIHRvIGFuIGljb24gb3IgYSBjbGFzc05hbWUsIGlmIHVzaW5nIGFuIGltYWdlIHRoYXQgaXMgaW4gdGhlIGN1cnJlbnQgZGlyZWN0b3J5IHVzZSBhIGAuL2AgcHJlZml4LCBvdGhlcndpc2UgaXQgd2lsbCBiZSBkZXRlY3RlZCBhcyBhIGNsYXNzXHJcblx0XHQgKi9cclxuXHRcdHNldF9pY29uIDogZnVuY3Rpb24gKG9iaiwgaWNvbikge1xyXG5cdFx0XHR2YXIgdDEsIHQyLCBkb20sIG9sZDtcclxuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcclxuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcclxuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcclxuXHRcdFx0XHRcdHRoaXMuc2V0X2ljb24ob2JqW3QxXSwgaWNvbik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICcjJykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0b2xkID0gb2JqLmljb247XHJcblx0XHRcdG9iai5pY29uID0gaWNvbjtcclxuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIikuY2hpbGRyZW4oXCIuanN0cmVlLXRoZW1laWNvblwiKTtcclxuXHRcdFx0aWYoaWNvbiA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHR0aGlzLmhpZGVfaWNvbihvYmopO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYoaWNvbiA9PT0gdHJ1ZSkge1xyXG5cdFx0XHRcdGRvbS5yZW1vdmVDbGFzcygnanN0cmVlLXRoZW1laWNvbi1jdXN0b20gJyArIG9sZCkuY3NzKFwiYmFja2dyb3VuZFwiLFwiXCIpLnJlbW92ZUF0dHIoXCJyZWxcIik7XHJcblx0XHRcdFx0aWYob2xkID09PSBmYWxzZSkgeyB0aGlzLnNob3dfaWNvbihvYmopOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSBpZihpY29uLmluZGV4T2YoXCIvXCIpID09PSAtMSAmJiBpY29uLmluZGV4T2YoXCIuXCIpID09PSAtMSkge1xyXG5cdFx0XHRcdGRvbS5yZW1vdmVDbGFzcyhvbGQpLmNzcyhcImJhY2tncm91bmRcIixcIlwiKTtcclxuXHRcdFx0XHRkb20uYWRkQ2xhc3MoaWNvbiArICcganN0cmVlLXRoZW1laWNvbi1jdXN0b20nKS5hdHRyKFwicmVsXCIsaWNvbik7XHJcblx0XHRcdFx0aWYob2xkID09PSBmYWxzZSkgeyB0aGlzLnNob3dfaWNvbihvYmopOyB9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0ZG9tLnJlbW92ZUNsYXNzKG9sZCkuY3NzKFwiYmFja2dyb3VuZFwiLFwiXCIpO1xyXG5cdFx0XHRcdGRvbS5hZGRDbGFzcygnanN0cmVlLXRoZW1laWNvbi1jdXN0b20nKS5jc3MoXCJiYWNrZ3JvdW5kXCIsIFwidXJsKCdcIiArIGljb24gKyBcIicpIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0XCIpLmF0dHIoXCJyZWxcIixpY29uKTtcclxuXHRcdFx0XHRpZihvbGQgPT09IGZhbHNlKSB7IHRoaXMuc2hvd19pY29uKG9iaik7IH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGdldCB0aGUgbm9kZSBpY29uIGZvciBhIG5vZGVcclxuXHRcdCAqIEBuYW1lIGdldF9pY29uKG9iailcclxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9ialxyXG5cdFx0ICogQHJldHVybiB7U3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRfaWNvbiA6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRyZXR1cm4gKCFvYmogfHwgb2JqLmlkID09PSAnIycpID8gZmFsc2UgOiBvYmouaWNvbjtcclxuXHRcdH0sXHJcblx0XHQvKipcclxuXHRcdCAqIGhpZGUgdGhlIGljb24gb24gYW4gaW5kaXZpZHVhbCBub2RlXHJcblx0XHQgKiBAbmFtZSBoaWRlX2ljb24ob2JqKVxyXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqXHJcblx0XHQgKi9cclxuXHRcdGhpZGVfaWNvbiA6IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdFx0dmFyIHQxLCB0MjtcclxuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcclxuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcclxuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcclxuXHRcdFx0XHRcdHRoaXMuaGlkZV9pY29uKG9ialt0MV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XHJcblx0XHRcdGlmKCFvYmogfHwgb2JqID09PSAnIycpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdG9iai5pY29uID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS10aGVtZWljb25cIikuYWRkQ2xhc3MoJ2pzdHJlZS10aGVtZWljb24taGlkZGVuJyk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fSxcclxuXHRcdC8qKlxyXG5cdFx0ICogc2hvdyB0aGUgaWNvbiBvbiBhbiBpbmRpdmlkdWFsIG5vZGVcclxuXHRcdCAqIEBuYW1lIHNob3dfaWNvbihvYmopXHJcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmpcclxuXHRcdCAqL1xyXG5cdFx0c2hvd19pY29uIDogZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0XHR2YXIgdDEsIHQyLCBkb207XHJcblx0XHRcdGlmKCQuaXNBcnJheShvYmopKSB7XHJcblx0XHRcdFx0b2JqID0gb2JqLnNsaWNlKCk7XHJcblx0XHRcdFx0Zm9yKHQxID0gMCwgdDIgPSBvYmoubGVuZ3RoOyB0MSA8IHQyOyB0MSsrKSB7XHJcblx0XHRcdFx0XHR0aGlzLnNob3dfaWNvbihvYmpbdDFdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZighb2JqIHx8IG9iaiA9PT0gJyMnKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSk7XHJcblx0XHRcdG9iai5pY29uID0gZG9tLmxlbmd0aCA/IGRvbS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS10aGVtZWljb25cIikuYXR0cigncmVsJykgOiB0cnVlO1xyXG5cdFx0XHRpZighb2JqLmljb24pIHsgb2JqLmljb24gPSB0cnVlOyB9XHJcblx0XHRcdGRvbS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS10aGVtZWljb25cIikucmVtb3ZlQ2xhc3MoJ2pzdHJlZS10aGVtZWljb24taGlkZGVuJyk7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vIGhlbHBlcnNcclxuXHQkLnZha2F0YSA9IHt9O1xyXG5cdC8vIGNvbGxlY3QgYXR0cmlidXRlc1xyXG5cdCQudmFrYXRhLmF0dHJpYnV0ZXMgPSBmdW5jdGlvbihub2RlLCB3aXRoX3ZhbHVlcykge1xyXG5cdFx0bm9kZSA9ICQobm9kZSlbMF07XHJcblx0XHR2YXIgYXR0ciA9IHdpdGhfdmFsdWVzID8ge30gOiBbXTtcclxuXHRcdGlmKG5vZGUgJiYgbm9kZS5hdHRyaWJ1dGVzKSB7XHJcblx0XHRcdCQuZWFjaChub2RlLmF0dHJpYnV0ZXMsIGZ1bmN0aW9uIChpLCB2KSB7XHJcblx0XHRcdFx0aWYoJC5pbkFycmF5KHYubmFtZS50b0xvd2VyQ2FzZSgpLFsnc3R5bGUnLCdjb250ZW50ZWRpdGFibGUnLCdoYXNmb2N1cycsJ3RhYmluZGV4J10pICE9PSAtMSkgeyByZXR1cm47IH1cclxuXHRcdFx0XHRpZih2LnZhbHVlICE9PSBudWxsICYmICQudHJpbSh2LnZhbHVlKSAhPT0gJycpIHtcclxuXHRcdFx0XHRcdGlmKHdpdGhfdmFsdWVzKSB7IGF0dHJbdi5uYW1lXSA9IHYudmFsdWU7IH1cclxuXHRcdFx0XHRcdGVsc2UgeyBhdHRyLnB1c2godi5uYW1lKTsgfVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYXR0cjtcclxuXHR9O1xyXG5cdCQudmFrYXRhLmFycmF5X3VuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcblx0XHR2YXIgYSA9IFtdLCBpLCBqLCBsO1xyXG5cdFx0Zm9yKGkgPSAwLCBsID0gYXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRcdGZvcihqID0gMDsgaiA8PSBpOyBqKyspIHtcclxuXHRcdFx0XHRpZihhcnJheVtpXSA9PT0gYXJyYXlbal0pIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZihqID09PSBpKSB7IGEucHVzaChhcnJheVtpXSk7IH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBhO1xyXG5cdH07XHJcblx0Ly8gcmVtb3ZlIGl0ZW0gZnJvbSBhcnJheVxyXG5cdCQudmFrYXRhLmFycmF5X3JlbW92ZSA9IGZ1bmN0aW9uKGFycmF5LCBmcm9tLCB0bykge1xyXG5cdFx0dmFyIHJlc3QgPSBhcnJheS5zbGljZSgodG8gfHwgZnJvbSkgKyAxIHx8IGFycmF5Lmxlbmd0aCk7XHJcblx0XHRhcnJheS5sZW5ndGggPSBmcm9tIDwgMCA/IGFycmF5Lmxlbmd0aCArIGZyb20gOiBmcm9tO1xyXG5cdFx0YXJyYXkucHVzaC5hcHBseShhcnJheSwgcmVzdCk7XHJcblx0XHRyZXR1cm4gYXJyYXk7XHJcblx0fTtcclxuXHQvLyByZW1vdmUgaXRlbSBmcm9tIGFycmF5XHJcblx0JC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0gPSBmdW5jdGlvbihhcnJheSwgaXRlbSkge1xyXG5cdFx0dmFyIHRtcCA9ICQuaW5BcnJheShpdGVtLCBhcnJheSk7XHJcblx0XHRyZXR1cm4gdG1wICE9PSAtMSA/ICQudmFrYXRhLmFycmF5X3JlbW92ZShhcnJheSwgdG1wKSA6IGFycmF5O1xyXG5cdH07XHJcblxyXG5cclxuLyoqXHJcbiAqICMjIyBDaGVja2JveCBwbHVnaW5cclxuICpcclxuICogVGhpcyBwbHVnaW4gcmVuZGVycyBjaGVja2JveCBpY29ucyBpbiBmcm9udCBvZiBlYWNoIG5vZGUsIG1ha2luZyBtdWx0aXBsZSBzZWxlY3Rpb24gbXVjaCBlYXNpZXIuIFxyXG4gKiBJdCBhbHNvIHN1cHBvcnRzIHRyaS1zdGF0ZSBiZWhhdmlvciwgbWVhbmluZyB0aGF0IGlmIGEgbm9kZSBoYXMgYSBmZXcgb2YgaXRzIGNoaWxkcmVuIGNoZWNrZWQgaXQgd2lsbCBiZSByZW5kZXJlZCBhcyB1bmRldGVybWluZWQsIGFuZCBzdGF0ZSB3aWxsIGJlIHByb3BhZ2F0ZWQgdXAuXHJcbiAqL1xyXG5cclxuXHR2YXIgX2kgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdJJyk7XHJcblx0X2kuY2xhc3NOYW1lID0gJ2pzdHJlZS1pY29uIGpzdHJlZS1jaGVja2JveCc7XHJcblx0X2kuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xyXG5cdC8qKlxyXG5cdCAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBjaGVja2JveCBwbHVnaW5cclxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveFxyXG5cdCAqIEBwbHVnaW4gY2hlY2tib3hcclxuXHQgKi9cclxuXHQkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveCA9IHtcclxuXHRcdC8qKlxyXG5cdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgY2hlY2tib3hlcyBzaG91bGQgYmUgdmlzaWJsZSAoY2FuIGJlIGNoYW5nZWQgYXQgYSBsYXRlciB0aW1lIHVzaW5nIGBzaG93X2NoZWNrYm94ZXMoKWAgYW5kIGBoaWRlX2NoZWNrYm94ZXNgKS4gRGVmYXVsdHMgdG8gYHRydWVgLlxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gudmlzaWJsZVxyXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxyXG5cdFx0ICovXHJcblx0XHR2aXNpYmxlXHRcdFx0XHQ6IHRydWUsXHJcblx0XHQvKipcclxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGNoZWNrYm94ZXMgc2hvdWxkIGNhc2NhZGUgZG93biBhbmQgaGF2ZSBhbiB1bmRldGVybWluZWQgc3RhdGUuIERlZmF1bHRzIHRvIGB0cnVlYC5cclxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LnRocmVlX3N0YXRlXHJcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XHJcblx0XHQgKi9cclxuXHRcdHRocmVlX3N0YXRlXHRcdFx0OiB0cnVlLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjbGlja2luZyBhbnl3aGVyZSBvbiB0aGUgbm9kZSBzaG91bGQgYWN0IGFzIGNsaWNraW5nIG9uIHRoZSBjaGVja2JveC4gRGVmYXVsdHMgdG8gYHRydWVgLlxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3gud2hvbGVfbm9kZVxyXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxyXG5cdFx0ICovXHJcblx0XHR3aG9sZV9ub2RlXHRcdFx0OiB0cnVlLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgc2VsZWN0ZWQgc3R5bGUgb2YgYSBub2RlIHNob3VsZCBiZSBrZXB0LCBvciByZW1vdmVkLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXHJcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jaGVja2JveC5rZWVwX3NlbGVjdGVkX3N0eWxlXHJcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XHJcblx0XHQgKi9cclxuXHRcdGtlZXBfc2VsZWN0ZWRfc3R5bGVcdDogdHJ1ZSxcclxuXHRcdC8qKlxyXG5cdFx0ICogVGhpcyBzZXR0aW5nIGNvbnRyb2xzIGhvdyBjYXNjYWRpbmcgYW5kIHVuZGV0ZXJtaW5lZCBub2RlcyBhcmUgYXBwbGllZC4gXHJcblx0XHQgKiBJZiAndXAnIGlzIGluIHRoZSBzdHJpbmcgLSBjYXNjYWRpbmcgdXAgaXMgZW5hYmxlZCwgaWYgJ2Rvd24nIGlzIGluIHRoZSBzdHJpbmcgLSBjYXNjYWRpbmcgZG93biBpcyBlbmFibGVkLCBpZiAndW5kZXRlcm1pbmVkJyBpcyBpbiB0aGUgc3RyaW5nIC0gdW5kZXRlcm1pbmVkIG5vZGVzIHdpbGwgYmUgdXNlZC4gXHJcblx0XHQgKiBJZiBgdGhyZWVfc3RhdGVgIGlzIHNldCB0byBgdHJ1ZWAgdGhpcyBzZXR0aW5nIGlzIGF1dG9tYXRpY2FsbHkgc2V0IHRvICd1cCtkb3duK3VuZGV0ZXJtaW5lZCcuIERlZmF1bHRzIHRvICcnLlxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY2hlY2tib3guY2FzY2FkZVxyXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxyXG5cdFx0ICovXHJcblx0XHRjYXNjYWRlXHRcdFx0XHQ6ICcnLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaGlzIHNldHRpbmcgY29udHJvbHMgaWYgY2hlY2tib3ggYXJlIGJvdW5kIHRvIHRoZSBnZW5lcmFsIHRyZWUgc2VsZWN0aW9uIG9yIHRvIGFuIGludGVybmFsIGFycmF5IG1haW50YWluZWQgYnkgdGhlIGNoZWNrYm94IHBsdWdpbi4gRGVmYXVsdHMgdG8gYHRydWVgLCBvbmx5IHNldCB0byBgZmFsc2VgIGlmIHlvdSBrbm93IGV4YWN0bHkgd2hhdCB5b3UgYXJlIGRvaW5nLiBcclxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb25cclxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcclxuXHRcdCAqL1xyXG5cdFx0dGllX3NlbGVjdGlvblx0XHQ6IHRydWVcclxuXHR9O1xyXG5cdCQuanN0cmVlLnBsdWdpbnMuY2hlY2tib3ggPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XHJcblx0XHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XHJcblx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3gudXRvID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgPSBbXTtcclxuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aHJlZV9zdGF0ZSkge1xyXG5cdFx0XHRcdHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZSA9ICd1cCtkb3duK3VuZGV0ZXJtaW5lZCc7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5lbGVtZW50XHJcblx0XHRcdFx0Lm9uKFwiaW5pdC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3gudmlzaWJsZSA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudmlzaWJsZTtcclxuXHRcdFx0XHRcdFx0aWYoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gua2VlcF9zZWxlY3RlZF9zdHlsZSkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5hZGRDbGFzcygnanN0cmVlLWNoZWNrYm94LW5vLWNsaWNrZWQnKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2JveC1zZWxlY3Rpb24nKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSwgdGhpcykpXHJcblx0XHRcdFx0Lm9uKFwibG9hZGluZy5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdHRoaXNbIHRoaXMuX2RhdGEuY2hlY2tib3gudmlzaWJsZSA/ICdzaG93X2NoZWNrYm94ZXMnIDogJ2hpZGVfY2hlY2tib3hlcycgXSgpO1xyXG5cdFx0XHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUuaW5kZXhPZigndW5kZXRlcm1pbmVkJykgIT09IC0xKSB7XHJcblx0XHRcdFx0dGhpcy5lbGVtZW50XHJcblx0XHRcdFx0XHQub24oJ2NoYW5nZWQuanN0cmVlIHVuY2hlY2tfbm9kZS5qc3RyZWUgY2hlY2tfbm9kZS5qc3RyZWUgdW5jaGVja19hbGwuanN0cmVlIGNoZWNrX2FsbC5qc3RyZWUgbW92ZV9ub2RlLmpzdHJlZSBjb3B5X25vZGUuanN0cmVlIHJlZHJhdy5qc3RyZWUgb3Blbl9ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIG9ubHkgaWYgdW5kZXRlcm1pbmVkIGlzIGluIHNldHRpbmdcclxuXHRcdFx0XHRcdFx0XHRpZih0aGlzLl9kYXRhLmNoZWNrYm94LnV0bykgeyBjbGVhclRpbWVvdXQodGhpcy5fZGF0YS5jaGVja2JveC51dG8pOyB9XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC51dG8gPSBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5fdW5kZXRlcm1pbmVkLCB0aGlzKSwgNTApO1xyXG5cdFx0XHRcdFx0XHR9LCB0aGlzKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xyXG5cdFx0XHRcdHRoaXMuZWxlbWVudFxyXG5cdFx0XHRcdFx0Lm9uKCdtb2RlbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XHJcblx0XHRcdFx0XHRcdHZhciBtID0gdGhpcy5fbW9kZWwuZGF0YSxcclxuXHRcdFx0XHRcdFx0XHRwID0gbVtkYXRhLnBhcmVudF0sXHJcblx0XHRcdFx0XHRcdFx0ZHBjID0gZGF0YS5ub2RlcyxcclxuXHRcdFx0XHRcdFx0XHRpLCBqO1xyXG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBkcGMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0bVtkcGNbaV1dLnN0YXRlLmNoZWNrZWQgPSAobVtkcGNbaV1dLm9yaWdpbmFsICYmIG1bZHBjW2ldXS5vcmlnaW5hbC5zdGF0ZSAmJiBtW2RwY1tpXV0ub3JpZ2luYWwuc3RhdGUuY2hlY2tlZCk7XHJcblx0XHRcdFx0XHRcdFx0aWYobVtkcGNbaV1dLnN0YXRlLmNoZWNrZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQucHVzaChkcGNbaV0pO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1cCcpICE9PSAtMSB8fCB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUuaW5kZXhPZignZG93bicpICE9PSAtMSkge1xyXG5cdFx0XHRcdHRoaXMuZWxlbWVudFxyXG5cdFx0XHRcdFx0Lm9uKCdtb2RlbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxyXG5cdFx0XHRcdFx0XHRcdFx0cCA9IG1bZGF0YS5wYXJlbnRdLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZHBjID0gZGF0YS5ub2RlcyxcclxuXHRcdFx0XHRcdFx0XHRcdGNoZCA9IFtdLFxyXG5cdFx0XHRcdFx0XHRcdFx0YywgaSwgaiwgaywgbCwgdG1wLCBzID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLCB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0XHRcdC8vIGFwcGx5IGRvd25cclxuXHRcdFx0XHRcdFx0XHRcdGlmKHAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0pIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdG1bZHBjW2ldXS5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCA9IHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQuY29uY2F0KGRwYyk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKG1bZHBjW2ldXS5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Zm9yKGsgPSAwLCBsID0gbVtkcGNbaV1dLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1bbVtkcGNbaV1dLmNoaWxkcmVuX2Rba11dLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSB0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLmNvbmNhdChtW2RwY1tpXV0uY2hpbGRyZW5fZCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ3VwJykgIT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBhcHBseSB1cFxyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gcC5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZighbVtwLmNoaWxkcmVuX2RbaV1dLmNoaWxkcmVuLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNoZC5wdXNoKG1bcC5jaGlsZHJlbl9kW2ldXS5wYXJlbnQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRjaGQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUoY2hkKTtcclxuXHRcdFx0XHRcdFx0XHRcdGZvcihrID0gMCwgbCA9IGNoZC5sZW5ndGg7IGsgPCBsOyBrKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cCA9IG1bY2hkW2tdXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0d2hpbGUocCAmJiBwLmlkICE9PSAnIycpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjID0gMDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YyArPSBtW3AuY2hpbGRyZW5baV1dLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihjID09PSBqKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQucHVzaChwLmlkKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKCB0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwID0gdGhpcy5nZXRfbm9kZShwLnBhcmVudCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCk7XHJcblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxyXG5cdFx0XHRcdFx0Lm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdzZWxlY3Rfbm9kZS5qc3RyZWUnIDogJ2NoZWNrX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBvYmogPSBkYXRhLm5vZGUsXHJcblx0XHRcdFx0XHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSxcclxuXHRcdFx0XHRcdFx0XHRcdHBhciA9IHRoaXMuZ2V0X25vZGUob2JqLnBhcmVudCksXHJcblx0XHRcdFx0XHRcdFx0XHRkb20gPSB0aGlzLmdldF9ub2RlKG9iaiwgdHJ1ZSksXHJcblx0XHRcdFx0XHRcdFx0XHRpLCBqLCBjLCB0bXAsIHMgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LmNhc2NhZGUsIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb247XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IGRvd25cclxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV91bmlxdWUodGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5jb25jYXQob2JqLmNoaWxkcmVuX2QpKTtcclxuXHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSBtW29iai5jaGlsZHJlbl9kW2ldXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5vcmlnaW5hbCAmJiB0bXAub3JpZ2luYWwuc3RhdGUgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgdXBcclxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ3VwJykgIT09IC0xKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR3aGlsZShwYXIgJiYgcGFyLmlkICE9PSAnIycpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YyA9IDA7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHBhci5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjICs9IG1bcGFyLmNoaWxkcmVuW2ldXS5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZihjID09PSBqKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cGFyLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLnB1c2gocGFyLmlkKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKHBhciwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0cGFyID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IGRvd24gKHByb2Nlc3MgLmNoaWxkcmVuIHNlcGFyYXRlbHk/KVxyXG5cdFx0XHRcdFx0XHRcdGlmKHMuaW5kZXhPZignZG93bicpICE9PSAtMSAmJiBkb20ubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRkb20uZmluZCgnLmpzdHJlZS1hbmNob3InKS5hZGRDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpLnBhcmVudCgpLmF0dHIoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxyXG5cdFx0XHRcdFx0Lm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdkZXNlbGVjdF9hbGwuanN0cmVlJyA6ICd1bmNoZWNrX2FsbC5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIG9iaiA9IHRoaXMuZ2V0X25vZGUoJyMnKSxcclxuXHRcdFx0XHRcdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxyXG5cdFx0XHRcdFx0XHRcdFx0aSwgaiwgdG1wO1xyXG5cdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0dG1wID0gbVtvYmouY2hpbGRyZW5fZFtpXV07XHJcblx0XHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLm9yaWdpbmFsICYmIHRtcC5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxyXG5cdFx0XHRcdFx0Lm9uKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiA/ICdkZXNlbGVjdF9ub2RlLmpzdHJlZScgOiAndW5jaGVja19ub2RlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0XHR2YXIgb2JqID0gZGF0YS5ub2RlLFxyXG5cdFx0XHRcdFx0XHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxyXG5cdFx0XHRcdFx0XHRcdFx0aSwgaiwgdG1wLCBzID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC5jYXNjYWRlLCB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uO1xyXG5cdFx0XHRcdFx0XHRcdGlmKG9iaiAmJiBvYmoub3JpZ2luYWwgJiYgb2JqLm9yaWdpbmFsLnN0YXRlICYmIG9iai5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG9iai5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IGRvd25cclxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLl9tb2RlbC5kYXRhW29iai5jaGlsZHJlbl9kW2ldXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dG1wLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKHRtcCAmJiB0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAub3JpZ2luYWwuc3RhdGUudW5kZXRlcm1pbmVkID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IHVwXHJcblx0XHRcdFx0XHRcdFx0aWYocy5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLnBhcmVudHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuX21vZGVsLmRhdGFbb2JqLnBhcmVudHNbaV1dO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAuc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF0gPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5vcmlnaW5hbCAmJiB0bXAub3JpZ2luYWwuc3RhdGUgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKG9iai5wYXJlbnRzW2ldLCB0cnVlKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIGZhbHNlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdHRtcCA9IFtdO1xyXG5cdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBhcHBseSBkb3duICsgYXBwbHkgdXBcclxuXHRcdFx0XHRcdFx0XHRcdGlmKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQocy5pbmRleE9mKCdkb3duJykgPT09IC0xIHx8ICQuaW5BcnJheSh0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkW2ldLCBvYmouY2hpbGRyZW5fZCkgPT09IC0xKSAmJlxyXG5cdFx0XHRcdFx0XHRcdFx0XHQocy5pbmRleE9mKCd1cCcpID09PSAtMSB8fCAkLmluQXJyYXkodGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZFtpXSwgb2JqLnBhcmVudHMpID09PSAtMSlcclxuXHRcdFx0XHRcdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR0bXAucHVzaCh0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkW2ldKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X3VuaXF1ZSh0bXApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBhcHBseSBkb3duIChwcm9jZXNzIC5jaGlsZHJlbiBzZXBhcmF0ZWx5PylcclxuXHRcdFx0XHRcdFx0XHRpZihzLmluZGV4T2YoJ2Rvd24nKSAhPT0gLTEgJiYgZG9tLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZG9tLmZpbmQoJy5qc3RyZWUtYW5jaG9yJykucmVtb3ZlQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKS5wYXJlbnQoKS5hdHRyKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1cCcpICE9PSAtMSkge1xyXG5cdFx0XHRcdHRoaXMuZWxlbWVudFxyXG5cdFx0XHRcdFx0Lm9uKCdkZWxldGVfbm9kZS5qc3RyZWUnLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gYXBwbHkgdXAgKHdob2xlIGhhbmRsZXIpXHJcblx0XHRcdFx0XHRcdFx0dmFyIHAgPSB0aGlzLmdldF9ub2RlKGRhdGEucGFyZW50KSxcclxuXHRcdFx0XHRcdFx0XHRcdG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxyXG5cdFx0XHRcdFx0XHRcdFx0aSwgaiwgYywgdG1wLCB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uO1xyXG5cdFx0XHRcdFx0XHRcdHdoaWxlKHAgJiYgcC5pZCAhPT0gJyMnKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjID0gMDtcclxuXHRcdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IHAuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGMgKz0gbVtwLmNoaWxkcmVuW2ldXS5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmKGMgPT09IGopIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQucHVzaChwLmlkKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShwLCB0cnVlKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIHRydWUpLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLmFkZENsYXNzKHQgPyAnanN0cmVlLWNsaWNrZWQnIDogJ2pzdHJlZS1jaGVja2VkJyk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdHAgPSB0aGlzLmdldF9ub2RlKHAucGFyZW50KTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0sIHRoaXMpKVxyXG5cdFx0XHRcdFx0Lm9uKCdtb3ZlX25vZGUuanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIGFwcGx5IHVwICh3aG9sZSBoYW5kbGVyKVxyXG5cdFx0XHRcdFx0XHRcdHZhciBpc19tdWx0aSA9IGRhdGEuaXNfbXVsdGksXHJcblx0XHRcdFx0XHRcdFx0XHRvbGRfcGFyID0gZGF0YS5vbGRfcGFyZW50LFxyXG5cdFx0XHRcdFx0XHRcdFx0bmV3X3BhciA9IHRoaXMuZ2V0X25vZGUoZGF0YS5wYXJlbnQpLFxyXG5cdFx0XHRcdFx0XHRcdFx0bSA9IHRoaXMuX21vZGVsLmRhdGEsXHJcblx0XHRcdFx0XHRcdFx0XHRwLCBjLCBpLCBqLCB0bXAsIHQgPSB0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb247XHJcblx0XHRcdFx0XHRcdFx0aWYoIWlzX211bHRpKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRwID0gdGhpcy5nZXRfbm9kZShvbGRfcGFyKTtcclxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlKHAgJiYgcC5pZCAhPT0gJyMnKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGMgPSAwO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGMgKz0gbVtwLmNoaWxkcmVuW2ldXS5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZihjID09PSBqKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuZ2V0X25vZGUocC5wYXJlbnQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRwID0gbmV3X3BhcjtcclxuXHRcdFx0XHRcdFx0XHR3aGlsZShwICYmIHAuaWQgIT09ICcjJykge1xyXG5cdFx0XHRcdFx0XHRcdFx0YyA9IDA7XHJcblx0XHRcdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSBwLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRjICs9IG1bcC5jaGlsZHJlbltpXV0uc3RhdGVbIHQgPyAnc2VsZWN0ZWQnIDogJ2NoZWNrZWQnIF07XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZihjID09PSBqKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCFwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZC5wdXNoKHAuaWQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUocCwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYodG1wICYmIHRtcC5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRtcC5hdHRyKCdhcmlhLXNlbGVjdGVkJywgdHJ1ZSkuY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3ModCA/ICdqc3RyZWUtY2xpY2tlZCcgOiAnanN0cmVlLWNoZWNrZWQnKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZihwLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cC5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbSh0aGlzLl9kYXRhWyB0ID8gJ2NvcmUnIDogJ2NoZWNrYm94JyBdLnNlbGVjdGVkLCBwLmlkKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ub2RlKHAsIHRydWUpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmKHRtcCAmJiB0bXAubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0bXAuYXR0cignYXJpYS1zZWxlY3RlZCcsIGZhbHNlKS5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5yZW1vdmVDbGFzcyh0ID8gJ2pzdHJlZS1jbGlja2VkJyA6ICdqc3RyZWUtY2hlY2tlZCcpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0cCA9IHRoaXMuZ2V0X25vZGUocC5wYXJlbnQpO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0LyoqXHJcblx0XHQgKiBzZXQgdGhlIHVuZGV0ZXJtaW5lZCBzdGF0ZSB3aGVyZSBhbmQgaWYgbmVjZXNzYXJ5LiBVc2VkIGludGVybmFsbHkuXHJcblx0XHQgKiBAcHJpdmF0ZVxyXG5cdFx0ICogQG5hbWUgX3VuZGV0ZXJtaW5lZCgpXHJcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX3VuZGV0ZXJtaW5lZCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIGksIGosIG0gPSB0aGlzLl9tb2RlbC5kYXRhLCB0ID0gdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uLCBzID0gdGhpcy5fZGF0YVsgdCA/ICdjb3JlJyA6ICdjaGVja2JveCcgXS5zZWxlY3RlZCwgcCA9IFtdLCB0dCA9IHRoaXM7XHJcblx0XHRcdGZvcihpID0gMCwgaiA9IHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0aWYobVtzW2ldXSAmJiBtW3NbaV1dLnBhcmVudHMpIHtcclxuXHRcdFx0XHRcdHAgPSBwLmNvbmNhdChtW3NbaV1dLnBhcmVudHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBhdHRlbXB0IGZvciBzZXJ2ZXIgc2lkZSB1bmRldGVybWluZWQgc3RhdGVcclxuXHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtY2xvc2VkJykubm90KCc6aGFzKC5qc3RyZWUtY2hpbGRyZW4pJylcclxuXHRcdFx0XHQuZWFjaChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHR2YXIgdG1wID0gdHQuZ2V0X25vZGUodGhpcyksIHRtcDI7XHJcblx0XHRcdFx0XHRpZighdG1wLnN0YXRlLmxvYWRlZCkge1xyXG5cdFx0XHRcdFx0XHRpZih0bXAub3JpZ2luYWwgJiYgdG1wLm9yaWdpbmFsLnN0YXRlICYmIHRtcC5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgJiYgdG1wLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9PT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFx0XHRcdHAucHVzaCh0bXAuaWQpO1xyXG5cdFx0XHRcdFx0XHRcdHAgPSBwLmNvbmNhdCh0bXAucGFyZW50cyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAuY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHR0bXAyID0gbVt0bXAuY2hpbGRyZW5fZFtpXV07XHJcblx0XHRcdFx0XHRcdFx0aWYoIXRtcDIuc3RhdGUubG9hZGVkICYmIHRtcDIub3JpZ2luYWwgJiYgdG1wMi5vcmlnaW5hbC5zdGF0ZSAmJiB0bXAyLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCAmJiB0bXAyLm9yaWdpbmFsLnN0YXRlLnVuZGV0ZXJtaW5lZCA9PT0gdHJ1ZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0cC5wdXNoKHRtcDIuaWQpO1xyXG5cdFx0XHRcdFx0XHRcdFx0cCA9IHAuY29uY2F0KHRtcDIucGFyZW50cyk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdHAgPSAkLnZha2F0YS5hcnJheV91bmlxdWUocCk7XHJcblx0XHRcdHAgPSAkLnZha2F0YS5hcnJheV9yZW1vdmVfaXRlbShwLCcjJyk7XHJcblxyXG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS11bmRldGVybWluZWQnKS5yZW1vdmVDbGFzcygnanN0cmVlLXVuZGV0ZXJtaW5lZCcpO1xyXG5cdFx0XHRmb3IoaSA9IDAsIGogPSBwLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdGlmKCFtW3BbaV1dLnN0YXRlWyB0ID8gJ3NlbGVjdGVkJyA6ICdjaGVja2VkJyBdKSB7XHJcblx0XHRcdFx0XHRzID0gdGhpcy5nZXRfbm9kZShwW2ldLCB0cnVlKTtcclxuXHRcdFx0XHRcdGlmKHMgJiYgcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0cy5jaGlsZHJlbignLmpzdHJlZS1hbmNob3InKS5jaGlsZHJlbignLmpzdHJlZS1jaGVja2JveCcpLmFkZENsYXNzKCdqc3RyZWUtdW5kZXRlcm1pbmVkJyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0dGhpcy5yZWRyYXdfbm9kZSA9IGZ1bmN0aW9uKG9iaiwgZGVlcCwgaXNfY2FsbGJhY2ssIGZvcmNlX3JlbmRlcikge1xyXG5cdFx0XHRvYmogPSBwYXJlbnQucmVkcmF3X25vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0aWYob2JqKSB7XHJcblx0XHRcdFx0dmFyIGksIGosIHRtcCA9IG51bGw7XHJcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gb2JqLmNoaWxkTm9kZXMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRpZihvYmouY2hpbGROb2Rlc1tpXSAmJiBvYmouY2hpbGROb2Rlc1tpXS5jbGFzc05hbWUgJiYgb2JqLmNoaWxkTm9kZXNbaV0uY2xhc3NOYW1lLmluZGV4T2YoXCJqc3RyZWUtYW5jaG9yXCIpICE9PSAtMSkge1xyXG5cdFx0XHRcdFx0XHR0bXAgPSBvYmouY2hpbGROb2Rlc1tpXTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHRtcCkge1xyXG5cdFx0XHRcdFx0aWYoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiAmJiB0aGlzLl9tb2RlbC5kYXRhW29iai5pZF0uc3RhdGUuY2hlY2tlZCkgeyB0bXAuY2xhc3NOYW1lICs9ICcganN0cmVlLWNoZWNrZWQnOyB9XHJcblx0XHRcdFx0XHR0bXAuaW5zZXJ0QmVmb3JlKF9pLmNsb25lTm9kZShmYWxzZSksIHRtcC5jaGlsZE5vZGVzWzBdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIWlzX2NhbGxiYWNrICYmIHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZS5pbmRleE9mKCd1bmRldGVybWluZWQnKSAhPT0gLTEpIHtcclxuXHRcdFx0XHRpZih0aGlzLl9kYXRhLmNoZWNrYm94LnV0bykgeyBjbGVhclRpbWVvdXQodGhpcy5fZGF0YS5jaGVja2JveC51dG8pOyB9XHJcblx0XHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC51dG8gPSBzZXRUaW1lb3V0KCQucHJveHkodGhpcy5fdW5kZXRlcm1pbmVkLCB0aGlzKSwgNTApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBvYmo7XHJcblx0XHR9O1xyXG5cdFx0LyoqXHJcblx0XHQgKiBzaG93IHRoZSBub2RlIGNoZWNrYm94IGljb25zXHJcblx0XHQgKiBAbmFtZSBzaG93X2NoZWNrYm94ZXMoKVxyXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnNob3dfY2hlY2tib3hlcyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5jaGVja2JveGVzID0gdHJ1ZTsgdGhpcy5nZXRfY29udGFpbmVyX3VsKCkucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtbm8tY2hlY2tib3hlc1wiKTsgfTtcclxuXHRcdC8qKlxyXG5cdFx0ICogaGlkZSB0aGUgbm9kZSBjaGVja2JveCBpY29uc1xyXG5cdFx0ICogQG5hbWUgaGlkZV9jaGVja2JveGVzKClcclxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5oaWRlX2NoZWNrYm94ZXMgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2RhdGEuY29yZS50aGVtZXMuY2hlY2tib3hlcyA9IGZhbHNlOyB0aGlzLmdldF9jb250YWluZXJfdWwoKS5hZGRDbGFzcyhcImpzdHJlZS1uby1jaGVja2JveGVzXCIpOyB9O1xyXG5cdFx0LyoqXHJcblx0XHQgKiB0b2dnbGUgdGhlIG5vZGUgaWNvbnNcclxuXHRcdCAqIEBuYW1lIHRvZ2dsZV9jaGVja2JveGVzKClcclxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy50b2dnbGVfY2hlY2tib3hlcyA9IGZ1bmN0aW9uICgpIHsgaWYodGhpcy5fZGF0YS5jb3JlLnRoZW1lcy5jaGVja2JveGVzKSB7IHRoaXMuaGlkZV9jaGVja2JveGVzKCk7IH0gZWxzZSB7IHRoaXMuc2hvd19jaGVja2JveGVzKCk7IH0gfTtcclxuXHRcdC8qKlxyXG5cdFx0ICogY2hlY2tzIGlmIGEgbm9kZSBpcyBpbiBhbiB1bmRldGVybWluZWQgc3RhdGVcclxuXHRcdCAqIEBuYW1lIGlzX3VuZGV0ZXJtaW5lZChvYmopXHJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gb2JqXHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzX3VuZGV0ZXJtaW5lZCA9IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHR2YXIgcyA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3guY2FzY2FkZSwgaSwgaiwgdCA9IHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiwgZCA9IHRoaXMuX2RhdGFbIHQgPyAnY29yZScgOiAnY2hlY2tib3gnIF0uc2VsZWN0ZWQsIG0gPSB0aGlzLl9tb2RlbC5kYXRhO1xyXG5cdFx0XHRpZighb2JqIHx8IG9iai5zdGF0ZVsgdCA/ICdzZWxlY3RlZCcgOiAnY2hlY2tlZCcgXSA9PT0gdHJ1ZSB8fCBzLmluZGV4T2YoJ3VuZGV0ZXJtaW5lZCcpID09PSAtMSB8fCAocy5pbmRleE9mKCdkb3duJykgPT09IC0xICYmIHMuaW5kZXhPZigndXAnKSA9PT0gLTEpKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCFvYmouc3RhdGUubG9hZGVkICYmIG9iai5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQgPT09IHRydWUpIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IoaSA9IDAsIGogPSBvYmouY2hpbGRyZW5fZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRpZigkLmluQXJyYXkob2JqLmNoaWxkcmVuX2RbaV0sIGQpICE9PSAtMSB8fCAoIW1bb2JqLmNoaWxkcmVuX2RbaV1dLnN0YXRlLmxvYWRlZCAmJiBtW29iai5jaGlsZHJlbl9kW2ldXS5vcmlnaW5hbC5zdGF0ZS51bmRldGVybWluZWQpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fTtcclxuXHJcblx0XHR0aGlzLmFjdGl2YXRlX25vZGUgPSBmdW5jdGlvbiAob2JqLCBlKSB7XHJcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiAmJiAodGhpcy5zZXR0aW5ncy5jaGVja2JveC53aG9sZV9ub2RlIHx8ICQoZS50YXJnZXQpLmhhc0NsYXNzKCdqc3RyZWUtY2hlY2tib3gnKSkpIHtcclxuXHRcdFx0XHRlLmN0cmxLZXkgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbiB8fCAoIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gud2hvbGVfbm9kZSAmJiAhJChlLnRhcmdldCkuaGFzQ2xhc3MoJ2pzdHJlZS1jaGVja2JveCcpKSkge1xyXG5cdFx0XHRcdHJldHVybiBwYXJlbnQuYWN0aXZhdGVfbm9kZS5jYWxsKHRoaXMsIG9iaiwgZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodGhpcy5pc19kaXNhYmxlZChvYmopKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHRoaXMuaXNfY2hlY2tlZChvYmopKSB7XHJcblx0XHRcdFx0dGhpcy51bmNoZWNrX25vZGUob2JqLCBlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIHtcclxuXHRcdFx0XHR0aGlzLmNoZWNrX25vZGUob2JqLCBlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2FjdGl2YXRlX25vZGUnLCB7ICdub2RlJyA6IHRoaXMuZ2V0X25vZGUob2JqKSB9KTtcclxuXHRcdH07XHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBjaGVjayBhIG5vZGUgKG9ubHkgaWYgdGllX3NlbGVjdGlvbiBpbiBjaGVja2JveCBzZXR0aW5ncyBpcyBmYWxzZSwgb3RoZXJ3aXNlIHNlbGVjdF9ub2RlIHdpbGwgYmUgY2FsbGVkIGludGVybmFsbHkpXHJcblx0XHQgKiBAbmFtZSBjaGVja19ub2RlKG9iailcclxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiBhbiBhcnJheSBjYW4gYmUgdXNlZCB0byBjaGVjayBtdWx0aXBsZSBub2Rlc1xyXG5cdFx0ICogQHRyaWdnZXIgY2hlY2tfbm9kZS5qc3RyZWVcclxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jaGVja19ub2RlID0gZnVuY3Rpb24gKG9iaiwgZSkge1xyXG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHsgcmV0dXJuIHRoaXMuc2VsZWN0X25vZGUob2JqLCBmYWxzZSwgdHJ1ZSwgZSk7IH1cclxuXHRcdFx0dmFyIGRvbSwgdDEsIHQyLCB0aDtcclxuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcclxuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcclxuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcclxuXHRcdFx0XHRcdHRoaXMuY2hlY2tfbm9kZShvYmpbdDFdLCBlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRvbSA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKTtcclxuXHRcdFx0aWYoIW9iai5zdGF0ZS5jaGVja2VkKSB7XHJcblx0XHRcdFx0b2JqLnN0YXRlLmNoZWNrZWQgPSB0cnVlO1xyXG5cdFx0XHRcdHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQucHVzaChvYmouaWQpO1xyXG5cdFx0XHRcdGlmKGRvbSAmJiBkb20ubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRkb20uY2hpbGRyZW4oJy5qc3RyZWUtYW5jaG9yJykuYWRkQ2xhc3MoJ2pzdHJlZS1jaGVja2VkJyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8qKlxyXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIGFuIG5vZGUgaXMgY2hlY2tlZCAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlKVxyXG5cdFx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHRcdCAqIEBuYW1lIGNoZWNrX25vZGUuanN0cmVlXHJcblx0XHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG5vZGVcclxuXHRcdFx0XHQgKiBAcGFyYW0ge0FycmF5fSBzZWxlY3RlZCB0aGUgY3VycmVudCBzZWxlY3Rpb25cclxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IChpZiBhbnkpIHRoYXQgdHJpZ2dlcmVkIHRoaXMgY2hlY2tfbm9kZVxyXG5cdFx0XHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcclxuXHRcdFx0XHQgKi9cclxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ2NoZWNrX25vZGUnLCB7ICdub2RlJyA6IG9iaiwgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICdldmVudCcgOiBlIH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0LyoqXHJcblx0XHQgKiB1bmNoZWNrIGEgbm9kZSAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlLCBvdGhlcndpc2UgZGVzZWxlY3Rfbm9kZSB3aWxsIGJlIGNhbGxlZCBpbnRlcm5hbGx5KVxyXG5cdFx0ICogQG5hbWUgZGVzZWxlY3Rfbm9kZShvYmopXHJcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogYW4gYXJyYXkgY2FuIGJlIHVzZWQgdG8gZGVzZWxlY3QgbXVsdGlwbGUgbm9kZXNcclxuXHRcdCAqIEB0cmlnZ2VyIHVuY2hlY2tfbm9kZS5qc3RyZWVcclxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy51bmNoZWNrX25vZGUgPSBmdW5jdGlvbiAob2JqLCBlKSB7XHJcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5kZXNlbGVjdF9ub2RlKG9iaiwgZmFsc2UsIGUpOyB9XHJcblx0XHRcdHZhciB0MSwgdDIsIGRvbTtcclxuXHRcdFx0aWYoJC5pc0FycmF5KG9iaikpIHtcclxuXHRcdFx0XHRvYmogPSBvYmouc2xpY2UoKTtcclxuXHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IG9iai5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcclxuXHRcdFx0XHRcdHRoaXMudW5jaGVja19ub2RlKG9ialt0MV0sIGUpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRvYmogPSB0aGlzLmdldF9ub2RlKG9iaik7XHJcblx0XHRcdGlmKCFvYmogfHwgb2JqLmlkID09PSAnIycpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0ZG9tID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpO1xyXG5cdFx0XHRpZihvYmouc3RhdGUuY2hlY2tlZCkge1xyXG5cdFx0XHRcdG9iai5zdGF0ZS5jaGVja2VkID0gZmFsc2U7XHJcblx0XHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9ICQudmFrYXRhLmFycmF5X3JlbW92ZV9pdGVtKHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsIG9iai5pZCk7XHJcblx0XHRcdFx0aWYoZG9tLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0ZG9tLmNoaWxkcmVuKCcuanN0cmVlLWFuY2hvcicpLnJlbW92ZUNsYXNzKCdqc3RyZWUtY2hlY2tlZCcpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvKipcclxuXHRcdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbiBub2RlIGlzIHVuY2hlY2tlZCAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlKVxyXG5cdFx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHRcdCAqIEBuYW1lIHVuY2hlY2tfbm9kZS5qc3RyZWVcclxuXHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxyXG5cdFx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxyXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgKGlmIGFueSkgdGhhdCB0cmlnZ2VyZWQgdGhpcyB1bmNoZWNrX25vZGVcclxuXHRcdFx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XHJcblx0XHRcdFx0ICovXHJcblx0XHRcdFx0dGhpcy50cmlnZ2VyKCd1bmNoZWNrX25vZGUnLCB7ICdub2RlJyA6IG9iaiwgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQsICdldmVudCcgOiBlIH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0LyoqXHJcblx0XHQgKiBjaGVja3MgYWxsIG5vZGVzIGluIHRoZSB0cmVlIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBzZWxlY3RfYWxsIHdpbGwgYmUgY2FsbGVkIGludGVybmFsbHkpXHJcblx0XHQgKiBAbmFtZSBjaGVja19hbGwoKVxyXG5cdFx0ICogQHRyaWdnZXIgY2hlY2tfYWxsLmpzdHJlZSwgY2hhbmdlZC5qc3RyZWVcclxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5jaGVja19hbGwgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5zZWxlY3RfYWxsKCk7IH1cclxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQuY29uY2F0KFtdKSwgaSwgajtcclxuXHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IHRoaXMuX21vZGVsLmRhdGFbJyMnXS5jaGlsZHJlbl9kLmNvbmNhdCgpO1xyXG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0pIHtcclxuXHRcdFx0XHRcdHRoaXMuX21vZGVsLmRhdGFbdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZFtpXV0uc3RhdGUuY2hlY2tlZCA9IHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMucmVkcmF3KHRydWUpO1xyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gYWxsIG5vZGVzIGFyZSBjaGVja2VkIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UpXHJcblx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHQgKiBAbmFtZSBjaGVja19hbGwuanN0cmVlXHJcblx0XHRcdCAqIEBwYXJhbSB7QXJyYXl9IHNlbGVjdGVkIHRoZSBjdXJyZW50IHNlbGVjdGlvblxyXG5cdFx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2NoZWNrX2FsbCcsIHsgJ3NlbGVjdGVkJyA6IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQgfSk7XHJcblx0XHR9O1xyXG5cdFx0LyoqXHJcblx0XHQgKiB1bmNoZWNrIGFsbCBjaGVja2VkIG5vZGVzIChvbmx5IGlmIHRpZV9zZWxlY3Rpb24gaW4gY2hlY2tib3ggc2V0dGluZ3MgaXMgZmFsc2UsIG90aGVyd2lzZSBkZXNlbGVjdF9hbGwgd2lsbCBiZSBjYWxsZWQgaW50ZXJuYWxseSlcclxuXHRcdCAqIEBuYW1lIHVuY2hlY2tfYWxsKClcclxuXHRcdCAqIEB0cmlnZ2VyIHVuY2hlY2tfYWxsLmpzdHJlZVxyXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnVuY2hlY2tfYWxsID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLmNoZWNrYm94LnRpZV9zZWxlY3Rpb24pIHsgcmV0dXJuIHRoaXMuZGVzZWxlY3RfYWxsKCk7IH1cclxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQuY29uY2F0KFtdKSwgaSwgajtcclxuXHRcdFx0Zm9yKGkgPSAwLCBqID0gdGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRpZih0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWRbaV1dKSB7XHJcblx0XHRcdFx0XHR0aGlzLl9tb2RlbC5kYXRhW3RoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWRbaV1dLnN0YXRlLmNoZWNrZWQgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCA9IFtdO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCgnLmpzdHJlZS1jaGVja2VkJykucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1jaGVja2VkJyk7XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB0cmlnZ2VyZWQgd2hlbiBhbGwgbm9kZXMgYXJlIHVuY2hlY2tlZCAob25seSBpZiB0aWVfc2VsZWN0aW9uIGluIGNoZWNrYm94IHNldHRpbmdzIGlzIGZhbHNlKVxyXG5cdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0ICogQG5hbWUgdW5jaGVja19hbGwuanN0cmVlXHJcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBwcmV2aW91cyBzZWxlY3Rpb25cclxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gc2VsZWN0ZWQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXHJcblx0XHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcclxuXHRcdFx0ICovXHJcblx0XHRcdHRoaXMudHJpZ2dlcigndW5jaGVja19hbGwnLCB7ICdzZWxlY3RlZCcgOiB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLCAnbm9kZScgOiB0bXAgfSk7XHJcblx0XHR9O1xyXG5cdFx0LyoqXHJcblx0XHQgKiBjaGVja3MgaWYgYSBub2RlIGlzIGNoZWNrZWQgKGlmIHRpZV9zZWxlY3Rpb24gaXMgb24gaW4gdGhlIHNldHRpbmdzIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgYXMgaXNfc2VsZWN0ZWQpXHJcblx0XHQgKiBAbmFtZSBpc19jaGVja2VkKG9iailcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgb2JqXHJcblx0XHQgKiBAcmV0dXJuIHtCb29sZWFufVxyXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmlzX2NoZWNrZWQgPSBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5pc19zZWxlY3RlZChvYmopOyB9XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0aWYoIW9iaiB8fCBvYmouaWQgPT09ICcjJykgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0cmV0dXJuIG9iai5zdGF0ZS5jaGVja2VkO1xyXG5cdFx0fTtcclxuXHRcdC8qKlxyXG5cdFx0ICogZ2V0IGFuIGFycmF5IG9mIGFsbCBjaGVja2VkIG5vZGVzIChpZiB0aWVfc2VsZWN0aW9uIGlzIG9uIGluIHRoZSBzZXR0aW5ncyB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGFzIGdldF9zZWxlY3RlZClcclxuXHRcdCAqIEBuYW1lIGdldF9jaGVja2VkKFtmdWxsXSlcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSAgZnVsbCBpZiBzZXQgdG8gYHRydWVgIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGNvbnNpc3Qgb2YgdGhlIGZ1bGwgbm9kZSBvYmplY3RzLCBvdGhlcndpc2UgLSBvbmx5IElEcyB3aWxsIGJlIHJldHVybmVkXHJcblx0XHQgKiBAcmV0dXJuIHtBcnJheX1cclxuXHRcdCAqIEBwbHVnaW4gY2hlY2tib3hcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5nZXRfY2hlY2tlZCA9IGZ1bmN0aW9uIChmdWxsKSB7XHJcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5nZXRfc2VsZWN0ZWQoZnVsbCk7IH1cclxuXHRcdFx0cmV0dXJuIGZ1bGwgPyAkLm1hcCh0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLmdldF9ub2RlKGkpOyB9LCB0aGlzKSkgOiB0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkO1xyXG5cdFx0fTtcclxuXHRcdC8qKlxyXG5cdFx0ICogZ2V0IGFuIGFycmF5IG9mIGFsbCB0b3AgbGV2ZWwgY2hlY2tlZCBub2RlcyAoaWdub3JpbmcgY2hpbGRyZW4gb2YgY2hlY2tlZCBub2RlcykgKGlmIHRpZV9zZWxlY3Rpb24gaXMgb24gaW4gdGhlIHNldHRpbmdzIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHNhbWUgYXMgZ2V0X3RvcF9zZWxlY3RlZClcclxuXHRcdCAqIEBuYW1lIGdldF90b3BfY2hlY2tlZChbZnVsbF0pXHJcblx0XHQgKiBAcGFyYW0gIHttaXhlZH0gIGZ1bGwgaWYgc2V0IHRvIGB0cnVlYCB0aGUgcmV0dXJuZWQgYXJyYXkgd2lsbCBjb25zaXN0IG9mIHRoZSBmdWxsIG5vZGUgb2JqZWN0cywgb3RoZXJ3aXNlIC0gb25seSBJRHMgd2lsbCBiZSByZXR1cm5lZFxyXG5cdFx0ICogQHJldHVybiB7QXJyYXl9XHJcblx0XHQgKiBAcGx1Z2luIGNoZWNrYm94XHJcblx0XHQgKi9cclxuXHRcdHRoaXMuZ2V0X3RvcF9jaGVja2VkID0gZnVuY3Rpb24gKGZ1bGwpIHtcclxuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7IHJldHVybiB0aGlzLmdldF90b3Bfc2VsZWN0ZWQoZnVsbCk7IH1cclxuXHRcdFx0dmFyIHRtcCA9IHRoaXMuZ2V0X2NoZWNrZWQodHJ1ZSksXHJcblx0XHRcdFx0b2JqID0ge30sIGksIGosIGssIGw7XHJcblx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRvYmpbdG1wW2ldLmlkXSA9IHRtcFtpXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0Zm9yKGsgPSAwLCBsID0gdG1wW2ldLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XHJcblx0XHRcdFx0XHRpZihvYmpbdG1wW2ldLmNoaWxkcmVuX2Rba11dKSB7XHJcblx0XHRcdFx0XHRcdGRlbGV0ZSBvYmpbdG1wW2ldLmNoaWxkcmVuX2Rba11dO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHR0bXAgPSBbXTtcclxuXHRcdFx0Zm9yKGkgaW4gb2JqKSB7XHJcblx0XHRcdFx0aWYob2JqLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0XHRcdFx0XHR0bXAucHVzaChpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZ1bGwgPyAkLm1hcCh0bXAsICQucHJveHkoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHRoaXMuZ2V0X25vZGUoaSk7IH0sIHRoaXMpKSA6IHRtcDtcclxuXHRcdH07XHJcblx0XHQvKipcclxuXHRcdCAqIGdldCBhbiBhcnJheSBvZiBhbGwgYm90dG9tIGxldmVsIGNoZWNrZWQgbm9kZXMgKGlnbm9yaW5nIHNlbGVjdGVkIHBhcmVudHMpIChpZiB0aWVfc2VsZWN0aW9uIGlzIG9uIGluIHRoZSBzZXR0aW5ncyB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSBzYW1lIGFzIGdldF9ib3R0b21fc2VsZWN0ZWQpXHJcblx0XHQgKiBAbmFtZSBnZXRfYm90dG9tX2NoZWNrZWQoW2Z1bGxdKVxyXG5cdFx0ICogQHBhcmFtICB7bWl4ZWR9ICBmdWxsIGlmIHNldCB0byBgdHJ1ZWAgdGhlIHJldHVybmVkIGFycmF5IHdpbGwgY29uc2lzdCBvZiB0aGUgZnVsbCBub2RlIG9iamVjdHMsIG90aGVyd2lzZSAtIG9ubHkgSURzIHdpbGwgYmUgcmV0dXJuZWRcclxuXHRcdCAqIEByZXR1cm4ge0FycmF5fVxyXG5cdFx0ICogQHBsdWdpbiBjaGVja2JveFxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmdldF9ib3R0b21fY2hlY2tlZCA9IGZ1bmN0aW9uIChmdWxsKSB7XHJcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikgeyByZXR1cm4gdGhpcy5nZXRfYm90dG9tX3NlbGVjdGVkKGZ1bGwpOyB9XHJcblx0XHRcdHZhciB0bXAgPSB0aGlzLmdldF9jaGVja2VkKHRydWUpLFxyXG5cdFx0XHRcdG9iaiA9IFtdLCBpLCBqO1xyXG5cdFx0XHRmb3IoaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0aWYoIXRtcFtpXS5jaGlsZHJlbi5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdG9iai5wdXNoKHRtcFtpXS5pZCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmdWxsID8gJC5tYXAob2JqLCAkLnByb3h5KGZ1bmN0aW9uIChpKSB7IHJldHVybiB0aGlzLmdldF9ub2RlKGkpOyB9LCB0aGlzKSkgOiBvYmo7XHJcblx0XHR9O1xyXG5cdFx0dGhpcy5sb2FkX25vZGUgPSBmdW5jdGlvbiAob2JqLCBjYWxsYmFjaykge1xyXG5cdFx0XHR2YXIgaywgbCwgaSwgaiwgYywgdG1wO1xyXG5cdFx0XHRpZighJC5pc0FycmF5KG9iaikgJiYgIXRoaXMuc2V0dGluZ3MuY2hlY2tib3gudGllX3NlbGVjdGlvbikge1xyXG5cdFx0XHRcdHRtcCA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0XHRpZih0bXAgJiYgdG1wLnN0YXRlLmxvYWRlZCkge1xyXG5cdFx0XHRcdFx0Zm9yKGsgPSAwLCBsID0gdG1wLmNoaWxkcmVuX2QubGVuZ3RoOyBrIDwgbDsgaysrKSB7XHJcblx0XHRcdFx0XHRcdGlmKHRoaXMuX21vZGVsLmRhdGFbdG1wLmNoaWxkcmVuX2Rba11dLnN0YXRlLmNoZWNrZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRjID0gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNoZWNrYm94LnNlbGVjdGVkID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0odGhpcy5fZGF0YS5jaGVja2JveC5zZWxlY3RlZCwgdG1wLmNoaWxkcmVuX2Rba10pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBwYXJlbnQubG9hZF9ub2RlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR9O1xyXG5cdFx0dGhpcy5nZXRfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBzdGF0ZSA9IHBhcmVudC5nZXRfc3RhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7IHJldHVybiBzdGF0ZTsgfVxyXG5cdFx0XHRzdGF0ZS5jaGVja2JveCA9IHRoaXMuX2RhdGEuY2hlY2tib3guc2VsZWN0ZWQuc2xpY2UoKTtcclxuXHRcdFx0cmV0dXJuIHN0YXRlO1xyXG5cdFx0fTtcclxuXHRcdHRoaXMuc2V0X3N0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCBjYWxsYmFjaykge1xyXG5cdFx0XHR2YXIgcmVzID0gcGFyZW50LnNldF9zdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRpZihyZXMgJiYgc3RhdGUuY2hlY2tib3gpIHtcclxuXHRcdFx0XHRpZighdGhpcy5zZXR0aW5ncy5jaGVja2JveC50aWVfc2VsZWN0aW9uKSB7XHJcblx0XHRcdFx0XHR0aGlzLnVuY2hlY2tfYWxsKCk7XHJcblx0XHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzO1xyXG5cdFx0XHRcdFx0JC5lYWNoKHN0YXRlLmNoZWNrYm94LCBmdW5jdGlvbiAoaSwgdikge1xyXG5cdFx0XHRcdFx0XHRfdGhpcy5jaGVja19ub2RlKHYpO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGRlbGV0ZSBzdGF0ZS5jaGVja2JveDtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHJlcztcclxuXHRcdH07XHJcblx0fTtcclxuXHJcblx0Ly8gaW5jbHVkZSB0aGUgY2hlY2tib3ggcGx1Z2luIGJ5IGRlZmF1bHRcclxuXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJjaGVja2JveFwiKTtcclxuXHJcbi8qKlxyXG4gKiAjIyMgQ29udGV4dG1lbnUgcGx1Z2luXHJcbiAqXHJcbiAqIFNob3dzIGEgY29udGV4dCBtZW51IHdoZW4gYSBub2RlIGlzIHJpZ2h0LWNsaWNrZWQuXHJcbiAqL1xyXG5cclxuXHR2YXIgY3RvID0gbnVsbCwgZXgsIGV5O1xyXG5cclxuXHQvKipcclxuXHQgKiBzdG9yZXMgYWxsIGRlZmF1bHRzIGZvciB0aGUgY29udGV4dG1lbnUgcGx1Z2luXHJcblx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnVcclxuXHQgKiBAcGx1Z2luIGNvbnRleHRtZW51XHJcblx0ICovXHJcblx0JC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnUgPSB7XHJcblx0XHQvKipcclxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZSBub2RlIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIHRoZSBjb250ZXh0IG1lbnUgaXMgaW52b2tlZCBvbiBpdC4gRGVmYXVsdHMgdG8gYHRydWVgLlxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnUuc2VsZWN0X25vZGVcclxuXHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcclxuXHRcdCAqL1xyXG5cdFx0c2VsZWN0X25vZGUgOiB0cnVlLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgbWVudSBzaG91bGQgYmUgc2hvd24gYWxpZ25lZCB3aXRoIHRoZSBub2RlLiBEZWZhdWx0cyB0byBgdHJ1ZWAsIG90aGVyd2lzZSB0aGUgbW91c2UgY29vcmRpbmF0ZXMgYXJlIHVzZWQuXHJcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudS5zaG93X2F0X25vZGVcclxuXHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcclxuXHRcdCAqL1xyXG5cdFx0c2hvd19hdF9ub2RlIDogdHJ1ZSxcclxuXHRcdC8qKlxyXG5cdFx0ICogYW4gb2JqZWN0IG9mIGFjdGlvbnMsIG9yIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGEgbm9kZSBhbmQgYSBjYWxsYmFjayBmdW5jdGlvbiBhbmQgY2FsbHMgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggYW4gb2JqZWN0IG9mIGFjdGlvbnMgYXZhaWxhYmxlIGZvciB0aGF0IG5vZGUgKHlvdSBjYW4gYWxzbyByZXR1cm4gdGhlIGl0ZW1zIHRvbykuXHJcblx0XHQgKiBcclxuXHRcdCAqIEVhY2ggYWN0aW9uIGNvbnNpc3RzIG9mIGEga2V5IChhIHVuaXF1ZSBuYW1lKSBhbmQgYSB2YWx1ZSB3aGljaCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgKG9ubHkgbGFiZWwgYW5kIGFjdGlvbiBhcmUgcmVxdWlyZWQpOlxyXG5cdFx0ICogXHJcblx0XHQgKiAqIGBzZXBhcmF0b3JfYmVmb3JlYCAtIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZXJlIHNob3VsZCBiZSBhIHNlcGFyYXRvciBiZWZvcmUgdGhpcyBpdGVtXHJcblx0XHQgKiAqIGBzZXBhcmF0b3JfYWZ0ZXJgIC0gYSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlcmUgc2hvdWxkIGJlIGEgc2VwYXJhdG9yIGFmdGVyIHRoaXMgaXRlbVxyXG5cdFx0ICogKiBgX2Rpc2FibGVkYCAtIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoaXMgYWN0aW9uIHNob3VsZCBiZSBkaXNhYmxlZFxyXG5cdFx0ICogKiBgbGFiZWxgIC0gYSBzdHJpbmcgLSB0aGUgbmFtZSBvZiB0aGUgYWN0aW9uIChjb3VsZCBiZSBhIGZ1bmN0aW9uIHJldHVybmluZyBhIHN0cmluZylcclxuXHRcdCAqICogYGFjdGlvbmAgLSBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGlmIHRoaXMgaXRlbSBpcyBjaG9zZW5cclxuXHRcdCAqICogYGljb25gIC0gYSBzdHJpbmcsIGNhbiBiZSBhIHBhdGggdG8gYW4gaWNvbiBvciBhIGNsYXNzTmFtZSwgaWYgdXNpbmcgYW4gaW1hZ2UgdGhhdCBpcyBpbiB0aGUgY3VycmVudCBkaXJlY3RvcnkgdXNlIGEgYC4vYCBwcmVmaXgsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRldGVjdGVkIGFzIGEgY2xhc3NcclxuXHRcdCAqICogYHNob3J0Y3V0YCAtIGtleUNvZGUgd2hpY2ggd2lsbCB0cmlnZ2VyIHRoZSBhY3Rpb24gaWYgdGhlIG1lbnUgaXMgb3BlbiAoZm9yIGV4YW1wbGUgYDExM2AgZm9yIHJlbmFtZSwgd2hpY2ggZXF1YWxzIEYyKVxyXG5cdFx0ICogKiBgc2hvcnRjdXRfbGFiZWxgIC0gc2hvcnRjdXQgbGFiZWwgKGxpa2UgZm9yIGV4YW1wbGUgYEYyYCBmb3IgcmVuYW1lKVxyXG5cdFx0ICogXHJcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5jb250ZXh0bWVudS5pdGVtc1xyXG5cdFx0ICogQHBsdWdpbiBjb250ZXh0bWVudVxyXG5cdFx0ICovXHJcblx0XHRpdGVtcyA6IGZ1bmN0aW9uIChvLCBjYikgeyAvLyBDb3VsZCBiZSBhbiBvYmplY3QgZGlyZWN0bHlcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcImNyZWF0ZVwiIDoge1xyXG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYmVmb3JlXCJcdDogZmFsc2UsXHJcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IHRydWUsXHJcblx0XHRcdFx0XHRcIl9kaXNhYmxlZFwiXHRcdFx0OiBmYWxzZSwgLy8odGhpcy5jaGVjayhcImNyZWF0ZV9ub2RlXCIsIGRhdGEucmVmZXJlbmNlLCB7fSwgXCJsYXN0XCIpKSxcclxuXHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIkNyZWF0ZVwiLFxyXG5cdFx0XHRcdFx0XCJhY3Rpb25cIlx0XHRcdDogZnVuY3Rpb24gKGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxyXG5cdFx0XHRcdFx0XHRcdG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xyXG5cdFx0XHRcdFx0XHRpbnN0LmNyZWF0ZV9ub2RlKG9iaiwge30sIFwibGFzdFwiLCBmdW5jdGlvbiAobmV3X25vZGUpIHtcclxuXHRcdFx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgaW5zdC5lZGl0KG5ld19ub2RlKTsgfSwwKTtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRcInJlbmFtZVwiIDoge1xyXG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYmVmb3JlXCJcdDogZmFsc2UsXHJcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9hZnRlclwiXHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0XCJfZGlzYWJsZWRcIlx0XHRcdDogZmFsc2UsIC8vKHRoaXMuY2hlY2soXCJyZW5hbWVfbm9kZVwiLCBkYXRhLnJlZmVyZW5jZSwgdGhpcy5nZXRfcGFyZW50KGRhdGEucmVmZXJlbmNlKSwgXCJcIikpLFxyXG5cdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiUmVuYW1lXCIsXHJcblx0XHRcdFx0XHQvKlxyXG5cdFx0XHRcdFx0XCJzaG9ydGN1dFwiXHRcdFx0OiAxMTMsXHJcblx0XHRcdFx0XHRcInNob3J0Y3V0X2xhYmVsXCJcdDogJ0YyJyxcclxuXHRcdFx0XHRcdFwiaWNvblwiXHRcdFx0XHQ6IFwiZ2x5cGhpY29uIGdseXBoaWNvbi1sZWFmXCIsXHJcblx0XHRcdFx0XHQqL1xyXG5cdFx0XHRcdFx0XCJhY3Rpb25cIlx0XHRcdDogZnVuY3Rpb24gKGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxyXG5cdFx0XHRcdFx0XHRcdG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xyXG5cdFx0XHRcdFx0XHRpbnN0LmVkaXQob2JqKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdFwicmVtb3ZlXCIgOiB7XHJcblx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdFwiaWNvblwiXHRcdFx0XHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0XCJzZXBhcmF0b3JfYWZ0ZXJcIlx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdFwiX2Rpc2FibGVkXCJcdFx0XHQ6IGZhbHNlLCAvLyh0aGlzLmNoZWNrKFwiZGVsZXRlX25vZGVcIiwgZGF0YS5yZWZlcmVuY2UsIHRoaXMuZ2V0X3BhcmVudChkYXRhLnJlZmVyZW5jZSksIFwiXCIpKSxcclxuXHRcdFx0XHRcdFwibGFiZWxcIlx0XHRcdFx0OiBcIkRlbGV0ZVwiLFxyXG5cdFx0XHRcdFx0XCJhY3Rpb25cIlx0XHRcdDogZnVuY3Rpb24gKGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0dmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxyXG5cdFx0XHRcdFx0XHRcdG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xyXG5cdFx0XHRcdFx0XHRpZihpbnN0LmlzX3NlbGVjdGVkKG9iaikpIHtcclxuXHRcdFx0XHRcdFx0XHRpbnN0LmRlbGV0ZV9ub2RlKGluc3QuZ2V0X3NlbGVjdGVkKCkpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdGluc3QuZGVsZXRlX25vZGUob2JqKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0XCJjY3BcIiA6IHtcclxuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IHRydWUsXHJcblx0XHRcdFx0XHRcImljb25cIlx0XHRcdFx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXHJcblx0XHRcdFx0XHRcImxhYmVsXCJcdFx0XHRcdDogXCJFZGl0XCIsXHJcblx0XHRcdFx0XHRcImFjdGlvblwiXHRcdFx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdFwic3VibWVudVwiIDoge1xyXG5cdFx0XHRcdFx0XHRcImN1dFwiIDoge1xyXG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXHJcblx0XHRcdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiQ3V0XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJhY3Rpb25cIlx0XHRcdDogZnVuY3Rpb24gKGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0b2JqID0gaW5zdC5nZXRfbm9kZShkYXRhLnJlZmVyZW5jZSk7XHJcblx0XHRcdFx0XHRcdFx0XHRpZihpbnN0LmlzX3NlbGVjdGVkKG9iaikpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aW5zdC5jdXQoaW5zdC5nZXRfc2VsZWN0ZWQoKSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0aW5zdC5jdXQob2JqKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdFwiY29weVwiIDoge1xyXG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2JlZm9yZVwiXHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0XHRcdFwiaWNvblwiXHRcdFx0XHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0XHRcdFwic2VwYXJhdG9yX2FmdGVyXCJcdDogZmFsc2UsXHJcblx0XHRcdFx0XHRcdFx0XCJsYWJlbFwiXHRcdFx0XHQ6IFwiQ29weVwiLFxyXG5cdFx0XHRcdFx0XHRcdFwiYWN0aW9uXCJcdFx0XHQ6IGZ1bmN0aW9uIChkYXRhKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYoaW5zdC5pc19zZWxlY3RlZChvYmopKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGluc3QuY29weShpbnN0LmdldF9zZWxlY3RlZCgpKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpbnN0LmNvcHkob2JqKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdFwicGFzdGVcIiA6IHtcclxuXHRcdFx0XHRcdFx0XHRcInNlcGFyYXRvcl9iZWZvcmVcIlx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdFx0XHRcImljb25cIlx0XHRcdFx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdFx0XHRcIl9kaXNhYmxlZFwiXHRcdFx0OiBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICEkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLmNhbl9wYXN0ZSgpO1xyXG5cdFx0XHRcdFx0XHRcdH0sXHJcblx0XHRcdFx0XHRcdFx0XCJzZXBhcmF0b3JfYWZ0ZXJcIlx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdFx0XHRcImxhYmVsXCJcdFx0XHRcdDogXCJQYXN0ZVwiLFxyXG5cdFx0XHRcdFx0XHRcdFwiYWN0aW9uXCJcdFx0XHQ6IGZ1bmN0aW9uIChkYXRhKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXHJcblx0XHRcdFx0XHRcdFx0XHRcdG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xyXG5cdFx0XHRcdFx0XHRcdFx0aW5zdC5wYXN0ZShvYmopO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQkLmpzdHJlZS5wbHVnaW5zLmNvbnRleHRtZW51ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xyXG5cdFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdFx0dmFyIGxhc3RfdHMgPSAwO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRcclxuXHRcdFx0XHQub24oXCJjb250ZXh0bWVudS5qc3RyZWVcIiwgXCIuanN0cmVlLWFuY2hvclwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XHJcblx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRcdFx0bGFzdF90cyA9IGUuY3RybEtleSA/ICtuZXcgRGF0ZSgpIDogMDtcclxuXHRcdFx0XHRcdFx0aWYoZGF0YSB8fCBjdG8pIHtcclxuXHRcdFx0XHRcdFx0XHRsYXN0X3RzID0gKCtuZXcgRGF0ZSgpKSArIDEwMDAwO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKGN0bykge1xyXG5cdFx0XHRcdFx0XHRcdGNsZWFyVGltZW91dChjdG8pO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKCF0aGlzLmlzX2xvYWRpbmcoZS5jdXJyZW50VGFyZ2V0KSkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuc2hvd19jb250ZXh0bWVudShlLmN1cnJlbnRUYXJnZXQsIGUucGFnZVgsIGUucGFnZVksIGUpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LCB0aGlzKSlcclxuXHRcdFx0XHQub24oXCJjbGljay5qc3RyZWVcIiwgXCIuanN0cmVlLWFuY2hvclwiLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRcdGlmKHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSAmJiAoIWxhc3RfdHMgfHwgKCtuZXcgRGF0ZSgpKSAtIGxhc3RfdHMgPiAyNTApKSB7IC8vIHdvcmsgYXJvdW5kIHNhZmFyaSAmIG1hY09TIGN0cmwrY2xpY2tcclxuXHRcdFx0XHRcdFx0XHQkLnZha2F0YS5jb250ZXh0LmhpZGUoKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRsYXN0X3RzID0gMDtcclxuXHRcdFx0XHRcdH0sIHRoaXMpKVxyXG5cdFx0XHRcdC5vbihcInRvdWNoc3RhcnQuanN0cmVlXCIsIFwiLmpzdHJlZS1hbmNob3JcIiwgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdFx0aWYoIWUub3JpZ2luYWxFdmVudCB8fCAhZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzIHx8ICFlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pIHtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0ZXggPSBlLnBhZ2VYO1xyXG5cdFx0XHRcdFx0XHRleSA9IGUucGFnZVk7XHJcblx0XHRcdFx0XHRcdGN0byA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS50cmlnZ2VyKCdjb250ZXh0bWVudScsIHRydWUpO1xyXG5cdFx0XHRcdFx0XHR9LCA3NTApO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdC8qXHJcblx0XHRcdGlmKCEoJ29uY29udGV4dG1lbnUnIGluIGRvY3VtZW50LmJvZHkpICYmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5ib2R5KSkge1xyXG5cdFx0XHRcdHZhciBlbCA9IG51bGwsIHRtID0gbnVsbDtcclxuXHRcdFx0XHR0aGlzLmVsZW1lbnRcclxuXHRcdFx0XHRcdC5vbihcInRvdWNoc3RhcnRcIiwgXCIuanN0cmVlLWFuY2hvclwiLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHRlbCA9IGUuY3VycmVudFRhcmdldDtcclxuXHRcdFx0XHRcdFx0dG0gPSArbmV3IERhdGUoKTtcclxuXHRcdFx0XHRcdFx0JChkb2N1bWVudCkub25lKFwidG91Y2hlbmRcIiwgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdFx0XHRlLnRhcmdldCA9IGRvY3VtZW50LmVsZW1lbnRGcm9tUG9pbnQoZS5vcmlnaW5hbEV2ZW50LnRhcmdldFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC50YXJnZXRUb3VjaGVzWzBdLnBhZ2VZIC0gd2luZG93LnBhZ2VZT2Zmc2V0KTtcclxuXHRcdFx0XHRcdFx0XHRlLmN1cnJlbnRUYXJnZXQgPSBlLnRhcmdldDtcclxuXHRcdFx0XHRcdFx0XHR0bSA9ICgoKyhuZXcgRGF0ZSgpKSkgLSB0bSk7XHJcblx0XHRcdFx0XHRcdFx0aWYoZS50YXJnZXQgPT09IGVsICYmIHRtID4gNjAwICYmIHRtIDwgMTAwMCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0JChlbCkudHJpZ2dlcignY29udGV4dG1lbnUnLCBlKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0ZWwgPSBudWxsO1xyXG5cdFx0XHRcdFx0XHRcdHRtID0gbnVsbDtcclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0XHQqL1xyXG5cdFx0XHQkKGRvY3VtZW50KS5vbihcImNvbnRleHRfaGlkZS52YWthdGEuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkgeyB0aGlzLl9kYXRhLmNvbnRleHRtZW51LnZpc2libGUgPSBmYWxzZTsgfSwgdGhpcykpO1xyXG5cdFx0fTtcclxuXHRcdHRoaXMudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmKHRoaXMuX2RhdGEuY29udGV4dG1lbnUudmlzaWJsZSkge1xyXG5cdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHBhcmVudC50ZWFyZG93bi5jYWxsKHRoaXMpO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIHByZXBhcmUgYW5kIHNob3cgdGhlIGNvbnRleHQgbWVudSBmb3IgYSBub2RlXHJcblx0XHQgKiBAbmFtZSBzaG93X2NvbnRleHRtZW51KG9iaiBbLCB4LCB5XSlcclxuXHRcdCAqIEBwYXJhbSB7bWl4ZWR9IG9iaiB0aGUgbm9kZVxyXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHggdGhlIHgtY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxyXG5cdFx0ICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHktY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgZG9jdW1lbnQgdG8gc2hvdyB0aGUgbWVudSBhdFxyXG5cdFx0ICogQHBhcmFtIHtPYmplY3R9IGUgdGhlIGV2ZW50IGlmIGF2YWlsYWJsZSB0aGF0IHRyaWdnZXJlZCB0aGUgY29udGV4dG1lbnVcclxuXHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcclxuXHRcdCAqIEB0cmlnZ2VyIHNob3dfY29udGV4dG1lbnUuanN0cmVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuc2hvd19jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChvYmosIHgsIHksIGUpIHtcclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZighb2JqIHx8IG9iai5pZCA9PT0gJyMnKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHR2YXIgcyA9IHRoaXMuc2V0dGluZ3MuY29udGV4dG1lbnUsXHJcblx0XHRcdFx0ZCA9IHRoaXMuZ2V0X25vZGUob2JqLCB0cnVlKSxcclxuXHRcdFx0XHRhID0gZC5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLFxyXG5cdFx0XHRcdG8gPSBmYWxzZSxcclxuXHRcdFx0XHRpID0gZmFsc2U7XHJcblx0XHRcdGlmKHMuc2hvd19hdF9ub2RlIHx8IHggPT09IHVuZGVmaW5lZCB8fCB5ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRvID0gYS5vZmZzZXQoKTtcclxuXHRcdFx0XHR4ID0gby5sZWZ0O1xyXG5cdFx0XHRcdHkgPSBvLnRvcCArIHRoaXMuX2RhdGEuY29yZS5saV9oZWlnaHQ7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodGhpcy5zZXR0aW5ncy5jb250ZXh0bWVudS5zZWxlY3Rfbm9kZSAmJiAhdGhpcy5pc19zZWxlY3RlZChvYmopKSB7XHJcblx0XHRcdFx0dGhpcy5hY3RpdmF0ZV9ub2RlKG9iaiwgZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGkgPSBzLml0ZW1zO1xyXG5cdFx0XHRpZigkLmlzRnVuY3Rpb24oaSkpIHtcclxuXHRcdFx0XHRpID0gaS5jYWxsKHRoaXMsIG9iaiwgJC5wcm94eShmdW5jdGlvbiAoaSkge1xyXG5cdFx0XHRcdFx0dGhpcy5fc2hvd19jb250ZXh0bWVudShvYmosIHgsIHksIGkpO1xyXG5cdFx0XHRcdH0sIHRoaXMpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZigkLmlzUGxhaW5PYmplY3QoaSkpIHtcclxuXHRcdFx0XHR0aGlzLl9zaG93X2NvbnRleHRtZW51KG9iaiwgeCwgeSwgaSk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0XHQvKipcclxuXHRcdCAqIHNob3cgdGhlIHByZXBhcmVkIGNvbnRleHQgbWVudSBmb3IgYSBub2RlXHJcblx0XHQgKiBAbmFtZSBfc2hvd19jb250ZXh0bWVudShvYmosIHgsIHksIGkpXHJcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGVcclxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4IHRoZSB4LWNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50IHRvIHNob3cgdGhlIG1lbnUgYXRcclxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB5LWNvb3JkaW5hdGUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50IHRvIHNob3cgdGhlIG1lbnUgYXRcclxuXHRcdCAqIEBwYXJhbSB7TnVtYmVyfSBpIHRoZSBvYmplY3Qgb2YgaXRlbXMgdG8gc2hvd1xyXG5cdFx0ICogQHBsdWdpbiBjb250ZXh0bWVudVxyXG5cdFx0ICogQHRyaWdnZXIgc2hvd19jb250ZXh0bWVudS5qc3RyZWVcclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX3Nob3dfY29udGV4dG1lbnUgPSBmdW5jdGlvbiAob2JqLCB4LCB5LCBpKSB7XHJcblx0XHRcdHZhciBkID0gdGhpcy5nZXRfbm9kZShvYmosIHRydWUpLFxyXG5cdFx0XHRcdGEgPSBkLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIik7XHJcblx0XHRcdCQoZG9jdW1lbnQpLm9uZShcImNvbnRleHRfc2hvdy52YWthdGEuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuXHRcdFx0XHR2YXIgY2xzID0gJ2pzdHJlZS1jb250ZXh0bWVudSBqc3RyZWUtJyArIHRoaXMuZ2V0X3RoZW1lKCkgKyAnLWNvbnRleHRtZW51JztcclxuXHRcdFx0XHQkKGRhdGEuZWxlbWVudCkuYWRkQ2xhc3MoY2xzKTtcclxuXHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0XHR0aGlzLl9kYXRhLmNvbnRleHRtZW51LnZpc2libGUgPSB0cnVlO1xyXG5cdFx0XHQkLnZha2F0YS5jb250ZXh0LnNob3coYSwgeyAneCcgOiB4LCAneScgOiB5IH0sIGkpO1xyXG5cdFx0XHQvKipcclxuXHRcdFx0ICogdHJpZ2dlcmVkIHdoZW4gdGhlIGNvbnRleHRtZW51IGlzIHNob3duIGZvciBhIG5vZGVcclxuXHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdCAqIEBuYW1lIHNob3dfY29udGV4dG1lbnUuanN0cmVlXHJcblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIHRoZSBub2RlXHJcblx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB4IHRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIG1lbnUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50XHJcblx0XHRcdCAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSB5LWNvb3JkaW5hdGUgb2YgdGhlIG1lbnUgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50XHJcblx0XHRcdCAqIEBwbHVnaW4gY29udGV4dG1lbnVcclxuXHRcdFx0ICovXHJcblx0XHRcdHRoaXMudHJpZ2dlcignc2hvd19jb250ZXh0bWVudScsIHsgXCJub2RlXCIgOiBvYmosIFwieFwiIDogeCwgXCJ5XCIgOiB5IH0pO1xyXG5cdFx0fTtcclxuXHR9O1xyXG5cclxuXHQkKGZ1bmN0aW9uICgpIHtcclxuXHRcdCQoZG9jdW1lbnQpXHJcblx0XHRcdC5vbigndG91Y2htb3ZlLnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdGlmKGN0byAmJiBlLm9yaWdpbmFsRXZlbnQgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSAmJiAoTWF0aC5hYnMoZXggLSBlLnBhZ2VYKSA+IDUwIHx8IE1hdGguYWJzKGV5IC0gZS5wYWdlWSkgPiA1MCkpIHtcclxuXHRcdFx0XHRcdGNsZWFyVGltZW91dChjdG8pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSlcclxuXHRcdFx0Lm9uKCd0b3VjaGVuZC52YWthdGEuanN0cmVlJywgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRpZihjdG8pIHtcclxuXHRcdFx0XHRcdGNsZWFyVGltZW91dChjdG8pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdC8vIGNvbnRleHRtZW51IGhlbHBlclxyXG5cdChmdW5jdGlvbiAoJCkge1xyXG5cdFx0dmFyIHJpZ2h0X3RvX2xlZnQgPSBmYWxzZSxcclxuXHRcdFx0dmFrYXRhX2NvbnRleHQgPSB7XHJcblx0XHRcdFx0ZWxlbWVudFx0XHQ6IGZhbHNlLFxyXG5cdFx0XHRcdHJlZmVyZW5jZVx0OiBmYWxzZSxcclxuXHRcdFx0XHRwb3NpdGlvbl94XHQ6IDAsXHJcblx0XHRcdFx0cG9zaXRpb25feVx0OiAwLFxyXG5cdFx0XHRcdGl0ZW1zXHRcdDogW10sXHJcblx0XHRcdFx0aHRtbFx0XHQ6IFwiXCIsXHJcblx0XHRcdFx0aXNfdmlzaWJsZVx0OiBmYWxzZVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdCQudmFrYXRhLmNvbnRleHQgPSB7XHJcblx0XHRcdHNldHRpbmdzIDoge1xyXG5cdFx0XHRcdGhpZGVfb25tb3VzZWxlYXZlXHQ6IDAsXHJcblx0XHRcdFx0aWNvbnNcdFx0XHRcdDogdHJ1ZVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRfdHJpZ2dlciA6IGZ1bmN0aW9uIChldmVudF9uYW1lKSB7XHJcblx0XHRcdFx0JChkb2N1bWVudCkudHJpZ2dlckhhbmRsZXIoXCJjb250ZXh0X1wiICsgZXZlbnRfbmFtZSArIFwiLnZha2F0YVwiLCB7XHJcblx0XHRcdFx0XHRcInJlZmVyZW5jZVwiXHQ6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSxcclxuXHRcdFx0XHRcdFwiZWxlbWVudFwiXHQ6IHZha2F0YV9jb250ZXh0LmVsZW1lbnQsXHJcblx0XHRcdFx0XHRcInBvc2l0aW9uXCJcdDoge1xyXG5cdFx0XHRcdFx0XHRcInhcIiA6IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3gsXHJcblx0XHRcdFx0XHRcdFwieVwiIDogdmFrYXRhX2NvbnRleHQucG9zaXRpb25feVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRfZXhlY3V0ZSA6IGZ1bmN0aW9uIChpKSB7XHJcblx0XHRcdFx0aSA9IHZha2F0YV9jb250ZXh0Lml0ZW1zW2ldO1xyXG5cdFx0XHRcdHJldHVybiBpICYmICghaS5fZGlzYWJsZWQgfHwgKCQuaXNGdW5jdGlvbihpLl9kaXNhYmxlZCkgJiYgIWkuX2Rpc2FibGVkKHsgXCJpdGVtXCIgOiBpLCBcInJlZmVyZW5jZVwiIDogdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlLCBcImVsZW1lbnRcIiA6IHZha2F0YV9jb250ZXh0LmVsZW1lbnQgfSkpKSAmJiBpLmFjdGlvbiA/IGkuYWN0aW9uLmNhbGwobnVsbCwge1xyXG5cdFx0XHRcdFx0XHRcdFwiaXRlbVwiXHRcdDogaSxcclxuXHRcdFx0XHRcdFx0XHRcInJlZmVyZW5jZVwiXHQ6IHZha2F0YV9jb250ZXh0LnJlZmVyZW5jZSxcclxuXHRcdFx0XHRcdFx0XHRcImVsZW1lbnRcIlx0OiB2YWthdGFfY29udGV4dC5lbGVtZW50LFxyXG5cdFx0XHRcdFx0XHRcdFwicG9zaXRpb25cIlx0OiB7XHJcblx0XHRcdFx0XHRcdFx0XHRcInhcIiA6IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3gsXHJcblx0XHRcdFx0XHRcdFx0XHRcInlcIiA6IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3lcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH0pIDogZmFsc2U7XHJcblx0XHRcdH0sXHJcblx0XHRcdF9wYXJzZSA6IGZ1bmN0aW9uIChvLCBpc19jYWxsYmFjaykge1xyXG5cdFx0XHRcdGlmKCFvKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRcdGlmKCFpc19jYWxsYmFjaykge1xyXG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuaHRtbFx0XHQ9IFwiXCI7XHJcblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5pdGVtc1x0PSBbXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIHN0ciA9IFwiXCIsXHJcblx0XHRcdFx0XHRzZXAgPSBmYWxzZSxcclxuXHRcdFx0XHRcdHRtcDtcclxuXHJcblx0XHRcdFx0aWYoaXNfY2FsbGJhY2spIHsgc3RyICs9IFwiPFwiK1widWw+XCI7IH1cclxuXHRcdFx0XHQkLmVhY2gobywgZnVuY3Rpb24gKGksIHZhbCkge1xyXG5cdFx0XHRcdFx0aWYoIXZhbCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuaXRlbXMucHVzaCh2YWwpO1xyXG5cdFx0XHRcdFx0aWYoIXNlcCAmJiB2YWwuc2VwYXJhdG9yX2JlZm9yZSkge1xyXG5cdFx0XHRcdFx0XHRzdHIgKz0gXCI8XCIrXCJsaSBjbGFzcz0ndmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yJz48XCIrXCJhIGhyZWY9JyMnIFwiICsgKCQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaWNvbnMgPyAnJyA6ICdzdHlsZT1cIm1hcmdpbi1sZWZ0OjBweDtcIicpICsgXCI+JiMxNjA7PFwiK1wiL2E+PFwiK1wiL2xpPlwiO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c2VwID0gZmFsc2U7XHJcblx0XHRcdFx0XHRzdHIgKz0gXCI8XCIrXCJsaSBjbGFzcz0nXCIgKyAodmFsLl9jbGFzcyB8fCBcIlwiKSArICh2YWwuX2Rpc2FibGVkID09PSB0cnVlIHx8ICgkLmlzRnVuY3Rpb24odmFsLl9kaXNhYmxlZCkgJiYgdmFsLl9kaXNhYmxlZCh7IFwiaXRlbVwiIDogdmFsLCBcInJlZmVyZW5jZVwiIDogdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlLCBcImVsZW1lbnRcIiA6IHZha2F0YV9jb250ZXh0LmVsZW1lbnQgfSkpID8gXCIgdmFrYXRhLWNvbnRleHRtZW51LWRpc2FibGVkIFwiIDogXCJcIikgKyBcIicgXCIrKHZhbC5zaG9ydGN1dD9cIiBkYXRhLXNob3J0Y3V0PSdcIit2YWwuc2hvcnRjdXQrXCInIFwiOicnKStcIj5cIjtcclxuXHRcdFx0XHRcdHN0ciArPSBcIjxcIitcImEgaHJlZj0nIycgcmVsPSdcIiArICh2YWthdGFfY29udGV4dC5pdGVtcy5sZW5ndGggLSAxKSArIFwiJz5cIjtcclxuXHRcdFx0XHRcdGlmKCQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaWNvbnMpIHtcclxuXHRcdFx0XHRcdFx0c3RyICs9IFwiPFwiK1wiaSBcIjtcclxuXHRcdFx0XHRcdFx0aWYodmFsLmljb24pIHtcclxuXHRcdFx0XHRcdFx0XHRpZih2YWwuaWNvbi5pbmRleE9mKFwiL1wiKSAhPT0gLTEgfHwgdmFsLmljb24uaW5kZXhPZihcIi5cIikgIT09IC0xKSB7IHN0ciArPSBcIiBzdHlsZT0nYmFja2dyb3VuZDp1cmwoXFxcIlwiICsgdmFsLmljb24gKyBcIlxcXCIpIGNlbnRlciBjZW50ZXIgbm8tcmVwZWF0JyBcIjsgfVxyXG5cdFx0XHRcdFx0XHRcdGVsc2UgeyBzdHIgKz0gXCIgY2xhc3M9J1wiICsgdmFsLmljb24gKyBcIicgXCI7IH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRzdHIgKz0gXCI+PFwiK1wiL2k+PFwiK1wic3BhbiBjbGFzcz0ndmFrYXRhLWNvbnRleHRtZW51LXNlcCc+JiMxNjA7PFwiK1wiL3NwYW4+XCI7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRzdHIgKz0gKCQuaXNGdW5jdGlvbih2YWwubGFiZWwpID8gdmFsLmxhYmVsKHsgXCJpdGVtXCIgOiBpLCBcInJlZmVyZW5jZVwiIDogdmFrYXRhX2NvbnRleHQucmVmZXJlbmNlLCBcImVsZW1lbnRcIiA6IHZha2F0YV9jb250ZXh0LmVsZW1lbnQgfSkgOiB2YWwubGFiZWwpICsgKHZhbC5zaG9ydGN1dD8nIDxzcGFuIGNsYXNzPVwidmFrYXRhLWNvbnRleHRtZW51LXNob3J0Y3V0IHZha2F0YS1jb250ZXh0bWVudS1zaG9ydGN1dC0nK3ZhbC5zaG9ydGN1dCsnXCI+JysgKHZhbC5zaG9ydGN1dF9sYWJlbCB8fCAnJykgKyc8L3NwYW4+JzonJykgKyBcIjxcIitcIi9hPlwiO1xyXG5cdFx0XHRcdFx0aWYodmFsLnN1Ym1lbnUpIHtcclxuXHRcdFx0XHRcdFx0dG1wID0gJC52YWthdGEuY29udGV4dC5fcGFyc2UodmFsLnN1Ym1lbnUsIHRydWUpO1xyXG5cdFx0XHRcdFx0XHRpZih0bXApIHsgc3RyICs9IHRtcDsgfVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c3RyICs9IFwiPFwiK1wiL2xpPlwiO1xyXG5cdFx0XHRcdFx0aWYodmFsLnNlcGFyYXRvcl9hZnRlcikge1xyXG5cdFx0XHRcdFx0XHRzdHIgKz0gXCI8XCIrXCJsaSBjbGFzcz0ndmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yJz48XCIrXCJhIGhyZWY9JyMnIFwiICsgKCQudmFrYXRhLmNvbnRleHQuc2V0dGluZ3MuaWNvbnMgPyAnJyA6ICdzdHlsZT1cIm1hcmdpbi1sZWZ0OjBweDtcIicpICsgXCI+JiMxNjA7PFwiK1wiL2E+PFwiK1wiL2xpPlwiO1xyXG5cdFx0XHRcdFx0XHRzZXAgPSB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHN0ciAgPSBzdHIucmVwbGFjZSgvPGxpIGNsYXNzXFw9J3Zha2F0YS1jb250ZXh0LXNlcGFyYXRvcidcXD48XFwvbGlcXD4kLyxcIlwiKTtcclxuXHRcdFx0XHRpZihpc19jYWxsYmFjaykgeyBzdHIgKz0gXCI8L3VsPlwiOyB9XHJcblx0XHRcdFx0LyoqXHJcblx0XHRcdFx0ICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBwYXJzZWQgKEhUTUwgaXMgYnVpbHQpXHJcblx0XHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdFx0ICogQHBsdWdpbiBjb250ZXh0bWVudVxyXG5cdFx0XHRcdCAqIEBuYW1lIGNvbnRleHRfcGFyc2UudmFrYXRhXHJcblx0XHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IHJlZmVyZW5jZSB0aGUgZWxlbWVudCB0aGF0IHdhcyByaWdodCBjbGlja2VkXHJcblx0XHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBtZW51IGl0c2VsZlxyXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiB0aGUgeCAmIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1lbnVcclxuXHRcdFx0XHQgKi9cclxuXHRcdFx0XHRpZighaXNfY2FsbGJhY2spIHsgdmFrYXRhX2NvbnRleHQuaHRtbCA9IHN0cjsgJC52YWthdGEuY29udGV4dC5fdHJpZ2dlcihcInBhcnNlXCIpOyB9XHJcblx0XHRcdFx0cmV0dXJuIHN0ci5sZW5ndGggPiAxMCA/IHN0ciA6IGZhbHNlO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRfc2hvd19zdWJtZW51IDogZnVuY3Rpb24gKG8pIHtcclxuXHRcdFx0XHRvID0gJChvKTtcclxuXHRcdFx0XHRpZighby5sZW5ndGggfHwgIW8uY2hpbGRyZW4oXCJ1bFwiKS5sZW5ndGgpIHsgcmV0dXJuOyB9XHJcblx0XHRcdFx0dmFyIGUgPSBvLmNoaWxkcmVuKFwidWxcIiksXHJcblx0XHRcdFx0XHR4ID0gby5vZmZzZXQoKS5sZWZ0ICsgby5vdXRlcldpZHRoKCksXHJcblx0XHRcdFx0XHR5ID0gby5vZmZzZXQoKS50b3AsXHJcblx0XHRcdFx0XHR3ID0gZS53aWR0aCgpLFxyXG5cdFx0XHRcdFx0aCA9IGUuaGVpZ2h0KCksXHJcblx0XHRcdFx0XHRkdyA9ICQod2luZG93KS53aWR0aCgpICsgJCh3aW5kb3cpLnNjcm9sbExlZnQoKSxcclxuXHRcdFx0XHRcdGRoID0gJCh3aW5kb3cpLmhlaWdodCgpICsgJCh3aW5kb3cpLnNjcm9sbFRvcCgpO1xyXG5cdFx0XHRcdC8vINC80L7QttC1INC00LAg0YHQtSDRgdC/0LXRgdGC0Lgg0LUg0LXQtNC90LAg0L/RgNC+0LLQtdGA0LrQsCAtINC00LDQu9C4INC90Y/QvNCwINC90Y/QutC+0Lkg0L7RgiDQutC70LDRgdC+0LLQtdGC0LUg0LLQtdGH0LUg0L3QsNCz0L7RgNC1XHJcblx0XHRcdFx0aWYocmlnaHRfdG9fbGVmdCkge1xyXG5cdFx0XHRcdFx0b1t4IC0gKHcgKyAxMCArIG8ub3V0ZXJXaWR0aCgpKSA8IDAgPyBcImFkZENsYXNzXCIgOiBcInJlbW92ZUNsYXNzXCJdKFwidmFrYXRhLWNvbnRleHQtbGVmdFwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRvW3ggKyB3ICsgMTAgPiBkdyA/IFwiYWRkQ2xhc3NcIiA6IFwicmVtb3ZlQ2xhc3NcIl0oXCJ2YWthdGEtY29udGV4dC1yaWdodFwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoeSArIGggKyAxMCA+IGRoKSB7XHJcblx0XHRcdFx0XHRlLmNzcyhcImJvdHRvbVwiLFwiLTFweFwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZS5zaG93KCk7XHJcblx0XHRcdH0sXHJcblx0XHRcdHNob3cgOiBmdW5jdGlvbiAocmVmZXJlbmNlLCBwb3NpdGlvbiwgZGF0YSkge1xyXG5cdFx0XHRcdHZhciBvLCBlLCB4LCB5LCB3LCBoLCBkdywgZGgsIGNvbmQgPSB0cnVlO1xyXG5cdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0LmVsZW1lbnQgJiYgdmFrYXRhX2NvbnRleHQuZWxlbWVudC5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQud2lkdGgoJycpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRzd2l0Y2goY29uZCkge1xyXG5cdFx0XHRcdFx0Y2FzZSAoIXBvc2l0aW9uICYmICFyZWZlcmVuY2UpOlxyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0XHRjYXNlICghIXBvc2l0aW9uICYmICEhcmVmZXJlbmNlKTpcclxuXHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQucmVmZXJlbmNlXHQ9IHJlZmVyZW5jZTtcclxuXHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQucG9zaXRpb25feFx0PSBwb3NpdGlvbi54O1xyXG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl95XHQ9IHBvc2l0aW9uLnk7XHJcblx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0Y2FzZSAoIXBvc2l0aW9uICYmICEhcmVmZXJlbmNlKTpcclxuXHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQucmVmZXJlbmNlXHQ9IHJlZmVyZW5jZTtcclxuXHRcdFx0XHRcdFx0byA9IHJlZmVyZW5jZS5vZmZzZXQoKTtcclxuXHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQucG9zaXRpb25feFx0PSBvLmxlZnQgKyByZWZlcmVuY2Uub3V0ZXJIZWlnaHQoKTtcclxuXHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQucG9zaXRpb25feVx0PSBvLnRvcDtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlICghIXBvc2l0aW9uICYmICFyZWZlcmVuY2UpOlxyXG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5wb3NpdGlvbl94XHQ9IHBvc2l0aW9uLng7XHJcblx0XHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3lcdD0gcG9zaXRpb24ueTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCEhcmVmZXJlbmNlICYmICFkYXRhICYmICQocmVmZXJlbmNlKS5kYXRhKCd2YWthdGFfY29udGV4dG1lbnUnKSkge1xyXG5cdFx0XHRcdFx0ZGF0YSA9ICQocmVmZXJlbmNlKS5kYXRhKCd2YWthdGFfY29udGV4dG1lbnUnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoJC52YWthdGEuY29udGV4dC5fcGFyc2UoZGF0YSkpIHtcclxuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuaHRtbCh2YWthdGFfY29udGV4dC5odG1sKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYodmFrYXRhX2NvbnRleHQuaXRlbXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5lbGVtZW50LmFwcGVuZFRvKFwiYm9keVwiKTtcclxuXHRcdFx0XHRcdGUgPSB2YWthdGFfY29udGV4dC5lbGVtZW50O1xyXG5cdFx0XHRcdFx0eCA9IHZha2F0YV9jb250ZXh0LnBvc2l0aW9uX3g7XHJcblx0XHRcdFx0XHR5ID0gdmFrYXRhX2NvbnRleHQucG9zaXRpb25feTtcclxuXHRcdFx0XHRcdHcgPSBlLndpZHRoKCk7XHJcblx0XHRcdFx0XHRoID0gZS5oZWlnaHQoKTtcclxuXHRcdFx0XHRcdGR3ID0gJCh3aW5kb3cpLndpZHRoKCkgKyAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpO1xyXG5cdFx0XHRcdFx0ZGggPSAkKHdpbmRvdykuaGVpZ2h0KCkgKyAkKHdpbmRvdykuc2Nyb2xsVG9wKCk7XHJcblx0XHRcdFx0XHRpZihyaWdodF90b19sZWZ0KSB7XHJcblx0XHRcdFx0XHRcdHggLT0gKGUub3V0ZXJXaWR0aCgpIC0gJChyZWZlcmVuY2UpLm91dGVyV2lkdGgoKSk7XHJcblx0XHRcdFx0XHRcdGlmKHggPCAkKHdpbmRvdykuc2Nyb2xsTGVmdCgpICsgMjApIHtcclxuXHRcdFx0XHRcdFx0XHR4ID0gJCh3aW5kb3cpLnNjcm9sbExlZnQoKSArIDIwO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZih4ICsgdyArIDIwID4gZHcpIHtcclxuXHRcdFx0XHRcdFx0eCA9IGR3IC0gKHcgKyAyMCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZih5ICsgaCArIDIwID4gZGgpIHtcclxuXHRcdFx0XHRcdFx0eSA9IGRoIC0gKGggKyAyMCk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudFxyXG5cdFx0XHRcdFx0XHQuY3NzKHsgXCJsZWZ0XCIgOiB4LCBcInRvcFwiIDogeSB9KVxyXG5cdFx0XHRcdFx0XHQuc2hvdygpXHJcblx0XHRcdFx0XHRcdC5maW5kKCdhJykuZmlyc3QoKS5mb2N1cygpLnBhcmVudCgpLmFkZENsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIik7XHJcblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5pc192aXNpYmxlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdC8qKlxyXG5cdFx0XHRcdFx0ICogdHJpZ2dlcmVkIG9uIHRoZSBkb2N1bWVudCB3aGVuIHRoZSBjb250ZXh0bWVudSBpcyBzaG93blxyXG5cdFx0XHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdFx0XHQgKiBAcGx1Z2luIGNvbnRleHRtZW51XHJcblx0XHRcdFx0XHQgKiBAbmFtZSBjb250ZXh0X3Nob3cudmFrYXRhXHJcblx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHJpZ2h0IGNsaWNrZWRcclxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBvZiB0aGUgbWVudSBpdHNlbGZcclxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiB0aGUgeCAmIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1lbnVcclxuXHRcdFx0XHRcdCAqL1xyXG5cdFx0XHRcdFx0JC52YWthdGEuY29udGV4dC5fdHJpZ2dlcihcInNob3dcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cdFx0XHRoaWRlIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcclxuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuaGlkZSgpLmZpbmQoXCJ1bFwiKS5oaWRlKCkuZW5kKCkuZmluZCgnOmZvY3VzJykuYmx1cigpLmVuZCgpLmRldGFjaCgpO1xyXG5cdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0LyoqXHJcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gdGhlIGNvbnRleHRtZW51IGlzIGhpZGRlblxyXG5cdFx0XHRcdFx0ICogQGV2ZW50XHJcblx0XHRcdFx0XHQgKiBAcGx1Z2luIGNvbnRleHRtZW51XHJcblx0XHRcdFx0XHQgKiBAbmFtZSBjb250ZXh0X2hpZGUudmFrYXRhXHJcblx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gcmVmZXJlbmNlIHRoZSBlbGVtZW50IHRoYXQgd2FzIHJpZ2h0IGNsaWNrZWRcclxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBvZiB0aGUgbWVudSBpdHNlbGZcclxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiB0aGUgeCAmIHkgY29vcmRpbmF0ZXMgb2YgdGhlIG1lbnVcclxuXHRcdFx0XHRcdCAqL1xyXG5cdFx0XHRcdFx0JC52YWthdGEuY29udGV4dC5fdHJpZ2dlcihcImhpZGVcIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0JChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJpZ2h0X3RvX2xlZnQgPSAkKFwiYm9keVwiKS5jc3MoXCJkaXJlY3Rpb25cIikgPT09IFwicnRsXCI7XHJcblx0XHRcdHZhciB0byA9IGZhbHNlO1xyXG5cclxuXHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudCA9ICQoXCI8dWwgY2xhc3M9J3Zha2F0YS1jb250ZXh0Jz48L3VsPlwiKTtcclxuXHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudFxyXG5cdFx0XHRcdC5vbihcIm1vdXNlZW50ZXJcIiwgXCJsaVwiLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuXHJcblx0XHRcdFx0XHRpZigkLmNvbnRhaW5zKHRoaXMsIGUucmVsYXRlZFRhcmdldCkpIHtcclxuXHRcdFx0XHRcdFx0Ly8g0L/RgNC10LzQsNGF0L3QsNGC0L4g0LfQsNGA0LDQtNC4IGRlbGVnYXRlIG1vdXNlbGVhdmUg0L/Qvi3QtNC+0LvRg1xyXG5cdFx0XHRcdFx0XHQvLyAkKHRoaXMpLmZpbmQoXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcIikucmVtb3ZlQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmKHRvKSB7IGNsZWFyVGltZW91dCh0byk7IH1cclxuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcIi52YWthdGEtY29udGV4dC1ob3ZlclwiKS5yZW1vdmVDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmVuZCgpO1xyXG5cclxuXHRcdFx0XHRcdCQodGhpcylcclxuXHRcdFx0XHRcdFx0LnNpYmxpbmdzKCkuZmluZChcInVsXCIpLmhpZGUoKS5lbmQoKS5lbmQoKVxyXG5cdFx0XHRcdFx0XHQucGFyZW50c1VudGlsKFwiLnZha2F0YS1jb250ZXh0XCIsIFwibGlcIikuYWRkQmFjaygpLmFkZENsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIik7XHJcblx0XHRcdFx0XHQkLnZha2F0YS5jb250ZXh0Ll9zaG93X3N1Ym1lbnUodGhpcyk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XHQvLyDRgtC10YHRgtC+0LLQviAtINC00LDQu9C4INC90LUg0L3QsNGC0L7QstCw0YDQstCwP1xyXG5cdFx0XHRcdC5vbihcIm1vdXNlbGVhdmVcIiwgXCJsaVwiLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0aWYoJC5jb250YWlucyh0aGlzLCBlLnJlbGF0ZWRUYXJnZXQpKSB7IHJldHVybjsgfVxyXG5cdFx0XHRcdFx0JCh0aGlzKS5maW5kKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmFkZEJhY2soKS5yZW1vdmVDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwibW91c2VsZWF2ZVwiLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0JCh0aGlzKS5maW5kKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIik7XHJcblx0XHRcdFx0XHRpZigkLnZha2F0YS5jb250ZXh0LnNldHRpbmdzLmhpZGVfb25tb3VzZWxlYXZlKSB7XHJcblx0XHRcdFx0XHRcdHRvID0gc2V0VGltZW91dChcclxuXHRcdFx0XHRcdFx0XHQoZnVuY3Rpb24gKHQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiAoKSB7ICQudmFrYXRhLmNvbnRleHQuaGlkZSgpOyB9O1xyXG5cdFx0XHRcdFx0XHRcdH0odGhpcykpLCAkLnZha2F0YS5jb250ZXh0LnNldHRpbmdzLmhpZGVfb25tb3VzZWxlYXZlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5vbihcImNsaWNrXCIsIFwiYVwiLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdC8vfSlcclxuXHRcdFx0XHQvLy5vbihcIm1vdXNldXBcIiwgXCJhXCIsIGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRpZighJCh0aGlzKS5ibHVyKCkucGFyZW50KCkuaGFzQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1kaXNhYmxlZFwiKSAmJiAkLnZha2F0YS5jb250ZXh0Ll9leGVjdXRlKCQodGhpcykuYXR0cihcInJlbFwiKSkgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKCdrZXlkb3duJywgJ2EnLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgbyA9IG51bGw7XHJcblx0XHRcdFx0XHRcdHN3aXRjaChlLndoaWNoKSB7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAxMzpcclxuXHRcdFx0XHRcdFx0XHRjYXNlIDMyOlxyXG5cdFx0XHRcdFx0XHRcdFx0ZS50eXBlID0gXCJtb3VzZXVwXCI7XHJcblx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0XHRcdFx0XHQkKGUuY3VycmVudFRhcmdldCkudHJpZ2dlcihlKTtcclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgMzc6XHJcblx0XHRcdFx0XHRcdFx0XHRpZih2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcIi52YWthdGEtY29udGV4dC1ob3ZlclwiKS5sYXN0KCkuY2xvc2VzdChcImxpXCIpLmZpcnN0KCkuZmluZChcInVsXCIpLmhpZGUoKS5maW5kKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIikuZW5kKCkuZW5kKCkuY2hpbGRyZW4oJ2EnKS5mb2N1cygpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRjYXNlIDM4OlxyXG5cdFx0XHRcdFx0XHRcdFx0aWYodmFrYXRhX2NvbnRleHQuaXNfdmlzaWJsZSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRvID0gdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwidWw6dmlzaWJsZVwiKS5hZGRCYWNrKCkubGFzdCgpLmNoaWxkcmVuKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLnJlbW92ZUNsYXNzKFwidmFrYXRhLWNvbnRleHQtaG92ZXJcIikucHJldkFsbChcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVwiKS5maXJzdCgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZighby5sZW5ndGgpIHsgbyA9IHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcInVsOnZpc2libGVcIikuYWRkQmFjaygpLmxhc3QoKS5jaGlsZHJlbihcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVwiKS5sYXN0KCk7IH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0by5hZGRDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmNoaWxkcmVuKCdhJykuZm9jdXMoKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAzOTpcclxuXHRcdFx0XHRcdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwiLnZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmxhc3QoKS5jaGlsZHJlbihcInVsXCIpLnNob3coKS5jaGlsZHJlbihcImxpOm5vdCgudmFrYXRhLWNvbnRleHQtc2VwYXJhdG9yKVwiKS5yZW1vdmVDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmZpcnN0KCkuYWRkQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKS5jaGlsZHJlbignYScpLmZvY3VzKCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdGNhc2UgNDA6XHJcblx0XHRcdFx0XHRcdFx0XHRpZih2YWthdGFfY29udGV4dC5pc192aXNpYmxlKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG8gPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXCJ1bDp2aXNpYmxlXCIpLmFkZEJhY2soKS5sYXN0KCkuY2hpbGRyZW4oXCIudmFrYXRhLWNvbnRleHQtaG92ZXJcIikucmVtb3ZlQ2xhc3MoXCJ2YWthdGEtY29udGV4dC1ob3ZlclwiKS5uZXh0QWxsKFwibGk6bm90KC52YWthdGEtY29udGV4dC1zZXBhcmF0b3IpXCIpLmZpcnN0KCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKCFvLmxlbmd0aCkgeyBvID0gdmFrYXRhX2NvbnRleHQuZWxlbWVudC5maW5kKFwidWw6dmlzaWJsZVwiKS5hZGRCYWNrKCkubGFzdCgpLmNoaWxkcmVuKFwibGk6bm90KC52YWthdGEtY29udGV4dC1zZXBhcmF0b3IpXCIpLmZpcnN0KCk7IH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0by5hZGRDbGFzcyhcInZha2F0YS1jb250ZXh0LWhvdmVyXCIpLmNoaWxkcmVuKCdhJykuZm9jdXMoKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0Y2FzZSAyNzpcclxuXHRcdFx0XHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coZS53aGljaCk7XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSlcclxuXHRcdFx0XHQub24oJ2tleWRvd24nLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0dmFyIGEgPSB2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoJy52YWthdGEtY29udGV4dG1lbnUtc2hvcnRjdXQtJyArIGUud2hpY2gpLnBhcmVudCgpO1xyXG5cdFx0XHRcdFx0aWYoYS5wYXJlbnQoKS5ub3QoJy52YWthdGEtY29udGV4dC1kaXNhYmxlZCcpKSB7XHJcblx0XHRcdFx0XHRcdGEuY2xpY2soKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdCQoZG9jdW1lbnQpXHJcblx0XHRcdFx0Lm9uKFwibW91c2Vkb3duLnZha2F0YS5qc3RyZWVcIiwgZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdGlmKHZha2F0YV9jb250ZXh0LmlzX3Zpc2libGUgJiYgISQuY29udGFpbnModmFrYXRhX2NvbnRleHQuZWxlbWVudFswXSwgZS50YXJnZXQpKSB7XHJcblx0XHRcdFx0XHRcdCQudmFrYXRhLmNvbnRleHQuaGlkZSgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwiY29udGV4dF9zaG93LnZha2F0YS5qc3RyZWVcIiwgZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuXHRcdFx0XHRcdHZha2F0YV9jb250ZXh0LmVsZW1lbnQuZmluZChcImxpOmhhcyh1bClcIikuY2hpbGRyZW4oXCJhXCIpLmFkZENsYXNzKFwidmFrYXRhLWNvbnRleHQtcGFyZW50XCIpO1xyXG5cdFx0XHRcdFx0aWYocmlnaHRfdG9fbGVmdCkge1xyXG5cdFx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5lbGVtZW50LmFkZENsYXNzKFwidmFrYXRhLWNvbnRleHQtcnRsXCIpLmNzcyhcImRpcmVjdGlvblwiLCBcInJ0bFwiKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vIGFsc28gYXBwbHkgYSBSVEwgY2xhc3M/XHJcblx0XHRcdFx0XHR2YWthdGFfY29udGV4dC5lbGVtZW50LmZpbmQoXCJ1bFwiKS5oaWRlKCkuZW5kKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9KCQpKTtcclxuXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJjb250ZXh0bWVudVwiKTtcclxuXHJcbi8qKlxyXG4gKiAjIyMgRHJhZyduJ2Ryb3AgcGx1Z2luXHJcbiAqXHJcbiAqIEVuYWJsZXMgZHJhZ2dpbmcgYW5kIGRyb3BwaW5nIG9mIG5vZGVzIGluIHRoZSB0cmVlLCByZXN1bHRpbmcgaW4gYSBtb3ZlIG9yIGNvcHkgb3BlcmF0aW9ucy5cclxuICovXHJcblxyXG5cdC8qKlxyXG5cdCAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBkcmFnJ24nZHJvcCBwbHVnaW5cclxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmRcclxuXHQgKiBAcGx1Z2luIGRuZFxyXG5cdCAqL1xyXG5cdCQuanN0cmVlLmRlZmF1bHRzLmRuZCA9IHtcclxuXHRcdC8qKlxyXG5cdFx0ICogYSBib29sZWFuIGluZGljYXRpbmcgaWYgYSBjb3B5IHNob3VsZCBiZSBwb3NzaWJsZSB3aGlsZSBkcmFnZ2luZyAoYnkgcHJlc3NpbnQgdGhlIG1ldGEga2V5IG9yIEN0cmwpLiBEZWZhdWx0cyB0byBgdHJ1ZWAuXHJcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuY29weVxyXG5cdFx0ICogQHBsdWdpbiBkbmRcclxuXHRcdCAqL1xyXG5cdFx0Y29weSA6IHRydWUsXHJcblx0XHQvKipcclxuXHRcdCAqIGEgbnVtYmVyIGluZGljYXRpbmcgaG93IGxvbmcgYSBub2RlIHNob3VsZCByZW1haW4gaG92ZXJlZCB3aGlsZSBkcmFnZ2luZyB0byBiZSBvcGVuZWQuIERlZmF1bHRzIHRvIGA1MDBgLlxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLm9wZW5fdGltZW91dFxyXG5cdFx0ICogQHBsdWdpbiBkbmRcclxuXHRcdCAqL1xyXG5cdFx0b3Blbl90aW1lb3V0IDogNTAwLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBhIGZ1bmN0aW9uIGludm9rZWQgZWFjaCB0aW1lIGEgbm9kZSBpcyBhYm91dCB0byBiZSBkcmFnZ2VkLCBpbnZva2VkIGluIHRoZSB0cmVlJ3Mgc2NvcGUgYW5kIHJlY2VpdmVzIHRoZSBub2RlcyBhYm91dCB0byBiZSBkcmFnZ2VkIGFzIGFuIGFyZ3VtZW50IChhcnJheSkgLSByZXR1cm4gYGZhbHNlYCB0byBwcmV2ZW50IGRyYWdnaW5nXHJcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5kbmQuaXNfZHJhZ2dhYmxlXHJcblx0XHQgKiBAcGx1Z2luIGRuZFxyXG5cdFx0ICovXHJcblx0XHRpc19kcmFnZ2FibGUgOiB0cnVlLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBjaGVja3Mgc2hvdWxkIGNvbnN0YW50bHkgYmUgbWFkZSB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZyB0aGUgbm9kZSAoYXMgb3Bwb3NlZCB0byBjaGVja2luZyBvbmx5IG9uIGRyb3ApLCBkZWZhdWx0IGlzIGB0cnVlYFxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmNoZWNrX3doaWxlX2RyYWdnaW5nXHJcblx0XHQgKiBAcGx1Z2luIGRuZFxyXG5cdFx0ICovXHJcblx0XHRjaGVja193aGlsZV9kcmFnZ2luZyA6IHRydWUsXHJcblx0XHQvKipcclxuXHRcdCAqIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIG5vZGVzIGZyb20gdGhpcyB0cmVlIHNob3VsZCBvbmx5IGJlIGNvcGllZCB3aXRoIGRuZCAoYXMgb3Bwb3NlZCB0byBtb3ZlZCksIGRlZmF1bHQgaXMgYGZhbHNlYFxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmFsd2F5c19jb3B5XHJcblx0XHQgKiBAcGx1Z2luIGRuZFxyXG5cdFx0ICovXHJcblx0XHRhbHdheXNfY29weSA6IGZhbHNlLFxyXG5cdFx0LyoqXHJcblx0XHQgKiB3aGVuIGRyb3BwaW5nIGEgbm9kZSBcImluc2lkZVwiLCB0aGlzIHNldHRpbmcgaW5kaWNhdGVzIHRoZSBwb3NpdGlvbiB0aGUgbm9kZSBzaG91bGQgZ28gdG8gLSBpdCBjYW4gYmUgYW4gaW50ZWdlciBvciBhIHN0cmluZzogXCJmaXJzdFwiIChzYW1lIGFzIDApIG9yIFwibGFzdFwiLCBkZWZhdWx0IGlzIGAwYFxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmluc2lkZV9wb3NcclxuXHRcdCAqIEBwbHVnaW4gZG5kXHJcblx0XHQgKi9cclxuXHRcdGluc2lkZV9wb3MgOiAwLFxyXG5cdFx0LyoqXHJcblx0XHQgKiB3aGVuIHN0YXJ0aW5nIHRoZSBkcmFnIG9uIGEgbm9kZSB0aGF0IGlzIHNlbGVjdGVkIHRoaXMgc2V0dGluZyBjb250cm9scyBpZiBhbGwgc2VsZWN0ZWQgbm9kZXMgYXJlIGRyYWdnZWQgb3Igb25seSB0aGUgc2luZ2xlIG5vZGUsIGRlZmF1bHQgaXMgYHRydWVgLCB3aGljaCBtZWFucyBhbGwgc2VsZWN0ZWQgbm9kZXMgYXJlIGRyYWdnZWQgd2hlbiB0aGUgZHJhZyBpcyBzdGFydGVkIG9uIGEgc2VsZWN0ZWQgbm9kZVxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLmRyYWdfc2VsZWN0aW9uXHJcblx0XHQgKiBAcGx1Z2luIGRuZFxyXG5cdFx0ICovXHJcblx0XHRkcmFnX3NlbGVjdGlvbiA6IHRydWUsXHJcblx0XHQvKipcclxuXHRcdCAqIGNvbnRyb2xzIHdoZXRoZXIgZG5kIHdvcmtzIG9uIHRvdWNoIGRldmljZXMuIElmIGxlZnQgYXMgYm9vbGVhbiB0cnVlIGRuZCB3aWxsIHdvcmsgdGhlIHNhbWUgYXMgaW4gZGVza3RvcCBicm93c2Vycywgd2hpY2ggaW4gc29tZSBjYXNlcyBtYXkgaW1wYWlyIHNjcm9sbGluZy4gSWYgc2V0IHRvIGJvb2xlYW4gZmFsc2UgZG5kIHdpbGwgbm90IHdvcmsgb24gdG91Y2ggZGV2aWNlcy4gVGhlcmUgaXMgYSBzcGVjaWFsIHRoaXJkIG9wdGlvbiAtIHN0cmluZyBcInNlbGVjdGVkXCIgd2hpY2ggbWVhbnMgb25seSBzZWxlY3RlZCBub2RlcyBjYW4gYmUgZHJhZ2dlZCBvbiB0b3VjaCBkZXZpY2VzLlxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuZG5kLnRvdWNoXHJcblx0XHQgKiBAcGx1Z2luIGRuZFxyXG5cdFx0ICovXHJcblx0XHR0b3VjaCA6IHRydWVcclxuXHR9O1xyXG5cdC8vIFRPRE86IG5vdyBjaGVjayB3b3JrcyBieSBjaGVja2luZyBmb3IgZWFjaCBub2RlIGluZGl2aWR1YWxseSwgaG93IGFib3V0IG1heF9jaGlsZHJlbiwgdW5pcXVlLCBldGM/XHJcblx0JC5qc3RyZWUucGx1Z2lucy5kbmQgPSBmdW5jdGlvbiAob3B0aW9ucywgcGFyZW50KSB7XHJcblx0XHR0aGlzLmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHBhcmVudC5iaW5kLmNhbGwodGhpcyk7XHJcblxyXG5cdFx0XHR0aGlzLmVsZW1lbnRcclxuXHRcdFx0XHQub24oJ21vdXNlZG93bi5qc3RyZWUgdG91Y2hzdGFydC5qc3RyZWUnLCAnLmpzdHJlZS1hbmNob3InLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRpZihlLnR5cGUgPT09IFwidG91Y2hzdGFydFwiICYmICghdGhpcy5zZXR0aW5ncy5kbmQudG91Y2ggfHwgKHRoaXMuc2V0dGluZ3MuZG5kLnRvdWNoID09PSAnc2VsZWN0ZWQnICYmICEkKGUuY3VycmVudFRhcmdldCkuaGFzQ2xhc3MoJ2pzdHJlZS1jbGlja2VkJykpKSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHZhciBvYmogPSB0aGlzLmdldF9ub2RlKGUudGFyZ2V0KSxcclxuXHRcdFx0XHRcdFx0bWx0ID0gdGhpcy5pc19zZWxlY3RlZChvYmopICYmIHRoaXMuc2V0dGluZ3MuZHJhZ19zZWxlY3Rpb24gPyB0aGlzLmdldF9zZWxlY3RlZCgpLmxlbmd0aCA6IDEsXHJcblx0XHRcdFx0XHRcdHR4dCA9IChtbHQgPiAxID8gbWx0ICsgJyAnICsgdGhpcy5nZXRfc3RyaW5nKCdub2RlcycpIDogdGhpcy5nZXRfdGV4dChlLmN1cnJlbnRUYXJnZXQpKTtcclxuXHRcdFx0XHRcdGlmKHRoaXMuc2V0dGluZ3MuY29yZS5mb3JjZV90ZXh0KSB7XHJcblx0XHRcdFx0XHRcdHR4dCA9ICQoJzxkaXYgLz4nKS50ZXh0KHR4dCkuaHRtbCgpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYob2JqICYmIG9iai5pZCAmJiBvYmouaWQgIT09IFwiI1wiICYmIChlLndoaWNoID09PSAxIHx8IGUudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIpICYmXHJcblx0XHRcdFx0XHRcdCh0aGlzLnNldHRpbmdzLmRuZC5pc19kcmFnZ2FibGUgPT09IHRydWUgfHwgKCQuaXNGdW5jdGlvbih0aGlzLnNldHRpbmdzLmRuZC5pc19kcmFnZ2FibGUpICYmIHRoaXMuc2V0dGluZ3MuZG5kLmlzX2RyYWdnYWJsZS5jYWxsKHRoaXMsIChtbHQgPiAxID8gdGhpcy5nZXRfc2VsZWN0ZWQodHJ1ZSkgOiBbb2JqXSkpKSlcclxuXHRcdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQudHJpZ2dlcignbW91c2Vkb3duLmpzdHJlZScpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gJC52YWthdGEuZG5kLnN0YXJ0KGUsIHsgJ2pzdHJlZScgOiB0cnVlLCAnb3JpZ2luJyA6IHRoaXMsICdvYmonIDogdGhpcy5nZXRfbm9kZShvYmosdHJ1ZSksICdub2RlcycgOiBtbHQgPiAxID8gdGhpcy5nZXRfc2VsZWN0ZWQoKSA6IFtvYmouaWRdIH0sICc8ZGl2IGlkPVwianN0cmVlLWRuZFwiIGNsYXNzPVwianN0cmVlLScgKyB0aGlzLmdldF90aGVtZSgpICsgJyBqc3RyZWUtJyArIHRoaXMuZ2V0X3RoZW1lKCkgKyAnLScgKyB0aGlzLmdldF90aGVtZV92YXJpYW50KCkgKyAnICcgKyAoIHRoaXMuc2V0dGluZ3MuY29yZS50aGVtZXMucmVzcG9uc2l2ZSA/ICcganN0cmVlLWRuZC1yZXNwb25zaXZlJyA6ICcnICkgKyAnXCI+PGkgY2xhc3M9XCJqc3RyZWUtaWNvbiBqc3RyZWUtZXJcIj48L2k+JyArIHR4dCArICc8aW5zIGNsYXNzPVwianN0cmVlLWNvcHlcIiBzdHlsZT1cImRpc3BsYXk6bm9uZTtcIj4rPC9pbnM+PC9kaXY+Jyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0fTtcclxuXHR9O1xyXG5cclxuXHQkKGZ1bmN0aW9uKCkge1xyXG5cdFx0Ly8gYmluZCBvbmx5IG9uY2UgZm9yIGFsbCBpbnN0YW5jZXNcclxuXHRcdHZhciBsYXN0bXYgPSBmYWxzZSxcclxuXHRcdFx0bGFzdGVyID0gZmFsc2UsXHJcblx0XHRcdG9wZW50byA9IGZhbHNlLFxyXG5cdFx0XHRtYXJrZXIgPSAkKCc8ZGl2IGlkPVwianN0cmVlLW1hcmtlclwiPiYjMTYwOzwvZGl2PicpLmhpZGUoKTsgLy8uYXBwZW5kVG8oJ2JvZHknKTtcclxuXHJcblx0XHQkKGRvY3VtZW50KVxyXG5cdFx0XHQub24oJ2RuZF9zdGFydC52YWthdGEuanN0cmVlJywgZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuXHRcdFx0XHRsYXN0bXYgPSBmYWxzZTtcclxuXHRcdFx0XHRpZighZGF0YSB8fCAhZGF0YS5kYXRhIHx8ICFkYXRhLmRhdGEuanN0cmVlKSB7IHJldHVybjsgfVxyXG5cdFx0XHRcdG1hcmtlci5hcHBlbmRUbygnYm9keScpOyAvLy5zaG93KCk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5vbignZG5kX21vdmUudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XHJcblx0XHRcdFx0aWYob3BlbnRvKSB7IGNsZWFyVGltZW91dChvcGVudG8pOyB9XHJcblx0XHRcdFx0aWYoIWRhdGEgfHwgIWRhdGEuZGF0YSB8fCAhZGF0YS5kYXRhLmpzdHJlZSkgeyByZXR1cm47IH1cclxuXHJcblx0XHRcdFx0Ly8gaWYgd2UgYXJlIGhvdmVyaW5nIHRoZSBtYXJrZXIgaW1hZ2UgZG8gbm90aGluZyAoY2FuIGhhcHBlbiBvbiBcImluc2lkZVwiIGRyYWdzKVxyXG5cdFx0XHRcdGlmKGRhdGEuZXZlbnQudGFyZ2V0LmlkICYmIGRhdGEuZXZlbnQudGFyZ2V0LmlkID09PSAnanN0cmVlLW1hcmtlcicpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBpbnMgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5ldmVudC50YXJnZXQpLFxyXG5cdFx0XHRcdFx0cmVmID0gZmFsc2UsXHJcblx0XHRcdFx0XHRvZmYgPSBmYWxzZSxcclxuXHRcdFx0XHRcdHJlbCA9IGZhbHNlLFxyXG5cdFx0XHRcdFx0bCwgdCwgaCwgcCwgaSwgbywgb2ssIHQxLCB0Miwgb3AsIHBzLCBwciwgaXAsIHRtO1xyXG5cdFx0XHRcdC8vIGlmIHdlIGFyZSBvdmVyIGFuIGluc3RhbmNlXHJcblx0XHRcdFx0aWYoaW5zICYmIGlucy5fZGF0YSAmJiBpbnMuX2RhdGEuZG5kKSB7XHJcblx0XHRcdFx0XHRtYXJrZXIuYXR0cignY2xhc3MnLCAnanN0cmVlLScgKyBpbnMuZ2V0X3RoZW1lKCkgKyAoIGlucy5zZXR0aW5ncy5jb3JlLnRoZW1lcy5yZXNwb25zaXZlID8gJyBqc3RyZWUtZG5kLXJlc3BvbnNpdmUnIDogJycgKSk7XHJcblx0XHRcdFx0XHRkYXRhLmhlbHBlclxyXG5cdFx0XHRcdFx0XHQuY2hpbGRyZW4oKS5hdHRyKCdjbGFzcycsICdqc3RyZWUtJyArIGlucy5nZXRfdGhlbWUoKSArICcganN0cmVlLScgKyBpbnMuZ2V0X3RoZW1lKCkgKyAnLScgKyBpbnMuZ2V0X3RoZW1lX3ZhcmlhbnQoKSArICcgJyArICggaW5zLnNldHRpbmdzLmNvcmUudGhlbWVzLnJlc3BvbnNpdmUgPyAnIGpzdHJlZS1kbmQtcmVzcG9uc2l2ZScgOiAnJyApKVxyXG5cdFx0XHRcdFx0XHQuZmluZCgnLmpzdHJlZS1jb3B5JykuZmlyc3QoKVsgZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmNvcHkgJiYgKGRhdGEuZXZlbnQubWV0YUtleSB8fCBkYXRhLmV2ZW50LmN0cmxLZXkpKSkgPyAnc2hvdycgOiAnaGlkZScgXSgpO1xyXG5cclxuXHJcblx0XHRcdFx0XHQvLyBpZiBhcmUgaG92ZXJpbmcgdGhlIGNvbnRhaW5lciBpdHNlbGYgYWRkIGEgbmV3IHJvb3Qgbm9kZVxyXG5cdFx0XHRcdFx0aWYoIChkYXRhLmV2ZW50LnRhcmdldCA9PT0gaW5zLmVsZW1lbnRbMF0gfHwgZGF0YS5ldmVudC50YXJnZXQgPT09IGlucy5nZXRfY29udGFpbmVyX3VsKClbMF0pICYmIGlucy5nZXRfY29udGFpbmVyX3VsKCkuY2hpbGRyZW4oKS5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHRcdFx0b2sgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IGRhdGEuZGF0YS5ub2Rlcy5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcclxuXHRcdFx0XHRcdFx0XHRvayA9IG9rICYmIGlucy5jaGVjayggKGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSkgKSA/IFwiY29weV9ub2RlXCIgOiBcIm1vdmVfbm9kZVwiKSwgKGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiAhPT0gaW5zID8gZGF0YS5kYXRhLm9yaWdpbi5nZXRfbm9kZShkYXRhLmRhdGEubm9kZXNbdDFdKSA6IGRhdGEuZGF0YS5ub2Rlc1t0MV0pLCAnIycsICdsYXN0JywgeyAnZG5kJyA6IHRydWUsICdyZWYnIDogaW5zLmdldF9ub2RlKCcjJyksICdwb3MnIDogJ2knLCAnaXNfbXVsdGknIDogKGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiAhPT0gaW5zKSwgJ2lzX2ZvcmVpZ24nIDogKCFkYXRhLmRhdGEub3JpZ2luKSB9KTtcclxuXHRcdFx0XHRcdFx0XHRpZighb2spIHsgYnJlYWs7IH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZihvaykge1xyXG5cdFx0XHRcdFx0XHRcdGxhc3RtdiA9IHsgJ2lucycgOiBpbnMsICdwYXInIDogJyMnLCAncG9zJyA6ICdsYXN0JyB9O1xyXG5cdFx0XHRcdFx0XHRcdG1hcmtlci5oaWRlKCk7XHJcblx0XHRcdFx0XHRcdFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1pY29uJykuZmlyc3QoKS5yZW1vdmVDbGFzcygnanN0cmVlLWVyJykuYWRkQ2xhc3MoJ2pzdHJlZS1vaycpO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRcdC8vIGlmIHdlIGFyZSBob3ZlcmluZyBhIHRyZWUgbm9kZVxyXG5cdFx0XHRcdFx0XHRyZWYgPSAkKGRhdGEuZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlLWFuY2hvcicpO1xyXG5cdFx0XHRcdFx0XHRpZihyZWYgJiYgcmVmLmxlbmd0aCAmJiByZWYucGFyZW50KCkuaXMoJy5qc3RyZWUtY2xvc2VkLCAuanN0cmVlLW9wZW4sIC5qc3RyZWUtbGVhZicpKSB7XHJcblx0XHRcdFx0XHRcdFx0b2ZmID0gcmVmLm9mZnNldCgpO1xyXG5cdFx0XHRcdFx0XHRcdHJlbCA9IGRhdGEuZXZlbnQucGFnZVkgLSBvZmYudG9wO1xyXG5cdFx0XHRcdFx0XHRcdGggPSByZWYuaGVpZ2h0KCk7XHJcblx0XHRcdFx0XHRcdFx0aWYocmVsIDwgaCAvIDMpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG8gPSBbJ2InLCAnaScsICdhJ107XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGVsc2UgaWYocmVsID4gaCAtIGggLyAzKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRvID0gWydhJywgJ2knLCAnYiddO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdG8gPSByZWwgPiBoIC8gMiA/IFsnaScsICdhJywgJ2InXSA6IFsnaScsICdiJywgJ2EnXTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0JC5lYWNoKG8sIGZ1bmN0aW9uIChqLCB2KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2godikge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlICdiJzpcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsID0gb2ZmLmxlZnQgLSA2O1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHQgPSBvZmYudG9wO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSBpbnMuZ2V0X3BhcmVudChyZWYpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGkgPSByZWYucGFyZW50KCkuaW5kZXgoKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FzZSAnaSc6XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aXAgPSBpbnMuc2V0dGluZ3MuZG5kLmluc2lkZV9wb3M7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dG0gPSBpbnMuZ2V0X25vZGUocmVmLnBhcmVudCgpKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRsID0gb2ZmLmxlZnQgLSAyO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHQgPSBvZmYudG9wICsgaCAvIDIgKyAxO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSB0bS5pZDtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpID0gaXAgPT09ICdmaXJzdCcgPyAwIDogKGlwID09PSAnbGFzdCcgPyB0bS5jaGlsZHJlbi5sZW5ndGggOiBNYXRoLm1pbihpcCwgdG0uY2hpbGRyZW4ubGVuZ3RoKSk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGNhc2UgJ2EnOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGwgPSBvZmYubGVmdCAtIDY7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0dCA9IG9mZi50b3AgKyBoO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHAgPSBpbnMuZ2V0X3BhcmVudChyZWYpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGkgPSByZWYucGFyZW50KCkuaW5kZXgoKSArIDE7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRvayA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRmb3IodDEgPSAwLCB0MiA9IGRhdGEuZGF0YS5ub2Rlcy5sZW5ndGg7IHQxIDwgdDI7IHQxKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0b3AgPSBkYXRhLmRhdGEub3JpZ2luICYmIChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5hbHdheXNfY29weSB8fCAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuY29weSAmJiAoZGF0YS5ldmVudC5tZXRhS2V5IHx8IGRhdGEuZXZlbnQuY3RybEtleSkpKSA/IFwiY29weV9ub2RlXCIgOiBcIm1vdmVfbm9kZVwiO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRwcyA9IGk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmKG9wID09PSBcIm1vdmVfbm9kZVwiICYmIHYgPT09ICdhJyAmJiAoZGF0YS5kYXRhLm9yaWdpbiAmJiBkYXRhLmRhdGEub3JpZ2luID09PSBpbnMpICYmIHAgPT09IGlucy5nZXRfcGFyZW50KGRhdGEuZGF0YS5ub2Rlc1t0MV0pKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0cHIgPSBpbnMuZ2V0X25vZGUocCk7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYocHMgPiAkLmluQXJyYXkoZGF0YS5kYXRhLm5vZGVzW3QxXSwgcHIuY2hpbGRyZW4pKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRwcyAtPSAxO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRvayA9IG9rICYmICggKGlucyAmJiBpbnMuc2V0dGluZ3MgJiYgaW5zLnNldHRpbmdzLmRuZCAmJiBpbnMuc2V0dGluZ3MuZG5kLmNoZWNrX3doaWxlX2RyYWdnaW5nID09PSBmYWxzZSkgfHwgaW5zLmNoZWNrKG9wLCAoZGF0YS5kYXRhLm9yaWdpbiAmJiBkYXRhLmRhdGEub3JpZ2luICE9PSBpbnMgPyBkYXRhLmRhdGEub3JpZ2luLmdldF9ub2RlKGRhdGEuZGF0YS5ub2Rlc1t0MV0pIDogZGF0YS5kYXRhLm5vZGVzW3QxXSksIHAsIHBzLCB7ICdkbmQnIDogdHJ1ZSwgJ3JlZicgOiBpbnMuZ2V0X25vZGUocmVmLnBhcmVudCgpKSwgJ3BvcycgOiB2LCAnaXNfbXVsdGknIDogKGRhdGEuZGF0YS5vcmlnaW4gJiYgZGF0YS5kYXRhLm9yaWdpbiAhPT0gaW5zKSwgJ2lzX2ZvcmVpZ24nIDogKCFkYXRhLmRhdGEub3JpZ2luKSB9KSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRpZighb2spIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZihpbnMgJiYgaW5zLmxhc3RfZXJyb3IpIHsgbGFzdGVyID0gaW5zLmxhc3RfZXJyb3IoKTsgfVxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZih2ID09PSAnaScgJiYgcmVmLnBhcmVudCgpLmlzKCcuanN0cmVlLWNsb3NlZCcpICYmIGlucy5zZXR0aW5ncy5kbmQub3Blbl90aW1lb3V0KSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG9wZW50byA9IHNldFRpbWVvdXQoKGZ1bmN0aW9uICh4LCB6KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHgub3Blbl9ub2RlKHopOyB9OyB9KGlucywgcmVmKSksIGlucy5zZXR0aW5ncy5kbmQub3Blbl90aW1lb3V0KTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdGlmKG9rKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGxhc3RtdiA9IHsgJ2lucycgOiBpbnMsICdwYXInIDogcCwgJ3BvcycgOiB2ID09PSAnaScgJiYgaXAgPT09ICdsYXN0JyAmJiBpID09PSAwICYmICFpbnMuaXNfbG9hZGVkKHRtKSA/ICdsYXN0JyA6IGkgfTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0bWFya2VyLmNzcyh7ICdsZWZ0JyA6IGwgKyAncHgnLCAndG9wJyA6IHQgKyAncHgnIH0pLnNob3coKTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1pY29uJykuZmlyc3QoKS5yZW1vdmVDbGFzcygnanN0cmVlLWVyJykuYWRkQ2xhc3MoJ2pzdHJlZS1vaycpO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRsYXN0ZXIgPSB7fTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0byA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0XHRpZihvID09PSB0cnVlKSB7IHJldHVybjsgfVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGxhc3RtdiA9IGZhbHNlO1xyXG5cdFx0XHRcdGRhdGEuaGVscGVyLmZpbmQoJy5qc3RyZWUtaWNvbicpLnJlbW92ZUNsYXNzKCdqc3RyZWUtb2snKS5hZGRDbGFzcygnanN0cmVlLWVyJyk7XHJcblx0XHRcdFx0bWFya2VyLmhpZGUoKTtcclxuXHRcdFx0fSlcclxuXHRcdFx0Lm9uKCdkbmRfc2Nyb2xsLnZha2F0YS5qc3RyZWUnLCBmdW5jdGlvbiAoZSwgZGF0YSkge1xyXG5cdFx0XHRcdGlmKCFkYXRhIHx8ICFkYXRhLmRhdGEgfHwgIWRhdGEuZGF0YS5qc3RyZWUpIHsgcmV0dXJuOyB9XHJcblx0XHRcdFx0bWFya2VyLmhpZGUoKTtcclxuXHRcdFx0XHRsYXN0bXYgPSBmYWxzZTtcclxuXHRcdFx0XHRkYXRhLmhlbHBlci5maW5kKCcuanN0cmVlLWljb24nKS5maXJzdCgpLnJlbW92ZUNsYXNzKCdqc3RyZWUtb2snKS5hZGRDbGFzcygnanN0cmVlLWVyJyk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5vbignZG5kX3N0b3AudmFrYXRhLmpzdHJlZScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XHJcblx0XHRcdFx0aWYob3BlbnRvKSB7IGNsZWFyVGltZW91dChvcGVudG8pOyB9XHJcblx0XHRcdFx0aWYoIWRhdGEgfHwgIWRhdGEuZGF0YSB8fCAhZGF0YS5kYXRhLmpzdHJlZSkgeyByZXR1cm47IH1cclxuXHRcdFx0XHRtYXJrZXIuaGlkZSgpLmRldGFjaCgpO1xyXG5cdFx0XHRcdHZhciBpLCBqLCBub2RlcyA9IFtdO1xyXG5cdFx0XHRcdGlmKGxhc3Rtdikge1xyXG5cdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZGF0YS5kYXRhLm5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRub2Rlc1tpXSA9IGRhdGEuZGF0YS5vcmlnaW4gPyBkYXRhLmRhdGEub3JpZ2luLmdldF9ub2RlKGRhdGEuZGF0YS5ub2Rlc1tpXSkgOiBkYXRhLmRhdGEubm9kZXNbaV07XHJcblx0XHRcdFx0XHRcdGlmKGRhdGEuZGF0YS5vcmlnaW4pIHtcclxuXHRcdFx0XHRcdFx0XHRub2Rlc1tpXS5pbnN0YW5jZSA9IGRhdGEuZGF0YS5vcmlnaW47XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGxhc3Rtdi5pbnNbIGRhdGEuZGF0YS5vcmlnaW4gJiYgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmFsd2F5c19jb3B5IHx8IChkYXRhLmRhdGEub3JpZ2luLnNldHRpbmdzLmRuZC5jb3B5ICYmIChkYXRhLmV2ZW50Lm1ldGFLZXkgfHwgZGF0YS5ldmVudC5jdHJsS2V5KSkpID8gJ2NvcHlfbm9kZScgOiAnbW92ZV9ub2RlJyBdKG5vZGVzLCBsYXN0bXYucGFyLCBsYXN0bXYucG9zKTtcclxuXHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG5vZGVzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRpZihub2Rlc1tpXS5pbnN0YW5jZSkge1xyXG5cdFx0XHRcdFx0XHRcdG5vZGVzW2ldLmluc3RhbmNlID0gbnVsbDtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdGkgPSAkKGRhdGEuZXZlbnQudGFyZ2V0KS5jbG9zZXN0KCcuanN0cmVlJyk7XHJcblx0XHRcdFx0XHRpZihpLmxlbmd0aCAmJiBsYXN0ZXIgJiYgbGFzdGVyLmVycm9yICYmIGxhc3Rlci5lcnJvciA9PT0gJ2NoZWNrJykge1xyXG5cdFx0XHRcdFx0XHRpID0gaS5qc3RyZWUodHJ1ZSk7XHJcblx0XHRcdFx0XHRcdGlmKGkpIHtcclxuXHRcdFx0XHRcdFx0XHRpLnNldHRpbmdzLmNvcmUuZXJyb3IuY2FsbCh0aGlzLCBsYXN0ZXIpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KVxyXG5cdFx0XHQub24oJ2tleXVwLmpzdHJlZSBrZXlkb3duLmpzdHJlZScsIGZ1bmN0aW9uIChlLCBkYXRhKSB7XHJcblx0XHRcdFx0ZGF0YSA9ICQudmFrYXRhLmRuZC5fZ2V0KCk7XHJcblx0XHRcdFx0aWYoZGF0YSAmJiBkYXRhLmRhdGEgJiYgZGF0YS5kYXRhLmpzdHJlZSkge1xyXG5cdFx0XHRcdFx0ZGF0YS5oZWxwZXIuZmluZCgnLmpzdHJlZS1jb3B5JykuZmlyc3QoKVsgZGF0YS5kYXRhLm9yaWdpbiAmJiAoZGF0YS5kYXRhLm9yaWdpbi5zZXR0aW5ncy5kbmQuYWx3YXlzX2NvcHkgfHwgKGRhdGEuZGF0YS5vcmlnaW4uc2V0dGluZ3MuZG5kLmNvcHkgJiYgKGUubWV0YUtleSB8fCBlLmN0cmxLZXkpKSkgPyAnc2hvdycgOiAnaGlkZScgXSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0fSk7XHJcblxyXG5cdC8vIGhlbHBlcnNcclxuXHQoZnVuY3Rpb24gKCQpIHtcclxuXHRcdC8vIHByaXZhdGUgdmFyaWFibGVcclxuXHRcdHZhciB2YWthdGFfZG5kID0ge1xyXG5cdFx0XHRlbGVtZW50XHQ6IGZhbHNlLFxyXG5cdFx0XHR0YXJnZXRcdDogZmFsc2UsXHJcblx0XHRcdGlzX2Rvd25cdDogZmFsc2UsXHJcblx0XHRcdGlzX2RyYWdcdDogZmFsc2UsXHJcblx0XHRcdGhlbHBlclx0OiBmYWxzZSxcclxuXHRcdFx0aGVscGVyX3c6IDAsXHJcblx0XHRcdGRhdGFcdDogZmFsc2UsXHJcblx0XHRcdGluaXRfeFx0OiAwLFxyXG5cdFx0XHRpbml0X3lcdDogMCxcclxuXHRcdFx0c2Nyb2xsX2w6IDAsXHJcblx0XHRcdHNjcm9sbF90OiAwLFxyXG5cdFx0XHRzY3JvbGxfZTogZmFsc2UsXHJcblx0XHRcdHNjcm9sbF9pOiBmYWxzZSxcclxuXHRcdFx0aXNfdG91Y2g6IGZhbHNlXHJcblx0XHR9O1xyXG5cdFx0JC52YWthdGEuZG5kID0ge1xyXG5cdFx0XHRzZXR0aW5ncyA6IHtcclxuXHRcdFx0XHRzY3JvbGxfc3BlZWRcdFx0OiAxMCxcclxuXHRcdFx0XHRzY3JvbGxfcHJveGltaXR5XHQ6IDIwLFxyXG5cdFx0XHRcdGhlbHBlcl9sZWZ0XHRcdFx0OiA1LFxyXG5cdFx0XHRcdGhlbHBlcl90b3BcdFx0XHQ6IDEwLFxyXG5cdFx0XHRcdHRocmVzaG9sZFx0XHRcdDogNSxcclxuXHRcdFx0XHR0aHJlc2hvbGRfdG91Y2hcdFx0OiA1MFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRfdHJpZ2dlciA6IGZ1bmN0aW9uIChldmVudF9uYW1lLCBlKSB7XHJcblx0XHRcdFx0dmFyIGRhdGEgPSAkLnZha2F0YS5kbmQuX2dldCgpO1xyXG5cdFx0XHRcdGRhdGEuZXZlbnQgPSBlO1xyXG5cdFx0XHRcdCQoZG9jdW1lbnQpLnRyaWdnZXJIYW5kbGVyKFwiZG5kX1wiICsgZXZlbnRfbmFtZSArIFwiLnZha2F0YVwiLCBkYXRhKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0X2dldCA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdFx0XCJkYXRhXCJcdFx0OiB2YWthdGFfZG5kLmRhdGEsXHJcblx0XHRcdFx0XHRcImVsZW1lbnRcIlx0OiB2YWthdGFfZG5kLmVsZW1lbnQsXHJcblx0XHRcdFx0XHRcImhlbHBlclwiXHQ6IHZha2F0YV9kbmQuaGVscGVyXHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSxcclxuXHRcdFx0X2NsZWFuIDogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdGlmKHZha2F0YV9kbmQuaGVscGVyKSB7IHZha2F0YV9kbmQuaGVscGVyLnJlbW92ZSgpOyB9XHJcblx0XHRcdFx0aWYodmFrYXRhX2RuZC5zY3JvbGxfaSkgeyBjbGVhckludGVydmFsKHZha2F0YV9kbmQuc2Nyb2xsX2kpOyB2YWthdGFfZG5kLnNjcm9sbF9pID0gZmFsc2U7IH1cclxuXHRcdFx0XHR2YWthdGFfZG5kID0ge1xyXG5cdFx0XHRcdFx0ZWxlbWVudFx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdHRhcmdldFx0OiBmYWxzZSxcclxuXHRcdFx0XHRcdGlzX2Rvd25cdDogZmFsc2UsXHJcblx0XHRcdFx0XHRpc19kcmFnXHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0aGVscGVyXHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0aGVscGVyX3c6IDAsXHJcblx0XHRcdFx0XHRkYXRhXHQ6IGZhbHNlLFxyXG5cdFx0XHRcdFx0aW5pdF94XHQ6IDAsXHJcblx0XHRcdFx0XHRpbml0X3lcdDogMCxcclxuXHRcdFx0XHRcdHNjcm9sbF9sOiAwLFxyXG5cdFx0XHRcdFx0c2Nyb2xsX3Q6IDAsXHJcblx0XHRcdFx0XHRzY3JvbGxfZTogZmFsc2UsXHJcblx0XHRcdFx0XHRzY3JvbGxfaTogZmFsc2UsXHJcblx0XHRcdFx0XHRpc190b3VjaDogZmFsc2VcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdCQoZG9jdW1lbnQpLm9mZihcIm1vdXNlbW92ZS52YWthdGEuanN0cmVlIHRvdWNobW92ZS52YWthdGEuanN0cmVlXCIsICQudmFrYXRhLmRuZC5kcmFnKTtcclxuXHRcdFx0XHQkKGRvY3VtZW50KS5vZmYoXCJtb3VzZXVwLnZha2F0YS5qc3RyZWUgdG91Y2hlbmQudmFrYXRhLmpzdHJlZVwiLCAkLnZha2F0YS5kbmQuc3RvcCk7XHJcblx0XHRcdH0sXHJcblx0XHRcdF9zY3JvbGwgOiBmdW5jdGlvbiAoaW5pdF9vbmx5KSB7XHJcblx0XHRcdFx0aWYoIXZha2F0YV9kbmQuc2Nyb2xsX2UgfHwgKCF2YWthdGFfZG5kLnNjcm9sbF9sICYmICF2YWthdGFfZG5kLnNjcm9sbF90KSkge1xyXG5cdFx0XHRcdFx0aWYodmFrYXRhX2RuZC5zY3JvbGxfaSkgeyBjbGVhckludGVydmFsKHZha2F0YV9kbmQuc2Nyb2xsX2kpOyB2YWthdGFfZG5kLnNjcm9sbF9pID0gZmFsc2U7IH1cclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIXZha2F0YV9kbmQuc2Nyb2xsX2kpIHtcclxuXHRcdFx0XHRcdHZha2F0YV9kbmQuc2Nyb2xsX2kgPSBzZXRJbnRlcnZhbCgkLnZha2F0YS5kbmQuX3Njcm9sbCwgMTAwKTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoaW5pdF9vbmx5ID09PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdFx0XHR2YXIgaSA9IHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsVG9wKCksXHJcblx0XHRcdFx0XHRqID0gdmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxMZWZ0KCk7XHJcblx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfZS5zY3JvbGxUb3AoaSArIHZha2F0YV9kbmQuc2Nyb2xsX3QgKiAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3NwZWVkKTtcclxuXHRcdFx0XHR2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbExlZnQoaiArIHZha2F0YV9kbmQuc2Nyb2xsX2wgKiAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3NwZWVkKTtcclxuXHRcdFx0XHRpZihpICE9PSB2YWthdGFfZG5kLnNjcm9sbF9lLnNjcm9sbFRvcCgpIHx8IGogIT09IHZha2F0YV9kbmQuc2Nyb2xsX2Uuc2Nyb2xsTGVmdCgpKSB7XHJcblx0XHRcdFx0XHQvKipcclxuXHRcdFx0XHRcdCAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiBhIGRyYWcgY2F1c2VzIGFuIGVsZW1lbnQgdG8gc2Nyb2xsXHJcblx0XHRcdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0XHRcdCAqIEBwbHVnaW4gZG5kXHJcblx0XHRcdFx0XHQgKiBAbmFtZSBkbmRfc2Nyb2xsLnZha2F0YVxyXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtNaXhlZH0gZGF0YSBhbnkgZGF0YSBzdXBwbGllZCB3aXRoIHRoZSBjYWxsIHRvICQudmFrYXRhLmRuZC5zdGFydFxyXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtET019IGVsZW1lbnQgdGhlIERPTSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcclxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBoZWxwZXIgdGhlIGhlbHBlciBzaG93biBuZXh0IHRvIHRoZSBtb3VzZVxyXG5cdFx0XHRcdFx0ICogQHBhcmFtIHtqUXVlcnl9IGV2ZW50IHRoZSBlbGVtZW50IHRoYXQgaXMgc2Nyb2xsaW5nXHJcblx0XHRcdFx0XHQgKi9cclxuXHRcdFx0XHRcdCQudmFrYXRhLmRuZC5fdHJpZ2dlcihcInNjcm9sbFwiLCB2YWthdGFfZG5kLnNjcm9sbF9lKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdHN0YXJ0IDogZnVuY3Rpb24gKGUsIGRhdGEsIGh0bWwpIHtcclxuXHRcdFx0XHRpZihlLnR5cGUgPT09IFwidG91Y2hzdGFydFwiICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSB7XHJcblx0XHRcdFx0XHRlLnBhZ2VYID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xyXG5cdFx0XHRcdFx0ZS5wYWdlWSA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcclxuXHRcdFx0XHRcdGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHZha2F0YV9kbmQuaXNfZHJhZykgeyAkLnZha2F0YS5kbmQuc3RvcCh7fSk7IH1cclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0ZS5jdXJyZW50VGFyZ2V0LnVuc2VsZWN0YWJsZSA9IFwib25cIjtcclxuXHRcdFx0XHRcdGUuY3VycmVudFRhcmdldC5vbnNlbGVjdHN0YXJ0ID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcclxuXHRcdFx0XHRcdGlmKGUuY3VycmVudFRhcmdldC5zdHlsZSkgeyBlLmN1cnJlbnRUYXJnZXQuc3R5bGUuTW96VXNlclNlbGVjdCA9IFwibm9uZVwiOyB9XHJcblx0XHRcdFx0fSBjYXRjaChpZ25vcmUpIHsgfVxyXG5cdFx0XHRcdHZha2F0YV9kbmQuaW5pdF94XHQ9IGUucGFnZVg7XHJcblx0XHRcdFx0dmFrYXRhX2RuZC5pbml0X3lcdD0gZS5wYWdlWTtcclxuXHRcdFx0XHR2YWthdGFfZG5kLmRhdGFcdFx0PSBkYXRhO1xyXG5cdFx0XHRcdHZha2F0YV9kbmQuaXNfZG93blx0PSB0cnVlO1xyXG5cdFx0XHRcdHZha2F0YV9kbmQuZWxlbWVudFx0PSBlLmN1cnJlbnRUYXJnZXQ7XHJcblx0XHRcdFx0dmFrYXRhX2RuZC50YXJnZXRcdD0gZS50YXJnZXQ7XHJcblx0XHRcdFx0dmFrYXRhX2RuZC5pc190b3VjaFx0PSBlLnR5cGUgPT09IFwidG91Y2hzdGFydFwiO1xyXG5cdFx0XHRcdGlmKGh0bWwgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0XHR2YWthdGFfZG5kLmhlbHBlciA9ICQoXCI8ZGl2IGlkPSd2YWthdGEtZG5kJz48L2Rpdj5cIikuaHRtbChodG1sKS5jc3Moe1xyXG5cdFx0XHRcdFx0XHRcImRpc3BsYXlcIlx0XHQ6IFwiYmxvY2tcIixcclxuXHRcdFx0XHRcdFx0XCJtYXJnaW5cIlx0XHQ6IFwiMFwiLFxyXG5cdFx0XHRcdFx0XHRcInBhZGRpbmdcIlx0XHQ6IFwiMFwiLFxyXG5cdFx0XHRcdFx0XHRcInBvc2l0aW9uXCJcdFx0OiBcImFic29sdXRlXCIsXHJcblx0XHRcdFx0XHRcdFwidG9wXCJcdFx0XHQ6IFwiLTIwMDBweFwiLFxyXG5cdFx0XHRcdFx0XHRcImxpbmVIZWlnaHRcIlx0OiBcIjE2cHhcIixcclxuXHRcdFx0XHRcdFx0XCJ6SW5kZXhcIlx0XHQ6IFwiMTAwMDBcIlxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdCQoZG9jdW1lbnQpLm9uKFwibW91c2Vtb3ZlLnZha2F0YS5qc3RyZWUgdG91Y2htb3ZlLnZha2F0YS5qc3RyZWVcIiwgJC52YWthdGEuZG5kLmRyYWcpO1xyXG5cdFx0XHRcdCQoZG9jdW1lbnQpLm9uKFwibW91c2V1cC52YWthdGEuanN0cmVlIHRvdWNoZW5kLnZha2F0YS5qc3RyZWVcIiwgJC52YWthdGEuZG5kLnN0b3ApO1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fSxcclxuXHRcdFx0ZHJhZyA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0aWYoZS50eXBlID09PSBcInRvdWNobW92ZVwiICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSB7XHJcblx0XHRcdFx0XHRlLnBhZ2VYID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xyXG5cdFx0XHRcdFx0ZS5wYWdlWSA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcclxuXHRcdFx0XHRcdGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCF2YWthdGFfZG5kLmlzX2Rvd24pIHsgcmV0dXJuOyB9XHJcblx0XHRcdFx0aWYoIXZha2F0YV9kbmQuaXNfZHJhZykge1xyXG5cdFx0XHRcdFx0aWYoXHJcblx0XHRcdFx0XHRcdE1hdGguYWJzKGUucGFnZVggLSB2YWthdGFfZG5kLmluaXRfeCkgPiAodmFrYXRhX2RuZC5pc190b3VjaCA/ICQudmFrYXRhLmRuZC5zZXR0aW5ncy50aHJlc2hvbGRfdG91Y2ggOiAkLnZha2F0YS5kbmQuc2V0dGluZ3MudGhyZXNob2xkKSB8fFxyXG5cdFx0XHRcdFx0XHRNYXRoLmFicyhlLnBhZ2VZIC0gdmFrYXRhX2RuZC5pbml0X3kpID4gKHZha2F0YV9kbmQuaXNfdG91Y2ggPyAkLnZha2F0YS5kbmQuc2V0dGluZ3MudGhyZXNob2xkX3RvdWNoIDogJC52YWthdGEuZG5kLnNldHRpbmdzLnRocmVzaG9sZClcclxuXHRcdFx0XHRcdCkge1xyXG5cdFx0XHRcdFx0XHRpZih2YWthdGFfZG5kLmhlbHBlcikge1xyXG5cdFx0XHRcdFx0XHRcdHZha2F0YV9kbmQuaGVscGVyLmFwcGVuZFRvKFwiYm9keVwiKTtcclxuXHRcdFx0XHRcdFx0XHR2YWthdGFfZG5kLmhlbHBlcl93ID0gdmFrYXRhX2RuZC5oZWxwZXIub3V0ZXJXaWR0aCgpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHZha2F0YV9kbmQuaXNfZHJhZyA9IHRydWU7XHJcblx0XHRcdFx0XHRcdC8qKlxyXG5cdFx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gYSBkcmFnIHN0YXJ0c1xyXG5cdFx0XHRcdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0XHRcdFx0ICogQHBsdWdpbiBkbmRcclxuXHRcdFx0XHRcdFx0ICogQG5hbWUgZG5kX3N0YXJ0LnZha2F0YVxyXG5cdFx0XHRcdFx0XHQgKiBAcGFyYW0ge01peGVkfSBkYXRhIGFueSBkYXRhIHN1cHBsaWVkIHdpdGggdGhlIGNhbGwgdG8gJC52YWthdGEuZG5kLnN0YXJ0XHJcblx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXHJcblx0XHRcdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBoZWxwZXIgdGhlIGhlbHBlciBzaG93biBuZXh0IHRvIHRoZSBtb3VzZVxyXG5cdFx0XHRcdFx0XHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoZSBzdGFydCAocHJvYmFibHkgbW91c2Vtb3ZlKVxyXG5cdFx0XHRcdFx0XHQgKi9cclxuXHRcdFx0XHRcdFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKFwic3RhcnRcIiwgZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRlbHNlIHsgcmV0dXJuOyB9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgZCAgPSBmYWxzZSwgdyAgPSBmYWxzZSxcclxuXHRcdFx0XHRcdGRoID0gZmFsc2UsIHdoID0gZmFsc2UsXHJcblx0XHRcdFx0XHRkdyA9IGZhbHNlLCB3dyA9IGZhbHNlLFxyXG5cdFx0XHRcdFx0ZHQgPSBmYWxzZSwgZGwgPSBmYWxzZSxcclxuXHRcdFx0XHRcdGh0ID0gZmFsc2UsIGhsID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAwO1xyXG5cdFx0XHRcdHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAwO1xyXG5cdFx0XHRcdHZha2F0YV9kbmQuc2Nyb2xsX2UgPSBmYWxzZTtcclxuXHRcdFx0XHQkKCQoZS50YXJnZXQpLnBhcmVudHNVbnRpbChcImJvZHlcIikuYWRkQmFjaygpLmdldCgpLnJldmVyc2UoKSlcclxuXHRcdFx0XHRcdC5maWx0ZXIoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm5cdCgvXmF1dG98c2Nyb2xsJC8pLnRlc3QoJCh0aGlzKS5jc3MoXCJvdmVyZmxvd1wiKSkgJiZcclxuXHRcdFx0XHRcdFx0XHRcdCh0aGlzLnNjcm9sbEhlaWdodCA+IHRoaXMub2Zmc2V0SGVpZ2h0IHx8IHRoaXMuc2Nyb2xsV2lkdGggPiB0aGlzLm9mZnNldFdpZHRoKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0XHQuZWFjaChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdHZhciB0ID0gJCh0aGlzKSwgbyA9IHQub2Zmc2V0KCk7XHJcblx0XHRcdFx0XHRcdGlmKHRoaXMuc2Nyb2xsSGVpZ2h0ID4gdGhpcy5vZmZzZXRIZWlnaHQpIHtcclxuXHRcdFx0XHRcdFx0XHRpZihvLnRvcCArIHQuaGVpZ2h0KCkgLSBlLnBhZ2VZIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpXHR7IHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAxOyB9XHJcblx0XHRcdFx0XHRcdFx0aWYoZS5wYWdlWSAtIG8udG9wIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpXHRcdFx0XHR7IHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAtMTsgfVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKHRoaXMuc2Nyb2xsV2lkdGggPiB0aGlzLm9mZnNldFdpZHRoKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoby5sZWZ0ICsgdC53aWR0aCgpIC0gZS5wYWdlWCA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KVx0eyB2YWthdGFfZG5kLnNjcm9sbF9sID0gMTsgfVxyXG5cdFx0XHRcdFx0XHRcdGlmKGUucGFnZVggLSBvLmxlZnQgPCAkLnZha2F0YS5kbmQuc2V0dGluZ3Muc2Nyb2xsX3Byb3hpbWl0eSlcdFx0XHRcdHsgdmFrYXRhX2RuZC5zY3JvbGxfbCA9IC0xOyB9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYodmFrYXRhX2RuZC5zY3JvbGxfdCB8fCB2YWthdGFfZG5kLnNjcm9sbF9sKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfZSA9ICQodGhpcyk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0aWYoIXZha2F0YV9kbmQuc2Nyb2xsX2UpIHtcclxuXHRcdFx0XHRcdGQgID0gJChkb2N1bWVudCk7IHcgPSAkKHdpbmRvdyk7XHJcblx0XHRcdFx0XHRkaCA9IGQuaGVpZ2h0KCk7IHdoID0gdy5oZWlnaHQoKTtcclxuXHRcdFx0XHRcdGR3ID0gZC53aWR0aCgpOyB3dyA9IHcud2lkdGgoKTtcclxuXHRcdFx0XHRcdGR0ID0gZC5zY3JvbGxUb3AoKTsgZGwgPSBkLnNjcm9sbExlZnQoKTtcclxuXHRcdFx0XHRcdGlmKGRoID4gd2ggJiYgZS5wYWdlWSAtIGR0IDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpXHRcdHsgdmFrYXRhX2RuZC5zY3JvbGxfdCA9IC0xOyAgfVxyXG5cdFx0XHRcdFx0aWYoZGggPiB3aCAmJiB3aCAtIChlLnBhZ2VZIC0gZHQpIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpXHR7IHZha2F0YV9kbmQuc2Nyb2xsX3QgPSAxOyB9XHJcblx0XHRcdFx0XHRpZihkdyA+IHd3ICYmIGUucGFnZVggLSBkbCA8ICQudmFrYXRhLmRuZC5zZXR0aW5ncy5zY3JvbGxfcHJveGltaXR5KVx0XHR7IHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAtMTsgfVxyXG5cdFx0XHRcdFx0aWYoZHcgPiB3dyAmJiB3dyAtIChlLnBhZ2VYIC0gZGwpIDwgJC52YWthdGEuZG5kLnNldHRpbmdzLnNjcm9sbF9wcm94aW1pdHkpXHR7IHZha2F0YV9kbmQuc2Nyb2xsX2wgPSAxOyB9XHJcblx0XHRcdFx0XHRpZih2YWthdGFfZG5kLnNjcm9sbF90IHx8IHZha2F0YV9kbmQuc2Nyb2xsX2wpIHtcclxuXHRcdFx0XHRcdFx0dmFrYXRhX2RuZC5zY3JvbGxfZSA9IGQ7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHZha2F0YV9kbmQuc2Nyb2xsX2UpIHsgJC52YWthdGEuZG5kLl9zY3JvbGwodHJ1ZSk7IH1cclxuXHJcblx0XHRcdFx0aWYodmFrYXRhX2RuZC5oZWxwZXIpIHtcclxuXHRcdFx0XHRcdGh0ID0gcGFyc2VJbnQoZS5wYWdlWSArICQudmFrYXRhLmRuZC5zZXR0aW5ncy5oZWxwZXJfdG9wLCAxMCk7XHJcblx0XHRcdFx0XHRobCA9IHBhcnNlSW50KGUucGFnZVggKyAkLnZha2F0YS5kbmQuc2V0dGluZ3MuaGVscGVyX2xlZnQsIDEwKTtcclxuXHRcdFx0XHRcdGlmKGRoICYmIGh0ICsgMjUgPiBkaCkgeyBodCA9IGRoIC0gNTA7IH1cclxuXHRcdFx0XHRcdGlmKGR3ICYmIGhsICsgdmFrYXRhX2RuZC5oZWxwZXJfdyA+IGR3KSB7IGhsID0gZHcgLSAodmFrYXRhX2RuZC5oZWxwZXJfdyArIDIpOyB9XHJcblx0XHRcdFx0XHR2YWthdGFfZG5kLmhlbHBlci5jc3Moe1xyXG5cdFx0XHRcdFx0XHRsZWZ0XHQ6IGhsICsgXCJweFwiLFxyXG5cdFx0XHRcdFx0XHR0b3BcdFx0OiBodCArIFwicHhcIlxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8qKlxyXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCBvbiB0aGUgZG9jdW1lbnQgd2hlbiBhIGRyYWcgaXMgaW4gcHJvZ3Jlc3NcclxuXHRcdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0XHQgKiBAcGx1Z2luIGRuZFxyXG5cdFx0XHRcdCAqIEBuYW1lIGRuZF9tb3ZlLnZha2F0YVxyXG5cdFx0XHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGRhdGEgYW55IGRhdGEgc3VwcGxpZWQgd2l0aCB0aGUgY2FsbCB0byAkLnZha2F0YS5kbmQuc3RhcnRcclxuXHRcdFx0XHQgKiBAcGFyYW0ge0RPTX0gZWxlbWVudCB0aGUgRE9NIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZFxyXG5cdFx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBoZWxwZXIgdGhlIGhlbHBlciBzaG93biBuZXh0IHRvIHRoZSBtb3VzZVxyXG5cdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhpcyB0byB0cmlnZ2VyIChtb3N0IGxpa2VseSBtb3VzZW1vdmUpXHJcblx0XHRcdFx0ICovXHJcblx0XHRcdFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKFwibW92ZVwiLCBlKTtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH0sXHJcblx0XHRcdHN0b3AgOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdGlmKGUudHlwZSA9PT0gXCJ0b3VjaGVuZFwiICYmIGUub3JpZ2luYWxFdmVudCAmJiBlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMgJiYgZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdKSB7XHJcblx0XHRcdFx0XHRlLnBhZ2VYID0gZS5vcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xyXG5cdFx0XHRcdFx0ZS5wYWdlWSA9IGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcclxuXHRcdFx0XHRcdGUudGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChlLm9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQsIGUub3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHZha2F0YV9kbmQuaXNfZHJhZykge1xyXG5cdFx0XHRcdFx0LyoqXHJcblx0XHRcdFx0XHQgKiB0cmlnZ2VyZWQgb24gdGhlIGRvY3VtZW50IHdoZW4gYSBkcmFnIHN0b3BzICh0aGUgZHJhZ2dlZCBlbGVtZW50IGlzIGRyb3BwZWQpXHJcblx0XHRcdFx0XHQgKiBAZXZlbnRcclxuXHRcdFx0XHRcdCAqIEBwbHVnaW4gZG5kXHJcblx0XHRcdFx0XHQgKiBAbmFtZSBkbmRfc3RvcC52YWthdGFcclxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7TWl4ZWR9IGRhdGEgYW55IGRhdGEgc3VwcGxpZWQgd2l0aCB0aGUgY2FsbCB0byAkLnZha2F0YS5kbmQuc3RhcnRcclxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7RE9NfSBlbGVtZW50IHRoZSBET00gZWxlbWVudCBiZWluZyBkcmFnZ2VkXHJcblx0XHRcdFx0XHQgKiBAcGFyYW0ge2pRdWVyeX0gaGVscGVyIHRoZSBoZWxwZXIgc2hvd24gbmV4dCB0byB0aGUgbW91c2VcclxuXHRcdFx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCB0aGUgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIHN0b3BcclxuXHRcdFx0XHRcdCAqL1xyXG5cdFx0XHRcdFx0JC52YWthdGEuZG5kLl90cmlnZ2VyKFwic3RvcFwiLCBlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0XHRpZihlLnR5cGUgPT09IFwidG91Y2hlbmRcIiAmJiBlLnRhcmdldCA9PT0gdmFrYXRhX2RuZC50YXJnZXQpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHRvID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7ICQoZS50YXJnZXQpLmNsaWNrKCk7IH0sIDEwMCk7XHJcblx0XHRcdFx0XHRcdCQoZS50YXJnZXQpLm9uZSgnY2xpY2snLCBmdW5jdGlvbigpIHsgaWYodG8pIHsgY2xlYXJUaW1lb3V0KHRvKTsgfSB9KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0JC52YWthdGEuZG5kLl9jbGVhbigpO1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHR9KCQpKTtcclxuXHJcblx0Ly8gaW5jbHVkZSB0aGUgZG5kIHBsdWdpbiBieSBkZWZhdWx0XHJcblx0Ly8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFwiZG5kXCIpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiAjIyMgU2VhcmNoIHBsdWdpblxyXG4gKlxyXG4gKiBBZGRzIHNlYXJjaCBmdW5jdGlvbmFsaXR5IHRvIGpzVHJlZS5cclxuICovXHJcblxyXG5cdC8qKlxyXG5cdCAqIHN0b3JlcyBhbGwgZGVmYXVsdHMgZm9yIHRoZSBzZWFyY2ggcGx1Z2luXHJcblx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoXHJcblx0ICogQHBsdWdpbiBzZWFyY2hcclxuXHQgKi9cclxuXHQkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2ggPSB7XHJcblx0XHQvKipcclxuXHRcdCAqIGEgalF1ZXJ5LWxpa2UgQUpBWCBjb25maWcsIHdoaWNoIGpzdHJlZSB1c2VzIGlmIGEgc2VydmVyIHNob3VsZCBiZSBxdWVyaWVkIGZvciByZXN1bHRzLiBcclxuXHRcdCAqIFxyXG5cdFx0ICogQSBgc3RyYCAod2hpY2ggaXMgdGhlIHNlYXJjaCBzdHJpbmcpIHBhcmFtZXRlciB3aWxsIGJlIGFkZGVkIHdpdGggdGhlIHJlcXVlc3QuIFRoZSBleHBlY3RlZCByZXN1bHQgaXMgYSBKU09OIGFycmF5IHdpdGggbm9kZXMgdGhhdCBuZWVkIHRvIGJlIG9wZW5lZCBzbyB0aGF0IG1hdGNoaW5nIG5vZGVzIHdpbGwgYmUgcmV2ZWFsZWQuXHJcblx0XHQgKiBMZWF2ZSB0aGlzIHNldHRpbmcgYXMgYGZhbHNlYCB0byBub3QgcXVlcnkgdGhlIHNlcnZlci4gWW91IGNhbiBhbHNvIHNldCB0aGlzIHRvIGEgZnVuY3Rpb24sIHdoaWNoIHdpbGwgYmUgaW52b2tlZCBpbiB0aGUgaW5zdGFuY2UncyBzY29wZSBhbmQgcmVjZWl2ZSAyIHBhcmFtZXRlcnMgLSB0aGUgc2VhcmNoIHN0cmluZyBhbmQgdGhlIGNhbGxiYWNrIHRvIGNhbGwgd2l0aCB0aGUgYXJyYXkgb2Ygbm9kZXMgdG8gbG9hZC5cclxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5hamF4XHJcblx0XHQgKiBAcGx1Z2luIHNlYXJjaFxyXG5cdFx0ICovXHJcblx0XHRhamF4IDogZmFsc2UsXHJcblx0XHQvKipcclxuXHRcdCAqIEluZGljYXRlcyBpZiB0aGUgc2VhcmNoIHNob3VsZCBiZSBmdXp6eSBvciBub3QgKHNob3VsZCBgY2huZDNgIG1hdGNoIGBjaGlsZCBub2RlIDNgKS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLmZ1enp5XHJcblx0XHQgKiBAcGx1Z2luIHNlYXJjaFxyXG5cdFx0ICovXHJcblx0XHRmdXp6eSA6IGZhbHNlLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJbmRpY2F0ZXMgaWYgdGhlIHNlYXJjaCBzaG91bGQgYmUgY2FzZSBzZW5zaXRpdmUuIERlZmF1bHQgaXMgYGZhbHNlYC5cclxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5jYXNlX3NlbnNpdGl2ZVxyXG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcclxuXHRcdCAqL1xyXG5cdFx0Y2FzZV9zZW5zaXRpdmUgOiBmYWxzZSxcclxuXHRcdC8qKlxyXG5cdFx0ICogSW5kaWNhdGVzIGlmIHRoZSB0cmVlIHNob3VsZCBiZSBmaWx0ZXJlZCAoYnkgZGVmYXVsdCkgdG8gc2hvdyBvbmx5IG1hdGNoaW5nIG5vZGVzIChrZWVwIGluIG1pbmQgdGhpcyBjYW4gYmUgYSBoZWF2eSBvbiBsYXJnZSB0cmVlcyBpbiBvbGQgYnJvd3NlcnMpLiBcclxuXHRcdCAqIFRoaXMgc2V0dGluZyBjYW4gYmUgY2hhbmdlZCBhdCBydW50aW1lIHdoZW4gY2FsbGluZyB0aGUgc2VhcmNoIG1ldGhvZC4gRGVmYXVsdCBpcyBgZmFsc2VgLlxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLnNob3dfb25seV9tYXRjaGVzXHJcblx0XHQgKiBAcGx1Z2luIHNlYXJjaFxyXG5cdFx0ICovXHJcblx0XHRzaG93X29ubHlfbWF0Y2hlcyA6IGZhbHNlLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJbmRpY2F0ZXMgaWYgYWxsIG5vZGVzIG9wZW5lZCB0byByZXZlYWwgdGhlIHNlYXJjaCByZXN1bHQsIHNob3VsZCBiZSBjbG9zZWQgd2hlbiB0aGUgc2VhcmNoIGlzIGNsZWFyZWQgb3IgYSBuZXcgc2VhcmNoIGlzIHBlcmZvcm1lZC4gRGVmYXVsdCBpcyBgdHJ1ZWAuXHJcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zZWFyY2guY2xvc2Vfb3BlbmVkX29uY2xlYXJcclxuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXHJcblx0XHQgKi9cclxuXHRcdGNsb3NlX29wZW5lZF9vbmNsZWFyIDogdHJ1ZSxcclxuXHRcdC8qKlxyXG5cdFx0ICogSW5kaWNhdGVzIGlmIG9ubHkgbGVhZiBub2RlcyBzaG91bGQgYmUgaW5jbHVkZWQgaW4gc2VhcmNoIHJlc3VsdHMuIERlZmF1bHQgaXMgYGZhbHNlYC5cclxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNlYXJjaC5zZWFyY2hfbGVhdmVzX29ubHlcclxuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXHJcblx0XHQgKi9cclxuXHRcdHNlYXJjaF9sZWF2ZXNfb25seSA6IGZhbHNlLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBJZiBzZXQgdG8gYSBmdW5jdGlvbiBpdCB3aWwgYmUgY2FsbGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIHdpdGggdHdvIGFyZ3VtZW50cyAtIHNlYXJjaCBzdHJpbmcgYW5kIG5vZGUgKHdoZXJlIG5vZGUgd2lsbCBiZSBldmVyeSBub2RlIGluIHRoZSBzdHJ1Y3R1cmUsIHNvIHVzZSB3aXRoIGNhdXRpb24pLlxyXG5cdFx0ICogSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUgdGhlIG5vZGUgd2lsbCBiZSBjb25zaWRlcmVkIGEgbWF0Y2ggKGl0IG1pZ2h0IG5vdCBiZSBkaXNwbGF5ZWQgaWYgc2VhcmNoX29ubHlfbGVhdmVzIGlzIHNldCB0byB0cnVlIGFuZCB0aGUgbm9kZSBpcyBub3QgYSBsZWFmKS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc2VhcmNoLnNlYXJjaF9jYWxsYmFja1xyXG5cdFx0ICogQHBsdWdpbiBzZWFyY2hcclxuXHRcdCAqL1xyXG5cdFx0c2VhcmNoX2NhbGxiYWNrIDogZmFsc2VcclxuXHR9O1xyXG5cclxuXHQkLmpzdHJlZS5wbHVnaW5zLnNlYXJjaCA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcclxuXHRcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcclxuXHJcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnN0ciA9IFwiXCI7XHJcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLmRvbSA9ICQoKTtcclxuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2gucmVzID0gW107XHJcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLm9wbiA9IFtdO1xyXG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5zb20gPSBmYWxzZTtcclxuXHJcblx0XHRcdHRoaXMuZWxlbWVudFxyXG5cdFx0XHRcdC5vbignYmVmb3JlX29wZW4uanN0cmVlJywgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xyXG5cdFx0XHRcdFx0XHR2YXIgaSwgaiwgZiwgciA9IHRoaXMuX2RhdGEuc2VhcmNoLnJlcywgcyA9IFtdLCBvID0gJCgpO1xyXG5cdFx0XHRcdFx0XHRpZihyICYmIHIubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tID0gJCh0aGlzLmVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnIycgKyAkLm1hcChyLCBmdW5jdGlvbiAodikgeyByZXR1cm4gXCIwMTIzNDU2Nzg5XCIuaW5kZXhPZih2WzBdKSAhPT0gLTEgPyAnXFxcXDMnICsgdlswXSArICcgJyArIHYuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJykgOiB2LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJyk7IH0pLmpvaW4oJywgIycpKSk7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIikuYWRkQ2xhc3MoJ2pzdHJlZS1zZWFyY2gnKTtcclxuXHRcdFx0XHRcdFx0XHRpZih0aGlzLl9kYXRhLnNlYXJjaC5zb20gJiYgdGhpcy5fZGF0YS5zZWFyY2gucmVzLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gci5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0cyA9IHMuY29uY2F0KHRoaXMuZ2V0X25vZGUocltpXSkucGFyZW50cyk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRzID0gJC52YWthdGEuYXJyYXlfcmVtb3ZlX2l0ZW0oJC52YWthdGEuYXJyYXlfdW5pcXVlKHMpLCcjJyk7XHJcblx0XHRcdFx0XHRcdFx0XHRvID0gcy5sZW5ndGggPyAkKHRoaXMuZWxlbWVudFswXS5xdWVyeVNlbGVjdG9yQWxsKCcjJyArICQubWFwKHMsIGZ1bmN0aW9uICh2KSB7IHJldHVybiBcIjAxMjM0NTY3ODlcIi5pbmRleE9mKHZbMF0pICE9PSAtMSA/ICdcXFxcMycgKyB2WzBdICsgJyAnICsgdi5zdWJzdHIoMSkucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKSA6IHYucmVwbGFjZSgkLmpzdHJlZS5pZHJlZ2V4LCdcXFxcJCYnKTsgfSkuam9pbignLCAjJykpKSA6ICQoKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZChcIi5qc3RyZWUtbm9kZVwiKS5oaWRlKCkuZmlsdGVyKCcuanN0cmVlLWxhc3QnKS5maWx0ZXIoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5leHRTaWJsaW5nOyB9KS5yZW1vdmVDbGFzcygnanN0cmVlLWxhc3QnKTtcclxuXHRcdFx0XHRcdFx0XHRcdG8gPSBvLmFkZCh0aGlzLl9kYXRhLnNlYXJjaC5kb20pO1xyXG5cdFx0XHRcdFx0XHRcdFx0by5wYXJlbnRzVW50aWwoXCIuanN0cmVlXCIpLmFkZEJhY2soKS5zaG93KClcclxuXHRcdFx0XHRcdFx0XHRcdFx0LmZpbHRlcihcIi5qc3RyZWUtY2hpbGRyZW5cIikuZWFjaChmdW5jdGlvbiAoKSB7ICQodGhpcykuY2hpbGRyZW4oXCIuanN0cmVlLW5vZGU6dmlzaWJsZVwiKS5lcSgtMSkuYWRkQ2xhc3MoXCJqc3RyZWUtbGFzdFwiKTsgfSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LCB0aGlzKSlcclxuXHRcdFx0XHQub24oXCJzZWFyY2guanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0aWYodGhpcy5fZGF0YS5zZWFyY2guc29tKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoZGF0YS5ub2Rlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5maW5kKFwiLmpzdHJlZS1ub2RlXCIpLmhpZGUoKS5maWx0ZXIoJy5qc3RyZWUtbGFzdCcpLmZpbHRlcihmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubmV4dFNpYmxpbmc7IH0pLnJlbW92ZUNsYXNzKCdqc3RyZWUtbGFzdCcpO1xyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YS5ub2Rlcy5wYXJlbnRzVW50aWwoXCIuanN0cmVlXCIpLmFkZEJhY2soKS5zaG93KClcclxuXHRcdFx0XHRcdFx0XHRcdFx0LmZpbHRlcihcIi5qc3RyZWUtY2hpbGRyZW5cIikuZWFjaChmdW5jdGlvbiAoKSB7ICQodGhpcykuY2hpbGRyZW4oXCIuanN0cmVlLW5vZGU6dmlzaWJsZVwiKS5lcSgtMSkuYWRkQ2xhc3MoXCJqc3RyZWUtbGFzdFwiKTsgfSk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LCB0aGlzKSlcclxuXHRcdFx0XHQub24oXCJjbGVhcl9zZWFyY2guanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0aWYodGhpcy5fZGF0YS5zZWFyY2guc29tICYmIGRhdGEubm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoXCIuanN0cmVlLW5vZGVcIikuY3NzKFwiZGlzcGxheVwiLFwiXCIpLmZpbHRlcignLmpzdHJlZS1sYXN0JykuZmlsdGVyKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5uZXh0U2libGluZzsgfSkucmVtb3ZlQ2xhc3MoJ2pzdHJlZS1sYXN0Jyk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcclxuXHRcdH07XHJcblx0XHQvKipcclxuXHRcdCAqIHVzZWQgdG8gc2VhcmNoIHRoZSB0cmVlIG5vZGVzIGZvciBhIGdpdmVuIHN0cmluZ1xyXG5cdFx0ICogQG5hbWUgc2VhcmNoKHN0ciBbLCBza2lwX2FzeW5jXSlcclxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHNlYXJjaCBzdHJpbmdcclxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2tpcF9hc3luYyBpZiBzZXQgdG8gdHJ1ZSBzZXJ2ZXIgd2lsbCBub3QgYmUgcXVlcmllZCBldmVuIGlmIGNvbmZpZ3VyZWRcclxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hvd19vbmx5X21hdGNoZXMgaWYgc2V0IHRvIHRydWUgb25seSBtYXRjaGluZyBub2RlcyB3aWxsIGJlIHNob3duIChrZWVwIGluIG1pbmQgdGhpcyBjYW4gYmUgdmVyeSBzbG93IG9uIGxhcmdlIHRyZWVzIG9yIG9sZCBicm93c2VycylcclxuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXHJcblx0XHQgKiBAdHJpZ2dlciBzZWFyY2guanN0cmVlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuc2VhcmNoID0gZnVuY3Rpb24gKHN0ciwgc2tpcF9hc3luYywgc2hvd19vbmx5X21hdGNoZXMpIHtcclxuXHRcdFx0aWYoc3RyID09PSBmYWxzZSB8fCAkLnRyaW0oc3RyLnRvU3RyaW5nKCkpID09PSBcIlwiKSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuY2xlYXJfc2VhcmNoKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3RyID0gc3RyLnRvU3RyaW5nKCk7XHJcblx0XHRcdHZhciBzID0gdGhpcy5zZXR0aW5ncy5zZWFyY2gsXHJcblx0XHRcdFx0YSA9IHMuYWpheCA/IHMuYWpheCA6IGZhbHNlLFxyXG5cdFx0XHRcdGYgPSBudWxsLFxyXG5cdFx0XHRcdHIgPSBbXSxcclxuXHRcdFx0XHRwID0gW10sIGksIGo7XHJcblx0XHRcdGlmKHRoaXMuX2RhdGEuc2VhcmNoLnJlcy5sZW5ndGgpIHtcclxuXHRcdFx0XHR0aGlzLmNsZWFyX3NlYXJjaCgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHNob3dfb25seV9tYXRjaGVzID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRzaG93X29ubHlfbWF0Y2hlcyA9IHMuc2hvd19vbmx5X21hdGNoZXM7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIXNraXBfYXN5bmMgJiYgYSAhPT0gZmFsc2UpIHtcclxuXHRcdFx0XHRpZigkLmlzRnVuY3Rpb24oYSkpIHtcclxuXHRcdFx0XHRcdHJldHVybiBhLmNhbGwodGhpcywgc3RyLCAkLnByb3h5KGZ1bmN0aW9uIChkKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYoZCAmJiBkLmQpIHsgZCA9IGQuZDsgfVxyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2xvYWRfbm9kZXMoISQuaXNBcnJheShkKSA/IFtdIDogJC52YWthdGEuYXJyYXlfdW5pcXVlKGQpLCBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNlYXJjaChzdHIsIHRydWUsIHNob3dfb25seV9tYXRjaGVzKTtcclxuXHRcdFx0XHRcdFx0XHR9LCB0cnVlKTtcclxuXHRcdFx0XHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRlbHNlIHtcclxuXHRcdFx0XHRcdGEgPSAkLmV4dGVuZCh7fSwgYSk7XHJcblx0XHRcdFx0XHRpZighYS5kYXRhKSB7IGEuZGF0YSA9IHt9OyB9XHJcblx0XHRcdFx0XHRhLmRhdGEuc3RyID0gc3RyO1xyXG5cdFx0XHRcdFx0cmV0dXJuICQuYWpheChhKVxyXG5cdFx0XHRcdFx0XHQuZmFpbCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHRcdFx0XHR0aGlzLl9kYXRhLmNvcmUubGFzdF9lcnJvciA9IHsgJ2Vycm9yJyA6ICdhamF4JywgJ3BsdWdpbicgOiAnc2VhcmNoJywgJ2lkJyA6ICdzZWFyY2hfMDEnLCAncmVhc29uJyA6ICdDb3VsZCBub3QgbG9hZCBzZWFyY2ggcGFyZW50cycsICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KGEpIH07XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5zZXR0aW5ncy5jb3JlLmVycm9yLmNhbGwodGhpcywgdGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IpO1xyXG5cdFx0XHRcdFx0XHR9LCB0aGlzKSlcclxuXHRcdFx0XHRcdFx0LmRvbmUoJC5wcm94eShmdW5jdGlvbiAoZCkge1xyXG5cdFx0XHRcdFx0XHRcdGlmKGQgJiYgZC5kKSB7IGQgPSBkLmQ7IH1cclxuXHRcdFx0XHRcdFx0XHR0aGlzLl9sb2FkX25vZGVzKCEkLmlzQXJyYXkoZCkgPyBbXSA6ICQudmFrYXRhLmFycmF5X3VuaXF1ZShkKSwgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZWFyY2goc3RyLCB0cnVlLCBzaG93X29ubHlfbWF0Y2hlcyk7XHJcblx0XHRcdFx0XHRcdFx0fSwgdHJ1ZSk7XHJcblx0XHRcdFx0XHRcdH0sIHRoaXMpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guc3RyID0gc3RyO1xyXG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5kb20gPSAkKCk7XHJcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnJlcyA9IFtdO1xyXG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5vcG4gPSBbXTtcclxuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guc29tID0gc2hvd19vbmx5X21hdGNoZXM7XHJcblxyXG5cdFx0XHRmID0gbmV3ICQudmFrYXRhLnNlYXJjaChzdHIsIHRydWUsIHsgY2FzZVNlbnNpdGl2ZSA6IHMuY2FzZV9zZW5zaXRpdmUsIGZ1enp5IDogcy5mdXp6eSB9KTtcclxuXHJcblx0XHRcdCQuZWFjaCh0aGlzLl9tb2RlbC5kYXRhLCBmdW5jdGlvbiAoaSwgdikge1xyXG5cdFx0XHRcdGlmKHYudGV4dCAmJiAoIChzLnNlYXJjaF9jYWxsYmFjayAmJiBzLnNlYXJjaF9jYWxsYmFjay5jYWxsKHRoaXMsIHN0ciwgdikpIHx8ICghcy5zZWFyY2hfY2FsbGJhY2sgJiYgZi5zZWFyY2godi50ZXh0KS5pc01hdGNoKSApICYmICghcy5zZWFyY2hfbGVhdmVzX29ubHkgfHwgKHYuc3RhdGUubG9hZGVkICYmIHYuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSkgKSB7XHJcblx0XHRcdFx0XHRyLnB1c2goaSk7XHJcblx0XHRcdFx0XHRwID0gcC5jb25jYXQodi5wYXJlbnRzKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRpZihyLmxlbmd0aCkge1xyXG5cdFx0XHRcdHAgPSAkLnZha2F0YS5hcnJheV91bmlxdWUocCk7XHJcblx0XHRcdFx0dGhpcy5fc2VhcmNoX29wZW4ocCk7XHJcblx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tID0gJCh0aGlzLmVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvckFsbCgnIycgKyAkLm1hcChyLCBmdW5jdGlvbiAodikgeyByZXR1cm4gXCIwMTIzNDU2Nzg5XCIuaW5kZXhPZih2WzBdKSAhPT0gLTEgPyAnXFxcXDMnICsgdlswXSArICcgJyArIHYuc3Vic3RyKDEpLnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJykgOiB2LnJlcGxhY2UoJC5qc3RyZWUuaWRyZWdleCwnXFxcXCQmJyk7IH0pLmpvaW4oJywgIycpKSk7XHJcblx0XHRcdFx0dGhpcy5fZGF0YS5zZWFyY2gucmVzID0gcjtcclxuXHRcdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5kb20uY2hpbGRyZW4oXCIuanN0cmVlLWFuY2hvclwiKS5hZGRDbGFzcygnanN0cmVlLXNlYXJjaCcpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB0cmlnZ2VyZWQgYWZ0ZXIgc2VhcmNoIGlzIGNvbXBsZXRlXHJcblx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHQgKiBAbmFtZSBzZWFyY2guanN0cmVlXHJcblx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBub2RlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIG1hdGNoaW5nIG5vZGVzXHJcblx0XHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgdGhlIHNlYXJjaCBzdHJpbmdcclxuXHRcdFx0ICogQHBhcmFtIHtBcnJheX0gcmVzIGEgY29sbGVjdGlvbiBvZiBvYmplY3RzIHJlcHJlc2VpbmcgdGhlIG1hdGNoaW5nIG5vZGVzXHJcblx0XHRcdCAqIEBwbHVnaW4gc2VhcmNoXHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ3NlYXJjaCcsIHsgbm9kZXMgOiB0aGlzLl9kYXRhLnNlYXJjaC5kb20sIHN0ciA6IHN0ciwgcmVzIDogdGhpcy5fZGF0YS5zZWFyY2gucmVzLCBzaG93X29ubHlfbWF0Y2hlcyA6IHNob3dfb25seV9tYXRjaGVzIH0pO1xyXG5cdFx0fTtcclxuXHRcdC8qKlxyXG5cdFx0ICogdXNlZCB0byBjbGVhciB0aGUgbGFzdCBzZWFyY2ggKHJlbW92ZXMgY2xhc3NlcyBhbmQgc2hvd3MgYWxsIG5vZGVzIGlmIGZpbHRlcmluZyBpcyBvbilcclxuXHRcdCAqIEBuYW1lIGNsZWFyX3NlYXJjaCgpXHJcblx0XHQgKiBAcGx1Z2luIHNlYXJjaFxyXG5cdFx0ICogQHRyaWdnZXIgY2xlYXJfc2VhcmNoLmpzdHJlZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLmNsZWFyX3NlYXJjaCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIikucmVtb3ZlQ2xhc3MoXCJqc3RyZWUtc2VhcmNoXCIpO1xyXG5cdFx0XHRpZih0aGlzLnNldHRpbmdzLnNlYXJjaC5jbG9zZV9vcGVuZWRfb25jbGVhcikge1xyXG5cdFx0XHRcdHRoaXMuY2xvc2Vfbm9kZSh0aGlzLl9kYXRhLnNlYXJjaC5vcG4sIDApO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8qKlxyXG5cdFx0XHQgKiB0cmlnZ2VyZWQgYWZ0ZXIgc2VhcmNoIGlzIGNvbXBsZXRlXHJcblx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHQgKiBAbmFtZSBjbGVhcl9zZWFyY2guanN0cmVlXHJcblx0XHRcdCAqIEBwYXJhbSB7alF1ZXJ5fSBub2RlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIG1hdGNoaW5nIG5vZGVzICh0aGUgcmVzdWx0IGZyb20gdGhlIGxhc3Qgc2VhcmNoKVxyXG5cdFx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzZWFyY2ggc3RyaW5nICh0aGUgbGFzdCBzZWFyY2ggc3RyaW5nKVxyXG5cdFx0XHQgKiBAcGFyYW0ge0FycmF5fSByZXMgYSBjb2xsZWN0aW9uIG9mIG9iamVjdHMgcmVwcmVzZWluZyB0aGUgbWF0Y2hpbmcgbm9kZXMgKHRoZSByZXN1bHQgZnJvbSB0aGUgbGFzdCBzZWFyY2gpXHJcblx0XHRcdCAqIEBwbHVnaW4gc2VhcmNoXHJcblx0XHRcdCAqL1xyXG5cdFx0XHR0aGlzLnRyaWdnZXIoJ2NsZWFyX3NlYXJjaCcsIHsgJ25vZGVzJyA6IHRoaXMuX2RhdGEuc2VhcmNoLmRvbSwgc3RyIDogdGhpcy5fZGF0YS5zZWFyY2guc3RyLCByZXMgOiB0aGlzLl9kYXRhLnNlYXJjaC5yZXMgfSk7XHJcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnN0ciA9IFwiXCI7XHJcblx0XHRcdHRoaXMuX2RhdGEuc2VhcmNoLnJlcyA9IFtdO1xyXG5cdFx0XHR0aGlzLl9kYXRhLnNlYXJjaC5vcG4gPSBbXTtcclxuXHRcdFx0dGhpcy5fZGF0YS5zZWFyY2guZG9tID0gJCgpO1xyXG5cdFx0fTtcclxuXHRcdC8qKlxyXG5cdFx0ICogb3BlbnMgbm9kZXMgdGhhdCBuZWVkIHRvIGJlIG9wZW5lZCB0byByZXZlYWwgdGhlIHNlYXJjaCByZXN1bHRzLiBVc2VkIG9ubHkgaW50ZXJuYWxseS5cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAbmFtZSBfc2VhcmNoX29wZW4oZClcclxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IGQgYW4gYXJyYXkgb2Ygbm9kZSBJRHNcclxuXHRcdCAqIEBwbHVnaW4gc2VhcmNoXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuX3NlYXJjaF9vcGVuID0gZnVuY3Rpb24gKGQpIHtcclxuXHRcdFx0dmFyIHQgPSB0aGlzO1xyXG5cdFx0XHQkLmVhY2goZC5jb25jYXQoW10pLCBmdW5jdGlvbiAoaSwgdikge1xyXG5cdFx0XHRcdGlmKHYgPT09IFwiI1wiKSB7IHJldHVybiB0cnVlOyB9XHJcblx0XHRcdFx0dHJ5IHsgdiA9ICQoJyMnICsgdi5yZXBsYWNlKCQuanN0cmVlLmlkcmVnZXgsJ1xcXFwkJicpLCB0LmVsZW1lbnQpOyB9IGNhdGNoKGlnbm9yZSkgeyB9XHJcblx0XHRcdFx0aWYodiAmJiB2Lmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0aWYodC5pc19jbG9zZWQodikpIHtcclxuXHRcdFx0XHRcdFx0dC5fZGF0YS5zZWFyY2gub3BuLnB1c2godlswXS5pZCk7XHJcblx0XHRcdFx0XHRcdHQub3Blbl9ub2RlKHYsIGZ1bmN0aW9uICgpIHsgdC5fc2VhcmNoX29wZW4oZCk7IH0sIDApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cdH07XHJcblxyXG5cdC8vIGhlbHBlcnNcclxuXHQoZnVuY3Rpb24gKCQpIHtcclxuXHRcdC8vIGZyb20gaHR0cDovL2tpcm8ubWUvcHJvamVjdHMvZnVzZS5odG1sXHJcblx0XHQkLnZha2F0YS5zZWFyY2ggPSBmdW5jdGlvbihwYXR0ZXJuLCB0eHQsIG9wdGlvbnMpIHtcclxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRcdGlmKG9wdGlvbnMuZnV6enkgIT09IGZhbHNlKSB7XHJcblx0XHRcdFx0b3B0aW9ucy5mdXp6eSA9IHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0cGF0dGVybiA9IG9wdGlvbnMuY2FzZVNlbnNpdGl2ZSA/IHBhdHRlcm4gOiBwYXR0ZXJuLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdHZhciBNQVRDSF9MT0NBVElPTlx0PSBvcHRpb25zLmxvY2F0aW9uIHx8IDAsXHJcblx0XHRcdFx0TUFUQ0hfRElTVEFOQ0VcdD0gb3B0aW9ucy5kaXN0YW5jZSB8fCAxMDAsXHJcblx0XHRcdFx0TUFUQ0hfVEhSRVNIT0xEXHQ9IG9wdGlvbnMudGhyZXNob2xkIHx8IDAuNixcclxuXHRcdFx0XHRwYXR0ZXJuTGVuID0gcGF0dGVybi5sZW5ndGgsXHJcblx0XHRcdFx0bWF0Y2htYXNrLCBwYXR0ZXJuX2FscGhhYmV0LCBtYXRjaF9iaXRhcFNjb3JlLCBzZWFyY2g7XHJcblx0XHRcdGlmKHBhdHRlcm5MZW4gPiAzMikge1xyXG5cdFx0XHRcdG9wdGlvbnMuZnV6enkgPSBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihvcHRpb25zLmZ1enp5KSB7XHJcblx0XHRcdFx0bWF0Y2htYXNrID0gMSA8PCAocGF0dGVybkxlbiAtIDEpO1xyXG5cdFx0XHRcdHBhdHRlcm5fYWxwaGFiZXQgPSAoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0dmFyIG1hc2sgPSB7fSxcclxuXHRcdFx0XHRcdFx0aSA9IDA7XHJcblx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGF0dGVybkxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdG1hc2tbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBwYXR0ZXJuTGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0bWFza1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCAocGF0dGVybkxlbiAtIGkgLSAxKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBtYXNrO1xyXG5cdFx0XHRcdH0oKSk7XHJcblx0XHRcdFx0bWF0Y2hfYml0YXBTY29yZSA9IGZ1bmN0aW9uIChlLCB4KSB7XHJcblx0XHRcdFx0XHR2YXIgYWNjdXJhY3kgPSBlIC8gcGF0dGVybkxlbixcclxuXHRcdFx0XHRcdFx0cHJveGltaXR5ID0gTWF0aC5hYnMoTUFUQ0hfTE9DQVRJT04gLSB4KTtcclxuXHRcdFx0XHRcdGlmKCFNQVRDSF9ESVNUQU5DRSkge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJveGltaXR5ID8gMS4wIDogYWNjdXJhY3k7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gYWNjdXJhY3kgKyAocHJveGltaXR5IC8gTUFUQ0hfRElTVEFOQ0UpO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHRcdFx0c2VhcmNoID0gZnVuY3Rpb24gKHRleHQpIHtcclxuXHRcdFx0XHR0ZXh0ID0gb3B0aW9ucy5jYXNlU2Vuc2l0aXZlID8gdGV4dCA6IHRleHQudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHRpZihwYXR0ZXJuID09PSB0ZXh0IHx8IHRleHQuaW5kZXhPZihwYXR0ZXJuKSAhPT0gLTEpIHtcclxuXHRcdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcdGlzTWF0Y2g6IHRydWUsXHJcblx0XHRcdFx0XHRcdHNjb3JlOiAwXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZighb3B0aW9ucy5mdXp6eSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdFx0aXNNYXRjaDogZmFsc2UsXHJcblx0XHRcdFx0XHRcdHNjb3JlOiAxXHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgaSwgaixcclxuXHRcdFx0XHRcdHRleHRMZW4gPSB0ZXh0Lmxlbmd0aCxcclxuXHRcdFx0XHRcdHNjb3JlVGhyZXNob2xkID0gTUFUQ0hfVEhSRVNIT0xELFxyXG5cdFx0XHRcdFx0YmVzdExvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBNQVRDSF9MT0NBVElPTiksXHJcblx0XHRcdFx0XHRiaW5NaW4sIGJpbk1pZCxcclxuXHRcdFx0XHRcdGJpbk1heCA9IHBhdHRlcm5MZW4gKyB0ZXh0TGVuLFxyXG5cdFx0XHRcdFx0bGFzdFJkLCBzdGFydCwgZmluaXNoLCByZCwgY2hhck1hdGNoLFxyXG5cdFx0XHRcdFx0c2NvcmUgPSAxLFxyXG5cdFx0XHRcdFx0bG9jYXRpb25zID0gW107XHJcblx0XHRcdFx0aWYgKGJlc3RMb2MgIT09IC0xKSB7XHJcblx0XHRcdFx0XHRzY29yZVRocmVzaG9sZCA9IE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmUoMCwgYmVzdExvYyksIHNjb3JlVGhyZXNob2xkKTtcclxuXHRcdFx0XHRcdGJlc3RMb2MgPSB0ZXh0Lmxhc3RJbmRleE9mKHBhdHRlcm4sIE1BVENIX0xPQ0FUSU9OICsgcGF0dGVybkxlbik7XHJcblx0XHRcdFx0XHRpZiAoYmVzdExvYyAhPT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0c2NvcmVUaHJlc2hvbGQgPSBNYXRoLm1pbihtYXRjaF9iaXRhcFNjb3JlKDAsIGJlc3RMb2MpLCBzY29yZVRocmVzaG9sZCk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJlc3RMb2MgPSAtMTtcclxuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgcGF0dGVybkxlbjsgaSsrKSB7XHJcblx0XHRcdFx0XHRiaW5NaW4gPSAwO1xyXG5cdFx0XHRcdFx0YmluTWlkID0gYmluTWF4O1xyXG5cdFx0XHRcdFx0d2hpbGUgKGJpbk1pbiA8IGJpbk1pZCkge1xyXG5cdFx0XHRcdFx0XHRpZiAobWF0Y2hfYml0YXBTY29yZShpLCBNQVRDSF9MT0NBVElPTiArIGJpbk1pZCkgPD0gc2NvcmVUaHJlc2hvbGQpIHtcclxuXHRcdFx0XHRcdFx0XHRiaW5NaW4gPSBiaW5NaWQ7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0YmluTWF4ID0gYmluTWlkO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGJpbk1pZCA9IE1hdGguZmxvb3IoKGJpbk1heCAtIGJpbk1pbikgLyAyICsgYmluTWluKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJpbk1heCA9IGJpbk1pZDtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gTWF0aC5tYXgoMSwgTUFUQ0hfTE9DQVRJT04gLSBiaW5NaWQgKyAxKTtcclxuXHRcdFx0XHRcdGZpbmlzaCA9IE1hdGgubWluKE1BVENIX0xPQ0FUSU9OICsgYmluTWlkLCB0ZXh0TGVuKSArIHBhdHRlcm5MZW47XHJcblx0XHRcdFx0XHRyZCA9IG5ldyBBcnJheShmaW5pc2ggKyAyKTtcclxuXHRcdFx0XHRcdHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgaSkgLSAxO1xyXG5cdFx0XHRcdFx0Zm9yIChqID0gZmluaXNoOyBqID49IHN0YXJ0OyBqLS0pIHtcclxuXHRcdFx0XHRcdFx0Y2hhck1hdGNoID0gcGF0dGVybl9hbHBoYWJldFt0ZXh0LmNoYXJBdChqIC0gMSldO1xyXG5cdFx0XHRcdFx0XHRpZiAoaSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRcdHJkW2pdID0gKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaDtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRyZFtqXSA9ICgocmRbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2ggfCAoKChsYXN0UmRbaiArIDFdIHwgbGFzdFJkW2pdKSA8PCAxKSB8IDEpIHwgbGFzdFJkW2ogKyAxXTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRpZiAocmRbal0gJiBtYXRjaG1hc2spIHtcclxuXHRcdFx0XHRcdFx0XHRzY29yZSA9IG1hdGNoX2JpdGFwU2NvcmUoaSwgaiAtIDEpO1xyXG5cdFx0XHRcdFx0XHRcdGlmIChzY29yZSA8PSBzY29yZVRocmVzaG9sZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0c2NvcmVUaHJlc2hvbGQgPSBzY29yZTtcclxuXHRcdFx0XHRcdFx0XHRcdGJlc3RMb2MgPSBqIC0gMTtcclxuXHRcdFx0XHRcdFx0XHRcdGxvY2F0aW9ucy5wdXNoKGJlc3RMb2MpO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKGJlc3RMb2MgPiBNQVRDSF9MT0NBVElPTikge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRzdGFydCA9IE1hdGgubWF4KDEsIDIgKiBNQVRDSF9MT0NBVElPTiAtIGJlc3RMb2MpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAobWF0Y2hfYml0YXBTY29yZShpICsgMSwgTUFUQ0hfTE9DQVRJT04pID4gc2NvcmVUaHJlc2hvbGQpIHtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRsYXN0UmQgPSByZDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHRcdGlzTWF0Y2g6IGJlc3RMb2MgPj0gMCxcclxuXHRcdFx0XHRcdHNjb3JlOiBzY29yZVxyXG5cdFx0XHRcdH07XHJcblx0XHRcdH07XHJcblx0XHRcdHJldHVybiB0eHQgPT09IHRydWUgPyB7ICdzZWFyY2gnIDogc2VhcmNoIH0gOiBzZWFyY2godHh0KTtcclxuXHRcdH07XHJcblx0fSgkKSk7XHJcblxyXG5cdC8vIGluY2x1ZGUgdGhlIHNlYXJjaCBwbHVnaW4gYnkgZGVmYXVsdFxyXG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcInNlYXJjaFwiKTtcclxuXHJcbi8qKlxyXG4gKiAjIyMgU29ydCBwbHVnaW5cclxuICpcclxuICogQXV0b21hdGljYWxseSBzb3J0cyBhbGwgc2libGluZ3MgaW4gdGhlIHRyZWUgYWNjb3JkaW5nIHRvIGEgc29ydGluZyBmdW5jdGlvbi5cclxuICovXHJcblxyXG5cdC8qKlxyXG5cdCAqIHRoZSBzZXR0aW5ncyBmdW5jdGlvbiB1c2VkIHRvIHNvcnQgdGhlIG5vZGVzLlxyXG5cdCAqIEl0IGlzIGV4ZWN1dGVkIGluIHRoZSB0cmVlJ3MgY29udGV4dCwgYWNjZXB0cyB0d28gbm9kZXMgYXMgYXJndW1lbnRzIGFuZCBzaG91bGQgcmV0dXJuIGAxYCBvciBgLTFgLlxyXG5cdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnNvcnRcclxuXHQgKiBAcGx1Z2luIHNvcnRcclxuXHQgKi9cclxuXHQkLmpzdHJlZS5kZWZhdWx0cy5zb3J0ID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuXHRcdC8vcmV0dXJuIHRoaXMuZ2V0X3R5cGUoYSkgPT09IHRoaXMuZ2V0X3R5cGUoYikgPyAodGhpcy5nZXRfdGV4dChhKSA+IHRoaXMuZ2V0X3RleHQoYikgPyAxIDogLTEpIDogdGhpcy5nZXRfdHlwZShhKSA+PSB0aGlzLmdldF90eXBlKGIpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0X3RleHQoYSkgPiB0aGlzLmdldF90ZXh0KGIpID8gMSA6IC0xO1xyXG5cdH07XHJcblx0JC5qc3RyZWUucGx1Z2lucy5zb3J0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xyXG5cdFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRcclxuXHRcdFx0XHQub24oXCJtb2RlbC5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnNvcnQoZGF0YS5wYXJlbnQsIHRydWUpO1xyXG5cdFx0XHRcdFx0fSwgdGhpcykpXHJcblx0XHRcdFx0Lm9uKFwicmVuYW1lX25vZGUuanN0cmVlIGNyZWF0ZV9ub2RlLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuc29ydChkYXRhLnBhcmVudCB8fCBkYXRhLm5vZGUucGFyZW50LCBmYWxzZSk7XHJcblx0XHRcdFx0XHRcdHRoaXMucmVkcmF3X25vZGUoZGF0YS5wYXJlbnQgfHwgZGF0YS5ub2RlLnBhcmVudCwgdHJ1ZSk7XHJcblx0XHRcdFx0XHR9LCB0aGlzKSlcclxuXHRcdFx0XHQub24oXCJtb3ZlX25vZGUuanN0cmVlIGNvcHlfbm9kZS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnNvcnQoZGF0YS5wYXJlbnQsIGZhbHNlKTtcclxuXHRcdFx0XHRcdFx0dGhpcy5yZWRyYXdfbm9kZShkYXRhLnBhcmVudCwgdHJ1ZSk7XHJcblx0XHRcdFx0XHR9LCB0aGlzKSk7XHJcblx0XHR9O1xyXG5cdFx0LyoqXHJcblx0XHQgKiB1c2VkIHRvIHNvcnQgYSBub2RlJ3MgY2hpbGRyZW5cclxuXHRcdCAqIEBwcml2YXRlXHJcblx0XHQgKiBAbmFtZSBzb3J0KG9iaiBbLCBkZWVwXSlcclxuXHRcdCAqIEBwYXJhbSAge21peGVkfSBvYmogdGhlIG5vZGVcclxuXHRcdCAqIEBwYXJhbSB7Qm9vbGVhbn0gZGVlcCBpZiBzZXQgdG8gYHRydWVgIG5vZGVzIGFyZSBzb3J0ZWQgcmVjdXJzaXZlbHkuXHJcblx0XHQgKiBAcGx1Z2luIHNvcnRcclxuXHRcdCAqIEB0cmlnZ2VyIHNlYXJjaC5qc3RyZWVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zb3J0ID0gZnVuY3Rpb24gKG9iaiwgZGVlcCkge1xyXG5cdFx0XHR2YXIgaSwgajtcclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZihvYmogJiYgb2JqLmNoaWxkcmVuICYmIG9iai5jaGlsZHJlbi5sZW5ndGgpIHtcclxuXHRcdFx0XHRvYmouY2hpbGRyZW4uc29ydCgkLnByb3h5KHRoaXMuc2V0dGluZ3Muc29ydCwgdGhpcykpO1xyXG5cdFx0XHRcdGlmKGRlZXApIHtcclxuXHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnNvcnQob2JqLmNoaWxkcmVuX2RbaV0sIGZhbHNlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fTtcclxuXHJcblx0Ly8gaW5jbHVkZSB0aGUgc29ydCBwbHVnaW4gYnkgZGVmYXVsdFxyXG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcInNvcnRcIik7XHJcblxyXG4vKipcclxuICogIyMjIFN0YXRlIHBsdWdpblxyXG4gKlxyXG4gKiBTYXZlcyB0aGUgc3RhdGUgb2YgdGhlIHRyZWUgKHNlbGVjdGVkIG5vZGVzLCBvcGVuZWQgbm9kZXMpIG9uIHRoZSB1c2VyJ3MgY29tcHV0ZXIgdXNpbmcgYXZhaWxhYmxlIG9wdGlvbnMgKGxvY2FsU3RvcmFnZSwgY29va2llcywgZXRjKVxyXG4gKi9cclxuXHJcblx0dmFyIHRvID0gZmFsc2U7XHJcblx0LyoqXHJcblx0ICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIHN0YXRlIHBsdWdpblxyXG5cdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlXHJcblx0ICogQHBsdWdpbiBzdGF0ZVxyXG5cdCAqL1xyXG5cdCQuanN0cmVlLmRlZmF1bHRzLnN0YXRlID0ge1xyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHN0cmluZyBmb3IgdGhlIGtleSB0byB1c2Ugd2hlbiBzYXZpbmcgdGhlIGN1cnJlbnQgdHJlZSAoY2hhbmdlIGlmIHVzaW5nIG11bHRpcGxlIHRyZWVzIGluIHlvdXIgcHJvamVjdCkuIERlZmF1bHRzIHRvIGBqc3RyZWVgLlxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc3RhdGUua2V5XHJcblx0XHQgKiBAcGx1Z2luIHN0YXRlXHJcblx0XHQgKi9cclxuXHRcdGtleVx0XHQ6ICdqc3RyZWUnLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIGV2ZW50cyB0aGF0IHRyaWdnZXIgYSBzdGF0ZSBzYXZlLiBEZWZhdWx0cyB0byBgY2hhbmdlZC5qc3RyZWUgb3Blbl9ub2RlLmpzdHJlZSBjbG9zZV9ub2RlLmpzdHJlZWAuXHJcblx0XHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy5zdGF0ZS5ldmVudHNcclxuXHRcdCAqIEBwbHVnaW4gc3RhdGVcclxuXHRcdCAqL1xyXG5cdFx0ZXZlbnRzXHQ6ICdjaGFuZ2VkLmpzdHJlZSBvcGVuX25vZGUuanN0cmVlIGNsb3NlX25vZGUuanN0cmVlIGNoZWNrX25vZGUuanN0cmVlIHVuY2hlY2tfbm9kZS5qc3RyZWUnLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBUaW1lIGluIG1pbGxpc2Vjb25kcyBhZnRlciB3aGljaCB0aGUgc3RhdGUgd2lsbCBleHBpcmUuIERlZmF1bHRzIHRvICdmYWxzZScgbWVhbmluZyAtIG5vIGV4cGlyZS5cclxuXHRcdCAqIEBuYW1lICQuanN0cmVlLmRlZmF1bHRzLnN0YXRlLnR0bFxyXG5cdFx0ICogQHBsdWdpbiBzdGF0ZVxyXG5cdFx0ICovXHJcblx0XHR0dGxcdFx0OiBmYWxzZSxcclxuXHRcdC8qKlxyXG5cdFx0ICogQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgcHJpb3IgdG8gcmVzdG9yaW5nIHN0YXRlIHdpdGggb25lIGFyZ3VtZW50IC0gdGhlIHN0YXRlIG9iamVjdC4gQ2FuIGJlIHVzZWQgdG8gY2xlYXIgdW53YW50ZWQgcGFydHMgb2YgdGhlIHN0YXRlLlxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMuc3RhdGUuZmlsdGVyXHJcblx0XHQgKiBAcGx1Z2luIHN0YXRlXHJcblx0XHQgKi9cclxuXHRcdGZpbHRlclx0OiBmYWxzZVxyXG5cdH07XHJcblx0JC5qc3RyZWUucGx1Z2lucy5zdGF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcclxuXHRcdHRoaXMuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcclxuXHRcdFx0dmFyIGJpbmQgPSAkLnByb3h5KGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHR0aGlzLmVsZW1lbnQub24odGhpcy5zZXR0aW5ncy5zdGF0ZS5ldmVudHMsICQucHJveHkoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0aWYodG8pIHsgY2xlYXJUaW1lb3V0KHRvKTsgfVxyXG5cdFx0XHRcdFx0dG8gPSBzZXRUaW1lb3V0KCQucHJveHkoZnVuY3Rpb24gKCkgeyB0aGlzLnNhdmVfc3RhdGUoKTsgfSwgdGhpcyksIDEwMCk7XHJcblx0XHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0XHRcdC8qKlxyXG5cdFx0XHRcdCAqIHRyaWdnZXJlZCB3aGVuIHRoZSBzdGF0ZSBwbHVnaW4gaXMgZmluaXNoZWQgcmVzdG9yaW5nIHRoZSBzdGF0ZSAoYW5kIGltbWVkaWF0ZWx5IGFmdGVyIHJlYWR5IGlmIHRoZXJlIGlzIG5vIHN0YXRlIHRvIHJlc3RvcmUpLlxyXG5cdFx0XHRcdCAqIEBldmVudFxyXG5cdFx0XHRcdCAqIEBuYW1lIHN0YXRlX3JlYWR5LmpzdHJlZVxyXG5cdFx0XHRcdCAqIEBwbHVnaW4gc3RhdGVcclxuXHRcdFx0XHQgKi9cclxuXHRcdFx0XHR0aGlzLnRyaWdnZXIoJ3N0YXRlX3JlYWR5Jyk7XHJcblx0XHRcdH0sIHRoaXMpO1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRcclxuXHRcdFx0XHQub24oXCJyZWFkeS5qc3RyZWVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSwgZGF0YSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmVsZW1lbnQub25lKFwicmVzdG9yZV9zdGF0ZS5qc3RyZWVcIiwgYmluZCk7XHJcblx0XHRcdFx0XHRcdGlmKCF0aGlzLnJlc3RvcmVfc3RhdGUoKSkgeyBiaW5kKCk7IH1cclxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcclxuXHRcdH07XHJcblx0XHQvKipcclxuXHRcdCAqIHNhdmUgdGhlIHN0YXRlXHJcblx0XHQgKiBAbmFtZSBzYXZlX3N0YXRlKClcclxuXHRcdCAqIEBwbHVnaW4gc3RhdGVcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zYXZlX3N0YXRlID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgc3QgPSB7ICdzdGF0ZScgOiB0aGlzLmdldF9zdGF0ZSgpLCAndHRsJyA6IHRoaXMuc2V0dGluZ3Muc3RhdGUudHRsLCAnc2VjJyA6ICsobmV3IERhdGUoKSkgfTtcclxuXHRcdFx0JC52YWthdGEuc3RvcmFnZS5zZXQodGhpcy5zZXR0aW5ncy5zdGF0ZS5rZXksIEpTT04uc3RyaW5naWZ5KHN0KSk7XHJcblx0XHR9O1xyXG5cdFx0LyoqXHJcblx0XHQgKiByZXN0b3JlIHRoZSBzdGF0ZSBmcm9tIHRoZSB1c2VyJ3MgY29tcHV0ZXJcclxuXHRcdCAqIEBuYW1lIHJlc3RvcmVfc3RhdGUoKVxyXG5cdFx0ICogQHBsdWdpbiBzdGF0ZVxyXG5cdFx0ICovXHJcblx0XHR0aGlzLnJlc3RvcmVfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHZhciBrID0gJC52YWthdGEuc3RvcmFnZS5nZXQodGhpcy5zZXR0aW5ncy5zdGF0ZS5rZXkpO1xyXG5cdFx0XHRpZighIWspIHsgdHJ5IHsgayA9IEpTT04ucGFyc2Uoayk7IH0gY2F0Y2goZXgpIHsgcmV0dXJuIGZhbHNlOyB9IH1cclxuXHRcdFx0aWYoISFrICYmIGsudHRsICYmIGsuc2VjICYmICsobmV3IERhdGUoKSkgLSBrLnNlYyA+IGsudHRsKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRpZighIWsgJiYgay5zdGF0ZSkgeyBrID0gay5zdGF0ZTsgfVxyXG5cdFx0XHRpZighIWsgJiYgJC5pc0Z1bmN0aW9uKHRoaXMuc2V0dGluZ3Muc3RhdGUuZmlsdGVyKSkgeyBrID0gdGhpcy5zZXR0aW5ncy5zdGF0ZS5maWx0ZXIuY2FsbCh0aGlzLCBrKTsgfVxyXG5cdFx0XHRpZighIWspIHtcclxuXHRcdFx0XHR0aGlzLmVsZW1lbnQub25lKFwic2V0X3N0YXRlLmpzdHJlZVwiLCBmdW5jdGlvbiAoZSwgZGF0YSkgeyBkYXRhLmluc3RhbmNlLnRyaWdnZXIoJ3Jlc3RvcmVfc3RhdGUnLCB7ICdzdGF0ZScgOiAkLmV4dGVuZCh0cnVlLCB7fSwgaykgfSk7IH0pO1xyXG5cdFx0XHRcdHRoaXMuc2V0X3N0YXRlKGspO1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH07XHJcblx0XHQvKipcclxuXHRcdCAqIGNsZWFyIHRoZSBzdGF0ZSBvbiB0aGUgdXNlcidzIGNvbXB1dGVyXHJcblx0XHQgKiBAbmFtZSBjbGVhcl9zdGF0ZSgpXHJcblx0XHQgKiBAcGx1Z2luIHN0YXRlXHJcblx0XHQgKi9cclxuXHRcdHRoaXMuY2xlYXJfc3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiAkLnZha2F0YS5zdG9yYWdlLmRlbCh0aGlzLnNldHRpbmdzLnN0YXRlLmtleSk7XHJcblx0XHR9O1xyXG5cdH07XHJcblxyXG5cdChmdW5jdGlvbiAoJCwgdW5kZWZpbmVkKSB7XHJcblx0XHQkLnZha2F0YS5zdG9yYWdlID0ge1xyXG5cdFx0XHQvLyBzaW1wbHkgc3BlY2lmeWluZyB0aGUgZnVuY3Rpb25zIGluIEZGIHRocm93cyBhbiBlcnJvclxyXG5cdFx0XHRzZXQgOiBmdW5jdGlvbiAoa2V5LCB2YWwpIHsgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbCk7IH0sXHJcblx0XHRcdGdldCA6IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpOyB9LFxyXG5cdFx0XHRkZWwgOiBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTsgfVxyXG5cdFx0fTtcclxuXHR9KCQpKTtcclxuXHJcblx0Ly8gaW5jbHVkZSB0aGUgc3RhdGUgcGx1Z2luIGJ5IGRlZmF1bHRcclxuXHQvLyAkLmpzdHJlZS5kZWZhdWx0cy5wbHVnaW5zLnB1c2goXCJzdGF0ZVwiKTtcclxuXHJcbi8qKlxyXG4gKiAjIyMgVHlwZXMgcGx1Z2luXHJcbiAqXHJcbiAqIE1ha2VzIGl0IHBvc3NpYmxlIHRvIGFkZCBwcmVkZWZpbmVkIHR5cGVzIGZvciBncm91cHMgb2Ygbm9kZXMsIHdoaWNoIG1ha2UgaXQgcG9zc2libGUgdG8gZWFzaWx5IGNvbnRyb2wgbmVzdGluZyBydWxlcyBhbmQgaWNvbiBmb3IgZWFjaCBncm91cC5cclxuICovXHJcblxyXG5cdC8qKlxyXG5cdCAqIEFuIG9iamVjdCBzdG9yaW5nIGFsbCB0eXBlcyBhcyBrZXkgdmFsdWUgcGFpcnMsIHdoZXJlIHRoZSBrZXkgaXMgdGhlIHR5cGUgbmFtZSBhbmQgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCB0aGF0IGNvdWxkIGNvbnRhaW4gZm9sbG93aW5nIGtleXMgKGFsbCBvcHRpb25hbCkuXHJcblx0ICogXHJcblx0ICogKiBgbWF4X2NoaWxkcmVuYCB0aGUgbWF4aW11bSBudW1iZXIgb2YgaW1tZWRpYXRlIGNoaWxkcmVuIHRoaXMgbm9kZSB0eXBlIGNhbiBoYXZlLiBEbyBub3Qgc3BlY2lmeSBvciBzZXQgdG8gYC0xYCBmb3IgdW5saW1pdGVkLlxyXG5cdCAqICogYG1heF9kZXB0aGAgdGhlIG1heGltdW0gbnVtYmVyIG9mIG5lc3RpbmcgdGhpcyBub2RlIHR5cGUgY2FuIGhhdmUuIEEgdmFsdWUgb2YgYDFgIHdvdWxkIG1lYW4gdGhhdCB0aGUgbm9kZSBjYW4gaGF2ZSBjaGlsZHJlbiwgYnV0IG5vIGdyYW5kY2hpbGRyZW4uIERvIG5vdCBzcGVjaWZ5IG9yIHNldCB0byBgLTFgIGZvciB1bmxpbWl0ZWQuXHJcblx0ICogKiBgdmFsaWRfY2hpbGRyZW5gIGFuIGFycmF5IG9mIG5vZGUgdHlwZSBzdHJpbmdzLCB0aGF0IG5vZGVzIG9mIHRoaXMgdHlwZSBjYW4gaGF2ZSBhcyBjaGlsZHJlbi4gRG8gbm90IHNwZWNpZnkgb3Igc2V0IHRvIGAtMWAgZm9yIG5vIGxpbWl0cy5cclxuXHQgKiAqIGBpY29uYCBhIHN0cmluZyAtIGNhbiBiZSBhIHBhdGggdG8gYW4gaWNvbiBvciBhIGNsYXNzTmFtZSwgaWYgdXNpbmcgYW4gaW1hZ2UgdGhhdCBpcyBpbiB0aGUgY3VycmVudCBkaXJlY3RvcnkgdXNlIGEgYC4vYCBwcmVmaXgsIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRldGVjdGVkIGFzIGEgY2xhc3MuIE9taXQgdG8gdXNlIHRoZSBkZWZhdWx0IGljb24gZnJvbSB5b3VyIHRoZW1lLlxyXG5cdCAqXHJcblx0ICogVGhlcmUgYXJlIHR3byBwcmVkZWZpbmVkIHR5cGVzOlxyXG5cdCAqIFxyXG5cdCAqICogYCNgIHJlcHJlc2VudHMgdGhlIHJvb3Qgb2YgdGhlIHRyZWUsIGZvciBleGFtcGxlIGBtYXhfY2hpbGRyZW5gIHdvdWxkIGNvbnRyb2wgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJvb3Qgbm9kZXMuXHJcblx0ICogKiBgZGVmYXVsdGAgcmVwcmVzZW50cyB0aGUgZGVmYXVsdCBub2RlIC0gYW55IHNldHRpbmdzIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIGFsbCBub2RlcyB0aGF0IGRvIG5vdCBoYXZlIGEgdHlwZSBzcGVjaWZpZWQuXHJcblx0ICogXHJcblx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMudHlwZXNcclxuXHQgKiBAcGx1Z2luIHR5cGVzXHJcblx0ICovXHJcblx0JC5qc3RyZWUuZGVmYXVsdHMudHlwZXMgPSB7XHJcblx0XHQnIycgOiB7fSxcclxuXHRcdCdkZWZhdWx0JyA6IHt9XHJcblx0fTtcclxuXHJcblx0JC5qc3RyZWUucGx1Z2lucy50eXBlcyA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcclxuXHRcdHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xyXG5cdFx0XHR2YXIgaSwgajtcclxuXHRcdFx0aWYob3B0aW9ucyAmJiBvcHRpb25zLnR5cGVzICYmIG9wdGlvbnMudHlwZXNbJ2RlZmF1bHQnXSkge1xyXG5cdFx0XHRcdGZvcihpIGluIG9wdGlvbnMudHlwZXMpIHtcclxuXHRcdFx0XHRcdGlmKGkgIT09IFwiZGVmYXVsdFwiICYmIGkgIT09IFwiI1wiICYmIG9wdGlvbnMudHlwZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcclxuXHRcdFx0XHRcdFx0Zm9yKGogaW4gb3B0aW9ucy50eXBlc1snZGVmYXVsdCddKSB7XHJcblx0XHRcdFx0XHRcdFx0aWYob3B0aW9ucy50eXBlc1snZGVmYXVsdCddLmhhc093blByb3BlcnR5KGopICYmIG9wdGlvbnMudHlwZXNbaV1bal0gPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy50eXBlc1tpXVtqXSA9IG9wdGlvbnMudHlwZXNbJ2RlZmF1bHQnXVtqXTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cGFyZW50LmluaXQuY2FsbCh0aGlzLCBlbCwgb3B0aW9ucyk7XHJcblx0XHRcdHRoaXMuX21vZGVsLmRhdGFbJyMnXS50eXBlID0gJyMnO1xyXG5cdFx0fTtcclxuXHRcdHRoaXMucmVmcmVzaCA9IGZ1bmN0aW9uIChza2lwX2xvYWRpbmcsIGZvcmdldF9zdGF0ZSkge1xyXG5cdFx0XHRwYXJlbnQucmVmcmVzaC5jYWxsKHRoaXMsIHNraXBfbG9hZGluZywgZm9yZ2V0X3N0YXRlKTtcclxuXHRcdFx0dGhpcy5fbW9kZWwuZGF0YVsnIyddLnR5cGUgPSAnIyc7XHJcblx0XHR9O1xyXG5cdFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR0aGlzLmVsZW1lbnRcclxuXHRcdFx0XHQub24oJ21vZGVsLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0dmFyIG0gPSB0aGlzLl9tb2RlbC5kYXRhLFxyXG5cdFx0XHRcdFx0XHRcdGRwYyA9IGRhdGEubm9kZXMsXHJcblx0XHRcdFx0XHRcdFx0dCA9IHRoaXMuc2V0dGluZ3MudHlwZXMsXHJcblx0XHRcdFx0XHRcdFx0aSwgaiwgYyA9ICdkZWZhdWx0JztcclxuXHRcdFx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gZHBjLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdGMgPSAnZGVmYXVsdCc7XHJcblx0XHRcdFx0XHRcdFx0aWYobVtkcGNbaV1dLm9yaWdpbmFsICYmIG1bZHBjW2ldXS5vcmlnaW5hbC50eXBlICYmIHRbbVtkcGNbaV1dLm9yaWdpbmFsLnR5cGVdKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRjID0gbVtkcGNbaV1dLm9yaWdpbmFsLnR5cGU7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGlmKG1bZHBjW2ldXS5kYXRhICYmIG1bZHBjW2ldXS5kYXRhLmpzdHJlZSAmJiBtW2RwY1tpXV0uZGF0YS5qc3RyZWUudHlwZSAmJiB0W21bZHBjW2ldXS5kYXRhLmpzdHJlZS50eXBlXSkge1xyXG5cdFx0XHRcdFx0XHRcdFx0YyA9IG1bZHBjW2ldXS5kYXRhLmpzdHJlZS50eXBlO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRtW2RwY1tpXV0udHlwZSA9IGM7XHJcblx0XHRcdFx0XHRcdFx0aWYobVtkcGNbaV1dLmljb24gPT09IHRydWUgJiYgdFtjXS5pY29uICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdFx0XHRcdG1bZHBjW2ldXS5pY29uID0gdFtjXS5pY29uO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRtWycjJ10udHlwZSA9ICcjJztcclxuXHRcdFx0XHRcdH0sIHRoaXMpKTtcclxuXHRcdFx0cGFyZW50LmJpbmQuY2FsbCh0aGlzKTtcclxuXHRcdH07XHJcblx0XHR0aGlzLmdldF9qc29uID0gZnVuY3Rpb24gKG9iaiwgb3B0aW9ucywgZmxhdCkge1xyXG5cdFx0XHR2YXIgaSwgaixcclxuXHRcdFx0XHRtID0gdGhpcy5fbW9kZWwuZGF0YSxcclxuXHRcdFx0XHRvcHQgPSBvcHRpb25zID8gJC5leHRlbmQodHJ1ZSwge30sIG9wdGlvbnMsIHtub19pZDpmYWxzZX0pIDoge30sXHJcblx0XHRcdFx0dG1wID0gcGFyZW50LmdldF9qc29uLmNhbGwodGhpcywgb2JqLCBvcHQsIGZsYXQpO1xyXG5cdFx0XHRpZih0bXAgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRpZigkLmlzQXJyYXkodG1wKSkge1xyXG5cdFx0XHRcdGZvcihpID0gMCwgaiA9IHRtcC5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRcdHRtcFtpXS50eXBlID0gdG1wW2ldLmlkICYmIG1bdG1wW2ldLmlkXSAmJiBtW3RtcFtpXS5pZF0udHlwZSA/IG1bdG1wW2ldLmlkXS50eXBlIDogXCJkZWZhdWx0XCI7XHJcblx0XHRcdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMubm9faWQpIHtcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIHRtcFtpXS5pZDtcclxuXHRcdFx0XHRcdFx0aWYodG1wW2ldLmxpX2F0dHIgJiYgdG1wW2ldLmxpX2F0dHIuaWQpIHtcclxuXHRcdFx0XHRcdFx0XHRkZWxldGUgdG1wW2ldLmxpX2F0dHIuaWQ7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYodG1wW2ldLmFfYXR0ciAmJiB0bXBbaV0uYV9hdHRyLmlkKSB7XHJcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHRtcFtpXS5hX2F0dHIuaWQ7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0dG1wLnR5cGUgPSB0bXAuaWQgJiYgbVt0bXAuaWRdICYmIG1bdG1wLmlkXS50eXBlID8gbVt0bXAuaWRdLnR5cGUgOiBcImRlZmF1bHRcIjtcclxuXHRcdFx0XHRpZihvcHRpb25zICYmIG9wdGlvbnMubm9faWQpIHtcclxuXHRcdFx0XHRcdHRtcCA9IHRoaXMuX2RlbGV0ZV9pZHModG1wKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRtcDtcclxuXHRcdH07XHJcblx0XHR0aGlzLl9kZWxldGVfaWRzID0gZnVuY3Rpb24gKHRtcCkge1xyXG5cdFx0XHRpZigkLmlzQXJyYXkodG1wKSkge1xyXG5cdFx0XHRcdGZvcih2YXIgaSA9IDAsIGogPSB0bXAubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHR0bXBbaV0gPSB0aGlzLl9kZWxldGVfaWRzKHRtcFtpXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0bXA7XHJcblx0XHRcdH1cclxuXHRcdFx0ZGVsZXRlIHRtcC5pZDtcclxuXHRcdFx0aWYodG1wLmxpX2F0dHIgJiYgdG1wLmxpX2F0dHIuaWQpIHtcclxuXHRcdFx0XHRkZWxldGUgdG1wLmxpX2F0dHIuaWQ7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodG1wLmFfYXR0ciAmJiB0bXAuYV9hdHRyLmlkKSB7XHJcblx0XHRcdFx0ZGVsZXRlIHRtcC5hX2F0dHIuaWQ7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodG1wLmNoaWxkcmVuICYmICQuaXNBcnJheSh0bXAuY2hpbGRyZW4pKSB7XHJcblx0XHRcdFx0dG1wLmNoaWxkcmVuID0gdGhpcy5fZGVsZXRlX2lkcyh0bXAuY2hpbGRyZW4pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0bXA7XHJcblx0XHR9O1xyXG5cdFx0dGhpcy5jaGVjayA9IGZ1bmN0aW9uIChjaGssIG9iaiwgcGFyLCBwb3MsIG1vcmUpIHtcclxuXHRcdFx0aWYocGFyZW50LmNoZWNrLmNhbGwodGhpcywgY2hrLCBvYmosIHBhciwgcG9zLCBtb3JlKSA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblx0XHRcdG9iaiA9IG9iaiAmJiBvYmouaWQgPyBvYmogOiB0aGlzLmdldF9ub2RlKG9iaik7XHJcblx0XHRcdHBhciA9IHBhciAmJiBwYXIuaWQgPyBwYXIgOiB0aGlzLmdldF9ub2RlKHBhcik7XHJcblx0XHRcdHZhciBtID0gb2JqICYmIG9iai5pZCA/ICQuanN0cmVlLnJlZmVyZW5jZShvYmouaWQpIDogbnVsbCwgdG1wLCBkLCBpLCBqO1xyXG5cdFx0XHRtID0gbSAmJiBtLl9tb2RlbCAmJiBtLl9tb2RlbC5kYXRhID8gbS5fbW9kZWwuZGF0YSA6IG51bGw7XHJcblx0XHRcdHN3aXRjaChjaGspIHtcclxuXHRcdFx0XHRjYXNlIFwiY3JlYXRlX25vZGVcIjpcclxuXHRcdFx0XHRjYXNlIFwibW92ZV9ub2RlXCI6XHJcblx0XHRcdFx0Y2FzZSBcImNvcHlfbm9kZVwiOlxyXG5cdFx0XHRcdFx0aWYoY2hrICE9PSAnbW92ZV9ub2RlJyB8fCAkLmluQXJyYXkob2JqLmlkLCBwYXIuY2hpbGRyZW4pID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ydWxlcyhwYXIpO1xyXG5cdFx0XHRcdFx0XHRpZih0bXAubWF4X2NoaWxkcmVuICE9PSB1bmRlZmluZWQgJiYgdG1wLm1heF9jaGlsZHJlbiAhPT0gLTEgJiYgdG1wLm1heF9jaGlsZHJlbiA9PT0gcGFyLmNoaWxkcmVuLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2NoZWNrJywgJ3BsdWdpbicgOiAndHlwZXMnLCAnaWQnIDogJ3R5cGVzXzAxJywgJ3JlYXNvbicgOiAnbWF4X2NoaWxkcmVuIHByZXZlbnRzIGZ1bmN0aW9uOiAnICsgY2hrLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdjaGsnIDogY2hrLCAncG9zJyA6IHBvcywgJ29iaicgOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsICdwYXInIDogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKHRtcC52YWxpZF9jaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIHRtcC52YWxpZF9jaGlsZHJlbiAhPT0gLTEgJiYgJC5pbkFycmF5KChvYmoudHlwZSB8fCAnZGVmYXVsdCcpLCB0bXAudmFsaWRfY2hpbGRyZW4pID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2NoZWNrJywgJ3BsdWdpbicgOiAndHlwZXMnLCAnaWQnIDogJ3R5cGVzXzAyJywgJ3JlYXNvbicgOiAndmFsaWRfY2hpbGRyZW4gcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0aWYobSAmJiBvYmouY2hpbGRyZW5fZCAmJiBvYmoucGFyZW50cykge1xyXG5cdFx0XHRcdFx0XHRcdGQgPSAwO1xyXG5cdFx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IG9iai5jaGlsZHJlbl9kLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0XHRcdFx0ZCA9IE1hdGgubWF4KGQsIG1bb2JqLmNoaWxkcmVuX2RbaV1dLnBhcmVudHMubGVuZ3RoKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0ZCA9IGQgLSBvYmoucGFyZW50cy5sZW5ndGggKyAxO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmKGQgPD0gMCB8fCBkID09PSB1bmRlZmluZWQpIHsgZCA9IDE7IH1cclxuXHRcdFx0XHRcdFx0ZG8ge1xyXG5cdFx0XHRcdFx0XHRcdGlmKHRtcC5tYXhfZGVwdGggIT09IHVuZGVmaW5lZCAmJiB0bXAubWF4X2RlcHRoICE9PSAtMSAmJiB0bXAubWF4X2RlcHRoIDwgZCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd0eXBlcycsICdpZCcgOiAndHlwZXNfMDMnLCAncmVhc29uJyA6ICdtYXhfZGVwdGggcHJldmVudHMgZnVuY3Rpb246ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcclxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0cGFyID0gdGhpcy5nZXRfbm9kZShwYXIucGFyZW50KTtcclxuXHRcdFx0XHRcdFx0XHR0bXAgPSB0aGlzLmdldF9ydWxlcyhwYXIpO1xyXG5cdFx0XHRcdFx0XHRcdGQrKztcclxuXHRcdFx0XHRcdFx0fSB3aGlsZShwYXIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9O1xyXG5cdFx0LyoqXHJcblx0XHQgKiB1c2VkIHRvIHJldHJpZXZlIHRoZSB0eXBlIHNldHRpbmdzIG9iamVjdCBmb3IgYSBub2RlXHJcblx0XHQgKiBAbmFtZSBnZXRfcnVsZXMob2JqKVxyXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGZpbmQgdGhlIHJ1bGVzIGZvclxyXG5cdFx0ICogQHJldHVybiB7T2JqZWN0fVxyXG5cdFx0ICogQHBsdWdpbiB0eXBlc1xyXG5cdFx0ICovXHJcblx0XHR0aGlzLmdldF9ydWxlcyA9IGZ1bmN0aW9uIChvYmopIHtcclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRpZighb2JqKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHR2YXIgdG1wID0gdGhpcy5nZXRfdHlwZShvYmosIHRydWUpO1xyXG5cdFx0XHRpZih0bXAubWF4X2RlcHRoID09PSB1bmRlZmluZWQpIHsgdG1wLm1heF9kZXB0aCA9IC0xOyB9XHJcblx0XHRcdGlmKHRtcC5tYXhfY2hpbGRyZW4gPT09IHVuZGVmaW5lZCkgeyB0bXAubWF4X2NoaWxkcmVuID0gLTE7IH1cclxuXHRcdFx0aWYodG1wLnZhbGlkX2NoaWxkcmVuID09PSB1bmRlZmluZWQpIHsgdG1wLnZhbGlkX2NoaWxkcmVuID0gLTE7IH1cclxuXHRcdFx0cmV0dXJuIHRtcDtcclxuXHRcdH07XHJcblx0XHQvKipcclxuXHRcdCAqIHVzZWQgdG8gcmV0cmlldmUgdGhlIHR5cGUgc3RyaW5nIG9yIHNldHRpbmdzIG9iamVjdCBmb3IgYSBub2RlXHJcblx0XHQgKiBAbmFtZSBnZXRfdHlwZShvYmogWywgcnVsZXNdKVxyXG5cdFx0ICogQHBhcmFtIHttaXhlZH0gb2JqIHRoZSBub2RlIHRvIGZpbmQgdGhlIHJ1bGVzIGZvclxyXG5cdFx0ICogQHBhcmFtIHtCb29sZWFufSBydWxlcyBpZiBzZXQgdG8gYHRydWVgIGluc3RlYWQgb2YgYSBzdHJpbmcgdGhlIHNldHRpbmdzIG9iamVjdCB3aWxsIGJlIHJldHVybmVkXHJcblx0XHQgKiBAcmV0dXJuIHtTdHJpbmd8T2JqZWN0fVxyXG5cdFx0ICogQHBsdWdpbiB0eXBlc1xyXG5cdFx0ICovXHJcblx0XHR0aGlzLmdldF90eXBlID0gZnVuY3Rpb24gKG9iaiwgcnVsZXMpIHtcclxuXHRcdFx0b2JqID0gdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRyZXR1cm4gKCFvYmopID8gZmFsc2UgOiAoIHJ1bGVzID8gJC5leHRlbmQoeyAndHlwZScgOiBvYmoudHlwZSB9LCB0aGlzLnNldHRpbmdzLnR5cGVzW29iai50eXBlXSkgOiBvYmoudHlwZSk7XHJcblx0XHR9O1xyXG5cdFx0LyoqXHJcblx0XHQgKiB1c2VkIHRvIGNoYW5nZSBhIG5vZGUncyB0eXBlXHJcblx0XHQgKiBAbmFtZSBzZXRfdHlwZShvYmosIHR5cGUpXHJcblx0XHQgKiBAcGFyYW0ge21peGVkfSBvYmogdGhlIG5vZGUgdG8gY2hhbmdlXHJcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSB0aGUgbmV3IHR5cGVcclxuXHRcdCAqIEBwbHVnaW4gdHlwZXNcclxuXHRcdCAqL1xyXG5cdFx0dGhpcy5zZXRfdHlwZSA9IGZ1bmN0aW9uIChvYmosIHR5cGUpIHtcclxuXHRcdFx0dmFyIHQsIHQxLCB0Miwgb2xkX3R5cGUsIG9sZF9pY29uO1xyXG5cdFx0XHRpZigkLmlzQXJyYXkob2JqKSkge1xyXG5cdFx0XHRcdG9iaiA9IG9iai5zbGljZSgpO1xyXG5cdFx0XHRcdGZvcih0MSA9IDAsIHQyID0gb2JqLmxlbmd0aDsgdDEgPCB0MjsgdDErKykge1xyXG5cdFx0XHRcdFx0dGhpcy5zZXRfdHlwZShvYmpbdDFdLCB0eXBlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdFx0dCA9IHRoaXMuc2V0dGluZ3MudHlwZXM7XHJcblx0XHRcdG9iaiA9IHRoaXMuZ2V0X25vZGUob2JqKTtcclxuXHRcdFx0aWYoIXRbdHlwZV0gfHwgIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHRcdFx0b2xkX3R5cGUgPSBvYmoudHlwZTtcclxuXHRcdFx0b2xkX2ljb24gPSB0aGlzLmdldF9pY29uKG9iaik7XHJcblx0XHRcdG9iai50eXBlID0gdHlwZTtcclxuXHRcdFx0aWYob2xkX2ljb24gPT09IHRydWUgfHwgKHRbb2xkX3R5cGVdICYmIHRbb2xkX3R5cGVdLmljb24gIT09IHVuZGVmaW5lZCAmJiBvbGRfaWNvbiA9PT0gdFtvbGRfdHlwZV0uaWNvbikpIHtcclxuXHRcdFx0XHR0aGlzLnNldF9pY29uKG9iaiwgdFt0eXBlXS5pY29uICE9PSB1bmRlZmluZWQgPyB0W3R5cGVdLmljb24gOiB0cnVlKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH07XHJcblx0fTtcclxuXHQvLyBpbmNsdWRlIHRoZSB0eXBlcyBwbHVnaW4gYnkgZGVmYXVsdFxyXG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcInR5cGVzXCIpO1xyXG5cclxuLyoqXHJcbiAqICMjIyBVbmlxdWUgcGx1Z2luXHJcbiAqXHJcbiAqIEVuZm9yY2VzIHRoYXQgbm8gbm9kZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGNhbiBjb2V4aXN0IGFzIHNpYmxpbmdzLlxyXG4gKi9cclxuXHJcblx0LyoqXHJcblx0ICogc3RvcmVzIGFsbCBkZWZhdWx0cyBmb3IgdGhlIHVuaXF1ZSBwbHVnaW5cclxuXHQgKiBAbmFtZSAkLmpzdHJlZS5kZWZhdWx0cy51bmlxdWVcclxuXHQgKiBAcGx1Z2luIHVuaXF1ZVxyXG5cdCAqL1xyXG5cdCQuanN0cmVlLmRlZmF1bHRzLnVuaXF1ZSA9IHtcclxuXHRcdC8qKlxyXG5cdFx0ICogSW5kaWNhdGVzIGlmIHRoZSBjb21wYXJpc29uIHNob3VsZCBiZSBjYXNlIHNlbnNpdGl2ZS4gRGVmYXVsdCBpcyBgZmFsc2VgLlxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMudW5pcXVlLmNhc2Vfc2Vuc2l0aXZlXHJcblx0XHQgKiBAcGx1Z2luIHVuaXF1ZVxyXG5cdFx0ICovXHJcblx0XHRjYXNlX3NlbnNpdGl2ZSA6IGZhbHNlLFxyXG5cdFx0LyoqXHJcblx0XHQgKiBBIGNhbGxiYWNrIGV4ZWN1dGVkIGluIHRoZSBpbnN0YW5jZSdzIHNjb3BlIHdoZW4gYSBuZXcgbm9kZSBpcyBjcmVhdGVkIGFuZCB0aGUgbmFtZSBpcyBhbHJlYWR5IHRha2VuLCB0aGUgdHdvIGFyZ3VtZW50cyBhcmUgdGhlIGNvbmZsaWN0aW5nIG5hbWUgYW5kIHRoZSBjb3VudGVyLiBUaGUgZGVmYXVsdCB3aWxsIHByb2R1Y2UgcmVzdWx0cyBsaWtlIGBOZXcgbm9kZSAoMilgLlxyXG5cdFx0ICogQG5hbWUgJC5qc3RyZWUuZGVmYXVsdHMudW5pcXVlLmR1cGxpY2F0ZVxyXG5cdFx0ICogQHBsdWdpbiB1bmlxdWVcclxuXHRcdCAqL1xyXG5cdFx0ZHVwbGljYXRlIDogZnVuY3Rpb24gKG5hbWUsIGNvdW50ZXIpIHtcclxuXHRcdFx0cmV0dXJuIG5hbWUgKyAnICgnICsgY291bnRlciArICcpJztcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQkLmpzdHJlZS5wbHVnaW5zLnVuaXF1ZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBwYXJlbnQpIHtcclxuXHRcdHRoaXMuY2hlY2sgPSBmdW5jdGlvbiAoY2hrLCBvYmosIHBhciwgcG9zLCBtb3JlKSB7XHJcblx0XHRcdGlmKHBhcmVudC5jaGVjay5jYWxsKHRoaXMsIGNoaywgb2JqLCBwYXIsIHBvcywgbW9yZSkgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0XHRvYmogPSBvYmogJiYgb2JqLmlkID8gb2JqIDogdGhpcy5nZXRfbm9kZShvYmopO1xyXG5cdFx0XHRwYXIgPSBwYXIgJiYgcGFyLmlkID8gcGFyIDogdGhpcy5nZXRfbm9kZShwYXIpO1xyXG5cdFx0XHRpZighcGFyIHx8ICFwYXIuY2hpbGRyZW4pIHsgcmV0dXJuIHRydWU7IH1cclxuXHRcdFx0dmFyIG4gPSBjaGsgPT09IFwicmVuYW1lX25vZGVcIiA/IHBvcyA6IG9iai50ZXh0LFxyXG5cdFx0XHRcdGMgPSBbXSxcclxuXHRcdFx0XHRzID0gdGhpcy5zZXR0aW5ncy51bmlxdWUuY2FzZV9zZW5zaXRpdmUsXHJcblx0XHRcdFx0bSA9IHRoaXMuX21vZGVsLmRhdGEsIGksIGo7XHJcblx0XHRcdGZvcihpID0gMCwgaiA9IHBhci5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcclxuXHRcdFx0XHRjLnB1c2gocyA/IG1bcGFyLmNoaWxkcmVuW2ldXS50ZXh0IDogbVtwYXIuY2hpbGRyZW5baV1dLnRleHQudG9Mb3dlckNhc2UoKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIXMpIHsgbiA9IG4udG9Mb3dlckNhc2UoKTsgfVxyXG5cdFx0XHRzd2l0Y2goY2hrKSB7XHJcblx0XHRcdFx0Y2FzZSBcImRlbGV0ZV9ub2RlXCI6XHJcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHRjYXNlIFwicmVuYW1lX25vZGVcIjpcclxuXHRcdFx0XHRcdGkgPSAoJC5pbkFycmF5KG4sIGMpID09PSAtMSB8fCAob2JqLnRleHQgJiYgb2JqLnRleHRbIHMgPyAndG9TdHJpbmcnIDogJ3RvTG93ZXJDYXNlJ10oKSA9PT0gbikpO1xyXG5cdFx0XHRcdFx0aWYoIWkpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd1bmlxdWUnLCAnaWQnIDogJ3VuaXF1ZV8wMScsICdyZWFzb24nIDogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBpO1xyXG5cdFx0XHRcdGNhc2UgXCJjcmVhdGVfbm9kZVwiOlxyXG5cdFx0XHRcdFx0aSA9ICgkLmluQXJyYXkobiwgYykgPT09IC0xKTtcclxuXHRcdFx0XHRcdGlmKCFpKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuX2RhdGEuY29yZS5sYXN0X2Vycm9yID0geyAnZXJyb3InIDogJ2NoZWNrJywgJ3BsdWdpbicgOiAndW5pcXVlJywgJ2lkJyA6ICd1bmlxdWVfMDQnLCAncmVhc29uJyA6ICdDaGlsZCB3aXRoIG5hbWUgJyArIG4gKyAnIGFscmVhZHkgZXhpc3RzLiBQcmV2ZW50aW5nOiAnICsgY2hrLCAnZGF0YScgOiBKU09OLnN0cmluZ2lmeSh7ICdjaGsnIDogY2hrLCAncG9zJyA6IHBvcywgJ29iaicgOiBvYmogJiYgb2JqLmlkID8gb2JqLmlkIDogZmFsc2UsICdwYXInIDogcGFyICYmIHBhci5pZCA/IHBhci5pZCA6IGZhbHNlIH0pIH07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gaTtcclxuXHRcdFx0XHRjYXNlIFwiY29weV9ub2RlXCI6XHJcblx0XHRcdFx0XHRpID0gKCQuaW5BcnJheShuLCBjKSA9PT0gLTEpO1xyXG5cdFx0XHRcdFx0aWYoIWkpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd1bmlxdWUnLCAnaWQnIDogJ3VuaXF1ZV8wMicsICdyZWFzb24nIDogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBpO1xyXG5cdFx0XHRcdGNhc2UgXCJtb3ZlX25vZGVcIjpcclxuXHRcdFx0XHRcdGkgPSAob2JqLnBhcmVudCA9PT0gcGFyLmlkIHx8ICQuaW5BcnJheShuLCBjKSA9PT0gLTEpO1xyXG5cdFx0XHRcdFx0aWYoIWkpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5fZGF0YS5jb3JlLmxhc3RfZXJyb3IgPSB7ICdlcnJvcicgOiAnY2hlY2snLCAncGx1Z2luJyA6ICd1bmlxdWUnLCAnaWQnIDogJ3VuaXF1ZV8wMycsICdyZWFzb24nIDogJ0NoaWxkIHdpdGggbmFtZSAnICsgbiArICcgYWxyZWFkeSBleGlzdHMuIFByZXZlbnRpbmc6ICcgKyBjaGssICdkYXRhJyA6IEpTT04uc3RyaW5naWZ5KHsgJ2NoaycgOiBjaGssICdwb3MnIDogcG9zLCAnb2JqJyA6IG9iaiAmJiBvYmouaWQgPyBvYmouaWQgOiBmYWxzZSwgJ3BhcicgOiBwYXIgJiYgcGFyLmlkID8gcGFyLmlkIDogZmFsc2UgfSkgfTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fTtcclxuXHRcdHRoaXMuY3JlYXRlX25vZGUgPSBmdW5jdGlvbiAocGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpIHtcclxuXHRcdFx0aWYoIW5vZGUgfHwgbm9kZS50ZXh0ID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRpZihwYXIgPT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHBhciA9IFwiI1wiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRwYXIgPSB0aGlzLmdldF9ub2RlKHBhcik7XHJcblx0XHRcdFx0aWYoIXBhcikge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5jcmVhdGVfbm9kZS5jYWxsKHRoaXMsIHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cG9zID0gcG9zID09PSB1bmRlZmluZWQgPyBcImxhc3RcIiA6IHBvcztcclxuXHRcdFx0XHRpZighcG9zLnRvU3RyaW5nKCkubWF0Y2goL14oYmVmb3JlfGFmdGVyKSQvKSAmJiAhaXNfbG9hZGVkICYmICF0aGlzLmlzX2xvYWRlZChwYXIpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50LmNyZWF0ZV9ub2RlLmNhbGwodGhpcywgcGFyLCBub2RlLCBwb3MsIGNhbGxiYWNrLCBpc19sb2FkZWQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZighbm9kZSkgeyBub2RlID0ge307IH1cclxuXHRcdFx0XHR2YXIgdG1wLCBuLCBkcGMsIGksIGosIG0gPSB0aGlzLl9tb2RlbC5kYXRhLCBzID0gdGhpcy5zZXR0aW5ncy51bmlxdWUuY2FzZV9zZW5zaXRpdmUsIGNiID0gdGhpcy5zZXR0aW5ncy51bmlxdWUuZHVwbGljYXRlO1xyXG5cdFx0XHRcdG4gPSB0bXAgPSB0aGlzLmdldF9zdHJpbmcoJ05ldyBub2RlJyk7XHJcblx0XHRcdFx0ZHBjID0gW107XHJcblx0XHRcdFx0Zm9yKGkgPSAwLCBqID0gcGFyLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGo7IGkrKykge1xyXG5cdFx0XHRcdFx0ZHBjLnB1c2gocyA/IG1bcGFyLmNoaWxkcmVuW2ldXS50ZXh0IDogbVtwYXIuY2hpbGRyZW5baV1dLnRleHQudG9Mb3dlckNhc2UoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSAxO1xyXG5cdFx0XHRcdHdoaWxlKCQuaW5BcnJheShzID8gbiA6IG4udG9Mb3dlckNhc2UoKSwgZHBjKSAhPT0gLTEpIHtcclxuXHRcdFx0XHRcdG4gPSBjYi5jYWxsKHRoaXMsIHRtcCwgKCsraSkpLnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdG5vZGUudGV4dCA9IG47XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHBhcmVudC5jcmVhdGVfbm9kZS5jYWxsKHRoaXMsIHBhciwgbm9kZSwgcG9zLCBjYWxsYmFjaywgaXNfbG9hZGVkKTtcclxuXHRcdH07XHJcblx0fTtcclxuXHJcblx0Ly8gaW5jbHVkZSB0aGUgdW5pcXVlIHBsdWdpbiBieSBkZWZhdWx0XHJcblx0Ly8gJC5qc3RyZWUuZGVmYXVsdHMucGx1Z2lucy5wdXNoKFwidW5pcXVlXCIpO1xyXG5cclxuXHJcbi8qKlxyXG4gKiAjIyMgV2hvbGVyb3cgcGx1Z2luXHJcbiAqXHJcbiAqIE1ha2VzIGVhY2ggbm9kZSBhcHBlYXIgYmxvY2sgbGV2ZWwuIE1ha2luZyBzZWxlY3Rpb24gZWFzaWVyLiBNYXkgY2F1c2Ugc2xvdyBkb3duIGZvciBsYXJnZSB0cmVlcyBpbiBvbGQgYnJvd3NlcnMuXHJcbiAqL1xyXG5cclxuXHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XHJcblx0ZGl2LnNldEF0dHJpYnV0ZSgndW5zZWxlY3RhYmxlJywnb24nKTtcclxuXHRkaXYuc2V0QXR0cmlidXRlKCdyb2xlJywncHJlc2VudGF0aW9uJyk7XHJcblx0ZGl2LmNsYXNzTmFtZSA9ICdqc3RyZWUtd2hvbGVyb3cnO1xyXG5cdGRpdi5pbm5lckhUTUwgPSAnJiMxNjA7JztcclxuXHQkLmpzdHJlZS5wbHVnaW5zLndob2xlcm93ID0gZnVuY3Rpb24gKG9wdGlvbnMsIHBhcmVudCkge1xyXG5cdFx0dGhpcy5iaW5kID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRwYXJlbnQuYmluZC5jYWxsKHRoaXMpO1xyXG5cclxuXHRcdFx0dGhpcy5lbGVtZW50XHJcblx0XHRcdFx0Lm9uKCdyZWFkeS5qc3RyZWUgc2V0X3N0YXRlLmpzdHJlZScsICQucHJveHkoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmhpZGVfZG90cygpO1xyXG5cdFx0XHRcdFx0fSwgdGhpcykpXHJcblx0XHRcdFx0Lm9uKFwiaW5pdC5qc3RyZWUgbG9hZGluZy5qc3RyZWUgcmVhZHkuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0XHQvL2Rpdi5zdHlsZS5oZWlnaHQgPSB0aGlzLl9kYXRhLmNvcmUubGlfaGVpZ2h0ICsgJ3B4JztcclxuXHRcdFx0XHRcdFx0dGhpcy5nZXRfY29udGFpbmVyX3VsKCkuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy11bCcpO1xyXG5cdFx0XHRcdFx0fSwgdGhpcykpXHJcblx0XHRcdFx0Lm9uKFwiZGVzZWxlY3RfYWxsLmpzdHJlZVwiLCAkLnByb3h5KGZ1bmN0aW9uIChlLCBkYXRhKSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuZWxlbWVudC5maW5kKCcuanN0cmVlLXdob2xlcm93LWNsaWNrZWQnKS5yZW1vdmVDbGFzcygnanN0cmVlLXdob2xlcm93LWNsaWNrZWQnKTtcclxuXHRcdFx0XHRcdH0sIHRoaXMpKVxyXG5cdFx0XHRcdC5vbihcImNoYW5nZWQuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5lbGVtZW50LmZpbmQoJy5qc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpLnJlbW92ZUNsYXNzKCdqc3RyZWUtd2hvbGVyb3ctY2xpY2tlZCcpO1xyXG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gZmFsc2UsIGksIGo7XHJcblx0XHRcdFx0XHRcdGZvcihpID0gMCwgaiA9IGRhdGEuc2VsZWN0ZWQubGVuZ3RoOyBpIDwgajsgaSsrKSB7XHJcblx0XHRcdFx0XHRcdFx0dG1wID0gdGhpcy5nZXRfbm9kZShkYXRhLnNlbGVjdGVkW2ldLCB0cnVlKTtcclxuXHRcdFx0XHRcdFx0XHRpZih0bXAgJiYgdG1wLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dG1wLmNoaWxkcmVuKCcuanN0cmVlLXdob2xlcm93JykuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9LCB0aGlzKSlcclxuXHRcdFx0XHQub24oXCJvcGVuX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5nZXRfbm9kZShkYXRhLm5vZGUsIHRydWUpLmZpbmQoJy5qc3RyZWUtY2xpY2tlZCcpLnBhcmVudCgpLmNoaWxkcmVuKCcuanN0cmVlLXdob2xlcm93JykuYWRkQ2xhc3MoJ2pzdHJlZS13aG9sZXJvdy1jbGlja2VkJyk7XHJcblx0XHRcdFx0XHR9LCB0aGlzKSlcclxuXHRcdFx0XHQub24oXCJob3Zlcl9ub2RlLmpzdHJlZSBkZWhvdmVyX25vZGUuanN0cmVlXCIsICQucHJveHkoZnVuY3Rpb24gKGUsIGRhdGEpIHtcclxuXHRcdFx0XHRcdFx0aWYoZS50eXBlID09PSBcImhvdmVyX25vZGVcIiAmJiB0aGlzLmlzX2Rpc2FibGVkKGRhdGEubm9kZSkpIHsgcmV0dXJuOyB9XHJcblx0XHRcdFx0XHRcdHRoaXMuZ2V0X25vZGUoZGF0YS5ub2RlLCB0cnVlKS5jaGlsZHJlbignLmpzdHJlZS13aG9sZXJvdycpW2UudHlwZSA9PT0gXCJob3Zlcl9ub2RlXCI/XCJhZGRDbGFzc1wiOlwicmVtb3ZlQ2xhc3NcIl0oJ2pzdHJlZS13aG9sZXJvdy1ob3ZlcmVkJyk7XHJcblx0XHRcdFx0XHR9LCB0aGlzKSlcclxuXHRcdFx0XHQub24oXCJjb250ZXh0bWVudS5qc3RyZWVcIiwgXCIuanN0cmVlLXdob2xlcm93XCIsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gJC5FdmVudCgnY29udGV4dG1lbnUnLCB7IG1ldGFLZXkgOiBlLm1ldGFLZXksIGN0cmxLZXkgOiBlLmN0cmxLZXksIGFsdEtleSA6IGUuYWx0S2V5LCBzaGlmdEtleSA6IGUuc2hpZnRLZXksIHBhZ2VYIDogZS5wYWdlWCwgcGFnZVkgOiBlLnBhZ2VZIH0pO1xyXG5cdFx0XHRcdFx0XHQkKGUuY3VycmVudFRhcmdldCkuY2xvc2VzdChcIi5qc3RyZWUtbm9kZVwiKS5jaGlsZHJlbihcIi5qc3RyZWUtYW5jaG9yXCIpLmZpcnN0KCkudHJpZ2dlcih0bXApO1xyXG5cdFx0XHRcdFx0fSwgdGhpcykpXHJcblx0XHRcdFx0Lm9uKFwiY2xpY2suanN0cmVlXCIsIFwiLmpzdHJlZS13aG9sZXJvd1wiLCBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gJC5FdmVudCgnY2xpY2snLCB7IG1ldGFLZXkgOiBlLm1ldGFLZXksIGN0cmxLZXkgOiBlLmN0cmxLZXksIGFsdEtleSA6IGUuYWx0S2V5LCBzaGlmdEtleSA6IGUuc2hpZnRLZXkgfSk7XHJcblx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KFwiLmpzdHJlZS1ub2RlXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIikuZmlyc3QoKS50cmlnZ2VyKHRtcCkuZm9jdXMoKTtcclxuXHRcdFx0XHRcdH0pXHJcblx0XHRcdFx0Lm9uKFwiY2xpY2suanN0cmVlXCIsIFwiLmpzdHJlZS1sZWFmID4gLmpzdHJlZS1vY2xcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRcdFx0XHR2YXIgdG1wID0gJC5FdmVudCgnY2xpY2snLCB7IG1ldGFLZXkgOiBlLm1ldGFLZXksIGN0cmxLZXkgOiBlLmN0cmxLZXksIGFsdEtleSA6IGUuYWx0S2V5LCBzaGlmdEtleSA6IGUuc2hpZnRLZXkgfSk7XHJcblx0XHRcdFx0XHRcdCQoZS5jdXJyZW50VGFyZ2V0KS5jbG9zZXN0KFwiLmpzdHJlZS1ub2RlXCIpLmNoaWxkcmVuKFwiLmpzdHJlZS1hbmNob3JcIikuZmlyc3QoKS50cmlnZ2VyKHRtcCkuZm9jdXMoKTtcclxuXHRcdFx0XHRcdH0sIHRoaXMpKVxyXG5cdFx0XHRcdC5vbihcIm1vdXNlb3Zlci5qc3RyZWVcIiwgXCIuanN0cmVlLXdob2xlcm93LCAuanN0cmVlLWljb25cIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRcdFx0XHRpZighdGhpcy5pc19kaXNhYmxlZChlLmN1cnJlbnRUYXJnZXQpKSB7XHJcblx0XHRcdFx0XHRcdFx0dGhpcy5ob3Zlcl9ub2RlKGUuY3VycmVudFRhcmdldCk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0fSwgdGhpcykpXHJcblx0XHRcdFx0Lm9uKFwibW91c2VsZWF2ZS5qc3RyZWVcIiwgXCIuanN0cmVlLW5vZGVcIiwgJC5wcm94eShmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmRlaG92ZXJfbm9kZShlLmN1cnJlbnRUYXJnZXQpO1xyXG5cdFx0XHRcdFx0fSwgdGhpcykpO1xyXG5cdFx0fTtcclxuXHRcdHRoaXMudGVhcmRvd24gPSBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmKHRoaXMuc2V0dGluZ3Mud2hvbGVyb3cpIHtcclxuXHRcdFx0XHR0aGlzLmVsZW1lbnQuZmluZChcIi5qc3RyZWUtd2hvbGVyb3dcIikucmVtb3ZlKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0cGFyZW50LnRlYXJkb3duLmNhbGwodGhpcyk7XHJcblx0XHR9O1xyXG5cdFx0dGhpcy5yZWRyYXdfbm9kZSA9IGZ1bmN0aW9uKG9iaiwgZGVlcCwgY2FsbGJhY2ssIGZvcmNlX3JlbmRlcikge1xyXG5cdFx0XHRvYmogPSBwYXJlbnQucmVkcmF3X25vZGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHRcdFx0aWYob2JqKSB7XHJcblx0XHRcdFx0dmFyIHRtcCA9IGRpdi5jbG9uZU5vZGUodHJ1ZSk7XHJcblx0XHRcdFx0Ly90bXAuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fZGF0YS5jb3JlLmxpX2hlaWdodCArICdweCc7XHJcblx0XHRcdFx0aWYoJC5pbkFycmF5KG9iai5pZCwgdGhpcy5fZGF0YS5jb3JlLnNlbGVjdGVkKSAhPT0gLTEpIHsgdG1wLmNsYXNzTmFtZSArPSAnIGpzdHJlZS13aG9sZXJvdy1jbGlja2VkJzsgfVxyXG5cdFx0XHRcdGlmKHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkICYmIHRoaXMuX2RhdGEuY29yZS5mb2N1c2VkID09PSBvYmouaWQpIHsgdG1wLmNsYXNzTmFtZSArPSAnIGpzdHJlZS13aG9sZXJvdy1ob3ZlcmVkJzsgfVxyXG5cdFx0XHRcdG9iai5pbnNlcnRCZWZvcmUodG1wLCBvYmouY2hpbGROb2Rlc1swXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG9iajtcclxuXHRcdH07XHJcblx0fTtcclxuXHQvLyBpbmNsdWRlIHRoZSB3aG9sZXJvdyBwbHVnaW4gYnkgZGVmYXVsdFxyXG5cdC8vICQuanN0cmVlLmRlZmF1bHRzLnBsdWdpbnMucHVzaChcIndob2xlcm93XCIpO1xyXG5cclxuXHJcbihmdW5jdGlvbiAoJCkge1xyXG5cdGlmKGRvY3VtZW50LnJlZ2lzdGVyRWxlbWVudCAmJiBPYmplY3QgJiYgT2JqZWN0LmNyZWF0ZSkge1xyXG5cdFx0dmFyIHByb3RvID0gT2JqZWN0LmNyZWF0ZShIVE1MRWxlbWVudC5wcm90b3R5cGUpO1xyXG5cdFx0cHJvdG8uY3JlYXRlZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHR2YXIgYyA9IHsgY29yZSA6IHt9LCBwbHVnaW5zIDogW10gfSwgaTtcclxuXHRcdFx0Zm9yKGkgaW4gJC5qc3RyZWUucGx1Z2lucykge1xyXG5cdFx0XHRcdGlmKCQuanN0cmVlLnBsdWdpbnMuaGFzT3duUHJvcGVydHkoaSkgJiYgdGhpcy5hdHRyaWJ1dGVzW2ldKSB7XHJcblx0XHRcdFx0XHRjLnBsdWdpbnMucHVzaChpKTtcclxuXHRcdFx0XHRcdGlmKHRoaXMuZ2V0QXR0cmlidXRlKGkpICYmIEpTT04ucGFyc2UodGhpcy5nZXRBdHRyaWJ1dGUoaSkpKSB7XHJcblx0XHRcdFx0XHRcdGNbaV0gPSBKU09OLnBhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKGkpKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKGkgaW4gJC5qc3RyZWUuZGVmYXVsdHMuY29yZSkge1xyXG5cdFx0XHRcdGlmKCQuanN0cmVlLmRlZmF1bHRzLmNvcmUuaGFzT3duUHJvcGVydHkoaSkgJiYgdGhpcy5hdHRyaWJ1dGVzW2ldKSB7XHJcblx0XHRcdFx0XHRjLmNvcmVbaV0gPSBKU09OLnBhcnNlKHRoaXMuZ2V0QXR0cmlidXRlKGkpKSB8fCB0aGlzLmdldEF0dHJpYnV0ZShpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0alF1ZXJ5KHRoaXMpLmpzdHJlZShjKTtcclxuXHRcdH07XHJcblx0XHQvLyBwcm90by5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgcHJldmlvdXMsIHZhbHVlKSB7IH07XHJcblx0XHR0cnkge1xyXG5cdFx0XHRkb2N1bWVudC5yZWdpc3RlckVsZW1lbnQoXCJ2YWthdGEtanN0cmVlXCIsIHsgcHJvdG90eXBlOiBwcm90byB9KTtcclxuXHRcdH0gY2F0Y2goaWdub3JlKSB7IH1cclxuXHR9XHJcbn0pO1xyXG59KSk7IiwiJCA9IHJlcXVpcmUoXCJqcXVlcnlcIik7XHJcblxyXG4vKipcclxuICogRXhwb3NlIGBub3RpZnlgLlxyXG4gKi9cclxuXHJcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IG5vdGlmeTtcclxuXHJcbi8qKlxyXG4gKiBOb3RpZmljYXRpb24gbGlzdC5cclxuICovXHJcblxyXG52YXIgbGlzdFRwbCA9ICc8dWwgaWQ9XCJub3RpZmljYXRpb25zXCI+PC91bD4nLFxyXG4gICAgc3Bpbm5lclRwbCA9ICc8ZGl2IGNsYXNzPVwic3Bpbm5lclwiPlxcXHJcbiAgICAgICAgPGRpdiBjbGFzcz1cImRvdWJsZS1ib3VuY2UxXCI+PC9kaXY+XFxcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZG91YmxlLWJvdW5jZTJcIj48L2Rpdj5cXFxyXG4gICAgICA8L2Rpdj4nO1xyXG5cclxuLyoqXHJcbiAqIEFwcGVuZCB0byBib2R5IHdoZW4gaXQgZXhpc3RzLlxyXG4gKi9cclxuXHJcbiQoc3Bpbm5lclRwbCkuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XHJcbiQobGlzdFRwbCkuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSk7XHJcblxyXG52YXIgbGlzdCA9ICQoJyNub3RpZmljYXRpb25zJyksXHJcbiAgICBzcGlubmVyRWwgPSAkKCcuc3Bpbm5lcicpLFxyXG4gICAgYWN0aXZlID0gZmFsc2U7XHJcblxyXG4vKipcclxuICogUmV0dXJuIGEgbmV3IGBOb3RpZmljYXRpb25gIHdpdGggdGhlIGdpdmVuXHJcbiAqIChvcHRpb25hbCkgYHRpdGxlYCBhbmQgYG1zZ2AuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0aXRsZSBvciBtc2dcclxuICogQHBhcmFtIHtTdHJpbmd9IG1zZ1xyXG4gKiBAcmV0dXJuIHtEaWFsb2d9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbm90aWZ5KHRpdGxlLCBtc2cpe1xyXG4gIGlmIChhY3RpdmUpIHJldHVybiBmYWxzZTtcclxuICBhY3RpdmUgPSB0cnVlO1xyXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcclxuICAgIGFjdGl2ZSA9IGZhbHNlO1xyXG4gIH0sIDMwMDApO1xyXG4gIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgY2FzZSAyOlxyXG4gICAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbih7IHRpdGxlOiB0aXRsZSwgbWVzc2FnZTogbXNnIH0pXHJcbiAgICAgICAgLmVmZmVjdCgnZmFkZScpXHJcbiAgICAgICAgLnNob3coKVxyXG4gICAgICAgIC5oaWRlKDIwMDApO1xyXG4gICAgY2FzZSAxOlxyXG4gICAgICByZXR1cm4gbmV3IE5vdGlmaWNhdGlvbih7IG1lc3NhZ2U6IHRpdGxlIH0pXHJcbiAgICAgICAgLmVmZmVjdCgnZmFkZScpXHJcbiAgICAgICAgLnNob3coKVxyXG4gICAgICAgIC5oaWRlKDIwMDApO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gc3Bpbm5lcihhY3Rpb24pIHtcclxuICBzd2l0Y2goYWN0aW9uKSB7XHJcbiAgICBjYXNlICdzaG93JzpcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICBzcGlubmVyRWwucmVtb3ZlQ2xhc3MoJ2hpZGUnKS5hZGRDbGFzcygnc2hvdycpO1xyXG4gICAgICB9LCAwKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlICdoaWRlJzpcclxuICAgICAgJCgnLnNwaW5uZXInKS5yZW1vdmVDbGFzcygnc2hvdycpLmFkZENsYXNzKCdoaWRlJyk7XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxufSBcclxuXHJcbi8qKlxyXG4gKiBDb25zdHJ1Y3QgYSBub3RpZmljYXRpb24gZnVuY3Rpb24gZm9yIGB0eXBlYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcclxuICogQHJldHVybiB7RnVuY3Rpb259XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHR5cGUodHlwZSkge1xyXG4gIHJldHVybiBmdW5jdGlvbih0aXRsZSwgbXNnKXtcclxuICAgIHJldHVybiBub3RpZnkuYXBwbHkodGhpcywgYXJndW1lbnRzKVxyXG4gICAgICAudHlwZSh0eXBlKTtcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogTm90aWZpY2F0aW9uIG1ldGhvZHMuXHJcbiAqL1xyXG5cclxuZXhwb3J0cy5zcGlubmVyID0gc3Bpbm5lcjtcclxuZXhwb3J0cy5pbmZvID0gbm90aWZ5O1xyXG5leHBvcnRzLndhcm4gPSB0eXBlKCd3YXJuJyk7XHJcbmV4cG9ydHMuZXJyb3IgPSB0eXBlKCdlcnJvcicpO1xyXG5cclxuLyoqXHJcbiAqIEV4cG9zZSBjb25zdHJ1Y3Rvci5cclxuICovXHJcblxyXG5leHBvcnRzLk5vdGlmaWNhdGlvbiA9IE5vdGlmaWNhdGlvbjtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBOb3RpZmljYXRpb25gLlxyXG4gKlxyXG4gKiBPcHRpb25zOlxyXG4gKlxyXG4gKiAgICAtIGB0aXRsZWAgZGlhbG9nIHRpdGxlXHJcbiAqICAgIC0gYG1lc3NhZ2VgIGEgbWVzc2FnZSB0byBkaXNwbGF5XHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gTm90aWZpY2F0aW9uKG9wdGlvbnMpIHtcclxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICB0aGlzLmVsID0gJzxsaSBjbGFzcz1cIm5vdGlmaWNhdGlvbiBoaWRlXCI+XFxcclxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRlbnRcIj5cXFxyXG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRpdGxlXCI+VGl0bGU8L3NwYW4+XFxcclxuICAgICAgICAgICAgPGEgaHJlZj1cIiNcIiBjbGFzcz1cImNsb3NlXCI+JiMyMTU7PC9hPlxcXHJcbiAgICAgICAgICAgIDxwPk1lc3NhZ2U8L3A+XFxcclxuICAgICAgICAgICAgPC9kaXY+XFxcclxuICAgICAgICAgICAgPC9saT4nO1xyXG4gIHRoaXMuJGVsID0gJCh0aGlzLmVsKVxyXG4gIHRoaXMucmVuZGVyKG9wdGlvbnMpO1xyXG4gIGlmIChvcHRpb25zLmNsYXNzbmFtZSkgdGhpcy4kZWwuYWRkQ2xhc3Mob3B0aW9ucy5jbGFzc25hbWUpO1xyXG4gIGlmIChOb3RpZmljYXRpb24uZWZmZWN0KSB0aGlzLmVmZmVjdChOb3RpZmljYXRpb24uZWZmZWN0KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbmRlciB3aXRoIHRoZSBnaXZlbiBgb3B0aW9uc2AuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuTm90aWZpY2F0aW9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihvcHRpb25zKXtcclxuICB2YXIgZWwgPSB0aGlzLiRlbFxyXG4gICAgLCB0aXRsZSA9IG9wdGlvbnMudGl0bGVcclxuICAgICwgbXNnID0gb3B0aW9ucy5tZXNzYWdlXHJcbiAgICAsIHNlbGYgPSB0aGlzO1xyXG5cclxuICBlbC5maW5kKCcuY2xvc2UnKS5vbignY2xpY2snLCBmdW5jdGlvbigpe1xyXG4gICAgc2VsZi5lbWl0KCdjbG9zZScpO1xyXG4gICAgc2VsZi5oaWRlKCk7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfSk7XHJcblxyXG4gIGVsLm9uKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgc2VsZi5lbWl0KCdjbGljaycsIGUpO1xyXG4gIH0pOyBcclxuXHJcbiAgZWwuZmluZCgnLnRpdGxlJykudGV4dCh0aXRsZSk7XHJcbiAgaWYgKCF0aXRsZSkgZWwuZmluZCgnLnRpdGxlJykucmVtb3ZlKCk7XHJcblxyXG4gIC8vIG1lc3NhZ2VcclxuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG1zZykge1xyXG4gICAgZWwuZmluZCgncCcpLnRleHQobXNnKTtcclxuICB9IGVsc2UgaWYgKG1zZykge1xyXG4gICAgZWwuZmluZCgncCcpLnJlcGxhY2UobXNnLmVsIHx8IG1zZyk7XHJcbiAgfVxyXG5cclxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcbiAgICBlbC5yZW1vdmVDbGFzcygnaGlkZScpO1xyXG4gIH0sIDApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVuYWJsZSB0aGUgZGlhbG9nIGNsb3NlIGxpbmsuXHJcbiAqXHJcbiAqIEByZXR1cm4ge05vdGlmaWNhdGlvbn0gZm9yIGNoYWluaW5nXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuTm90aWZpY2F0aW9uLnByb3RvdHlwZS5jbG9zYWJsZSA9IGZ1bmN0aW9uKCl7XHJcbiAgdGhpcy4kZWwuYWRkQ2xhc3MoJ2Nsb3NhYmxlJyk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IHRoZSBlZmZlY3QgdG8gYHR5cGVgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxyXG4gKiBAcmV0dXJuIHtOb3RpZmljYXRpb259IGZvciBjaGFpbmluZ1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbk5vdGlmaWNhdGlvbi5wcm90b3R5cGUuZWZmZWN0ID0gZnVuY3Rpb24odHlwZSl7XHJcbiAgdGhpcy5fZWZmZWN0ID0gdHlwZTtcclxuICB0aGlzLiRlbC5hZGRDbGFzcyh0eXBlKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTaG93IHRoZSBub3RpZmljYXRpb24uXHJcbiAqXHJcbiAqIEByZXR1cm4ge05vdGlmaWNhdGlvbn0gZm9yIGNoYWluaW5nXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuTm90aWZpY2F0aW9uLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24oKXtcclxuICB0aGlzLiRlbC5hcHBlbmRUbyhsaXN0KTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgdGhlIG5vdGlmaWNhdGlvbiBgdHlwZWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXHJcbiAqIEByZXR1cm4ge05vdGlmaWNhdGlvbn0gZm9yIGNoYWluaW5nXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuTm90aWZpY2F0aW9uLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24odHlwZSl7XHJcbiAgdGhpcy5fdHlwZSA9IHR5cGU7XHJcbiAgdGhpcy4kZWwuYWRkQ2xhc3ModHlwZSk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogTWFrZSBpdCBzdGljayAoY2xlYXIgaGlkZSB0aW1lciksIGFuZCBtYWtlIGl0IGNsb3NhYmxlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtOb3RpZmljYXRpb259IGZvciBjaGFpbmluZ1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbk5vdGlmaWNhdGlvbi5wcm90b3R5cGUuc3RpY2t5ID0gZnVuY3Rpb24oKXtcclxuICByZXR1cm4gdGhpcy5oaWRlKDApLmNsb3NhYmxlKCk7XHJcbn07XHJcblxyXG4vKipcclxuICogSGlkZSB0aGUgZGlhbG9nIHdpdGggb3B0aW9uYWwgZGVsYXkgb2YgYG1zYCxcclxuICogb3RoZXJ3aXNlIHRoZSBub3RpZmljYXRpb24gaXMgcmVtb3ZlZCBpbW1lZGlhdGVseS5cclxuICpcclxuICogQHJldHVybiB7TnVtYmVyfSBtc1xyXG4gKiBAcmV0dXJuIHtOb3RpZmljYXRpb259IGZvciBjaGFpbmluZ1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbk5vdGlmaWNhdGlvbi5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uKG1zKXtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gIC8vIGR1cmF0aW9uXHJcbiAgaWYgKCdudW1iZXInID09IHR5cGVvZiBtcykge1xyXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xyXG4gICAgaWYgKCFtcykgcmV0dXJuIHRoaXM7XHJcbiAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICBzZWxmLmhpZGUoKTtcclxuICAgIH0sIG1zKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gaGlkZSAvIHJlbW92ZVxyXG4gIHRoaXMuJGVsLmFkZENsYXNzKCdoaWRlJyk7XHJcbiAgaWYgKHRoaXMuX2VmZmVjdCkge1xyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbihzZWxmKXtcclxuICAgICAgc2VsZi5yZW1vdmUoKTtcclxuICAgIH0sIDUwMCwgdGhpcyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHNlbGYucmVtb3ZlKCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBIaWRlIHRoZSBub3RpZmljYXRpb24gd2l0aG91dCBwb3RlbnRpYWwgYW5pbWF0aW9uLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtEaWFsb2d9IGZvciBjaGFpbmluZ1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbk5vdGlmaWNhdGlvbi5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKXtcclxuICB0aGlzLiRlbC5yZW1vdmUoKTtcclxuICByZXR1cm4gdGhpcztcclxufTsiLCIvKlxyXG4qXHJcbiogQ29weXJpZ2h0IChjKSAyMDExLTIwMTQtIEp1c3RpbiBEZWFyaW5nICh6aXBweTE5ODFAZ21haWwuY29tKVxyXG4qIER1YWwgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHApXHJcbiogYW5kIEdQTCAoaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9ncGwtbGljZW5zZS5waHApIHZlcnNpb24gMiBsaWNlbnNlcy5cclxuKiBUaGlzIHNvZnR3YXJlIGlzIG5vdCBkaXN0cmlidXRlZCB1bmRlciB2ZXJzaW9uIDMgb3IgbGF0ZXIgb2YgdGhlIEdQTC5cclxuKlxyXG4qIFZlcnNpb24gMS4wLjJcclxuKlxyXG4qL1xyXG5cclxuaWYgKCFkb2N1bWVudCkgdmFyIGRvY3VtZW50ID0geyBjb29raWU6ICcnIH07IC8vIGZpeCBjcmFzaGVzIG9uIG5vZGVcclxuXHJcbi8qKlxyXG4gKiBKYXZhc2NyaXB0IGNsYXNzIHRoYXQgbWltaWNzIGhvdyBXQ0Ygc2VyaWFsaXplcyBhIG9iamVjdCBvZiB0eXBlIE1vbmdvREIuQnNvbi5PYmplY3RJZFxyXG4gKiBhbmQgY29udmVydHMgYmV0d2VlbiB0aGF0IGZvcm1hdCBhbmQgdGhlIHN0YW5kYXJkIDI0IGNoYXJhY3RlciByZXByZXNlbnRhdGlvbi5cclxuKi9cclxudmFyIE9iamVjdElkID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBpbmNyZW1lbnQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoMTY3NzcyMTYpKTtcclxuICAgIHZhciBwaWQgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoNjU1MzYpKTtcclxuICAgIHZhciBtYWNoaW5lID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDE2Nzc3MjE2KSk7XHJcblxyXG4gICAgdmFyIHNldE1hY2hpbmVDb29raWUgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgY29va2llTGlzdCA9IGRvY3VtZW50LmNvb2tpZS5zcGxpdCgnOyAnKTtcclxuICAgICAgICBmb3IgKHZhciBpIGluIGNvb2tpZUxpc3QpIHtcclxuICAgICAgICAgICAgdmFyIGNvb2tpZSA9IGNvb2tpZUxpc3RbaV0uc3BsaXQoJz0nKTtcclxuICAgICAgICAgICAgdmFyIGNvb2tpZU1hY2hpbmVJZCA9IHBhcnNlSW50KGNvb2tpZVsxXSwgMTApO1xyXG4gICAgICAgICAgICBpZiAoY29va2llWzBdID09ICdtb25nb01hY2hpbmVJZCcgJiYgY29va2llTWFjaGluZUlkICYmIGNvb2tpZU1hY2hpbmVJZCA+PSAwICYmIGNvb2tpZU1hY2hpbmVJZCA8PSAxNjc3NzIxNSkge1xyXG4gICAgICAgICAgICAgICAgbWFjaGluZSA9IGNvb2tpZU1hY2hpbmVJZDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LmNvb2tpZSA9ICdtb25nb01hY2hpbmVJZD0nICsgbWFjaGluZSArICc7ZXhwaXJlcz1UdWUsIDE5IEphbiAyMDM4IDA1OjAwOjAwIEdNVDtwYXRoPS8nO1xyXG4gICAgfTtcclxuICAgIGlmICh0eXBlb2YgKGxvY2FsU3RvcmFnZSkgIT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgbW9uZ29NYWNoaW5lSWQgPSBwYXJzZUludChsb2NhbFN0b3JhZ2VbJ21vbmdvTWFjaGluZUlkJ10pO1xyXG4gICAgICAgICAgICBpZiAobW9uZ29NYWNoaW5lSWQgPj0gMCAmJiBtb25nb01hY2hpbmVJZCA8PSAxNjc3NzIxNSkge1xyXG4gICAgICAgICAgICAgICAgbWFjaGluZSA9IE1hdGguZmxvb3IobG9jYWxTdG9yYWdlWydtb25nb01hY2hpbmVJZCddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBKdXN0IGFsd2F5cyBzdGljayB0aGUgdmFsdWUgaW4uXHJcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZVsnbW9uZ29NYWNoaW5lSWQnXSA9IG1hY2hpbmU7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICBzZXRNYWNoaW5lQ29va2llKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgc2V0TWFjaGluZUNvb2tpZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIE9iaklkKCkge1xyXG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBPYmplY3RJZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBPYmplY3RJZChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM10pLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodHlwZW9mIChhcmd1bWVudHNbMF0pID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gYXJndW1lbnRzWzBdLnRpbWVzdGFtcDtcclxuICAgICAgICAgICAgdGhpcy5tYWNoaW5lID0gYXJndW1lbnRzWzBdLm1hY2hpbmU7XHJcbiAgICAgICAgICAgIHRoaXMucGlkID0gYXJndW1lbnRzWzBdLnBpZDtcclxuICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnQgPSBhcmd1bWVudHNbMF0uaW5jcmVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKGFyZ3VtZW50c1swXSkgPT0gJ3N0cmluZycgJiYgYXJndW1lbnRzWzBdLmxlbmd0aCA9PSAyNCkge1xyXG4gICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IE51bWJlcignMHgnICsgYXJndW1lbnRzWzBdLnN1YnN0cigwLCA4KSksXHJcbiAgICAgICAgICAgIHRoaXMubWFjaGluZSA9IE51bWJlcignMHgnICsgYXJndW1lbnRzWzBdLnN1YnN0cig4LCA2KSksXHJcbiAgICAgICAgICAgIHRoaXMucGlkID0gTnVtYmVyKCcweCcgKyBhcmd1bWVudHNbMF0uc3Vic3RyKDE0LCA0KSksXHJcbiAgICAgICAgICAgIHRoaXMuaW5jcmVtZW50ID0gTnVtYmVyKCcweCcgKyBhcmd1bWVudHNbMF0uc3Vic3RyKDE4LCA2KSlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSA0ICYmIGFyZ3VtZW50c1swXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgICAgICB0aGlzLm1hY2hpbmUgPSBhcmd1bWVudHNbMV07XHJcbiAgICAgICAgICAgIHRoaXMucGlkID0gYXJndW1lbnRzWzJdO1xyXG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudCA9IGFyZ3VtZW50c1szXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gTWF0aC5mbG9vcihuZXcgRGF0ZSgpLnZhbHVlT2YoKSAvIDEwMDApO1xyXG4gICAgICAgICAgICB0aGlzLm1hY2hpbmUgPSBtYWNoaW5lO1xyXG4gICAgICAgICAgICB0aGlzLnBpZCA9IHBpZDtcclxuICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnQgPSBpbmNyZW1lbnQrKztcclxuICAgICAgICAgICAgaWYgKGluY3JlbWVudCA+IDB4ZmZmZmZmKSB7XHJcbiAgICAgICAgICAgICAgICBpbmNyZW1lbnQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBPYmpJZDtcclxufSkoKTtcclxuXHJcbk9iamVjdElkLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKHRoaXMudGltZXN0YW1wICogMTAwMCk7XHJcbn07XHJcblxyXG5PYmplY3RJZC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzdHJPaWQgPSB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICB2YXIgYXJyYXkgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgIGFycmF5W2ldID0gcGFyc2VJbnQoc3RyT2lkLnNsaWNlKGkqMiwgaSoyKzIpLCAxNik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG4vKipcclxuKiBUdXJucyBhIFdDRiByZXByZXNlbnRhdGlvbiBvZiBhIEJTT04gT2JqZWN0SWQgaW50byBhIDI0IGNoYXJhY3RlciBzdHJpbmcgcmVwcmVzZW50YXRpb24uXHJcbiovXHJcbk9iamVjdElkLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0aGlzLnRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgfHwgdGhpcy5tYWNoaW5lID09PSB1bmRlZmluZWRcclxuICAgICAgICB8fCB0aGlzLnBpZCA9PT0gdW5kZWZpbmVkXHJcbiAgICAgICAgfHwgdGhpcy5pbmNyZW1lbnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiAnSW52YWxpZCBPYmplY3RJZCc7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHRpbWVzdGFtcCA9IHRoaXMudGltZXN0YW1wLnRvU3RyaW5nKDE2KTtcclxuICAgIHZhciBtYWNoaW5lID0gdGhpcy5tYWNoaW5lLnRvU3RyaW5nKDE2KTtcclxuICAgIHZhciBwaWQgPSB0aGlzLnBpZC50b1N0cmluZygxNik7XHJcbiAgICB2YXIgaW5jcmVtZW50ID0gdGhpcy5pbmNyZW1lbnQudG9TdHJpbmcoMTYpO1xyXG4gICAgcmV0dXJuICcwMDAwMDAwMCcuc3Vic3RyKDAsIDggLSB0aW1lc3RhbXAubGVuZ3RoKSArIHRpbWVzdGFtcCArXHJcbiAgICAgICAgICAgJzAwMDAwMCcuc3Vic3RyKDAsIDYgLSBtYWNoaW5lLmxlbmd0aCkgKyBtYWNoaW5lICtcclxuICAgICAgICAgICAnMDAwMCcuc3Vic3RyKDAsIDQgLSBwaWQubGVuZ3RoKSArIHBpZCArXHJcbiAgICAgICAgICAgJzAwMDAwMCcuc3Vic3RyKDAsIDYgLSBpbmNyZW1lbnQubGVuZ3RoKSArIGluY3JlbWVudDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0SWQ7IiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKTtcclxuXHJcbkJhY2tib25lLkZvcm0uZWRpdG9ycy5QYXJlbnRDaG9vc2VyID0gQmFja2JvbmUuRm9ybS5lZGl0b3JzLkJhc2UuZXh0ZW5kKHtcclxuXHJcbiAgICB0YWdOYW1lOiAnZGl2JyxcclxuXHJcbiAgICBjbGFzc05hbWU6ICdwYXJlbnQnLFxyXG5cclxuICAgIGV2ZW50czoge1xyXG4gICAgICAgICdjbGljayAuY2hvb3NlLXBhcmVudCc6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NsaWNrJywgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX29uQ2xpY2tDaG9vc2UoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICdjbGljayAucm9vdC1wYXJlbnQnOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjbGljaycsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9vbkNsaWNrUm9vdCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2NsaWNrIC5hZGQtY2hpbGQnOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjbGljaycsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9vbkFkZENoaWxkKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAnY2xpY2sgLm1lcmdlJzogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignY2xpY2snLCB0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fb25NZXJnZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2NsaWNrIC5yZW1vdmUnOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjbGljaycsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9vblJlbW92ZSgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgJ2ZvY3VzJzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZm9jdXMnLCB0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICdibHVyJzogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmx1cicsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICAgIEJhY2tib25lLkZvcm0uZWRpdG9ycy5CYXNlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHBhcmVudENob29zZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcclxuICAgICAgICBwYXJlbnRDaG9vc2VyLmNsYXNzTmFtZSA9ICdjaG9vc2UtcGFyZW50IGJ0bic7XHJcbiAgICAgICAgcGFyZW50Q2hvb3Nlci5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ0Nob29zZSBuZXcgcGFyZW50Jyk7XHJcbiAgICAgICAgcGFyZW50Q2hvb3Nlci5pbm5lckhUTUwgPSAnPGkgY2xhc3M9XCJmYSBmYS1iYXJzXCI+PC9pPic7XHJcbiAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZChwYXJlbnRDaG9vc2VyKTtcclxuICAgICAgICBcclxuICAgICAgICB2YXIgcm9vdENob29zZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcclxuICAgICAgICByb290Q2hvb3Nlci5jbGFzc05hbWUgPSAncm9vdC1wYXJlbnQgYnRuJztcclxuICAgICAgICByb290Q2hvb3Nlci5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ1NldCByb290IGxldmVsJyk7XHJcbiAgICAgICAgcm9vdENob29zZXIuaW5uZXJIVE1MID0gJzxpIGNsYXNzPVwiZmEgZmEtbGV2ZWwtdXBcIj48L2k+JztcclxuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKHJvb3RDaG9vc2VyKTtcclxuXHJcbiAgICAgICAgdmFyIGFkZENoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgICAgICAgYWRkQ2hpbGQuY2xhc3NOYW1lID0gJ2FkZC1jaGlsZCBidG4nO1xyXG4gICAgICAgIGFkZENoaWxkLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnQWRkIGNoaWxkIHN1YmplY3QnKTtcclxuICAgICAgICBhZGRDaGlsZC5pbm5lckhUTUwgPSAnPGkgY2xhc3M9XCJmYSBmYS1wbHVzLXNxdWFyZS1vXCI+PC9pPic7XHJcbiAgICAgICAgdGhpcy5lbC5hcHBlbmRDaGlsZChhZGRDaGlsZCk7XHJcblxyXG4gICAgICAgIHZhciBtZXJnZUJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG4gICAgICAgIG1lcmdlQnRuLmNsYXNzTmFtZSA9ICdtZXJnZSBidG4nO1xyXG4gICAgICAgIG1lcmdlQnRuLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnTWVyZ2Ugd2l0aCBhbm90aGVyIHN1YmplY3QnKTtcclxuICAgICAgICBtZXJnZUJ0bi5pbm5lckhUTUwgPSAnPGkgY2xhc3M9XCJmYSBmYS1jb2RlLWZvcmtcIj48L2k+JztcclxuICAgICAgICB0aGlzLmVsLmFwcGVuZENoaWxkKG1lcmdlQnRuKTtcclxuXHJcbiAgICAgICAgdmFyIHJlbW92ZUJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG4gICAgICAgIHJlbW92ZUJ0bi5jbGFzc05hbWUgPSAncmVtb3ZlIGJ0bic7XHJcbiAgICAgICAgcmVtb3ZlQnRuLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnUmVtb3ZlIHN1YmplY3QnKTtcclxuICAgICAgICByZW1vdmVCdG4uaW5uZXJIVE1MID0gJzxpIGNsYXNzPVwiZmEgZmEtdHJhc2gtb1wiPjwvaT4nO1xyXG4gICAgICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQocmVtb3ZlQnRuKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIF9vbkNsaWNrQ2hvb3NlOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdlZGl0JywgdGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9vbkNsaWNrUm9vdDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMubW9kZWwuc2V0KCdwYXJlbnQnLCcnKTtcclxuICAgIH0sXHJcblxyXG4gICAgX29uQWRkQ2hpbGQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2FkZCcsIHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfb25NZXJnZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMudHJpZ2dlcignbWVyZ2UnLCB0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgX29uUmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGNvbmZpcm0gPSB3aW5kb3cuY29uZmlybShcIkFyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBkbyB0aGlzP1xcblRoaXMgYWN0aW9uIGNhbid0IGJlIHVuZG9uZS4gVGhpbmsgdHdpY2UhXCIpO1xyXG4gICAgICBpZihjb25maXJtKSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5kZXN0cm95KCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgZm9jdXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhc0ZvY3VzKSByZXR1cm47XHJcblxyXG4gICAgICAgIHRoaXMuJGVsLmZvY3VzKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGJsdXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5oYXNGb2N1cykgcmV0dXJuO1xyXG5cclxuICAgICAgICB0aGlzLiRlbC5ibHVyKCk7XHJcbiAgICB9XHJcbn0pOyIsInZhciBVdGlsaXR5ID0gcmVxdWlyZSgnLi91dGlsLmpzJyk7XHJcblxyXG52YXIgRG9jdW1lbnQgPSBVdGlsaXR5Lm1vZGVsLmV4dGVuZCh7XHJcbiAgdXJsUm9vdDogXCIvYXBpL2RvY3VtZW50c1wiXHJcbn0pXHJcbmV4cG9ydHMuZG9jdW1lbnQgPSBEb2N1bWVudFxyXG5cclxudmFyIERvY3VtZW50cyA9IFV0aWxpdHkuY29sbGVjdGlvbi5leHRlbmQoe1xyXG4gIG1vZGVsOiBEb2N1bWVudCxcclxuICB1cmw6IFwiL2FwaS9kb2N1bWVudHNcIixcclxuICBzdGF0ZToge1xyXG4gICAgcGFnZVNpemU6IDIwLFxyXG4gICAgc29ydEtleTogXCJjcmVhdGVkX2F0XCIsXHJcbiAgICBvcmRlcjogMVxyXG4gIH1cclxufSlcclxuZXhwb3J0cy5kb2N1bWVudHMgPSBEb2N1bWVudHMiLCJ2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpXHJcbiAgLCBkb2N1bWVudCA9IHJlcXVpcmUoJy4vZG9jdW1lbnQuanMnKVxyXG4gICwgc3ViamVjdCA9IHJlcXVpcmUoJy4vc3ViamVjdC5qcycpXHJcbiAgLCBtZW51ID0gcmVxdWlyZSgnLi9tZW51LmpzJylcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gXy5leHRlbmQoe30sIGRvY3VtZW50LCBzdWJqZWN0LCBtZW51KTsiLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpO1xyXG5cclxudmFyIE1lbnVJdGVtID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHt9KTtcclxuZXhwb3J0cy5tZW51SXRlbSA9IE1lbnVJdGVtXHJcblxyXG52YXIgTWVudUl0ZW1zID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoeyBtb2RlbDogTWVudUl0ZW0gfSk7XHJcbmV4cG9ydHMubWVudUl0ZW1zID0gTWVudUl0ZW1zXHJcblxyXG52YXIgQ29udGV4dEl0ZW0gPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe30pO1xyXG5leHBvcnRzLmNvbnRleHRJdGVtID0gQ29udGV4dEl0ZW1cclxuXHJcbnZhciBDb250ZXh0SXRlbXMgPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7IG1vZGVsOiBDb250ZXh0SXRlbSB9KTtcclxuZXhwb3J0cy5jb250ZXh0SXRlbXMgPSBDb250ZXh0SXRlbXMiLCJ2YXIgVXRpbGl0eSA9IHJlcXVpcmUoJy4vdXRpbC5qcycpLFxyXG4gICAgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xyXG5cclxudmFyIFN1YmplY3QgPSBVdGlsaXR5Lm1vZGVsLmV4dGVuZCh7XHJcbiAgdXJsUm9vdDogXCIvYXBpL3N1YmplY3RzXCIsXHJcbiAgc2NoZW1hOiB7XHJcbiAgICBuYW1lOiB7IHR5cGU6ICdUZXh0JywgdmFsaWRhdG9yczogWydyZXF1aXJlZCddLCB0aXRsZTogJ1RpdGxlJywgZWRpdG9yQXR0cnM6IHthdXRvZm9jdXM6J2F1dG9mb2N1cyd9IH0sXHJcbiAgICBkZXNjcmlwdGlvbjogeyB0eXBlOiAnVGV4dEFyZWEnLCB0aXRsZTogJ0Rlc2NyaXB0aW9uJyB9LFxyXG4gICAgcGFyZW50OiB7IHR5cGU6ICdQYXJlbnRDaG9vc2VyJyB9XHJcbiAgfVxyXG59KVxyXG5leHBvcnRzLnN1YmplY3QgPSBTdWJqZWN0XHJcblxyXG52YXIgU3ViamVjdHMgPSBVdGlsaXR5LmNvbGxlY3Rpb24uZXh0ZW5kKHtcclxuICBtb2RlbDogU3ViamVjdCxcclxuICB1cmw6IFwiL2FwaS9zdWJqZWN0c1wiLFxyXG4gIHN0YXRlOiB7XHJcbiAgICBwYWdlU2l6ZTogbnVsbCxcclxuICAgIHNvcnRLZXk6IFwibmFtZVwiLFxyXG4gICAgb3JkZXI6IC0xLFxyXG4gIH0sXHJcbiAgYnVpbGRJbmRleGVzOiBmdW5jdGlvbigpIHtcclxuICAgIC8vIEJ1aWxkIGEgbWFwIG9mIHBhcmVudHMgcmVmZXJlbmNpbmcgdGhlaXIga2lkc1xyXG4gICAgdGhpcy5wYXJlbnRJbmRleCA9IHt9O1xyXG4gICAgXy5lYWNoKHRoaXMubW9kZWxzLCBmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICB2YXIgcGFyZW50ID0gbW9kZWwuZ2V0KCdwYXJlbnQnKSB8fCBcInJvb3RcIjtcclxuICAgICAgaWYgKCF0aGlzLnBhcmVudEluZGV4W3BhcmVudF0pIHtcclxuICAgICAgICB0aGlzLnBhcmVudEluZGV4W3BhcmVudF0gPSBbIG1vZGVsIF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnRJbmRleFtwYXJlbnRdLnB1c2gobW9kZWwpO1xyXG4gICAgICB9XHJcbiAgICB9LCB0aGlzKTtcclxuICB9LFxyXG4gIGdldENoaWxkcmVuOiBmdW5jdGlvbihub2RlSWQpIHtcclxuICAgIHJldHVybiB0aGlzLnBhcmVudEluZGV4W25vZGVJZF0gfHwgW107XHJcbiAgfSxcclxuICBidWlsZFN1YmplY3RzVHJlZTogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgdGhpcy5idWlsZEluZGV4ZXMoKTtcclxuXHJcbiAgICBmdW5jdGlvbiBnZXRDaGlsZHJlbihwYXJlbnRJZCkge1xyXG4gICAgICB2YXIgcmVzID0gW107XHJcbiAgICAgIHZhciBub2RlcyA9IHNlbGYuZ2V0Q2hpbGRyZW4ocGFyZW50SWQpO1xyXG4gICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzOyAvLyBleGl0IGNvbmRpdGlvblxyXG5cclxuICAgICAgXy5lYWNoKG5vZGVzLCBmdW5jdGlvbihub2RlKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0ge1xyXG4gICAgICAgICAgaWQ6IG5vZGUuaWQsXHJcbiAgICAgICAgICB0ZXh0OiBub2RlLmdldCgnbmFtZScpLFxyXG4gICAgICAgICAgY2hpbGRyZW46IGdldENoaWxkcmVuKG5vZGUuaWQpIC8vIGdldCBjaGlsZHJlbiBmb3Igc3VialxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVzLnB1c2goZW50cnkpO1xyXG4gICAgICB9KTtcclxuICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ2V0Q2hpbGRyZW4oXCJyb290XCIpO1xyXG4gIH0sXHJcbiAgZ2V0Q2hhbmdlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubW9kZWxzLmZpbHRlcihmdW5jdGlvbihtKSB7XHJcbiAgICAgIHJldHVybiAobS5oYXNDaGFuZ2VkKCkgfHwgIW0uZ2V0KCdpZCcpKTtcclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgc2F2ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGNoYW5nZWQgPSB0aGlzLmdldENoYW5nZWQoKTtcclxuICAgIF8uZWFjaChjaGFuZ2VkLCBmdW5jdGlvbihtKSB7XHJcbiAgICAgIG0uc2F2ZSgpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG59KVxyXG5leHBvcnRzLnN1YmplY3RzID0gU3ViamVjdHMiLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpXHJcbiAgLCBQYWdpbmF0b3IgPSByZXF1aXJlKCdiYWNrYm9uZS5wYWdpbmF0b3InKTtcclxuXHJcbnZhciBNb2RlbCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XHJcbiAgXHRpZEF0dHJpYnV0ZTogJ19pZCdcclxufSk7XHJcbmV4cG9ydHMubW9kZWwgPSBNb2RlbDtcclxuXHJcbnZhciBDb2xsZWN0aW9uID0gQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uLmV4dGVuZCh7XHJcbiAgbW9kZTogJ3NlcnZlcicsXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgdGhhdCA9IHRoaXM7XHJcbiAgICBCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb24uX19zdXBlcl9fLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKVxyXG4gIH0sXHJcblx0c3RhdGU6IHtcclxuICBcdHBhZ2VTaXplOiAyMCxcclxuICBcdHNvcnRLZXk6IFwibmFtZVwiLFxyXG4gIFx0b3JkZXI6IC0xLFxyXG5cdH0sXHJcblx0cXVlcnlQYXJhbXM6IHtcclxuXHRcdGN1cnJlbnRQYWdlOiBcInBhZ2VcIixcclxuXHRcdHBhZ2VTaXplOlx0XCJwZXJfcGFnZVwiLFxyXG5cdFx0dG90YWxQYWdlczpcdFwidG90YWxfcGFnZXNcIixcclxuXHRcdHRvdGFsUmVjb3JkczogXCJ0b3RhbF9lbnRyaWVzXCIsXHJcblx0XHRzb3J0S2V5OiBcInNvcnRfYnlcIixcclxuICAgIHF1ZXJ5OiB7fVxyXG5cdH1cclxufSk7XHJcbmV4cG9ydHMuY29sbGVjdGlvbiA9IENvbGxlY3Rpb247IiwiLyoqXHJcbiAqIEJhY2tib25lIEZvcm1zIHYwLjE0LjBcclxuICpcclxuICogQ29weXJpZ2h0IChjKSAyMDE0IENoYXJsZXMgRGF2aXNvbiwgUG93IE1lZGlhIEx0ZFxyXG4gKlxyXG4gKiBMaWNlbnNlIGFuZCBtb3JlIGluZm9ybWF0aW9uIGF0OlxyXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9wb3dtZWRpYS9iYWNrYm9uZS1mb3Jtc1xyXG4gKi9cclxuOyhmdW5jdGlvbihyb290KSB7XHJcblxyXG4gIC8vREVQRU5ERU5DSUVTXHJcbiAgLy9Db21tb25KU1xyXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICB2YXIgXyA9IHJvb3QuXyB8fCByZXF1aXJlKCd1bmRlcnNjb3JlJyksXHJcbiAgICAgICAgQmFja2JvbmUgPSByb290LkJhY2tib25lIHx8IHJlcXVpcmUoJ2JhY2tib25lJyk7XHJcbiAgfVxyXG5cclxuICAvL0Jyb3dzZXJcclxuICBlbHNlIHtcclxuICAgIHZhciBfID0gcm9vdC5fLFxyXG4gICAgICAgIEJhY2tib25lID0gcm9vdC5CYWNrYm9uZTtcclxuICB9XHJcblxyXG5cclxuICAvL1NPVVJDRVxyXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuLy9GT1JNXHJcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbnZhciBGb3JtID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG5cclxuICBldmVudHM6IHtcclxuICAgICdzdWJtaXQnOiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ3N1Ym1pdCcsIGV2ZW50KTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3RvclxyXG4gICAqIFxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5zY2hlbWFdXHJcbiAgICogQHBhcmFtIHtCYWNrYm9uZS5Nb2RlbH0gW29wdGlvbnMubW9kZWxdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmRhdGFdXHJcbiAgICogQHBhcmFtIHtTdHJpbmdbXXxPYmplY3RbXX0gW29wdGlvbnMuZmllbGRzZXRzXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nW119IFtvcHRpb25zLmZpZWxkc11cclxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWRQcmVmaXhdXHJcbiAgICogQHBhcmFtIHtGb3JtLkZpZWxkfSBbb3B0aW9ucy5GaWVsZF1cclxuICAgKiBAcGFyYW0ge0Zvcm0uRmllbGRzZXR9IFtvcHRpb25zLkZpZWxkc2V0XVxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnRlbXBsYXRlXVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbnxTdHJpbmd9IFtvcHRpb25zLnN1Ym1pdEJ1dHRvbl1cclxuICAgKi9cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG4gICAgLy9NZXJnZSBkZWZhdWx0IG9wdGlvbnNcclxuICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgPSBfLmV4dGVuZCh7XHJcbiAgICAgIHN1Ym1pdEJ1dHRvbjogZmFsc2VcclxuICAgIH0sIG9wdGlvbnMpO1xyXG5cclxuICAgIC8vRmluZCB0aGUgc2NoZW1hIHRvIHVzZVxyXG4gICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICAvL1ByZWZlciBzY2hlbWEgZnJvbSBvcHRpb25zXHJcbiAgICAgIGlmIChvcHRpb25zLnNjaGVtYSkgcmV0dXJuIF8ucmVzdWx0KG9wdGlvbnMsICdzY2hlbWEnKTtcclxuXHJcbiAgICAgIC8vVGhlbiBzY2hlbWEgb24gbW9kZWxcclxuICAgICAgdmFyIG1vZGVsID0gb3B0aW9ucy5tb2RlbDtcclxuICAgICAgaWYgKG1vZGVsICYmIG1vZGVsLnNjaGVtYSkgcmV0dXJuIF8ucmVzdWx0KG1vZGVsLCAnc2NoZW1hJyk7XHJcblxyXG4gICAgICAvL1RoZW4gYnVpbHQtaW4gc2NoZW1hXHJcbiAgICAgIGlmIChzZWxmLnNjaGVtYSkgcmV0dXJuIF8ucmVzdWx0KHNlbGYsICdzY2hlbWEnKTtcclxuXHJcbiAgICAgIC8vRmFsbGJhY2sgdG8gZW1wdHkgc2NoZW1hXHJcbiAgICAgIHJldHVybiB7fTtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgLy9TdG9yZSBpbXBvcnRhbnQgZGF0YVxyXG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsICdtb2RlbCcsICdkYXRhJywgJ2lkUHJlZml4JywgJ3RlbXBsYXRlRGF0YScpKTtcclxuXHJcbiAgICAvL092ZXJyaWRlIGRlZmF1bHRzXHJcbiAgICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xyXG4gICAgdGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGUgfHwgdGhpcy50ZW1wbGF0ZSB8fCBjb25zdHJ1Y3Rvci50ZW1wbGF0ZTtcclxuICAgIHRoaXMuRmllbGRzZXQgPSBvcHRpb25zLkZpZWxkc2V0IHx8IHRoaXMuRmllbGRzZXQgfHwgY29uc3RydWN0b3IuRmllbGRzZXQ7XHJcbiAgICB0aGlzLkZpZWxkID0gb3B0aW9ucy5GaWVsZCB8fCB0aGlzLkZpZWxkIHx8IGNvbnN0cnVjdG9yLkZpZWxkO1xyXG4gICAgdGhpcy5OZXN0ZWRGaWVsZCA9IG9wdGlvbnMuTmVzdGVkRmllbGQgfHwgdGhpcy5OZXN0ZWRGaWVsZCB8fCBjb25zdHJ1Y3Rvci5OZXN0ZWRGaWVsZDtcclxuXHJcbiAgICAvL0NoZWNrIHdoaWNoIGZpZWxkcyB3aWxsIGJlIGluY2x1ZGVkIChkZWZhdWx0cyB0byBhbGwpXHJcbiAgICB2YXIgc2VsZWN0ZWRGaWVsZHMgPSB0aGlzLnNlbGVjdGVkRmllbGRzID0gb3B0aW9ucy5maWVsZHMgfHwgXy5rZXlzKHNjaGVtYSk7XHJcblxyXG4gICAgLy9DcmVhdGUgZmllbGRzXHJcbiAgICB2YXIgZmllbGRzID0gdGhpcy5maWVsZHMgPSB7fTtcclxuXHJcbiAgICBfLmVhY2goc2VsZWN0ZWRGaWVsZHMsIGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICB2YXIgZmllbGRTY2hlbWEgPSBzY2hlbWFba2V5XTtcclxuICAgICAgZmllbGRzW2tleV0gPSB0aGlzLmNyZWF0ZUZpZWxkKGtleSwgZmllbGRTY2hlbWEpO1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgLy9DcmVhdGUgZmllbGRzZXRzXHJcbiAgICB2YXIgZmllbGRzZXRTY2hlbWEgPSBvcHRpb25zLmZpZWxkc2V0cyB8fCBfLnJlc3VsdCh0aGlzLCAnZmllbGRzZXRzJykgfHwgXy5yZXN1bHQodGhpcy5tb2RlbCwgJ2ZpZWxkc2V0cycpIHx8IFtzZWxlY3RlZEZpZWxkc10sXHJcbiAgICAgICAgZmllbGRzZXRzID0gdGhpcy5maWVsZHNldHMgPSBbXTtcclxuXHJcbiAgICBfLmVhY2goZmllbGRzZXRTY2hlbWEsIGZ1bmN0aW9uKGl0ZW1TY2hlbWEpIHtcclxuICAgICAgdGhpcy5maWVsZHNldHMucHVzaCh0aGlzLmNyZWF0ZUZpZWxkc2V0KGl0ZW1TY2hlbWEpKTtcclxuICAgIH0sIHRoaXMpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBGaWVsZHNldCBpbnN0YW5jZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmdbXXxPYmplY3RbXX0gc2NoZW1hICAgICAgIEZpZWxkc2V0IHNjaGVtYVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Rm9ybS5GaWVsZHNldH1cclxuICAgKi9cclxuICBjcmVhdGVGaWVsZHNldDogZnVuY3Rpb24oc2NoZW1hKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgc2NoZW1hOiBzY2hlbWEsXHJcbiAgICAgIGZpZWxkczogdGhpcy5maWVsZHMsXHJcbiAgICAgIGxlZ2VuZDogc2NoZW1hLmxlZ2VuZCB8fCBudWxsXHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBuZXcgdGhpcy5GaWVsZHNldChvcHRpb25zKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgRmllbGQgaW5zdGFuY2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcclxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hICAgICAgIEZpZWxkIHNjaGVtYVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Rm9ybS5GaWVsZH1cclxuICAgKi9cclxuICBjcmVhdGVGaWVsZDogZnVuY3Rpb24oa2V5LCBzY2hlbWEpIHtcclxuICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICBmb3JtOiB0aGlzLFxyXG4gICAgICBrZXk6IGtleSxcclxuICAgICAgc2NoZW1hOiBzY2hlbWEsXHJcbiAgICAgIGlkUHJlZml4OiB0aGlzLmlkUHJlZml4XHJcbiAgICB9O1xyXG5cclxuICAgIGlmICh0aGlzLm1vZGVsKSB7XHJcbiAgICAgIG9wdGlvbnMubW9kZWwgPSB0aGlzLm1vZGVsO1xyXG4gICAgfSBlbHNlIGlmICh0aGlzLmRhdGEpIHtcclxuICAgICAgb3B0aW9ucy52YWx1ZSA9IHRoaXMuZGF0YVtrZXldO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3B0aW9ucy52YWx1ZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZpZWxkID0gbmV3IHRoaXMuRmllbGQob3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5saXN0ZW5UbyhmaWVsZC5lZGl0b3IsICdhbGwnLCB0aGlzLmhhbmRsZUVkaXRvckV2ZW50KTtcclxuXHJcbiAgICByZXR1cm4gZmllbGQ7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgZm9yIHdoZW4gYW4gZWRpdG9yIGV2ZW50IGlzIGZpcmVkLlxyXG4gICAqIFJlLXRyaWdnZXJzIGV2ZW50cyBvbiB0aGUgZm9ybSBhcyBrZXk6ZXZlbnQgYW5kIHRyaWdnZXJzIGFkZGl0aW9uYWwgZm9ybS1sZXZlbCBldmVudHNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAqIEBwYXJhbSB7RWRpdG9yfSBlZGl0b3JcclxuICAgKi9cclxuICBoYW5kbGVFZGl0b3JFdmVudDogZnVuY3Rpb24oZXZlbnQsIGVkaXRvcikge1xyXG4gICAgLy9SZS10cmlnZ2VyIGVkaXRvciBldmVudHMgb24gdGhlIGZvcm1cclxuICAgIHZhciBmb3JtRXZlbnQgPSBlZGl0b3Iua2V5Kyc6JytldmVudDtcclxuXHJcbiAgICB0aGlzLnRyaWdnZXIuY2FsbCh0aGlzLCBmb3JtRXZlbnQsIHRoaXMsIGVkaXRvciwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSk7XHJcblxyXG4gICAgLy9UcmlnZ2VyIGFkZGl0aW9uYWwgZXZlbnRzXHJcbiAgICBzd2l0Y2ggKGV2ZW50KSB7XHJcbiAgICAgIGNhc2UgJ2NoYW5nZSc6XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgJ2ZvY3VzJzpcclxuICAgICAgICBpZiAoIXRoaXMuaGFzRm9jdXMpIHRoaXMudHJpZ2dlcignZm9jdXMnLCB0aGlzKTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgJ2JsdXInOlxyXG4gICAgICAgIGlmICh0aGlzLmhhc0ZvY3VzKSB7XHJcbiAgICAgICAgICAvL1RPRE86IElzIHRoZSB0aW1lb3V0IGV0YyBuZWVkZWQ/XHJcbiAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB2YXIgZm9jdXNlZEZpZWxkID0gXy5maW5kKHNlbGYuZmllbGRzLCBmdW5jdGlvbihmaWVsZCkge1xyXG4gICAgICAgICAgICAgIHJldHVybiBmaWVsZC5lZGl0b3IuaGFzRm9jdXM7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFmb2N1c2VkRmllbGQpIHNlbGYudHJpZ2dlcignYmx1cicsIHNlbGYpO1xyXG4gICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHRlbXBsYXRlRGF0YTogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdWJtaXRCdXR0b246IG9wdGlvbnMuc3VibWl0QnV0dG9uXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBmaWVsZHMgPSB0aGlzLmZpZWxkcyxcclxuICAgICAgICAkID0gQmFja2JvbmUuJDtcclxuXHJcbiAgICAvL1JlbmRlciBmb3JtXHJcbiAgICB2YXIgJGZvcm0gPSAkKCQudHJpbSh0aGlzLnRlbXBsYXRlKF8ucmVzdWx0KHRoaXMsICd0ZW1wbGF0ZURhdGEnKSkpKTtcclxuXHJcbiAgICAvL1JlbmRlciBzdGFuZGFsb25lIGVkaXRvcnNcclxuICAgICRmb3JtLmZpbmQoJ1tkYXRhLWVkaXRvcnNdJykuYWRkKCRmb3JtKS5lYWNoKGZ1bmN0aW9uKGksIGVsKSB7XHJcbiAgICAgIHZhciAkY29udGFpbmVyID0gJChlbCksXHJcbiAgICAgICAgICBzZWxlY3Rpb24gPSAkY29udGFpbmVyLmF0dHIoJ2RhdGEtZWRpdG9ycycpO1xyXG5cclxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoc2VsZWN0aW9uKSkgcmV0dXJuO1xyXG5cclxuICAgICAgLy9Xb3JrIG91dCB3aGljaCBmaWVsZHMgdG8gaW5jbHVkZVxyXG4gICAgICB2YXIga2V5cyA9IChzZWxlY3Rpb24gPT0gJyonKVxyXG4gICAgICAgID8gc2VsZi5zZWxlY3RlZEZpZWxkcyB8fCBfLmtleXMoZmllbGRzKVxyXG4gICAgICAgIDogc2VsZWN0aW9uLnNwbGl0KCcsJyk7XHJcblxyXG4gICAgICAvL0FkZCB0aGVtXHJcbiAgICAgIF8uZWFjaChrZXlzLCBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNba2V5XTtcclxuXHJcbiAgICAgICAgJGNvbnRhaW5lci5hcHBlbmQoZmllbGQuZWRpdG9yLnJlbmRlcigpLmVsKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvL1JlbmRlciBzdGFuZGFsb25lIGZpZWxkc1xyXG4gICAgJGZvcm0uZmluZCgnW2RhdGEtZmllbGRzXScpLmFkZCgkZm9ybSkuZWFjaChmdW5jdGlvbihpLCBlbCkge1xyXG4gICAgICB2YXIgJGNvbnRhaW5lciA9ICQoZWwpLFxyXG4gICAgICAgICAgc2VsZWN0aW9uID0gJGNvbnRhaW5lci5hdHRyKCdkYXRhLWZpZWxkcycpO1xyXG5cclxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoc2VsZWN0aW9uKSkgcmV0dXJuO1xyXG5cclxuICAgICAgLy9Xb3JrIG91dCB3aGljaCBmaWVsZHMgdG8gaW5jbHVkZVxyXG4gICAgICB2YXIga2V5cyA9IChzZWxlY3Rpb24gPT0gJyonKVxyXG4gICAgICAgID8gc2VsZi5zZWxlY3RlZEZpZWxkcyB8fCBfLmtleXMoZmllbGRzKVxyXG4gICAgICAgIDogc2VsZWN0aW9uLnNwbGl0KCcsJyk7XHJcblxyXG4gICAgICAvL0FkZCB0aGVtXHJcbiAgICAgIF8uZWFjaChrZXlzLCBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNba2V5XTtcclxuXHJcbiAgICAgICAgJGNvbnRhaW5lci5hcHBlbmQoZmllbGQucmVuZGVyKCkuZWwpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vUmVuZGVyIGZpZWxkc2V0c1xyXG4gICAgJGZvcm0uZmluZCgnW2RhdGEtZmllbGRzZXRzXScpLmFkZCgkZm9ybSkuZWFjaChmdW5jdGlvbihpLCBlbCkge1xyXG4gICAgICB2YXIgJGNvbnRhaW5lciA9ICQoZWwpLFxyXG4gICAgICAgICAgc2VsZWN0aW9uID0gJGNvbnRhaW5lci5hdHRyKCdkYXRhLWZpZWxkc2V0cycpO1xyXG5cclxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoc2VsZWN0aW9uKSkgcmV0dXJuO1xyXG5cclxuICAgICAgXy5lYWNoKHNlbGYuZmllbGRzZXRzLCBmdW5jdGlvbihmaWVsZHNldCkge1xyXG4gICAgICAgICRjb250YWluZXIuYXBwZW5kKGZpZWxkc2V0LnJlbmRlcigpLmVsKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvL1NldCB0aGUgbWFpbiBlbGVtZW50XHJcbiAgICB0aGlzLnNldEVsZW1lbnQoJGZvcm0pO1xyXG4gICAgXHJcbiAgICAvL1NldCBjbGFzc1xyXG4gICAgJGZvcm0uYWRkQ2xhc3ModGhpcy5jbGFzc05hbWUpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFZhbGlkYXRlIHRoZSBkYXRhXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFZhbGlkYXRpb24gZXJyb3JzXHJcbiAgICovXHJcbiAgdmFsaWRhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICBmaWVsZHMgPSB0aGlzLmZpZWxkcyxcclxuICAgICAgICBtb2RlbCA9IHRoaXMubW9kZWwsXHJcbiAgICAgICAgZXJyb3JzID0ge307XHJcblxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgLy9Db2xsZWN0IGVycm9ycyBmcm9tIHNjaGVtYSB2YWxpZGF0aW9uXHJcbiAgICBfLmVhY2goZmllbGRzLCBmdW5jdGlvbihmaWVsZCkge1xyXG4gICAgICB2YXIgZXJyb3IgPSBmaWVsZC52YWxpZGF0ZSgpO1xyXG4gICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICBlcnJvcnNbZmllbGQua2V5XSA9IGVycm9yO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvL0dldCBlcnJvcnMgZnJvbSBkZWZhdWx0IEJhY2tib25lIG1vZGVsIHZhbGlkYXRvclxyXG4gICAgaWYgKCFvcHRpb25zLnNraXBNb2RlbFZhbGlkYXRlICYmIG1vZGVsICYmIG1vZGVsLnZhbGlkYXRlKSB7XHJcbiAgICAgIHZhciBtb2RlbEVycm9ycyA9IG1vZGVsLnZhbGlkYXRlKHRoaXMuZ2V0VmFsdWUoKSk7XHJcblxyXG4gICAgICBpZiAobW9kZWxFcnJvcnMpIHtcclxuICAgICAgICB2YXIgaXNEaWN0aW9uYXJ5ID0gXy5pc09iamVjdChtb2RlbEVycm9ycykgJiYgIV8uaXNBcnJheShtb2RlbEVycm9ycyk7XHJcblxyXG4gICAgICAgIC8vSWYgZXJyb3JzIGFyZSBub3QgaW4gb2JqZWN0IGZvcm0gdGhlbiBqdXN0IHN0b3JlIG9uIHRoZSBlcnJvciBvYmplY3RcclxuICAgICAgICBpZiAoIWlzRGljdGlvbmFyeSkge1xyXG4gICAgICAgICAgZXJyb3JzLl9vdGhlcnMgPSBlcnJvcnMuX290aGVycyB8fCBbXTtcclxuICAgICAgICAgIGVycm9ycy5fb3RoZXJzLnB1c2gobW9kZWxFcnJvcnMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy9NZXJnZSBwcm9ncmFtbWF0aWMgZXJyb3JzIChyZXF1aXJlcyBtb2RlbC52YWxpZGF0ZSgpIHRvIHJldHVybiBhbiBvYmplY3QgZS5nLiB7IGZpZWxkS2V5OiAnZXJyb3InIH0pXHJcbiAgICAgICAgaWYgKGlzRGljdGlvbmFyeSkge1xyXG4gICAgICAgICAgXy5lYWNoKG1vZGVsRXJyb3JzLCBmdW5jdGlvbih2YWwsIGtleSkge1xyXG4gICAgICAgICAgICAvL1NldCBlcnJvciBvbiBmaWVsZCBpZiB0aGVyZSBpc24ndCBvbmUgYWxyZWFkeVxyXG4gICAgICAgICAgICBpZiAoZmllbGRzW2tleV0gJiYgIWVycm9yc1trZXldKSB7XHJcbiAgICAgICAgICAgICAgZmllbGRzW2tleV0uc2V0RXJyb3IodmFsKTtcclxuICAgICAgICAgICAgICBlcnJvcnNba2V5XSA9IHZhbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgLy9PdGhlcndpc2UgYWRkIHRvICdfb3RoZXJzJyBrZXlcclxuICAgICAgICAgICAgICBlcnJvcnMuX290aGVycyA9IGVycm9ycy5fb3RoZXJzIHx8IFtdO1xyXG4gICAgICAgICAgICAgIHZhciB0bXBFcnIgPSB7fTtcclxuICAgICAgICAgICAgICB0bXBFcnJba2V5XSA9IHZhbDtcclxuICAgICAgICAgICAgICBlcnJvcnMuX290aGVycy5wdXNoKHRtcEVycik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBfLmlzRW1wdHkoZXJyb3JzKSA/IG51bGwgOiBlcnJvcnM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBtb2RlbCB3aXRoIGFsbCBsYXRlc3QgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAgT3B0aW9ucyB0byBwYXNzIHRvIE1vZGVsI3NldCAoZS5nLiB7IHNpbGVudDogdHJ1ZSB9KVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSAgVmFsaWRhdGlvbiBlcnJvcnNcclxuICAgKi9cclxuICBjb21taXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIC8vVmFsaWRhdGVcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIHZhciB2YWxpZGF0ZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgc2tpcE1vZGVsVmFsaWRhdGU6ICFvcHRpb25zLnZhbGlkYXRlXHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBlcnJvcnMgPSB0aGlzLnZhbGlkYXRlKHZhbGlkYXRlT3B0aW9ucyk7XHJcbiAgICBpZiAoZXJyb3JzKSByZXR1cm4gZXJyb3JzO1xyXG5cclxuICAgIC8vQ29tbWl0XHJcbiAgICB2YXIgbW9kZWxFcnJvcjtcclxuXHJcbiAgICB2YXIgc2V0T3B0aW9ucyA9IF8uZXh0ZW5kKHtcclxuICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1vZGVsLCBlKSB7XHJcbiAgICAgICAgbW9kZWxFcnJvciA9IGU7XHJcbiAgICAgIH1cclxuICAgIH0sIG9wdGlvbnMpO1xyXG5cclxuICAgIHRoaXMubW9kZWwuc2V0KHRoaXMuZ2V0VmFsdWUoKSwgc2V0T3B0aW9ucyk7XHJcbiAgICBcclxuICAgIGlmIChtb2RlbEVycm9yKSByZXR1cm4gbW9kZWxFcnJvcjtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBHZXQgYWxsIHRoZSBmaWVsZCB2YWx1ZXMgYXMgYW4gb2JqZWN0LlxyXG4gICAqIFVzZSB0aGlzIG1ldGhvZCB3aGVuIHBhc3NpbmcgZGF0YSBpbnN0ZWFkIG9mIG9iamVjdHNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XSAgICBTcGVjaWZpYyBmaWVsZCB2YWx1ZSB0byBnZXRcclxuICAgKi9cclxuICBnZXRWYWx1ZTogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICAvL1JldHVybiBvbmx5IGdpdmVuIGtleSBpZiBzcGVjaWZpZWRcclxuICAgIGlmIChrZXkpIHJldHVybiB0aGlzLmZpZWxkc1trZXldLmdldFZhbHVlKCk7XHJcblxyXG4gICAgLy9PdGhlcndpc2UgcmV0dXJuIGVudGlyZSBmb3JtXHJcbiAgICB2YXIgdmFsdWVzID0ge307XHJcbiAgICBfLmVhY2godGhpcy5maWVsZHMsIGZ1bmN0aW9uKGZpZWxkKSB7XHJcbiAgICAgIHZhbHVlc1tmaWVsZC5rZXldID0gZmllbGQuZ2V0VmFsdWUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGZpZWxkIHZhbHVlcywgcmVmZXJlbmNlZCBieSBrZXlcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30ga2V5ICAgICBOZXcgdmFsdWVzIHRvIHNldCwgb3IgcHJvcGVydHkgdG8gc2V0XHJcbiAgICogQHBhcmFtIHZhbCAgICAgICAgICAgICAgICAgICAgIFZhbHVlIHRvIHNldFxyXG4gICAqL1xyXG4gIHNldFZhbHVlOiBmdW5jdGlvbihwcm9wLCB2YWwpIHtcclxuICAgIHZhciBkYXRhID0ge307XHJcbiAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgIGRhdGFbcHJvcF0gPSB2YWw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkYXRhID0gcHJvcDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIga2V5O1xyXG4gICAgZm9yIChrZXkgaW4gdGhpcy5zY2hlbWEpIHtcclxuICAgICAgaWYgKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5maWVsZHNba2V5XS5zZXRWYWx1ZShkYXRhW2tleV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgZWRpdG9yIGZvciBhIGdpdmVuIGZpZWxkIGtleVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RWRpdG9yfVxyXG4gICAqL1xyXG4gIGdldEVkaXRvcjogZnVuY3Rpb24oa2V5KSB7XHJcbiAgICB2YXIgZmllbGQgPSB0aGlzLmZpZWxkc1trZXldO1xyXG4gICAgaWYgKCFmaWVsZCkgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBub3QgZm91bmQ6ICcra2V5KTtcclxuXHJcbiAgICByZXR1cm4gZmllbGQuZWRpdG9yO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEdpdmVzIHRoZSBmaXJzdCBlZGl0b3IgaW4gdGhlIGZvcm0gZm9jdXNcclxuICAgKi9cclxuICBmb2N1czogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5oYXNGb2N1cykgcmV0dXJuO1xyXG5cclxuICAgIC8vR2V0IHRoZSBmaXJzdCBmaWVsZFxyXG4gICAgdmFyIGZpZWxkc2V0ID0gdGhpcy5maWVsZHNldHNbMF0sXHJcbiAgICAgICAgZmllbGQgPSBmaWVsZHNldC5nZXRGaWVsZEF0KDApO1xyXG5cclxuICAgIGlmICghZmllbGQpIHJldHVybjtcclxuXHJcbiAgICAvL1NldCBmb2N1c1xyXG4gICAgZmllbGQuZWRpdG9yLmZvY3VzKCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBmb2N1cyBmcm9tIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlZGl0b3JcclxuICAgKi9cclxuICBibHVyOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICghdGhpcy5oYXNGb2N1cykgcmV0dXJuO1xyXG5cclxuICAgIHZhciBmb2N1c2VkRmllbGQgPSBfLmZpbmQodGhpcy5maWVsZHMsIGZ1bmN0aW9uKGZpZWxkKSB7XHJcbiAgICAgIHJldHVybiBmaWVsZC5lZGl0b3IuaGFzRm9jdXM7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAoZm9jdXNlZEZpZWxkKSBmb2N1c2VkRmllbGQuZWRpdG9yLmJsdXIoKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBNYW5hZ2VzIHRoZSBoYXNGb2N1cyBwcm9wZXJ0eVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAgICovXHJcbiAgdHJpZ2dlcjogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgIGlmIChldmVudCA9PT0gJ2ZvY3VzJykge1xyXG4gICAgICB0aGlzLmhhc0ZvY3VzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGV2ZW50ID09PSAnYmx1cicpIHtcclxuICAgICAgdGhpcy5oYXNGb2N1cyA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGUgZGVmYXVsdCByZW1vdmUgZnVuY3Rpb24gaW4gb3JkZXIgdG8gcmVtb3ZlIGVtYmVkZGVkIHZpZXdzXHJcbiAgICpcclxuICAgKiBUT0RPOiBJZiBlZGl0b3JzIGFyZSBpbmNsdWRlZCBkaXJlY3RseSB3aXRoIGRhdGEtZWRpdG9ycz1cInhcIiwgdGhleSBuZWVkIHRvIGJlIHJlbW92ZWRcclxuICAgKiBNYXkgYmUgYmVzdCB0byB1c2UgWFZpZXcgdG8gbWFuYWdlIGFkZGluZy9yZW1vdmluZyB2aWV3c1xyXG4gICAqL1xyXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XHJcbiAgICBfLmVhY2godGhpcy5maWVsZHNldHMsIGZ1bmN0aW9uKGZpZWxkc2V0KSB7XHJcbiAgICAgIGZpZWxkc2V0LnJlbW92ZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgXy5lYWNoKHRoaXMuZmllbGRzLCBmdW5jdGlvbihmaWVsZCkge1xyXG4gICAgICBmaWVsZC5yZW1vdmUoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG59LCB7XHJcblxyXG4gIC8vU1RBVElDU1xyXG4gIHRlbXBsYXRlOiBfLnRlbXBsYXRlKCdcXFxyXG4gICAgPGZvcm0+XFxcclxuICAgICA8ZGl2IGRhdGEtZmllbGRzZXRzPjwvZGl2PlxcXHJcbiAgICAgIDwlIGlmIChzdWJtaXRCdXR0b24pIHsgJT5cXFxyXG4gICAgICAgIDxidXR0b24gdHlwZT1cInN1Ym1pdFwiPjwlPSBzdWJtaXRCdXR0b24gJT48L2J1dHRvbj5cXFxyXG4gICAgICA8JSB9ICU+XFxcclxuICAgIDwvZm9ybT5cXFxyXG4gICcsIG51bGwsIHRoaXMudGVtcGxhdGVTZXR0aW5ncyksXHJcblxyXG4gIHRlbXBsYXRlU2V0dGluZ3M6IHtcclxuICAgIGV2YWx1YXRlOiAvPCUoW1xcc1xcU10rPyklPi9nLCBcclxuICAgIGludGVycG9sYXRlOiAvPCU9KFtcXHNcXFNdKz8pJT4vZywgXHJcbiAgICBlc2NhcGU6IC88JS0oW1xcc1xcU10rPyklPi9nXHJcbiAgfSxcclxuXHJcbiAgZWRpdG9yczoge31cclxuXHJcbn0pO1xyXG5cclxuICBcclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vL1ZBTElEQVRPUlNcclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuRm9ybS52YWxpZGF0b3JzID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuICB2YXIgdmFsaWRhdG9ycyA9IHt9O1xyXG5cclxuICB2YWxpZGF0b3JzLmVyck1lc3NhZ2VzID0ge1xyXG4gICAgcmVxdWlyZWQ6ICdSZXF1aXJlZCcsXHJcbiAgICByZWdleHA6ICdJbnZhbGlkJyxcclxuICAgIG51bWJlcjogJ011c3QgYmUgYSBudW1iZXInLFxyXG4gICAgZW1haWw6ICdJbnZhbGlkIGVtYWlsIGFkZHJlc3MnLFxyXG4gICAgdXJsOiAnSW52YWxpZCBVUkwnLFxyXG4gICAgbWF0Y2g6IF8udGVtcGxhdGUoJ011c3QgbWF0Y2ggZmllbGQgXCI8JT0gZmllbGQgJT5cIicsIG51bGwsIEZvcm0udGVtcGxhdGVTZXR0aW5ncylcclxuICB9O1xyXG4gIFxyXG4gIHZhbGlkYXRvcnMucmVxdWlyZWQgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xyXG4gICAgICB0eXBlOiAncmVxdWlyZWQnLFxyXG4gICAgICBtZXNzYWdlOiB0aGlzLmVyck1lc3NhZ2VzLnJlcXVpcmVkXHJcbiAgICB9LCBvcHRpb25zKTtcclxuICAgICBcclxuICAgIHJldHVybiBmdW5jdGlvbiByZXF1aXJlZCh2YWx1ZSkge1xyXG4gICAgICBvcHRpb25zLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgIFxyXG4gICAgICB2YXIgZXJyID0ge1xyXG4gICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZSxcclxuICAgICAgICBtZXNzYWdlOiBfLmlzRnVuY3Rpb24ob3B0aW9ucy5tZXNzYWdlKSA/IG9wdGlvbnMubWVzc2FnZShvcHRpb25zKSA6IG9wdGlvbnMubWVzc2FnZVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IGZhbHNlIHx8IHZhbHVlID09PSAnJykgcmV0dXJuIGVycjtcclxuICAgIH07XHJcbiAgfTtcclxuICBcclxuICB2YWxpZGF0b3JzLnJlZ2V4cCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIGlmICghb3B0aW9ucy5yZWdleHApIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBcInJlZ2V4cFwiIG9wdGlvbiBmb3IgXCJyZWdleHBcIiB2YWxpZGF0b3InKTtcclxuICBcclxuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XHJcbiAgICAgIHR5cGU6ICdyZWdleHAnLFxyXG4gICAgICBtYXRjaDogdHJ1ZSxcclxuICAgICAgbWVzc2FnZTogdGhpcy5lcnJNZXNzYWdlcy5yZWdleHBcclxuICAgIH0sIG9wdGlvbnMpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVnZXhwKHZhbHVlKSB7XHJcbiAgICAgIG9wdGlvbnMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgXHJcbiAgICAgIHZhciBlcnIgPSB7XHJcbiAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlLFxyXG4gICAgICAgIG1lc3NhZ2U6IF8uaXNGdW5jdGlvbihvcHRpb25zLm1lc3NhZ2UpID8gb3B0aW9ucy5tZXNzYWdlKG9wdGlvbnMpIDogb3B0aW9ucy5tZXNzYWdlXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICAvL0Rvbid0IGNoZWNrIGVtcHR5IHZhbHVlcyAoYWRkIGEgJ3JlcXVpcmVkJyB2YWxpZGF0b3IgZm9yIHRoaXMpXHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJykgcmV0dXJuO1xyXG5cclxuICAgICAgLy9DcmVhdGUgUmVnRXhwIGZyb20gc3RyaW5nIGlmIGl0J3MgdmFsaWRcclxuICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygb3B0aW9ucy5yZWdleHApIG9wdGlvbnMucmVnZXhwID0gbmV3IFJlZ0V4cChvcHRpb25zLnJlZ2V4cCwgb3B0aW9ucy5mbGFncyk7XHJcblxyXG4gICAgICBpZiAoKG9wdGlvbnMubWF0Y2gpID8gIW9wdGlvbnMucmVnZXhwLnRlc3QodmFsdWUpIDogb3B0aW9ucy5yZWdleHAudGVzdCh2YWx1ZSkpIHJldHVybiBlcnI7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIHZhbGlkYXRvcnMubnVtYmVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcclxuICAgICAgdHlwZTogJ251bWJlcicsXHJcbiAgICAgIG1lc3NhZ2U6IHRoaXMuZXJyTWVzc2FnZXMubnVtYmVyLFxyXG4gICAgICByZWdleHA6IC9eWzAtOV0qXFwuP1swLTldKj8kL1xyXG4gICAgfSwgb3B0aW9ucyk7XHJcbiAgICBcclxuICAgIHJldHVybiB2YWxpZGF0b3JzLnJlZ2V4cChvcHRpb25zKTtcclxuICB9O1xyXG4gIFxyXG4gIHZhbGlkYXRvcnMuZW1haWwgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xyXG4gICAgICB0eXBlOiAnZW1haWwnLFxyXG4gICAgICBtZXNzYWdlOiB0aGlzLmVyck1lc3NhZ2VzLmVtYWlsLFxyXG4gICAgICByZWdleHA6IC9eW1xcd1xcLV17MSx9KFtcXHdcXC1cXCsuXXsxLDF9W1xcd1xcLV17MSx9KXswLH1bQF1bXFx3XFwtXXsxLH0oWy5dKFtcXHdcXC1dezEsfSkpezEsM30kL1xyXG4gICAgfSwgb3B0aW9ucyk7XHJcbiAgICBcclxuICAgIHJldHVybiB2YWxpZGF0b3JzLnJlZ2V4cChvcHRpb25zKTtcclxuICB9O1xyXG4gIFxyXG4gIHZhbGlkYXRvcnMudXJsID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtcclxuICAgICAgdHlwZTogJ3VybCcsXHJcbiAgICAgIG1lc3NhZ2U6IHRoaXMuZXJyTWVzc2FnZXMudXJsLFxyXG4gICAgICByZWdleHA6IC9eKGh0dHB8aHR0cHMpOlxcL1xcLygoW0EtWjAtOV1bQS1aMC05X1xcLV0qKShcXC5bQS1aMC05XVtBLVowLTlfXFwtXSopKykoOihcXGQrKSk/XFwvPy9pXHJcbiAgICB9LCBvcHRpb25zKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHZhbGlkYXRvcnMucmVnZXhwKG9wdGlvbnMpO1xyXG4gIH07XHJcbiAgXHJcbiAgdmFsaWRhdG9ycy5tYXRjaCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIGlmICghb3B0aW9ucy5maWVsZCkgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIFwiZmllbGRcIiBvcHRpb25zIGZvciBcIm1hdGNoXCIgdmFsaWRhdG9yJyk7XHJcbiAgICBcclxuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XHJcbiAgICAgIHR5cGU6ICdtYXRjaCcsXHJcbiAgICAgIG1lc3NhZ2U6IHRoaXMuZXJyTWVzc2FnZXMubWF0Y2hcclxuICAgIH0sIG9wdGlvbnMpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gbWF0Y2godmFsdWUsIGF0dHJzKSB7XHJcbiAgICAgIG9wdGlvbnMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgXHJcbiAgICAgIHZhciBlcnIgPSB7XHJcbiAgICAgICAgdHlwZTogb3B0aW9ucy50eXBlLFxyXG4gICAgICAgIG1lc3NhZ2U6IF8uaXNGdW5jdGlvbihvcHRpb25zLm1lc3NhZ2UpID8gb3B0aW9ucy5tZXNzYWdlKG9wdGlvbnMpIDogb3B0aW9ucy5tZXNzYWdlXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICAvL0Rvbid0IGNoZWNrIGVtcHR5IHZhbHVlcyAoYWRkIGEgJ3JlcXVpcmVkJyB2YWxpZGF0b3IgZm9yIHRoaXMpXHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJykgcmV0dXJuO1xyXG4gICAgICBcclxuICAgICAgaWYgKHZhbHVlICE9PSBhdHRyc1tvcHRpb25zLmZpZWxkXSkgcmV0dXJuIGVycjtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcblxyXG4gIHJldHVybiB2YWxpZGF0b3JzO1xyXG5cclxufSkoKTtcclxuXHJcblxyXG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbi8vRklFTERTRVRcclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuRm9ybS5GaWVsZHNldCA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIFZhbGlkIGZpZWxkc2V0IHNjaGVtYXM6XHJcbiAgICogICBbJ2ZpZWxkMScsICdmaWVsZDInXVxyXG4gICAqICAgeyBsZWdlbmQ6ICdTb21lIEZpZWxkc2V0JywgZmllbGRzOiBbJ2ZpZWxkMScsICdmaWVsZDInXSB9XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfE9iamVjdFtdfSBvcHRpb25zLnNjaGVtYSAgICAgIEZpZWxkc2V0IHNjaGVtYVxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmZpZWxkcyAgICAgICAgICAgRm9ybSBmaWVsZHNcclxuICAgKi9cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAvL0NyZWF0ZSB0aGUgZnVsbCBmaWVsZHNldCBzY2hlbWEsIG1lcmdpbmcgZGVmYXVsdHMgZXRjLlxyXG4gICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hID0gdGhpcy5jcmVhdGVTY2hlbWEob3B0aW9ucy5zY2hlbWEpO1xyXG5cclxuICAgIC8vU3RvcmUgdGhlIGZpZWxkcyBmb3IgdGhpcyBmaWVsZHNldFxyXG4gICAgdGhpcy5maWVsZHMgPSBfLnBpY2sob3B0aW9ucy5maWVsZHMsIHNjaGVtYS5maWVsZHMpO1xyXG4gICAgXHJcbiAgICAvL092ZXJyaWRlIGRlZmF1bHRzXHJcbiAgICB0aGlzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZSB8fCBzY2hlbWEudGVtcGxhdGUgfHwgdGhpcy50ZW1wbGF0ZSB8fCB0aGlzLmNvbnN0cnVjdG9yLnRlbXBsYXRlO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgdGhlIGZ1bGwgZmllbGRzZXQgc2NoZW1hLCBub3JtYWxpc2luZywgbWVyZ2luZyBkZWZhdWx0cyBldGMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfE9iamVjdFtdfSBzY2hlbWFcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICBjcmVhdGVTY2hlbWE6IGZ1bmN0aW9uKHNjaGVtYSkge1xyXG4gICAgLy9Ob3JtYWxpc2UgdG8gb2JqZWN0XHJcbiAgICBpZiAoXy5pc0FycmF5KHNjaGVtYSkpIHtcclxuICAgICAgc2NoZW1hID0geyBmaWVsZHM6IHNjaGVtYSB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vQWRkIG51bGwgbGVnZW5kIHRvIHByZXZlbnQgdGVtcGxhdGUgZXJyb3JcclxuICAgIHNjaGVtYS5sZWdlbmQgPSBzY2hlbWEubGVnZW5kIHx8IG51bGw7XHJcblxyXG4gICAgcmV0dXJuIHNjaGVtYTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBmaWVsZCBmb3IgYSBnaXZlbiBpbmRleFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtGaWVsZH1cclxuICAgKi9cclxuICBnZXRGaWVsZEF0OiBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgdmFyIGtleSA9IHRoaXMuc2NoZW1hLmZpZWxkc1tpbmRleF07XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuZmllbGRzW2tleV07XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBkYXRhIHRvIHBhc3MgdG8gdGVtcGxhdGVcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge09iamVjdH1cclxuICAgKi9cclxuICB0ZW1wbGF0ZURhdGE6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuc2NoZW1hO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlcnMgdGhlIGZpZWxkc2V0IGFuZCBmaWVsZHNcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0ZpZWxkc2V0fSB0aGlzXHJcbiAgICovXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYSxcclxuICAgICAgICBmaWVsZHMgPSB0aGlzLmZpZWxkcyxcclxuICAgICAgICAkID0gQmFja2JvbmUuJDtcclxuXHJcbiAgICAvL1JlbmRlciBmaWVsZHNldFxyXG4gICAgdmFyICRmaWVsZHNldCA9ICQoJC50cmltKHRoaXMudGVtcGxhdGUoXy5yZXN1bHQodGhpcywgJ3RlbXBsYXRlRGF0YScpKSkpO1xyXG5cclxuICAgIC8vUmVuZGVyIGZpZWxkc1xyXG4gICAgJGZpZWxkc2V0LmZpbmQoJ1tkYXRhLWZpZWxkc10nKS5hZGQoJGZpZWxkc2V0KS5lYWNoKGZ1bmN0aW9uKGksIGVsKSB7XHJcbiAgICAgIHZhciAkY29udGFpbmVyID0gJChlbCksXHJcbiAgICAgICAgICBzZWxlY3Rpb24gPSAkY29udGFpbmVyLmF0dHIoJ2RhdGEtZmllbGRzJyk7XHJcblxyXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChzZWxlY3Rpb24pKSByZXR1cm47XHJcblxyXG4gICAgICBfLmVhY2goZmllbGRzLCBmdW5jdGlvbihmaWVsZCkge1xyXG4gICAgICAgICRjb250YWluZXIuYXBwZW5kKGZpZWxkLnJlbmRlcigpLmVsKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLnNldEVsZW1lbnQoJGZpZWxkc2V0KTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgZW1iZWRkZWQgdmlld3MgdGhlbiBzZWxmXHJcbiAgICovXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgIF8uZWFjaCh0aGlzLmZpZWxkcywgZnVuY3Rpb24oZmllbGQpIHtcclxuICAgICAgZmllbGQucmVtb3ZlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5yZW1vdmUuY2FsbCh0aGlzKTtcclxuICB9XHJcbiAgXHJcbn0sIHtcclxuICAvL1NUQVRJQ1NcclxuXHJcbiAgdGVtcGxhdGU6IF8udGVtcGxhdGUoJ1xcXHJcbiAgICA8ZmllbGRzZXQgZGF0YS1maWVsZHM+XFxcclxuICAgICAgPCUgaWYgKGxlZ2VuZCkgeyAlPlxcXHJcbiAgICAgICAgPGxlZ2VuZD48JT0gbGVnZW5kICU+PC9sZWdlbmQ+XFxcclxuICAgICAgPCUgfSAlPlxcXHJcbiAgICA8L2ZpZWxkc2V0PlxcXHJcbiAgJywgbnVsbCwgRm9ybS50ZW1wbGF0ZVNldHRpbmdzKVxyXG5cclxufSk7XHJcblxyXG5cclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vL0ZJRUxEXHJcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbkZvcm0uRmllbGQgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5rZXlcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5mb3JtXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnNjaGVtYV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5zY2hlbWEudGVtcGxhdGVdXHJcbiAgICogQHBhcmFtIHtCYWNrYm9uZS5Nb2RlbH0gW29wdGlvbnMubW9kZWxdXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnZhbHVlXVxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5pZFByZWZpeF1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy50ZW1wbGF0ZV1cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5lcnJvckNsYXNzTmFtZV1cclxuICAgKi9cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAvL1N0b3JlIGltcG9ydGFudCBkYXRhXHJcbiAgICBfLmV4dGVuZCh0aGlzLCBfLnBpY2sob3B0aW9ucywgJ2Zvcm0nLCAna2V5JywgJ21vZGVsJywgJ3ZhbHVlJywgJ2lkUHJlZml4JykpO1xyXG5cclxuICAgIC8vQ3JlYXRlIHRoZSBmdWxsIGZpZWxkIHNjaGVtYSwgbWVyZ2luZyBkZWZhdWx0cyBldGMuXHJcbiAgICB2YXIgc2NoZW1hID0gdGhpcy5zY2hlbWEgPSB0aGlzLmNyZWF0ZVNjaGVtYShvcHRpb25zLnNjaGVtYSk7XHJcblxyXG4gICAgLy9PdmVycmlkZSBkZWZhdWx0c1xyXG4gICAgdGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGUgfHwgc2NoZW1hLnRlbXBsYXRlIHx8IHRoaXMudGVtcGxhdGUgfHwgdGhpcy5jb25zdHJ1Y3Rvci50ZW1wbGF0ZTtcclxuICAgIHRoaXMuZXJyb3JDbGFzc05hbWUgPSBvcHRpb25zLmVycm9yQ2xhc3NOYW1lIHx8IHRoaXMuZXJyb3JDbGFzc05hbWUgfHwgdGhpcy5jb25zdHJ1Y3Rvci5lcnJvckNsYXNzTmFtZTtcclxuXHJcbiAgICAvL0NyZWF0ZSBlZGl0b3JcclxuICAgIHRoaXMuZWRpdG9yID0gdGhpcy5jcmVhdGVFZGl0b3IoKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIHRoZSBmdWxsIGZpZWxkIHNjaGVtYSwgbWVyZ2luZyBkZWZhdWx0cyBldGMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHNjaGVtYVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGNyZWF0ZVNjaGVtYTogZnVuY3Rpb24oc2NoZW1hKSB7XHJcbiAgICBpZiAoXy5pc1N0cmluZyhzY2hlbWEpKSBzY2hlbWEgPSB7IHR5cGU6IHNjaGVtYSB9O1xyXG5cclxuICAgIC8vU2V0IGRlZmF1bHRzXHJcbiAgICBzY2hlbWEgPSBfLmV4dGVuZCh7XHJcbiAgICAgIHR5cGU6ICdUZXh0JyxcclxuICAgICAgdGl0bGU6IHRoaXMuY3JlYXRlVGl0bGUoKVxyXG4gICAgfSwgc2NoZW1hKTtcclxuXHJcbiAgICAvL0dldCB0aGUgcmVhbCBjb25zdHJ1Y3RvciBmdW5jdGlvbiBpLmUuIGlmIHR5cGUgaXMgYSBzdHJpbmcgc3VjaCBhcyAnVGV4dCdcclxuICAgIHNjaGVtYS50eXBlID0gKF8uaXNTdHJpbmcoc2NoZW1hLnR5cGUpKSA/IEZvcm0uZWRpdG9yc1tzY2hlbWEudHlwZV0gOiBzY2hlbWEudHlwZTtcclxuXHJcbiAgICByZXR1cm4gc2NoZW1hO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgdGhlIGVkaXRvciBzcGVjaWZpZWQgaW4gdGhlIHNjaGVtYTsgZWl0aGVyIGFuIGVkaXRvciBzdHJpbmcgbmFtZSBvclxyXG4gICAqIGEgY29uc3RydWN0b3IgZnVuY3Rpb25cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1ZpZXd9XHJcbiAgICovXHJcbiAgY3JlYXRlRWRpdG9yOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBvcHRpb25zID0gXy5leHRlbmQoXHJcbiAgICAgIF8ucGljayh0aGlzLCAnc2NoZW1hJywgJ2Zvcm0nLCAna2V5JywgJ21vZGVsJywgJ3ZhbHVlJyksXHJcbiAgICAgIHsgaWQ6IHRoaXMuY3JlYXRlRWRpdG9ySWQoKSB9XHJcbiAgICApO1xyXG5cclxuICAgIHZhciBjb25zdHJ1Y3RvckZuID0gdGhpcy5zY2hlbWEudHlwZTtcclxuXHJcbiAgICByZXR1cm4gbmV3IGNvbnN0cnVjdG9yRm4ob3B0aW9ucyk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyB0aGUgSUQgdGhhdCB3aWxsIGJlIGFzc2lnbmVkIHRvIHRoZSBlZGl0b3JcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgKi9cclxuICBjcmVhdGVFZGl0b3JJZDogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgcHJlZml4ID0gdGhpcy5pZFByZWZpeCxcclxuICAgICAgICBpZCA9IHRoaXMua2V5O1xyXG5cclxuICAgIC8vUmVwbGFjZSBwZXJpb2RzIHdpdGggdW5kZXJzY29yZXMgKGUuZy4gZm9yIHdoZW4gdXNpbmcgcGF0aHMpXHJcbiAgICBpZCA9IGlkLnJlcGxhY2UoL1xcLi9nLCAnXycpO1xyXG5cclxuICAgIC8vSWYgYSBzcGVjaWZpYyBJRCBwcmVmaXggaXMgc2V0LCB1c2UgaXRcclxuICAgIGlmIChfLmlzU3RyaW5nKHByZWZpeCkgfHwgXy5pc051bWJlcihwcmVmaXgpKSByZXR1cm4gcHJlZml4ICsgaWQ7XHJcbiAgICBpZiAoXy5pc051bGwocHJlZml4KSkgcmV0dXJuIGlkO1xyXG5cclxuICAgIC8vT3RoZXJ3aXNlLCBpZiB0aGVyZSBpcyBhIG1vZGVsIHVzZSBpdCdzIENJRCB0byBhdm9pZCBjb25mbGljdHMgd2hlbiBtdWx0aXBsZSBmb3JtcyBhcmUgb24gdGhlIHBhZ2VcclxuICAgIGlmICh0aGlzLm1vZGVsKSByZXR1cm4gdGhpcy5tb2RlbC5jaWQgKyAnXycgKyBpZDtcclxuXHJcbiAgICByZXR1cm4gaWQ7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSBkZWZhdWx0IGZpZWxkIHRpdGxlIChsYWJlbCB0ZXh0KSBmcm9tIHRoZSBrZXkgbmFtZS5cclxuICAgKiAoQ29udmVydHMgJ2NhbWVsQ2FzZScgdG8gJ0NhbWVsIENhc2UnKVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7U3RyaW5nfVxyXG4gICAqL1xyXG4gIGNyZWF0ZVRpdGxlOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzdHIgPSB0aGlzLmtleTtcclxuXHJcbiAgICAvL0FkZCBzcGFjZXNcclxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csICcgJDEnKTtcclxuXHJcbiAgICAvL1VwcGVyY2FzZSBmaXJzdCBjaGFyYWN0ZXJcclxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC9eLi8sIGZ1bmN0aW9uKHN0cikgeyByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7IH0pO1xyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgZGF0YSB0byBiZSBwYXNzZWQgdG8gdGhlIHRlbXBsYXRlXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICovXHJcbiAgdGVtcGxhdGVEYXRhOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBoZWxwOiBzY2hlbWEuaGVscCB8fCAnJyxcclxuICAgICAgdGl0bGU6IHNjaGVtYS50aXRsZSxcclxuICAgICAgdGl0bGVIVE1MOiBzY2hlbWEudGl0bGVIVE1MLFxyXG4gICAgICBmaWVsZEF0dHJzOiBzY2hlbWEuZmllbGRBdHRycyxcclxuICAgICAgZWRpdG9yQXR0cnM6IHNjaGVtYS5lZGl0b3JBdHRycyxcclxuICAgICAga2V5OiB0aGlzLmtleSxcclxuICAgICAgZWRpdG9ySWQ6IHRoaXMuZWRpdG9yLmlkXHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlciB0aGUgZmllbGQgYW5kIGVkaXRvclxyXG4gICAqXHJcbiAgICogQHJldHVybiB7RmllbGR9IHNlbGZcclxuICAgKi9cclxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hLFxyXG4gICAgICAgIGVkaXRvciA9IHRoaXMuZWRpdG9yLFxyXG4gICAgICAgICQgPSBCYWNrYm9uZS4kO1xyXG5cclxuICAgIC8vT25seSByZW5kZXIgdGhlIGVkaXRvciBpZiByZXF1ZXN0ZWRcclxuICAgIGlmICh0aGlzLmVkaXRvci5ub0ZpZWxkID09PSB0cnVlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNldEVsZW1lbnQoZWRpdG9yLnJlbmRlcigpLmVsKTtcclxuICAgIH1cclxuXHJcbiAgICAvL1JlbmRlciBmaWVsZFxyXG4gICAgdmFyICRmaWVsZCA9ICQoJC50cmltKHRoaXMudGVtcGxhdGUoXy5yZXN1bHQodGhpcywgJ3RlbXBsYXRlRGF0YScpKSkpO1xyXG5cclxuICAgIGlmIChzY2hlbWEuZmllbGRDbGFzcykgJGZpZWxkLmFkZENsYXNzKHNjaGVtYS5maWVsZENsYXNzKTtcclxuICAgIGlmIChzY2hlbWEuZmllbGRBdHRycykgJGZpZWxkLmF0dHIoc2NoZW1hLmZpZWxkQXR0cnMpO1xyXG5cclxuICAgIC8vUmVuZGVyIGVkaXRvclxyXG4gICAgJGZpZWxkLmZpbmQoJ1tkYXRhLWVkaXRvcl0nKS5hZGQoJGZpZWxkKS5lYWNoKGZ1bmN0aW9uKGksIGVsKSB7XHJcbiAgICAgIHZhciAkY29udGFpbmVyID0gJChlbCksXHJcbiAgICAgICAgICBzZWxlY3Rpb24gPSAkY29udGFpbmVyLmF0dHIoJ2RhdGEtZWRpdG9yJyk7XHJcblxyXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChzZWxlY3Rpb24pKSByZXR1cm47XHJcblxyXG4gICAgICAkY29udGFpbmVyLmFwcGVuZChlZGl0b3IucmVuZGVyKCkuZWwpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5zZXRFbGVtZW50KCRmaWVsZCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogRGlzYWJsZSB0aGUgZmllbGQncyBlZGl0b3JcclxuICAgKiBXaWxsIGNhbGwgdGhlIGVkaXRvcidzIGRpc2FibGUgbWV0aG9kIGlmIGl0IGV4aXN0c1xyXG4gICAqIE90aGVyd2lzZSB3aWxsIGFkZCB0aGUgZGlzYWJsZWQgYXR0cmlidXRlIHRvIGFsbCBpbnB1dHMgaW4gdGhlIGVkaXRvclxyXG4gICAqL1xyXG4gIGRpc2FibGU6IGZ1bmN0aW9uKCl7XHJcbiAgICBpZiAoIF8uaXNGdW5jdGlvbih0aGlzLmVkaXRvci5kaXNhYmxlKSApe1xyXG4gICAgICB0aGlzLmVkaXRvci5kaXNhYmxlKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgJGlucHV0ID0gdGhpcy5lZGl0b3IuJGVsO1xyXG4gICAgICAkaW5wdXQgPSAkaW5wdXQuaXMoXCJpbnB1dFwiKSA/ICRpbnB1dCA6ICRpbnB1dC5maW5kKFwiaW5wdXRcIik7XHJcbiAgICAgICRpbnB1dC5hdHRyKFwiZGlzYWJsZWRcIix0cnVlKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBFbmFibGUgdGhlIGZpZWxkJ3MgZWRpdG9yXHJcbiAgICogV2lsbCBjYWxsIHRoZSBlZGl0b3IncyBkaXNhYmxlIG1ldGhvZCBpZiBpdCBleGlzdHNcclxuICAgKiBPdGhlcndpc2Ugd2lsbCByZW1vdmUgdGhlIGRpc2FibGVkIGF0dHJpYnV0ZSB0byBhbGwgaW5wdXRzIGluIHRoZSBlZGl0b3JcclxuICAgKi9cclxuICBlbmFibGU6IGZ1bmN0aW9uKCl7XHJcbiAgICBpZiAoIF8uaXNGdW5jdGlvbih0aGlzLmVkaXRvci5lbmFibGUpICl7XHJcbiAgICAgIHRoaXMuZWRpdG9yLmVuYWJsZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICRpbnB1dCA9IHRoaXMuZWRpdG9yLiRlbDtcclxuICAgICAgJGlucHV0ID0gJGlucHV0LmlzKFwiaW5wdXRcIikgPyAkaW5wdXQgOiAkaW5wdXQuZmluZChcImlucHV0XCIpO1xyXG4gICAgICAkaW5wdXQuYXR0cihcImRpc2FibGVkXCIsZmFsc2UpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIHRoZSB2YWxpZGl0eSBvZiB0aGUgZmllbGRcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgKi9cclxuICB2YWxpZGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZXJyb3IgPSB0aGlzLmVkaXRvci52YWxpZGF0ZSgpO1xyXG5cclxuICAgIGlmIChlcnJvcikge1xyXG4gICAgICB0aGlzLnNldEVycm9yKGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5jbGVhckVycm9yKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVycm9yO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgZmllbGQgaW50byBhbiBlcnJvciBzdGF0ZSwgYWRkaW5nIHRoZSBlcnJvciBjbGFzcyBhbmQgc2V0dGluZyB0aGUgZXJyb3IgbWVzc2FnZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1zZyAgICAgRXJyb3IgbWVzc2FnZVxyXG4gICAqL1xyXG4gIHNldEVycm9yOiBmdW5jdGlvbihtc2cpIHtcclxuICAgIC8vTmVzdGVkIGZvcm0gZWRpdG9ycyAoZS5nLiBPYmplY3QpIHNldCB0aGVpciBlcnJvcnMgaW50ZXJuYWxseVxyXG4gICAgaWYgKHRoaXMuZWRpdG9yLmhhc05lc3RlZEZvcm0pIHJldHVybjtcclxuXHJcbiAgICAvL0FkZCBlcnJvciBDU1MgY2xhc3NcclxuICAgIHRoaXMuJGVsLmFkZENsYXNzKHRoaXMuZXJyb3JDbGFzc05hbWUpO1xyXG5cclxuICAgIC8vU2V0IGVycm9yIG1lc3NhZ2VcclxuICAgIHRoaXMuJCgnW2RhdGEtZXJyb3JdJykuaHRtbChtc2cpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFyIHRoZSBlcnJvciBzdGF0ZSBhbmQgcmVzZXQgdGhlIGhlbHAgbWVzc2FnZVxyXG4gICAqL1xyXG4gIGNsZWFyRXJyb3I6IGZ1bmN0aW9uKCkge1xyXG4gICAgLy9SZW1vdmUgZXJyb3IgQ1NTIGNsYXNzXHJcbiAgICB0aGlzLiRlbC5yZW1vdmVDbGFzcyh0aGlzLmVycm9yQ2xhc3NOYW1lKTtcclxuXHJcbiAgICAvL0NsZWFyIGVycm9yIG1lc3NhZ2VcclxuICAgIHRoaXMuJCgnW2RhdGEtZXJyb3JdJykuZW1wdHkoKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIG1vZGVsIHdpdGggdGhlIG5ldyB2YWx1ZSBmcm9tIHRoZSBlZGl0b3JcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge01peGVkfVxyXG4gICAqL1xyXG4gIGNvbW1pdDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5lZGl0b3IuY29tbWl0KCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBlZGl0b3JcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge01peGVkfVxyXG4gICAqL1xyXG4gIGdldFZhbHVlOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLmVkaXRvci5nZXRWYWx1ZSgpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldC9jaGFuZ2UgdGhlIHZhbHVlIG9mIHRoZSBlZGl0b3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXHJcbiAgICovXHJcbiAgc2V0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICB0aGlzLmVkaXRvci5zZXRWYWx1ZSh2YWx1ZSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogR2l2ZSB0aGUgZWRpdG9yIGZvY3VzXHJcbiAgICovXHJcbiAgZm9jdXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5lZGl0b3IuZm9jdXMoKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgZm9jdXMgZnJvbSB0aGUgZWRpdG9yXHJcbiAgICovXHJcbiAgYmx1cjogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmVkaXRvci5ibHVyKCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIHRoZSBmaWVsZCBhbmQgZWRpdG9yIHZpZXdzXHJcbiAgICovXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZWRpdG9yLnJlbW92ZSgpO1xyXG5cclxuICAgIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMpO1xyXG4gIH1cclxuXHJcbn0sIHtcclxuICAvL1NUQVRJQ1NcclxuXHJcbiAgdGVtcGxhdGU6IF8udGVtcGxhdGUoJ1xcXHJcbiAgICA8ZGl2PlxcXHJcbiAgICAgIDxsYWJlbCBmb3I9XCI8JT0gZWRpdG9ySWQgJT5cIj5cXFxyXG4gICAgICAgIDwlIGlmICh0aXRsZUhUTUwpeyAlPjwlPSB0aXRsZUhUTUwgJT5cXFxyXG4gICAgICAgIDwlIH0gZWxzZSB7ICU+PCUtIHRpdGxlICU+PCUgfSAlPlxcXHJcbiAgICAgIDwvbGFiZWw+XFxcclxuICAgICAgPGRpdj5cXFxyXG4gICAgICAgIDxzcGFuIGRhdGEtZWRpdG9yPjwvc3Bhbj5cXFxyXG4gICAgICAgIDxkaXYgZGF0YS1lcnJvcj48L2Rpdj5cXFxyXG4gICAgICAgIDxkaXY+PCU9IGhlbHAgJT48L2Rpdj5cXFxyXG4gICAgICA8L2Rpdj5cXFxyXG4gICAgPC9kaXY+XFxcclxuICAnLCBudWxsLCBGb3JtLnRlbXBsYXRlU2V0dGluZ3MpLFxyXG5cclxuICAvKipcclxuICAgKiBDU1MgY2xhc3MgbmFtZSBhZGRlZCB0byB0aGUgZmllbGQgd2hlbiB0aGVyZSBpcyBhIHZhbGlkYXRpb24gZXJyb3JcclxuICAgKi9cclxuICBlcnJvckNsYXNzTmFtZTogJ2Vycm9yJ1xyXG5cclxufSk7XHJcblxyXG5cclxuLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4vL05FU1RFREZJRUxEXHJcbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbkZvcm0uTmVzdGVkRmllbGQgPSBGb3JtLkZpZWxkLmV4dGVuZCh7XHJcblxyXG4gIHRlbXBsYXRlOiBfLnRlbXBsYXRlKCdcXFxyXG4gICAgPGRpdj5cXFxyXG4gICAgICA8bGFiZWwgZm9yPVwiPCU9IGVkaXRvcklkICU+XCI+XFxcclxuICAgICAgICA8JSBpZiAodGl0bGVIVE1MKXsgJT48JT0gdGl0bGVIVE1MICU+XFxcclxuICAgICAgICA8JSB9IGVsc2UgeyAlPjwlLSB0aXRsZSAlPjwlIH0gJT5cXFxyXG4gICAgICA8L2xhYmVsPlxcXHJcbiAgICAgIDxkaXY+XFxcclxuICAgICAgICA8c3BhbiBkYXRhLWVkaXRvcj48L3NwYW4+XFxcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXJyb3ItdGV4dFwiIGRhdGEtZXJyb3I+PC9kaXY+XFxcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZXJyb3ItaGVscFwiPjwlPSBoZWxwICU+PC9kaXY+XFxcclxuICAgICAgPC9kaXY+XFxcclxuICAgIDwvZGl2PlxcXHJcbiAgJywgbnVsbCwgRm9ybS50ZW1wbGF0ZVNldHRpbmdzKVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICogQmFzZSBlZGl0b3IgKGludGVyZmFjZSkuIFRvIGJlIGV4dGVuZGVkLCBub3QgdXNlZCBkaXJlY3RseVxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuaWRdICAgICAgICAgRWRpdG9yIElEXHJcbiAqIEBwYXJhbSB7TW9kZWx9IFtvcHRpb25zLm1vZGVsXSAgICAgICBVc2UgaW5zdGVhZCBvZiB2YWx1ZSwgYW5kIHVzZSBjb21taXQoKVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMua2V5XSAgICAgICAgVGhlIG1vZGVsIGF0dHJpYnV0ZSBrZXkuIFJlcXVpcmVkIHdoZW4gdXNpbmcgJ21vZGVsJ1xyXG4gKiBAcGFyYW0ge01peGVkfSBbb3B0aW9ucy52YWx1ZV0gICAgICAgV2hlbiBub3QgdXNpbmcgYSBtb2RlbC4gSWYgbmVpdGhlciBwcm92aWRlZCwgZGVmYXVsdFZhbHVlIHdpbGwgYmUgdXNlZFxyXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuc2NoZW1hXSAgICAgRmllbGQgc2NoZW1hOyBtYXkgYmUgcmVxdWlyZWQgYnkgc29tZSBlZGl0b3JzXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy52YWxpZGF0b3JzXSBWYWxpZGF0b3JzOyBmYWxscyBiYWNrIHRvIHRob3NlIHN0b3JlZCBvbiBzY2hlbWFcclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmZvcm1dICAgICAgIFRoZSBmb3JtXHJcbiAqL1xyXG5Gb3JtLkVkaXRvciA9IEZvcm0uZWRpdG9ycy5CYXNlID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG5cclxuICBkZWZhdWx0VmFsdWU6IG51bGwsXHJcblxyXG4gIGhhc0ZvY3VzOiBmYWxzZSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgdmFyIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIC8vU2V0IGluaXRpYWwgdmFsdWVcclxuICAgIGlmIChvcHRpb25zLm1vZGVsKSB7XHJcbiAgICAgIGlmICghb3B0aW9ucy5rZXkpIHRocm93IG5ldyBFcnJvcihcIk1pc3Npbmcgb3B0aW9uOiAna2V5J1wiKTtcclxuXHJcbiAgICAgIHRoaXMubW9kZWwgPSBvcHRpb25zLm1vZGVsO1xyXG5cclxuICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubW9kZWwuZ2V0KG9wdGlvbnMua2V5KTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG9wdGlvbnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkKSB0aGlzLnZhbHVlID0gdGhpcy5kZWZhdWx0VmFsdWU7XHJcblxyXG4gICAgLy9TdG9yZSBpbXBvcnRhbnQgZGF0YVxyXG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsICdrZXknLCAnZm9ybScpKTtcclxuXHJcbiAgICB2YXIgc2NoZW1hID0gdGhpcy5zY2hlbWEgPSBvcHRpb25zLnNjaGVtYSB8fCB7fTtcclxuXHJcbiAgICB0aGlzLnZhbGlkYXRvcnMgPSBvcHRpb25zLnZhbGlkYXRvcnMgfHwgc2NoZW1hLnZhbGlkYXRvcnM7XHJcblxyXG4gICAgLy9NYWluIGF0dHJpYnV0ZXNcclxuICAgIHRoaXMuJGVsLmF0dHIoJ2lkJywgdGhpcy5pZCk7XHJcbiAgICB0aGlzLiRlbC5hdHRyKCduYW1lJywgdGhpcy5nZXROYW1lKCkpO1xyXG4gICAgaWYgKHNjaGVtYS5lZGl0b3JDbGFzcykgdGhpcy4kZWwuYWRkQ2xhc3Moc2NoZW1hLmVkaXRvckNsYXNzKTtcclxuICAgIGlmIChzY2hlbWEuZWRpdG9yQXR0cnMpIHRoaXMuJGVsLmF0dHIoc2NoZW1hLmVkaXRvckF0dHJzKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIHZhbHVlIGZvciB0aGUgZm9ybSBpbnB1dCAnbmFtZScgYXR0cmlidXRlXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICpcclxuICAgKiBAYXBpIHByaXZhdGVcclxuICAgKi9cclxuICBnZXROYW1lOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBrZXkgPSB0aGlzLmtleSB8fCAnJztcclxuXHJcbiAgICAvL1JlcGxhY2UgcGVyaW9kcyB3aXRoIHVuZGVyc2NvcmVzIChlLmcuIGZvciB3aGVuIHVzaW5nIHBhdGhzKVxyXG4gICAgcmV0dXJuIGtleS5yZXBsYWNlKC9cXC4vZywgJ18nKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBHZXQgZWRpdG9yIHZhbHVlXHJcbiAgICogRXh0ZW5kIGFuZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZWZsZWN0IGNoYW5nZXMgaW4gdGhlIERPTVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7TWl4ZWR9XHJcbiAgICovXHJcbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGVkaXRvciB2YWx1ZVxyXG4gICAqIEV4dGVuZCBhbmQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmVmbGVjdCBjaGFuZ2VzIGluIHRoZSBET01cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXHJcbiAgICovXHJcbiAgc2V0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogR2l2ZSB0aGUgZWRpdG9yIGZvY3VzXHJcbiAgICogRXh0ZW5kIGFuZCBvdmVycmlkZSB0aGlzIG1ldGhvZFxyXG4gICAqL1xyXG4gIGZvY3VzOiBmdW5jdGlvbigpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XHJcbiAgfSxcclxuICBcclxuICAvKipcclxuICAgKiBSZW1vdmUgZm9jdXMgZnJvbSB0aGUgZWRpdG9yXHJcbiAgICogRXh0ZW5kIGFuZCBvdmVycmlkZSB0aGlzIG1ldGhvZFxyXG4gICAqL1xyXG4gIGJsdXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIG1vZGVsIHdpdGggdGhlIGN1cnJlbnQgdmFsdWVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gICAgICAgICAgICAgIE9wdGlvbnMgdG8gcGFzcyB0byBtb2RlbC5zZXQoKVxyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMudmFsaWRhdGVdICAgIFNldCB0byB0cnVlIHRvIHRyaWdnZXIgYnVpbHQtaW4gbW9kZWwgdmFsaWRhdGlvblxyXG4gICAqXHJcbiAgICogQHJldHVybiB7TWl4ZWR9IGVycm9yXHJcbiAgICovXHJcbiAgY29tbWl0OiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlKCk7XHJcbiAgICBpZiAoZXJyb3IpIHJldHVybiBlcnJvcjtcclxuXHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsICdpbnZhbGlkJywgZnVuY3Rpb24obW9kZWwsIGUpIHtcclxuICAgICAgZXJyb3IgPSBlO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLm1vZGVsLnNldCh0aGlzLmtleSwgdGhpcy5nZXRWYWx1ZSgpLCBvcHRpb25zKTtcclxuXHJcbiAgICBpZiAoZXJyb3IpIHJldHVybiBlcnJvcjtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBDaGVjayB2YWxpZGl0eVxyXG4gICAqXHJcbiAgICogQHJldHVybiB7T2JqZWN0fFVuZGVmaW5lZH1cclxuICAgKi9cclxuICB2YWxpZGF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgJGVsID0gdGhpcy4kZWwsXHJcbiAgICAgICAgZXJyb3IgPSBudWxsLFxyXG4gICAgICAgIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpLFxyXG4gICAgICAgIGZvcm1WYWx1ZXMgPSB0aGlzLmZvcm0gPyB0aGlzLmZvcm0uZ2V0VmFsdWUoKSA6IHt9LFxyXG4gICAgICAgIHZhbGlkYXRvcnMgPSB0aGlzLnZhbGlkYXRvcnMsXHJcbiAgICAgICAgZ2V0VmFsaWRhdG9yID0gdGhpcy5nZXRWYWxpZGF0b3I7XHJcblxyXG4gICAgaWYgKHZhbGlkYXRvcnMpIHtcclxuICAgICAgLy9SdW4gdGhyb3VnaCB2YWxpZGF0b3JzIHVudGlsIGFuIGVycm9yIGlzIGZvdW5kXHJcbiAgICAgIF8uZXZlcnkodmFsaWRhdG9ycywgZnVuY3Rpb24odmFsaWRhdG9yKSB7XHJcbiAgICAgICAgZXJyb3IgPSBnZXRWYWxpZGF0b3IodmFsaWRhdG9yKSh2YWx1ZSwgZm9ybVZhbHVlcyk7XHJcblxyXG4gICAgICAgIHJldHVybiBlcnJvciA/IGZhbHNlIDogdHJ1ZTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVycm9yO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGlzLmhhc0ZvY3VzLCBvciBjYWxsIHBhcmVudCB0cmlnZ2VyKClcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gICAqL1xyXG4gIHRyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICBpZiAoZXZlbnQgPT09ICdmb2N1cycpIHtcclxuICAgICAgdGhpcy5oYXNGb2N1cyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChldmVudCA9PT0gJ2JsdXInKSB7XHJcbiAgICAgIHRoaXMuaGFzRm9jdXMgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gQmFja2JvbmUuVmlldy5wcm90b3R5cGUudHJpZ2dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGJhc2VkIG9uIHRoZSB0eXBlIGRlZmluZWQgaW4gdGhlIHNjaGVtYVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWdFeHB8U3RyaW5nfEZ1bmN0aW9ufSB2YWxpZGF0b3JcclxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn1cclxuICAgKi9cclxuICBnZXRWYWxpZGF0b3I6IGZ1bmN0aW9uKHZhbGlkYXRvcikge1xyXG4gICAgdmFyIHZhbGlkYXRvcnMgPSBGb3JtLnZhbGlkYXRvcnM7XHJcblxyXG4gICAgLy9Db252ZXJ0IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdG8gdmFsaWRhdG9yc1xyXG4gICAgaWYgKF8uaXNSZWdFeHAodmFsaWRhdG9yKSkge1xyXG4gICAgICByZXR1cm4gdmFsaWRhdG9ycy5yZWdleHAoeyByZWdleHA6IHZhbGlkYXRvciB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy9Vc2UgYSBidWlsdC1pbiB2YWxpZGF0b3IgaWYgZ2l2ZW4gYSBzdHJpbmdcclxuICAgIGlmIChfLmlzU3RyaW5nKHZhbGlkYXRvcikpIHtcclxuICAgICAgaWYgKCF2YWxpZGF0b3JzW3ZhbGlkYXRvcl0pIHRocm93IG5ldyBFcnJvcignVmFsaWRhdG9yIFwiJyt2YWxpZGF0b3IrJ1wiIG5vdCBmb3VuZCcpO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHZhbGlkYXRvcnNbdmFsaWRhdG9yXSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vRnVuY3Rpb25zIGNhbiBiZSB1c2VkIGRpcmVjdGx5XHJcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbGlkYXRvcikpIHJldHVybiB2YWxpZGF0b3I7XHJcblxyXG4gICAgLy9Vc2UgYSBjdXN0b21pc2VkIGJ1aWx0LWluIHZhbGlkYXRvciBpZiBnaXZlbiBhbiBvYmplY3RcclxuICAgIGlmIChfLmlzT2JqZWN0KHZhbGlkYXRvcikgJiYgdmFsaWRhdG9yLnR5cGUpIHtcclxuICAgICAgdmFyIGNvbmZpZyA9IHZhbGlkYXRvcjtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB2YWxpZGF0b3JzW2NvbmZpZy50eXBlXShjb25maWcpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvL1Vua293biB2YWxpZGF0b3IgdHlwZVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbGlkYXRvcjogJyArIHZhbGlkYXRvcik7XHJcbiAgfVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBUZXh0XHJcbiAqIFxyXG4gKiBUZXh0IGlucHV0IHdpdGggZm9jdXMsIGJsdXIgYW5kIGNoYW5nZSBldmVudHNcclxuICovXHJcbkZvcm0uZWRpdG9ycy5UZXh0ID0gRm9ybS5FZGl0b3IuZXh0ZW5kKHtcclxuXHJcbiAgdGFnTmFtZTogJ2lucHV0JyxcclxuXHJcbiAgZGVmYXVsdFZhbHVlOiAnJyxcclxuXHJcbiAgcHJldmlvdXNWYWx1ZTogJycsXHJcblxyXG4gIGV2ZW50czoge1xyXG4gICAgJ2tleXVwJzogICAgJ2RldGVybWluZUNoYW5nZScsXHJcbiAgICAna2V5cHJlc3MnOiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgc2VsZi5kZXRlcm1pbmVDaGFuZ2UoKTtcclxuICAgICAgfSwgMCk7XHJcbiAgICB9LFxyXG4gICAgJ3NlbGVjdCc6ICAgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdzZWxlY3QnLCB0aGlzKTtcclxuICAgIH0sXHJcbiAgICAnZm9jdXMnOiAgICBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2ZvY3VzJywgdGhpcyk7XHJcbiAgICB9LFxyXG4gICAgJ2JsdXInOiAgICAgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdibHVyJywgdGhpcyk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgRm9ybS5lZGl0b3JzLkJhc2UucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgICB2YXIgc2NoZW1hID0gdGhpcy5zY2hlbWE7XHJcblxyXG4gICAgLy9BbGxvdyBjdXN0b21pc2luZyB0ZXh0IHR5cGUgKGVtYWlsLCBwaG9uZSBldGMuKSBmb3IgSFRNTDUgYnJvd3NlcnNcclxuICAgIHZhciB0eXBlID0gJ3RleHQnO1xyXG5cclxuICAgIGlmIChzY2hlbWEgJiYgc2NoZW1hLmVkaXRvckF0dHJzICYmIHNjaGVtYS5lZGl0b3JBdHRycy50eXBlKSB0eXBlID0gc2NoZW1hLmVkaXRvckF0dHJzLnR5cGU7XHJcbiAgICBpZiAoc2NoZW1hICYmIHNjaGVtYS5kYXRhVHlwZSkgdHlwZSA9IHNjaGVtYS5kYXRhVHlwZTtcclxuXHJcbiAgICB0aGlzLiRlbC5hdHRyKCd0eXBlJywgdHlwZSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyB0aGUgZWRpdG9yIHRvIHRoZSBET01cclxuICAgKi9cclxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnZhbHVlKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBkZXRlcm1pbmVDaGFuZ2U6IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICB2YXIgY3VycmVudFZhbHVlID0gdGhpcy4kZWwudmFsKCk7XHJcbiAgICB2YXIgY2hhbmdlZCA9IChjdXJyZW50VmFsdWUgIT09IHRoaXMucHJldmlvdXNWYWx1ZSk7XHJcblxyXG4gICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gY3VycmVudFZhbHVlO1xyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGVkaXRvciB2YWx1ZVxyXG4gICAqIEByZXR1cm4ge1N0cmluZ31cclxuICAgKi9cclxuICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kZWwudmFsKCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIGZvcm0gZWxlbWVudFxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfVxyXG4gICAqL1xyXG4gIHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgdGhpcy4kZWwudmFsKHZhbHVlKTtcclxuICB9LFxyXG5cclxuICBmb2N1czogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5oYXNGb2N1cykgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMuJGVsLmZvY3VzKCk7XHJcbiAgfSxcclxuXHJcbiAgYmx1cjogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoIXRoaXMuaGFzRm9jdXMpIHJldHVybjtcclxuXHJcbiAgICB0aGlzLiRlbC5ibHVyKCk7XHJcbiAgfSxcclxuXHJcbiAgc2VsZWN0OiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuJGVsLnNlbGVjdCgpO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFRleHRBcmVhIGVkaXRvclxyXG4gKi9cclxuRm9ybS5lZGl0b3JzLlRleHRBcmVhID0gRm9ybS5lZGl0b3JzLlRleHQuZXh0ZW5kKHtcclxuXHJcbiAgdGFnTmFtZTogJ3RleHRhcmVhJyxcclxuXHJcbiAgLyoqXHJcbiAgICogT3ZlcnJpZGUgVGV4dCBjb25zdHJ1Y3RvciBzbyB0eXBlIHByb3BlcnR5IGlzbid0IHNldCAoaXNzdWUgIzI2MSlcclxuICAgKi9cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBGb3JtLmVkaXRvcnMuQmFzZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFBhc3N3b3JkIGVkaXRvclxyXG4gKi9cclxuRm9ybS5lZGl0b3JzLlBhc3N3b3JkID0gRm9ybS5lZGl0b3JzLlRleHQuZXh0ZW5kKHtcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgRm9ybS5lZGl0b3JzLlRleHQucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgICB0aGlzLiRlbC5hdHRyKCd0eXBlJywgJ3Bhc3N3b3JkJyk7XHJcbiAgfVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICogTlVNQkVSXHJcbiAqIFxyXG4gKiBOb3JtYWwgdGV4dCBpbnB1dCB0aGF0IG9ubHkgYWxsb3dzIGEgbnVtYmVyLiBMZXR0ZXJzIGV0Yy4gYXJlIG5vdCBlbnRlcmVkLlxyXG4gKi9cclxuRm9ybS5lZGl0b3JzLk51bWJlciA9IEZvcm0uZWRpdG9ycy5UZXh0LmV4dGVuZCh7XHJcblxyXG4gIGRlZmF1bHRWYWx1ZTogMCxcclxuXHJcbiAgZXZlbnRzOiBfLmV4dGVuZCh7fSwgRm9ybS5lZGl0b3JzLlRleHQucHJvdG90eXBlLmV2ZW50cywge1xyXG4gICAgJ2tleXByZXNzJzogJ29uS2V5UHJlc3MnLFxyXG4gICAgJ2NoYW5nZSc6ICdvbktleVByZXNzJ1xyXG4gIH0pLFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBGb3JtLmVkaXRvcnMuVGV4dC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYTtcclxuXHJcbiAgICB0aGlzLiRlbC5hdHRyKCd0eXBlJywgJ251bWJlcicpO1xyXG5cclxuICAgIGlmICghc2NoZW1hIHx8ICFzY2hlbWEuZWRpdG9yQXR0cnMgfHwgIXNjaGVtYS5lZGl0b3JBdHRycy5zdGVwKSB7XHJcbiAgICAgIC8vIHByb3ZpZGUgYSBkZWZhdWx0IGZvciBgc3RlcGAgYXR0cixcclxuICAgICAgLy8gYnV0IGRvbid0IG92ZXJ3cml0ZSBpZiBhbHJlYWR5IHNwZWNpZmllZFxyXG4gICAgICB0aGlzLiRlbC5hdHRyKCdzdGVwJywgJ2FueScpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIHZhbHVlIGlzIG51bWVyaWNcclxuICAgKi9cclxuICBvbktleVByZXNzOiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGRlbGF5ZWREZXRlcm1pbmVDaGFuZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHNlbGYuZGV0ZXJtaW5lQ2hhbmdlKCk7XHJcbiAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgIC8vQWxsb3cgYmFja3NwYWNlXHJcbiAgICBpZiAoZXZlbnQuY2hhckNvZGUgPT09IDApIHtcclxuICAgICAgZGVsYXllZERldGVybWluZUNoYW5nZSgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy9HZXQgdGhlIHdob2xlIG5ldyB2YWx1ZSBzbyB0aGF0IHdlIGNhbiBwcmV2ZW50IHRoaW5ncyBsaWtlIGRvdWJsZSBkZWNpbWFscyBwb2ludHMgZXRjLlxyXG4gICAgdmFyIG5ld1ZhbCA9IHRoaXMuJGVsLnZhbCgpXHJcbiAgICBpZiggZXZlbnQuY2hhckNvZGUgIT0gdW5kZWZpbmVkICkge1xyXG4gICAgICBuZXdWYWwgPSBuZXdWYWwgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2ZW50LmNoYXJDb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbnVtZXJpYyA9IC9eWzAtOV0qXFwuP1swLTldKj8kLy50ZXN0KG5ld1ZhbCk7XHJcblxyXG4gICAgaWYgKG51bWVyaWMpIHtcclxuICAgICAgZGVsYXllZERldGVybWluZUNoYW5nZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZhbHVlID0gdGhpcy4kZWwudmFsKCk7XHJcblxyXG4gICAgcmV0dXJuIHZhbHVlID09PSBcIlwiID8gbnVsbCA6IHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcclxuICB9LFxyXG5cclxuICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHZhbHVlID0gKGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoXy5pc051bWJlcih2YWx1ZSkpIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICAgIGlmIChfLmlzU3RyaW5nKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJycpIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlLCAxMCk7XHJcblxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0pKCk7XHJcblxyXG4gICAgaWYgKF8uaXNOYU4odmFsdWUpKSB2YWx1ZSA9IG51bGw7XHJcblxyXG4gICAgRm9ybS5lZGl0b3JzLlRleHQucHJvdG90eXBlLnNldFZhbHVlLmNhbGwodGhpcywgdmFsdWUpO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIEhpZGRlbiBlZGl0b3JcclxuICovXHJcbkZvcm0uZWRpdG9ycy5IaWRkZW4gPSBGb3JtLmVkaXRvcnMuVGV4dC5leHRlbmQoe1xyXG5cclxuICBkZWZhdWx0VmFsdWU6ICcnLFxyXG5cclxuICBub0ZpZWxkOiB0cnVlLFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBGb3JtLmVkaXRvcnMuVGV4dC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgIHRoaXMuJGVsLmF0dHIoJ3R5cGUnLCAnaGlkZGVuJyk7XHJcbiAgfSxcclxuXHJcbiAgZm9jdXM6IGZ1bmN0aW9uKCkge1xyXG5cclxuICB9LFxyXG5cclxuICBibHVyOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgfVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICogQ2hlY2tib3ggZWRpdG9yXHJcbiAqXHJcbiAqIENyZWF0ZXMgYSBzaW5nbGUgY2hlY2tib3gsIGkuZS4gYm9vbGVhbiB2YWx1ZVxyXG4gKi9cclxuRm9ybS5lZGl0b3JzLkNoZWNrYm94ID0gRm9ybS5lZGl0b3JzLkJhc2UuZXh0ZW5kKHtcclxuXHJcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcclxuXHJcbiAgdGFnTmFtZTogJ2lucHV0JyxcclxuXHJcbiAgZXZlbnRzOiB7XHJcbiAgICAnY2xpY2snOiAgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzKTtcclxuICAgIH0sXHJcbiAgICAnZm9jdXMnOiAgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdmb2N1cycsIHRoaXMpO1xyXG4gICAgfSxcclxuICAgICdibHVyJzogICBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2JsdXInLCB0aGlzKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBGb3JtLmVkaXRvcnMuQmFzZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgIHRoaXMuJGVsLmF0dHIoJ3R5cGUnLCAnY2hlY2tib3gnKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHRoZSBlZGl0b3IgdG8gdGhlIERPTVxyXG4gICAqL1xyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnNldFZhbHVlKHRoaXMudmFsdWUpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIGdldFZhbHVlOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLiRlbC5wcm9wKCdjaGVja2VkJyk7XHJcbiAgfSxcclxuXHJcbiAgc2V0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUpIHtcclxuICAgICAgdGhpcy4kZWwucHJvcCgnY2hlY2tlZCcsIHRydWUpO1xyXG4gICAgfWVsc2V7XHJcbiAgICAgIHRoaXMuJGVsLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgZm9jdXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMuaGFzRm9jdXMpIHJldHVybjtcclxuXHJcbiAgICB0aGlzLiRlbC5mb2N1cygpO1xyXG4gIH0sXHJcblxyXG4gIGJsdXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLmhhc0ZvY3VzKSByZXR1cm47XHJcblxyXG4gICAgdGhpcy4kZWwuYmx1cigpO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIFNlbGVjdCBlZGl0b3JcclxuICpcclxuICogUmVuZGVycyBhIDxzZWxlY3Q+IHdpdGggZ2l2ZW4gb3B0aW9uc1xyXG4gKlxyXG4gKiBSZXF1aXJlcyBhbiAnb3B0aW9ucycgdmFsdWUgb24gdGhlIHNjaGVtYS5cclxuICogIENhbiBiZSBhbiBhcnJheSBvZiBvcHRpb25zLCBhIGZ1bmN0aW9uIHRoYXQgY2FsbHMgYmFjayB3aXRoIHRoZSBhcnJheSBvZiBvcHRpb25zLCBhIHN0cmluZyBvZiBIVE1MXHJcbiAqICBvciBhIEJhY2tib25lIGNvbGxlY3Rpb24uIElmIGEgY29sbGVjdGlvbiwgdGhlIG1vZGVscyBtdXN0IGltcGxlbWVudCBhIHRvU3RyaW5nKCkgbWV0aG9kXHJcbiAqL1xyXG5Gb3JtLmVkaXRvcnMuU2VsZWN0ID0gRm9ybS5lZGl0b3JzLkJhc2UuZXh0ZW5kKHtcclxuXHJcbiAgdGFnTmFtZTogJ3NlbGVjdCcsXHJcblxyXG4gIHByZXZpb3VzVmFsdWU6ICcnLFxyXG5cclxuICBldmVudHM6IHtcclxuICAgICdrZXl1cCc6ICAgICdkZXRlcm1pbmVDaGFuZ2UnLFxyXG4gICAgJ2tleXByZXNzJzogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHNlbGYuZGV0ZXJtaW5lQ2hhbmdlKCk7XHJcbiAgICAgIH0sIDApO1xyXG4gICAgfSxcclxuICAgICdjaGFuZ2UnOiBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMpO1xyXG4gICAgfSxcclxuICAgICdmb2N1cyc6ICBmdW5jdGlvbihldmVudCkge1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2ZvY3VzJywgdGhpcyk7XHJcbiAgICB9LFxyXG4gICAgJ2JsdXInOiAgIGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgIHRoaXMudHJpZ2dlcignYmx1cicsIHRoaXMpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIEZvcm0uZWRpdG9ycy5CYXNlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgaWYgKCF0aGlzLnNjaGVtYSB8fCAhdGhpcy5zY2hlbWEub3B0aW9ucykgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCAnc2NoZW1hLm9wdGlvbnMnXCIpO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnNldE9wdGlvbnModGhpcy5zY2hlbWEub3B0aW9ucyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgb3B0aW9ucyB0aGF0IHBvcHVsYXRlIHRoZSA8c2VsZWN0PlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtNaXhlZH0gb3B0aW9uc1xyXG4gICAqL1xyXG4gIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICAvL0lmIGEgY29sbGVjdGlvbiB3YXMgcGFzc2VkLCBjaGVjayBpZiBpdCBuZWVkcyBmZXRjaGluZ1xyXG4gICAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBCYWNrYm9uZS5Db2xsZWN0aW9uKSB7XHJcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gb3B0aW9ucztcclxuXHJcbiAgICAgIC8vRG9uJ3QgZG8gdGhlIGZldGNoIGlmIGl0J3MgYWxyZWFkeSBwb3B1bGF0ZWRcclxuICAgICAgaWYgKGNvbGxlY3Rpb24ubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHRoaXMucmVuZGVyT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb2xsZWN0aW9uLmZldGNoKHtcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgc2VsZi5yZW5kZXJPcHRpb25zKG9wdGlvbnMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9JZiBhIGZ1bmN0aW9uIHdhcyBwYXNzZWQsIHJ1biBpdCB0byBnZXQgdGhlIG9wdGlvbnNcclxuICAgIGVsc2UgaWYgKF8uaXNGdW5jdGlvbihvcHRpb25zKSkge1xyXG4gICAgICBvcHRpb25zKGZ1bmN0aW9uKHJlc3VsdCkge1xyXG4gICAgICAgIHNlbGYucmVuZGVyT3B0aW9ucyhyZXN1bHQpO1xyXG4gICAgICB9LCBzZWxmKTtcclxuICAgIH1cclxuXHJcbiAgICAvL090aGVyd2lzZSwgcmVhZHkgdG8gZ28gc3RyYWlnaHQgdG8gcmVuZGVyT3B0aW9uc1xyXG4gICAgZWxzZSB7XHJcbiAgICAgIHRoaXMucmVuZGVyT3B0aW9ucyhvcHRpb25zKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIHRoZSA8b3B0aW9uPiBodG1sIHRvIHRoZSBET01cclxuICAgKiBAcGFyYW0ge01peGVkfSAgIE9wdGlvbnMgYXMgYSBzaW1wbGUgYXJyYXkgZS5nLiBbJ29wdGlvbjEnLCAnb3B0aW9uMiddXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgb3IgYXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBlLmcuIFt7dmFsOiA1NDMsIGxhYmVsOiAnVGl0bGUgZm9yIG9iamVjdCA1NDMnfV1cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBvciBhcyBhIHN0cmluZyBvZiA8b3B0aW9uPiBIVE1MIHRvIGluc2VydCBpbnRvIHRoZSA8c2VsZWN0PlxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgIG9yIGFueSBvYmplY3RcclxuICAgKi9cclxuICByZW5kZXJPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICB2YXIgJHNlbGVjdCA9IHRoaXMuJGVsLFxyXG4gICAgICAgIGh0bWw7XHJcblxyXG4gICAgaHRtbCA9IHRoaXMuX2dldE9wdGlvbnNIdG1sKG9wdGlvbnMpO1xyXG5cclxuICAgIC8vSW5zZXJ0IG9wdGlvbnNcclxuICAgICRzZWxlY3QuaHRtbChodG1sKTtcclxuXHJcbiAgICAvL1NlbGVjdCBjb3JyZWN0IG9wdGlvblxyXG4gICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnZhbHVlKTtcclxuICB9LFxyXG5cclxuICBfZ2V0T3B0aW9uc0h0bWw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIHZhciBodG1sO1xyXG4gICAgLy9BY2NlcHQgc3RyaW5nIG9mIEhUTUxcclxuICAgIGlmIChfLmlzU3RyaW5nKG9wdGlvbnMpKSB7XHJcbiAgICAgIGh0bWwgPSBvcHRpb25zO1xyXG4gICAgfVxyXG5cclxuICAgIC8vT3IgYXJyYXlcclxuICAgIGVsc2UgaWYgKF8uaXNBcnJheShvcHRpb25zKSkge1xyXG4gICAgICBodG1sID0gdGhpcy5fYXJyYXlUb0h0bWwob3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy9PciBCYWNrYm9uZSBjb2xsZWN0aW9uXHJcbiAgICBlbHNlIGlmIChvcHRpb25zIGluc3RhbmNlb2YgQmFja2JvbmUuQ29sbGVjdGlvbikge1xyXG4gICAgICBodG1sID0gdGhpcy5fY29sbGVjdGlvblRvSHRtbChvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBlbHNlIGlmIChfLmlzRnVuY3Rpb24ob3B0aW9ucykpIHtcclxuICAgICAgdmFyIG5ld09wdGlvbnM7XHJcblxyXG4gICAgICBvcHRpb25zKGZ1bmN0aW9uKG9wdHMpIHtcclxuICAgICAgICBuZXdPcHRpb25zID0gb3B0cztcclxuICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICBodG1sID0gdGhpcy5fZ2V0T3B0aW9uc0h0bWwobmV3T3B0aW9ucyk7XHJcbiAgICAvL09yIGFueSBvYmplY3RcclxuICAgIH1lbHNle1xyXG4gICAgICBodG1sID0gdGhpcy5fb2JqZWN0VG9IdG1sKG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBodG1sO1xyXG4gIH0sXHJcblxyXG4gIGRldGVybWluZUNoYW5nZTogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgIHZhciBjdXJyZW50VmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XHJcbiAgICB2YXIgY2hhbmdlZCA9IChjdXJyZW50VmFsdWUgIT09IHRoaXMucHJldmlvdXNWYWx1ZSk7XHJcblxyXG4gICAgaWYgKGNoYW5nZWQpIHtcclxuICAgICAgdGhpcy5wcmV2aW91c1ZhbHVlID0gY3VycmVudFZhbHVlO1xyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy4kZWwudmFsKCk7XHJcbiAgfSxcclxuXHJcbiAgc2V0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICB0aGlzLiRlbC52YWwodmFsdWUpO1xyXG4gIH0sXHJcblxyXG4gIGZvY3VzOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLmhhc0ZvY3VzKSByZXR1cm47XHJcblxyXG4gICAgdGhpcy4kZWwuZm9jdXMoKTtcclxuICB9LFxyXG5cclxuICBibHVyOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICghdGhpcy5oYXNGb2N1cykgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMuJGVsLmJsdXIoKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBUcmFuc2Zvcm1zIGEgY29sbGVjdGlvbiBpbnRvIEhUTUwgcmVhZHkgdG8gdXNlIGluIHRoZSByZW5kZXJPcHRpb25zIG1ldGhvZFxyXG4gICAqIEBwYXJhbSB7QmFja2JvbmUuQ29sbGVjdGlvbn1cclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgX2NvbGxlY3Rpb25Ub0h0bWw6IGZ1bmN0aW9uKGNvbGxlY3Rpb24pIHtcclxuICAgIC8vQ29udmVydCBjb2xsZWN0aW9uIHRvIGFycmF5IGZpcnN0XHJcbiAgICB2YXIgYXJyYXkgPSBbXTtcclxuICAgIGNvbGxlY3Rpb24uZWFjaChmdW5jdGlvbihtb2RlbCkge1xyXG4gICAgICBhcnJheS5wdXNoKHsgdmFsOiBtb2RlbC5pZCwgbGFiZWw6IG1vZGVsLnRvU3RyaW5nKCkgfSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICAvL05vdyBjb252ZXJ0IHRvIEhUTUxcclxuICAgIHZhciBodG1sID0gdGhpcy5fYXJyYXlUb0h0bWwoYXJyYXkpO1xyXG5cclxuICAgIHJldHVybiBodG1sO1xyXG4gIH0sXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtcyBhbiBvYmplY3QgaW50byBIVE1MIHJlYWR5IHRvIHVzZSBpbiB0aGUgcmVuZGVyT3B0aW9ucyBtZXRob2RcclxuICAgKiBAcGFyYW0ge09iamVjdH1cclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAgICovXHJcbiAgX29iamVjdFRvSHRtbDogZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAvL0NvbnZlcnQgb2JqZWN0IHRvIGFycmF5IGZpcnN0XHJcbiAgICB2YXIgYXJyYXkgPSBbXTtcclxuICAgIGZvcih2YXIga2V5IGluIG9iail7XHJcbiAgICAgIGlmKCBvYmouaGFzT3duUHJvcGVydHkoIGtleSApICkge1xyXG4gICAgICAgIGFycmF5LnB1c2goeyB2YWw6IGtleSwgbGFiZWw6IG9ialtrZXldIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy9Ob3cgY29udmVydCB0byBIVE1MXHJcbiAgICB2YXIgaHRtbCA9IHRoaXMuX2FycmF5VG9IdG1sKGFycmF5KTtcclxuXHJcbiAgICByZXR1cm4gaHRtbDtcclxuICB9LFxyXG5cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgPG9wdGlvbj4gSFRNTFxyXG4gICAqIEBwYXJhbSB7QXJyYXl9ICAgT3B0aW9ucyBhcyBhIHNpbXBsZSBhcnJheSBlLmcuIFsnb3B0aW9uMScsICdvcHRpb24yJ11cclxuICAgKiAgICAgICAgICAgICAgICAgICAgICBvciBhcyBhbiBhcnJheSBvZiBvYmplY3RzIGUuZy4gW3t2YWw6IDU0MywgbGFiZWw6ICdUaXRsZSBmb3Igb2JqZWN0IDU0Myd9XVxyXG4gICAqIEByZXR1cm4ge1N0cmluZ30gSFRNTFxyXG4gICAqL1xyXG4gIF9hcnJheVRvSHRtbDogZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIHZhciBodG1sID0gJCgpO1xyXG5cclxuICAgIC8vR2VuZXJhdGUgSFRNTFxyXG4gICAgXy5lYWNoKGFycmF5LCBmdW5jdGlvbihvcHRpb24pIHtcclxuICAgICAgaWYgKF8uaXNPYmplY3Qob3B0aW9uKSkge1xyXG4gICAgICAgIGlmIChvcHRpb24uZ3JvdXApIHtcclxuICAgICAgICAgIHZhciBvcHRncm91cCA9ICQoXCI8b3B0Z3JvdXA+XCIpXHJcbiAgICAgICAgICAgIC5hdHRyKFwibGFiZWxcIixvcHRpb24uZ3JvdXApXHJcbiAgICAgICAgICAgIC5odG1sKCB0aGlzLl9nZXRPcHRpb25zSHRtbChvcHRpb24ub3B0aW9ucykgKTtcclxuICAgICAgICAgIGh0bWwgPSBodG1sLmFkZChvcHRncm91cCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHZhciB2YWwgPSAob3B0aW9uLnZhbCB8fCBvcHRpb24udmFsID09PSAwKSA/IG9wdGlvbi52YWwgOiAnJztcclxuICAgICAgICAgIGh0bWwgPSBodG1sLmFkZCggJCgnPG9wdGlvbj4nKS52YWwodmFsKS50ZXh0KG9wdGlvbi5sYWJlbCkgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSB7XHJcbiAgICAgICAgaHRtbCA9IGh0bWwuYWRkKCAkKCc8b3B0aW9uPicpLnRleHQob3B0aW9uKSApO1xyXG4gICAgICB9XHJcbiAgICB9LCB0aGlzKTtcclxuXHJcbiAgICByZXR1cm4gaHRtbDtcclxuICB9XHJcblxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBSYWRpbyBlZGl0b3JcclxuICpcclxuICogUmVuZGVycyBhIDx1bD4gd2l0aCBnaXZlbiBvcHRpb25zIHJlcHJlc2VudGVkIGFzIDxsaT4gb2JqZWN0cyBjb250YWluaW5nIHJhZGlvIGJ1dHRvbnNcclxuICpcclxuICogUmVxdWlyZXMgYW4gJ29wdGlvbnMnIHZhbHVlIG9uIHRoZSBzY2hlbWEuXHJcbiAqICBDYW4gYmUgYW4gYXJyYXkgb2Ygb3B0aW9ucywgYSBmdW5jdGlvbiB0aGF0IGNhbGxzIGJhY2sgd2l0aCB0aGUgYXJyYXkgb2Ygb3B0aW9ucywgYSBzdHJpbmcgb2YgSFRNTFxyXG4gKiAgb3IgYSBCYWNrYm9uZSBjb2xsZWN0aW9uLiBJZiBhIGNvbGxlY3Rpb24sIHRoZSBtb2RlbHMgbXVzdCBpbXBsZW1lbnQgYSB0b1N0cmluZygpIG1ldGhvZFxyXG4gKi9cclxuRm9ybS5lZGl0b3JzLlJhZGlvID0gRm9ybS5lZGl0b3JzLlNlbGVjdC5leHRlbmQoe1xyXG5cclxuICB0YWdOYW1lOiAndWwnLFxyXG5cclxuICBldmVudHM6IHtcclxuICAgICdjaGFuZ2UgaW5wdXRbdHlwZT1yYWRpb10nOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzKTtcclxuICAgIH0sXHJcbiAgICAnZm9jdXMgaW5wdXRbdHlwZT1yYWRpb10nOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMuaGFzRm9jdXMpIHJldHVybjtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdmb2N1cycsIHRoaXMpO1xyXG4gICAgfSxcclxuICAgICdibHVyIGlucHV0W3R5cGU9cmFkaW9dJzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICghdGhpcy5oYXNGb2N1cykgcmV0dXJuO1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHNlbGYuJCgnaW5wdXRbdHlwZT1yYWRpb106Zm9jdXMnKVswXSkgcmV0dXJuO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignYmx1cicsIHNlbGYpO1xyXG4gICAgICB9LCAwKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZS4gT3ZlcnJpZGUgZm9yIGN1c3RvbSB0ZW1wbGF0ZXNcclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSAgICAgICBDb21waWxlZCB0ZW1wbGF0ZVxyXG4gICAqL1xyXG4gIGdldFRlbXBsYXRlOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnNjaGVtYS50ZW1wbGF0ZSB8fCB0aGlzLmNvbnN0cnVjdG9yLnRlbXBsYXRlO1xyXG4gIH0sXHJcblxyXG4gIGdldFZhbHVlOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLiQoJ2lucHV0W3R5cGU9cmFkaW9dOmNoZWNrZWQnKS52YWwoKTtcclxuICB9LFxyXG5cclxuICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHRoaXMuJCgnaW5wdXRbdHlwZT1yYWRpb10nKS52YWwoW3ZhbHVlXSk7XHJcbiAgfSxcclxuXHJcbiAgZm9jdXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMuaGFzRm9jdXMpIHJldHVybjtcclxuXHJcbiAgICB2YXIgY2hlY2tlZCA9IHRoaXMuJCgnaW5wdXRbdHlwZT1yYWRpb106Y2hlY2tlZCcpO1xyXG4gICAgaWYgKGNoZWNrZWRbMF0pIHtcclxuICAgICAgY2hlY2tlZC5mb2N1cygpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy4kKCdpbnB1dFt0eXBlPXJhZGlvXScpLmZpcnN0KCkuZm9jdXMoKTtcclxuICB9LFxyXG5cclxuICBibHVyOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICghdGhpcy5oYXNGb2N1cykgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMuJCgnaW5wdXRbdHlwZT1yYWRpb106Zm9jdXMnKS5ibHVyKCk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlIHRoZSByYWRpbyBsaXN0IEhUTUxcclxuICAgKiBAcGFyYW0ge0FycmF5fSAgIE9wdGlvbnMgYXMgYSBzaW1wbGUgYXJyYXkgZS5nLiBbJ29wdGlvbjEnLCAnb3B0aW9uMiddXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgb3IgYXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBlLmcuIFt7dmFsOiA1NDMsIGxhYmVsOiAnVGl0bGUgZm9yIG9iamVjdCA1NDMnfV1cclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IEhUTUxcclxuICAgKi9cclxuICBfYXJyYXlUb0h0bWw6IGZ1bmN0aW9uIChhcnJheSkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIHZhciB0ZW1wbGF0ZSA9IHRoaXMuZ2V0VGVtcGxhdGUoKSxcclxuICAgICAgICBuYW1lID0gc2VsZi5nZXROYW1lKCksXHJcbiAgICAgICAgaWQgPSBzZWxmLmlkO1xyXG5cclxuICAgIHZhciBpdGVtcyA9IF8ubWFwKGFycmF5LCBmdW5jdGlvbihvcHRpb24sIGluZGV4KSB7XHJcbiAgICAgIHZhciBpdGVtID0ge1xyXG4gICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgaWQ6IGlkICsgJy0nICsgaW5kZXhcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChfLmlzT2JqZWN0KG9wdGlvbikpIHtcclxuICAgICAgICBpdGVtLnZhbHVlID0gKG9wdGlvbi52YWwgfHwgb3B0aW9uLnZhbCA9PT0gMCkgPyBvcHRpb24udmFsIDogJyc7XHJcbiAgICAgICAgaXRlbS5sYWJlbCA9IG9wdGlvbi5sYWJlbDtcclxuICAgICAgICBpdGVtLmxhYmVsSFRNTCA9IG9wdGlvbi5sYWJlbEhUTUw7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaXRlbS52YWx1ZSA9IG9wdGlvbjtcclxuICAgICAgICBpdGVtLmxhYmVsID0gb3B0aW9uO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaXRlbTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0ZW1wbGF0ZSh7IGl0ZW1zOiBpdGVtcyB9KTtcclxuICB9XHJcblxyXG59LCB7XHJcblxyXG4gIC8vU1RBVElDU1xyXG4gIHRlbXBsYXRlOiBfLnRlbXBsYXRlKCdcXFxyXG4gICAgPCUgXy5lYWNoKGl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7ICU+XFxcclxuICAgICAgPGxpPlxcXHJcbiAgICAgICAgPGlucHV0IHR5cGU9XCJyYWRpb1wiIG5hbWU9XCI8JT0gaXRlbS5uYW1lICU+XCIgdmFsdWU9XCI8JS0gaXRlbS52YWx1ZSAlPlwiIGlkPVwiPCU9IGl0ZW0uaWQgJT5cIiAvPlxcXHJcbiAgICAgICAgPGxhYmVsIGZvcj1cIjwlPSBpdGVtLmlkICU+XCI+PCUgaWYgKGl0ZW0ubGFiZWxIVE1MKXsgJT48JT0gaXRlbS5sYWJlbEhUTUwgJT48JSB9ZWxzZXsgJT48JS0gaXRlbS5sYWJlbCAlPjwlIH0gJT48L2xhYmVsPlxcXHJcbiAgICAgIDwvbGk+XFxcclxuICAgIDwlIH0pOyAlPlxcXHJcbiAgJywgbnVsbCwgRm9ybS50ZW1wbGF0ZVNldHRpbmdzKVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICogQ2hlY2tib3hlcyBlZGl0b3JcclxuICpcclxuICogUmVuZGVycyBhIDx1bD4gd2l0aCBnaXZlbiBvcHRpb25zIHJlcHJlc2VudGVkIGFzIDxsaT4gb2JqZWN0cyBjb250YWluaW5nIGNoZWNrYm94ZXNcclxuICpcclxuICogUmVxdWlyZXMgYW4gJ29wdGlvbnMnIHZhbHVlIG9uIHRoZSBzY2hlbWEuXHJcbiAqICBDYW4gYmUgYW4gYXJyYXkgb2Ygb3B0aW9ucywgYSBmdW5jdGlvbiB0aGF0IGNhbGxzIGJhY2sgd2l0aCB0aGUgYXJyYXkgb2Ygb3B0aW9ucywgYSBzdHJpbmcgb2YgSFRNTFxyXG4gKiAgb3IgYSBCYWNrYm9uZSBjb2xsZWN0aW9uLiBJZiBhIGNvbGxlY3Rpb24sIHRoZSBtb2RlbHMgbXVzdCBpbXBsZW1lbnQgYSB0b1N0cmluZygpIG1ldGhvZFxyXG4gKi9cclxuRm9ybS5lZGl0b3JzLkNoZWNrYm94ZXMgPSBGb3JtLmVkaXRvcnMuU2VsZWN0LmV4dGVuZCh7XHJcblxyXG4gIHRhZ05hbWU6ICd1bCcsXHJcblxyXG4gIGdyb3VwTnVtYmVyOiAwLFxyXG5cclxuICBldmVudHM6IHtcclxuICAgICdjbGljayBpbnB1dFt0eXBlPWNoZWNrYm94XSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMpO1xyXG4gICAgfSxcclxuICAgICdmb2N1cyBpbnB1dFt0eXBlPWNoZWNrYm94XSc6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAodGhpcy5oYXNGb2N1cykgcmV0dXJuO1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2ZvY3VzJywgdGhpcyk7XHJcbiAgICB9LFxyXG4gICAgJ2JsdXIgaW5wdXRbdHlwZT1jaGVja2JveF0nOiAgZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICghdGhpcy5oYXNGb2N1cykgcmV0dXJuO1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHNlbGYuJCgnaW5wdXRbdHlwZT1jaGVja2JveF06Zm9jdXMnKVswXSkgcmV0dXJuO1xyXG4gICAgICAgIHNlbGYudHJpZ2dlcignYmx1cicsIHNlbGYpO1xyXG4gICAgICB9LCAwKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmFsdWVzID0gW107XHJcbiAgICB0aGlzLiQoJ2lucHV0W3R5cGU9Y2hlY2tib3hdOmNoZWNrZWQnKS5lYWNoKGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YWx1ZXMucHVzaCgkKHRoaXMpLnZhbCgpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHZhbHVlcztcclxuICB9LFxyXG5cclxuICBzZXRWYWx1ZTogZnVuY3Rpb24odmFsdWVzKSB7XHJcbiAgICBpZiAoIV8uaXNBcnJheSh2YWx1ZXMpKSB2YWx1ZXMgPSBbdmFsdWVzXTtcclxuICAgIHRoaXMuJCgnaW5wdXRbdHlwZT1jaGVja2JveF0nKS52YWwodmFsdWVzKTtcclxuICB9LFxyXG5cclxuICBmb2N1czogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5oYXNGb2N1cykgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMuJCgnaW5wdXRbdHlwZT1jaGVja2JveF0nKS5maXJzdCgpLmZvY3VzKCk7XHJcbiAgfSxcclxuXHJcbiAgYmx1cjogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoIXRoaXMuaGFzRm9jdXMpIHJldHVybjtcclxuXHJcbiAgICB0aGlzLiQoJ2lucHV0W3R5cGU9Y2hlY2tib3hdOmZvY3VzJykuYmx1cigpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSB0aGUgY2hlY2tib3ggbGlzdCBIVE1MXHJcbiAgICogQHBhcmFtIHtBcnJheX0gICBPcHRpb25zIGFzIGEgc2ltcGxlIGFycmF5IGUuZy4gWydvcHRpb24xJywgJ29wdGlvbjInXVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgIG9yIGFzIGFuIGFycmF5IG9mIG9iamVjdHMgZS5nLiBbe3ZhbDogNTQzLCBsYWJlbDogJ1RpdGxlIGZvciBvYmplY3QgNTQzJ31dXHJcbiAgICogQHJldHVybiB7U3RyaW5nfSBIVE1MXHJcbiAgICovXHJcbiAgX2FycmF5VG9IdG1sOiBmdW5jdGlvbiAoYXJyYXkpIHtcclxuICAgIHZhciBodG1sID0gJCgpO1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuICAgIF8uZWFjaChhcnJheSwgZnVuY3Rpb24ob3B0aW9uLCBpbmRleCkge1xyXG4gICAgICB2YXIgaXRlbUh0bWwgPSAkKCc8bGk+Jyk7XHJcbiAgICAgIGlmIChfLmlzT2JqZWN0KG9wdGlvbikpIHtcclxuICAgICAgICBpZiAob3B0aW9uLmdyb3VwKSB7XHJcbiAgICAgICAgICB2YXIgb3JpZ2luYWxJZCA9IHNlbGYuaWQ7XHJcbiAgICAgICAgICBzZWxmLmlkICs9IFwiLVwiICsgc2VsZi5ncm91cE51bWJlcisrO1xyXG4gICAgICAgICAgaXRlbUh0bWwgPSAkKCc8ZmllbGRzZXQgY2xhc3M9XCJncm91cFwiPicpLmFwcGVuZCggJCgnPGxlZ2VuZD4nKS50ZXh0KG9wdGlvbi5ncm91cCkgKTtcclxuICAgICAgICAgIGl0ZW1IdG1sID0gaXRlbUh0bWwuYXBwZW5kKCBzZWxmLl9hcnJheVRvSHRtbChvcHRpb24ub3B0aW9ucykgKTtcclxuICAgICAgICAgIHNlbGYuaWQgPSBvcmlnaW5hbElkO1xyXG4gICAgICAgICAgY2xvc2UgPSBmYWxzZTtcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgIHZhciB2YWwgPSAob3B0aW9uLnZhbCB8fCBvcHRpb24udmFsID09PSAwKSA/IG9wdGlvbi52YWwgOiAnJztcclxuICAgICAgICAgIGl0ZW1IdG1sLmFwcGVuZCggJCgnPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5hbWU9XCInK3NlbGYuZ2V0TmFtZSgpKydcIiBpZD1cIicrc2VsZi5pZCsnLScraW5kZXgrJ1wiIC8+JykudmFsKHZhbCkgKTtcclxuICAgICAgICAgIGlmIChvcHRpb24ubGFiZWxIVE1MKXtcclxuICAgICAgICAgICAgaXRlbUh0bWwuYXBwZW5kKCAkKCc8bGFiZWwgZm9yPVwiJytzZWxmLmlkKyctJytpbmRleCsnXCI+JykuaHRtbChvcHRpb24ubGFiZWxIVE1MKSApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGl0ZW1IdG1sLmFwcGVuZCggJCgnPGxhYmVsIGZvcj1cIicrc2VsZi5pZCsnLScraW5kZXgrJ1wiPicpLnRleHQob3B0aW9uLmxhYmVsKSApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBpdGVtSHRtbC5hcHBlbmQoICQoJzxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBuYW1lPVwiJytzZWxmLmdldE5hbWUoKSsnXCIgaWQ9XCInK3NlbGYuaWQrJy0nK2luZGV4KydcIiAvPicpLnZhbChvcHRpb24pICk7XHJcbiAgICAgICAgaXRlbUh0bWwuYXBwZW5kKCAkKCc8bGFiZWwgZm9yPVwiJytzZWxmLmlkKyctJytpbmRleCsnXCI+JykudGV4dChvcHRpb24pICk7XHJcbiAgICAgIH1cclxuICAgICAgaHRtbCA9IGh0bWwuYWRkKGl0ZW1IdG1sKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBodG1sO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIE9iamVjdCBlZGl0b3JcclxuICpcclxuICogQ3JlYXRlcyBhIGNoaWxkIGZvcm0uIEZvciBlZGl0aW5nIEphdmFzY3JpcHQgb2JqZWN0c1xyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge0Zvcm19IG9wdGlvbnMuZm9ybSAgICAgICAgICAgICAgICAgVGhlIGZvcm0gdGhpcyBlZGl0b3IgYmVsb25ncyB0bzsgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgbmVzdGVkIGZvcm1cclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuc2NoZW1hICAgICAgICAgICAgIFRoZSBzY2hlbWEgZm9yIHRoZSBvYmplY3RcclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuc2NoZW1hLnN1YlNjaGVtYSAgIFRoZSBzY2hlbWEgZm9yIHRoZSBuZXN0ZWQgZm9ybVxyXG4gKi9cclxuRm9ybS5lZGl0b3JzLk9iamVjdCA9IEZvcm0uZWRpdG9ycy5CYXNlLmV4dGVuZCh7XHJcbiAgLy9QcmV2ZW50IGVycm9yIGNsYXNzZXMgYmVpbmcgc2V0IG9uIHRoZSBtYWluIGNvbnRyb2w7IHRoZXkgYXJlIGludGVybmFsbHkgb24gdGhlIGluZGl2aWR1YWwgZmllbGRzXHJcbiAgaGFzTmVzdGVkRm9ybTogdHJ1ZSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgLy9TZXQgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIGluc3RhbmNlIHNvIGl0J3Mgbm90IGEgc2hhcmVkIG9iamVjdFxyXG4gICAgdGhpcy52YWx1ZSA9IHt9O1xyXG5cclxuICAgIC8vSW5pdFxyXG4gICAgRm9ybS5lZGl0b3JzLkJhc2UucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgICAvL0NoZWNrIHJlcXVpcmVkIG9wdGlvbnNcclxuICAgIGlmICghdGhpcy5mb3JtKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgb3B0aW9uIFwiZm9ybVwiJyk7XHJcbiAgICBpZiAoIXRoaXMuc2NoZW1hLnN1YlNjaGVtYSkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCAnc2NoZW1hLnN1YlNjaGVtYScgb3B0aW9uIGZvciBPYmplY3QgZWRpdG9yXCIpO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAvL0dldCB0aGUgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIHRoZSBuZXN0ZWQgZm9ybTsgaS5lLiB0aGUgc2FtZSBjb25zdHJ1Y3RvciBhcyB1c2VkIGJ5IHRoZSBwYXJlbnQgZm9ybVxyXG4gICAgdmFyIE5lc3RlZEZvcm0gPSB0aGlzLmZvcm0uY29uc3RydWN0b3I7XHJcblxyXG4gICAgLy9DcmVhdGUgdGhlIG5lc3RlZCBmb3JtXHJcbiAgICB0aGlzLm5lc3RlZEZvcm0gPSBuZXcgTmVzdGVkRm9ybSh7XHJcbiAgICAgIHNjaGVtYTogdGhpcy5zY2hlbWEuc3ViU2NoZW1hLFxyXG4gICAgICBkYXRhOiB0aGlzLnZhbHVlLFxyXG4gICAgICBpZFByZWZpeDogdGhpcy5pZCArICdfJyxcclxuICAgICAgRmllbGQ6IE5lc3RlZEZvcm0uTmVzdGVkRmllbGRcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX29ic2VydmVGb3JtRXZlbnRzKCk7XHJcblxyXG4gICAgdGhpcy4kZWwuaHRtbCh0aGlzLm5lc3RlZEZvcm0ucmVuZGVyKCkuZWwpO1xyXG5cclxuICAgIGlmICh0aGlzLmhhc0ZvY3VzKSB0aGlzLnRyaWdnZXIoJ2JsdXInLCB0aGlzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5uZXN0ZWRGb3JtKSByZXR1cm4gdGhpcy5uZXN0ZWRGb3JtLmdldFZhbHVlKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgfSxcclxuXHJcbiAgc2V0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcblxyXG4gICAgdGhpcy5yZW5kZXIoKTtcclxuICB9LFxyXG5cclxuICBmb2N1czogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAodGhpcy5oYXNGb2N1cykgcmV0dXJuO1xyXG5cclxuICAgIHRoaXMubmVzdGVkRm9ybS5mb2N1cygpO1xyXG4gIH0sXHJcblxyXG4gIGJsdXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKCF0aGlzLmhhc0ZvY3VzKSByZXR1cm47XHJcblxyXG4gICAgdGhpcy5uZXN0ZWRGb3JtLmJsdXIoKTtcclxuICB9LFxyXG5cclxuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5uZXN0ZWRGb3JtLnJlbW92ZSgpO1xyXG5cclxuICAgIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMpO1xyXG4gIH0sXHJcblxyXG4gIHZhbGlkYXRlOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBlcnJvcnMgPSBfLmV4dGVuZCh7fSwgXHJcbiAgICAgIEZvcm0uZWRpdG9ycy5CYXNlLnByb3RvdHlwZS52YWxpZGF0ZS5jYWxsKHRoaXMpLFxyXG4gICAgICB0aGlzLm5lc3RlZEZvcm0udmFsaWRhdGUoKVxyXG4gICAgKTtcclxuICAgIHJldHVybiBfLmlzRW1wdHkoZXJyb3JzKT9mYWxzZTplcnJvcnM7XHJcbiAgfSxcclxuXHJcbiAgX29ic2VydmVGb3JtRXZlbnRzOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICghdGhpcy5uZXN0ZWRGb3JtKSByZXR1cm47XHJcbiAgICBcclxuICAgIHRoaXMubmVzdGVkRm9ybS5vbignYWxsJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgIC8vIGFyZ3MgPSBbXCJrZXk6Y2hhbmdlXCIsIGZvcm0sIGZpZWxkRWRpdG9yXVxyXG4gICAgICB2YXIgYXJncyA9IF8udG9BcnJheShhcmd1bWVudHMpO1xyXG4gICAgICBhcmdzWzFdID0gdGhpcztcclxuICAgICAgLy8gYXJncyA9IFtcImtleTpjaGFuZ2VcIiwgdGhpcz1vYmplY3RFZGl0b3IsIGZpZWxkRWRpdG9yXVxyXG5cclxuICAgICAgdGhpcy50cmlnZ2VyLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgfVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICogTmVzdGVkTW9kZWwgZWRpdG9yXHJcbiAqXHJcbiAqIENyZWF0ZXMgYSBjaGlsZCBmb3JtLiBGb3IgZWRpdGluZyBuZXN0ZWQgQmFja2JvbmUgbW9kZWxzXHJcbiAqXHJcbiAqIFNwZWNpYWwgb3B0aW9uczpcclxuICogICBzY2hlbWEubW9kZWw6ICAgRW1iZWRkZWQgbW9kZWwgY29uc3RydWN0b3JcclxuICovXHJcbkZvcm0uZWRpdG9ycy5OZXN0ZWRNb2RlbCA9IEZvcm0uZWRpdG9ycy5PYmplY3QuZXh0ZW5kKHtcclxuICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICBGb3JtLmVkaXRvcnMuQmFzZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgIGlmICghdGhpcy5mb3JtKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgb3B0aW9uIFwiZm9ybVwiJyk7XHJcbiAgICBpZiAoIW9wdGlvbnMuc2NoZW1hLm1vZGVsKSB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgXCJzY2hlbWEubW9kZWxcIiBvcHRpb24gZm9yIE5lc3RlZE1vZGVsIGVkaXRvcicpO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAvL0dldCB0aGUgY29uc3RydWN0b3IgZm9yIGNyZWF0aW5nIHRoZSBuZXN0ZWQgZm9ybTsgaS5lLiB0aGUgc2FtZSBjb25zdHJ1Y3RvciBhcyB1c2VkIGJ5IHRoZSBwYXJlbnQgZm9ybVxyXG4gICAgdmFyIE5lc3RlZEZvcm0gPSB0aGlzLmZvcm0uY29uc3RydWN0b3I7XHJcblxyXG4gICAgdmFyIGRhdGEgPSB0aGlzLnZhbHVlIHx8IHt9LFxyXG4gICAgICAgIGtleSA9IHRoaXMua2V5LFxyXG4gICAgICAgIG5lc3RlZE1vZGVsID0gdGhpcy5zY2hlbWEubW9kZWw7XHJcblxyXG4gICAgLy9XcmFwIHRoZSBkYXRhIGluIGEgbW9kZWwgaWYgaXQgaXNuJ3QgYWxyZWFkeSBhIG1vZGVsIGluc3RhbmNlXHJcbiAgICB2YXIgbW9kZWxJbnN0YW5jZSA9IChkYXRhLmNvbnN0cnVjdG9yID09PSBuZXN0ZWRNb2RlbCkgPyBkYXRhIDogbmV3IG5lc3RlZE1vZGVsKGRhdGEpO1xyXG5cclxuICAgIHRoaXMubmVzdGVkRm9ybSA9IG5ldyBOZXN0ZWRGb3JtKHtcclxuICAgICAgbW9kZWw6IG1vZGVsSW5zdGFuY2UsXHJcbiAgICAgIGlkUHJlZml4OiB0aGlzLmlkICsgJ18nLFxyXG4gICAgICBmaWVsZFRlbXBsYXRlOiAnbmVzdGVkRmllbGQnXHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLl9vYnNlcnZlRm9ybUV2ZW50cygpO1xyXG5cclxuICAgIC8vUmVuZGVyIGZvcm1cclxuICAgIHRoaXMuJGVsLmh0bWwodGhpcy5uZXN0ZWRGb3JtLnJlbmRlcigpLmVsKTtcclxuXHJcbiAgICBpZiAodGhpcy5oYXNGb2N1cykgdGhpcy50cmlnZ2VyKCdibHVyJywgdGhpcyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBlbWJlZGRlZCBtb2RlbCwgY2hlY2tpbmcgZm9yIG5lc3RlZCB2YWxpZGF0aW9uIGVycm9ycyBhbmQgcGFzcyB0aGVtIHVwXHJcbiAgICogVGhlbiB1cGRhdGUgdGhlIG1haW4gbW9kZWwgaWYgYWxsIE9LXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtFcnJvcnxudWxsfSBWYWxpZGF0aW9uIGVycm9yIG9yIG51bGxcclxuICAgKi9cclxuICBjb21taXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGVycm9yID0gdGhpcy5uZXN0ZWRGb3JtLmNvbW1pdCgpO1xyXG4gICAgaWYgKGVycm9yKSB7XHJcbiAgICAgIHRoaXMuJGVsLmFkZENsYXNzKCdlcnJvcicpO1xyXG4gICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIEZvcm0uZWRpdG9ycy5PYmplY3QucHJvdG90eXBlLmNvbW1pdC5jYWxsKHRoaXMpO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAqIERhdGUgZWRpdG9yXHJcbiAqXHJcbiAqIFNjaGVtYSBvcHRpb25zXHJcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gW29wdGlvbnMuc2NoZW1hLnllYXJTdGFydF0gIEZpcnN0IHllYXIgaW4gbGlzdC4gRGVmYXVsdDogMTAwIHllYXJzIGFnb1xyXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IFtvcHRpb25zLnNjaGVtYS55ZWFyRW5kXSAgICBMYXN0IHllYXIgaW4gbGlzdC4gRGVmYXVsdDogY3VycmVudCB5ZWFyXHJcbiAqXHJcbiAqIENvbmZpZyBvcHRpb25zIChpZiBub3Qgc2V0LCBkZWZhdWx0cyB0byBvcHRpb25zIHN0b3JlZCBvbiB0aGUgbWFpbiBEYXRlIGNsYXNzKVxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNob3dNb250aE5hbWVzXSAgVXNlIG1vbnRoIG5hbWVzIGluc3RlYWQgb2YgbnVtYmVycy4gRGVmYXVsdDogdHJ1ZVxyXG4gKiBAcGFyYW0ge1N0cmluZ1tdfSBbb3B0aW9ucy5tb250aE5hbWVzXSAgICAgTW9udGggbmFtZXMuIERlZmF1bHQ6IEZ1bGwgRW5nbGlzaCBuYW1lc1xyXG4gKi9cclxuRm9ybS5lZGl0b3JzLkRhdGUgPSBGb3JtLmVkaXRvcnMuQmFzZS5leHRlbmQoe1xyXG5cclxuICBldmVudHM6IHtcclxuICAgICdjaGFuZ2Ugc2VsZWN0JzogIGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLnVwZGF0ZUhpZGRlbigpO1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMpO1xyXG4gICAgfSxcclxuICAgICdmb2N1cyBzZWxlY3QnOiAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAodGhpcy5oYXNGb2N1cykgcmV0dXJuO1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2ZvY3VzJywgdGhpcyk7XHJcbiAgICB9LFxyXG4gICAgJ2JsdXIgc2VsZWN0JzogICAgZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICghdGhpcy5oYXNGb2N1cykgcmV0dXJuO1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHNlbGYuJCgnc2VsZWN0OmZvY3VzJylbMF0pIHJldHVybjtcclxuICAgICAgICBzZWxmLnRyaWdnZXIoJ2JsdXInLCBzZWxmKTtcclxuICAgICAgfSwgMCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblxyXG4gICAgRm9ybS5lZGl0b3JzLkJhc2UucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgICB2YXIgU2VsZiA9IEZvcm0uZWRpdG9ycy5EYXRlLFxyXG4gICAgICAgIHRvZGF5ID0gbmV3IERhdGUoKTtcclxuXHJcbiAgICAvL09wdGlvbiBkZWZhdWx0c1xyXG4gICAgdGhpcy5vcHRpb25zID0gXy5leHRlbmQoe1xyXG4gICAgICBtb250aE5hbWVzOiBTZWxmLm1vbnRoTmFtZXMsXHJcbiAgICAgIHNob3dNb250aE5hbWVzOiBTZWxmLnNob3dNb250aE5hbWVzXHJcbiAgICB9LCBvcHRpb25zKTtcclxuXHJcbiAgICAvL1NjaGVtYSBkZWZhdWx0c1xyXG4gICAgdGhpcy5zY2hlbWEgPSBfLmV4dGVuZCh7XHJcbiAgICAgIHllYXJTdGFydDogdG9kYXkuZ2V0RnVsbFllYXIoKSAtIDEwMCxcclxuICAgICAgeWVhckVuZDogdG9kYXkuZ2V0RnVsbFllYXIoKVxyXG4gICAgfSwgb3B0aW9ucy5zY2hlbWEgfHwge30pO1xyXG5cclxuICAgIC8vQ2FzdCB0byBEYXRlXHJcbiAgICBpZiAodGhpcy52YWx1ZSAmJiAhXy5pc0RhdGUodGhpcy52YWx1ZSkpIHtcclxuICAgICAgdGhpcy52YWx1ZSA9IG5ldyBEYXRlKHRoaXMudmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vU2V0IGRlZmF1bHQgZGF0ZVxyXG4gICAgaWYgKCF0aGlzLnZhbHVlKSB7XHJcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcclxuICAgICAgZGF0ZS5zZXRTZWNvbmRzKDApO1xyXG4gICAgICBkYXRlLnNldE1pbGxpc2Vjb25kcygwKTtcclxuXHJcbiAgICAgIHRoaXMudmFsdWUgPSBkYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vVGVtcGxhdGVcclxuICAgIHRoaXMudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlIHx8IHRoaXMuY29uc3RydWN0b3IudGVtcGxhdGU7XHJcbiAgfSxcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG4gICAgICAgIHNjaGVtYSA9IHRoaXMuc2NoZW1hLFxyXG4gICAgICAgICQgPSBCYWNrYm9uZS4kO1xyXG5cclxuICAgIHZhciBkYXRlc09wdGlvbnMgPSBfLm1hcChfLnJhbmdlKDEsIDMyKSwgZnVuY3Rpb24oZGF0ZSkge1xyXG4gICAgICByZXR1cm4gJzxvcHRpb24gdmFsdWU9XCInK2RhdGUrJ1wiPicgKyBkYXRlICsgJzwvb3B0aW9uPic7XHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgbW9udGhzT3B0aW9ucyA9IF8ubWFwKF8ucmFuZ2UoMCwgMTIpLCBmdW5jdGlvbihtb250aCkge1xyXG4gICAgICB2YXIgdmFsdWUgPSAob3B0aW9ucy5zaG93TW9udGhOYW1lcylcclxuICAgICAgICAgID8gb3B0aW9ucy5tb250aE5hbWVzW21vbnRoXVxyXG4gICAgICAgICAgOiAobW9udGggKyAxKTtcclxuXHJcbiAgICAgIHJldHVybiAnPG9wdGlvbiB2YWx1ZT1cIicrbW9udGgrJ1wiPicgKyB2YWx1ZSArICc8L29wdGlvbj4nO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdmFyIHllYXJSYW5nZSA9IChzY2hlbWEueWVhclN0YXJ0IDwgc2NoZW1hLnllYXJFbmQpXHJcbiAgICAgID8gXy5yYW5nZShzY2hlbWEueWVhclN0YXJ0LCBzY2hlbWEueWVhckVuZCArIDEpXHJcbiAgICAgIDogXy5yYW5nZShzY2hlbWEueWVhclN0YXJ0LCBzY2hlbWEueWVhckVuZCAtIDEsIC0xKTtcclxuXHJcbiAgICB2YXIgeWVhcnNPcHRpb25zID0gXy5tYXAoeWVhclJhbmdlLCBmdW5jdGlvbih5ZWFyKSB7XHJcbiAgICAgIHJldHVybiAnPG9wdGlvbiB2YWx1ZT1cIicreWVhcisnXCI+JyArIHllYXIgKyAnPC9vcHRpb24+JztcclxuICAgIH0pO1xyXG5cclxuICAgIC8vUmVuZGVyIHRoZSBzZWxlY3RzXHJcbiAgICB2YXIgJGVsID0gJCgkLnRyaW0odGhpcy50ZW1wbGF0ZSh7XHJcbiAgICAgIGRhdGVzOiBkYXRlc09wdGlvbnMuam9pbignJyksXHJcbiAgICAgIG1vbnRoczogbW9udGhzT3B0aW9ucy5qb2luKCcnKSxcclxuICAgICAgeWVhcnM6IHllYXJzT3B0aW9ucy5qb2luKCcnKVxyXG4gICAgfSkpKTtcclxuXHJcbiAgICAvL1N0b3JlIHJlZmVyZW5jZXMgdG8gc2VsZWN0c1xyXG4gICAgdGhpcy4kZGF0ZSA9ICRlbC5maW5kKCdbZGF0YS10eXBlPVwiZGF0ZVwiXScpO1xyXG4gICAgdGhpcy4kbW9udGggPSAkZWwuZmluZCgnW2RhdGEtdHlwZT1cIm1vbnRoXCJdJyk7XHJcbiAgICB0aGlzLiR5ZWFyID0gJGVsLmZpbmQoJ1tkYXRhLXR5cGU9XCJ5ZWFyXCJdJyk7XHJcblxyXG4gICAgLy9DcmVhdGUgdGhlIGhpZGRlbiBmaWVsZCB0byBzdG9yZSB2YWx1ZXMgaW4gY2FzZSBQT1NUZWQgdG8gc2VydmVyXHJcbiAgICB0aGlzLiRoaWRkZW4gPSAkKCc8aW5wdXQgdHlwZT1cImhpZGRlblwiIG5hbWU9XCInK3RoaXMua2V5KydcIiAvPicpO1xyXG4gICAgJGVsLmFwcGVuZCh0aGlzLiRoaWRkZW4pO1xyXG5cclxuICAgIC8vU2V0IHZhbHVlIG9uIHRoaXMgYW5kIGhpZGRlbiBmaWVsZFxyXG4gICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnZhbHVlKTtcclxuXHJcbiAgICAvL1JlbW92ZSB0aGUgd3JhcHBlciB0YWdcclxuICAgIHRoaXMuc2V0RWxlbWVudCgkZWwpO1xyXG4gICAgdGhpcy4kZWwuYXR0cignaWQnLCB0aGlzLmlkKTtcclxuICAgIHRoaXMuJGVsLmF0dHIoJ25hbWUnLCB0aGlzLmdldE5hbWUoKSk7XHJcblxyXG4gICAgaWYgKHRoaXMuaGFzRm9jdXMpIHRoaXMudHJpZ2dlcignYmx1cicsIHRoaXMpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge0RhdGV9ICAgU2VsZWN0ZWQgZGF0ZVxyXG4gICAqL1xyXG4gIGdldFZhbHVlOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB5ZWFyID0gdGhpcy4keWVhci52YWwoKSxcclxuICAgICAgICBtb250aCA9IHRoaXMuJG1vbnRoLnZhbCgpLFxyXG4gICAgICAgIGRhdGUgPSB0aGlzLiRkYXRlLnZhbCgpO1xyXG5cclxuICAgIGlmICgheWVhciB8fCAhbW9udGggfHwgIWRhdGUpIHJldHVybiBudWxsO1xyXG5cclxuICAgIHJldHVybiBuZXcgRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtEYXRlfSBkYXRlXHJcbiAgICovXHJcbiAgc2V0VmFsdWU6IGZ1bmN0aW9uKGRhdGUpIHtcclxuICAgIHRoaXMuJGRhdGUudmFsKGRhdGUuZ2V0RGF0ZSgpKTtcclxuICAgIHRoaXMuJG1vbnRoLnZhbChkYXRlLmdldE1vbnRoKCkpO1xyXG4gICAgdGhpcy4keWVhci52YWwoZGF0ZS5nZXRGdWxsWWVhcigpKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZUhpZGRlbigpO1xyXG4gIH0sXHJcblxyXG4gIGZvY3VzOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLmhhc0ZvY3VzKSByZXR1cm47XHJcblxyXG4gICAgdGhpcy4kKCdzZWxlY3QnKS5maXJzdCgpLmZvY3VzKCk7XHJcbiAgfSxcclxuXHJcbiAgYmx1cjogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoIXRoaXMuaGFzRm9jdXMpIHJldHVybjtcclxuXHJcbiAgICB0aGlzLiQoJ3NlbGVjdDpmb2N1cycpLmJsdXIoKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGhpZGRlbiBpbnB1dCB3aGljaCBpcyBtYWludGFpbmVkIGZvciB3aGVuIHN1Ym1pdHRpbmcgYSBmb3JtXHJcbiAgICogdmlhIGEgbm9ybWFsIGJyb3dzZXIgUE9TVFxyXG4gICAqL1xyXG4gIHVwZGF0ZUhpZGRlbjogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmFsID0gdGhpcy5nZXRWYWx1ZSgpO1xyXG5cclxuICAgIGlmIChfLmlzRGF0ZSh2YWwpKSB2YWwgPSB2YWwudG9JU09TdHJpbmcoKTtcclxuXHJcbiAgICB0aGlzLiRoaWRkZW4udmFsKHZhbCk7XHJcbiAgfVxyXG5cclxufSwge1xyXG4gIC8vU1RBVElDU1xyXG4gIHRlbXBsYXRlOiBfLnRlbXBsYXRlKCdcXFxyXG4gICAgPGRpdj5cXFxyXG4gICAgICA8c2VsZWN0IGRhdGEtdHlwZT1cImRhdGVcIj48JT0gZGF0ZXMgJT48L3NlbGVjdD5cXFxyXG4gICAgICA8c2VsZWN0IGRhdGEtdHlwZT1cIm1vbnRoXCI+PCU9IG1vbnRocyAlPjwvc2VsZWN0PlxcXHJcbiAgICAgIDxzZWxlY3QgZGF0YS10eXBlPVwieWVhclwiPjwlPSB5ZWFycyAlPjwvc2VsZWN0PlxcXHJcbiAgICA8L2Rpdj5cXFxyXG4gICcsIG51bGwsIEZvcm0udGVtcGxhdGVTZXR0aW5ncyksXHJcblxyXG4gIC8vV2hldGhlciB0byBzaG93IG1vbnRoIG5hbWVzIGluc3RlYWQgb2YgbnVtYmVyc1xyXG4gIHNob3dNb250aE5hbWVzOiB0cnVlLFxyXG5cclxuICAvL01vbnRoIG5hbWVzIHRvIHVzZSBpZiBzaG93TW9udGhOYW1lcyBpcyB0cnVlXHJcbiAgLy9SZXBsYWNlIGZvciBsb2NhbGlzYXRpb24sIGUuZy4gRm9ybS5lZGl0b3JzLkRhdGUubW9udGhOYW1lcyA9IFsnSmFudmllcicsICdGZXZyaWVyJy4uLl1cclxuICBtb250aE5hbWVzOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBEYXRlVGltZSBlZGl0b3JcclxuICpcclxuICogQHBhcmFtIHtFZGl0b3J9IFtvcHRpb25zLkRhdGVFZGl0b3JdICAgICAgICAgICBEYXRlIGVkaXRvciB2aWV3IHRvIHVzZSAobm90IGRlZmluaXRpb24pXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5zY2hlbWEubWluc0ludGVydmFsXSAgSW50ZXJ2YWwgYmV0d2VlbiBtaW51dGVzLiBEZWZhdWx0OiAxNVxyXG4gKi9cclxuRm9ybS5lZGl0b3JzLkRhdGVUaW1lID0gRm9ybS5lZGl0b3JzLkJhc2UuZXh0ZW5kKHtcclxuXHJcbiAgZXZlbnRzOiB7XHJcbiAgICAnY2hhbmdlIHNlbGVjdCc6ICBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy51cGRhdGVIaWRkZW4oKTtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCB0aGlzKTtcclxuICAgIH0sXHJcbiAgICAnZm9jdXMgc2VsZWN0JzogICBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMuaGFzRm9jdXMpIHJldHVybjtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdmb2N1cycsIHRoaXMpO1xyXG4gICAgfSxcclxuICAgICdibHVyIHNlbGVjdCc6ICAgIGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoIXRoaXMuaGFzRm9jdXMpIHJldHVybjtcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChzZWxmLiQoJ3NlbGVjdDpmb2N1cycpWzBdKSByZXR1cm47XHJcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdibHVyJywgc2VsZik7XHJcbiAgICAgIH0sIDApO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAgIEZvcm0uZWRpdG9ycy5CYXNlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgLy9PcHRpb24gZGVmYXVsdHNcclxuICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHtcclxuICAgICAgRGF0ZUVkaXRvcjogRm9ybS5lZGl0b3JzLkRhdGVUaW1lLkRhdGVFZGl0b3JcclxuICAgIH0sIG9wdGlvbnMpO1xyXG5cclxuICAgIC8vU2NoZW1hIGRlZmF1bHRzXHJcbiAgICB0aGlzLnNjaGVtYSA9IF8uZXh0ZW5kKHtcclxuICAgICAgbWluc0ludGVydmFsOiAxNVxyXG4gICAgfSwgb3B0aW9ucy5zY2hlbWEgfHwge30pO1xyXG5cclxuICAgIC8vQ3JlYXRlIGVtYmVkZGVkIGRhdGUgZWRpdG9yXHJcbiAgICB0aGlzLmRhdGVFZGl0b3IgPSBuZXcgdGhpcy5vcHRpb25zLkRhdGVFZGl0b3Iob3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy52YWx1ZSA9IHRoaXMuZGF0ZUVkaXRvci52YWx1ZTtcclxuXHJcbiAgICAvL1RlbXBsYXRlXHJcbiAgICB0aGlzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZSB8fCB0aGlzLmNvbnN0cnVjdG9yLnRlbXBsYXRlO1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICBmdW5jdGlvbiBwYWQobikge1xyXG4gICAgICByZXR1cm4gbiA8IDEwID8gJzAnICsgbiA6IG47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hLFxyXG4gICAgICAgICQgPSBCYWNrYm9uZS4kO1xyXG5cclxuICAgIC8vQ3JlYXRlIG9wdGlvbnNcclxuICAgIHZhciBob3Vyc09wdGlvbnMgPSBfLm1hcChfLnJhbmdlKDAsIDI0KSwgZnVuY3Rpb24oaG91cikge1xyXG4gICAgICByZXR1cm4gJzxvcHRpb24gdmFsdWU9XCInK2hvdXIrJ1wiPicgKyBwYWQoaG91cikgKyAnPC9vcHRpb24+JztcclxuICAgIH0pO1xyXG5cclxuICAgIHZhciBtaW5zT3B0aW9ucyA9IF8ubWFwKF8ucmFuZ2UoMCwgNjAsIHNjaGVtYS5taW5zSW50ZXJ2YWwpLCBmdW5jdGlvbihtaW4pIHtcclxuICAgICAgcmV0dXJuICc8b3B0aW9uIHZhbHVlPVwiJyttaW4rJ1wiPicgKyBwYWQobWluKSArICc8L29wdGlvbj4nO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy9SZW5kZXIgdGltZSBzZWxlY3RzXHJcbiAgICB2YXIgJGVsID0gJCgkLnRyaW0odGhpcy50ZW1wbGF0ZSh7XHJcbiAgICAgIGhvdXJzOiBob3Vyc09wdGlvbnMuam9pbigpLFxyXG4gICAgICBtaW5zOiBtaW5zT3B0aW9ucy5qb2luKClcclxuICAgIH0pKSk7XHJcblxyXG4gICAgLy9JbmNsdWRlIHRoZSBkYXRlIGVkaXRvclxyXG4gICAgJGVsLmZpbmQoJ1tkYXRhLWRhdGVdJykuYXBwZW5kKHRoaXMuZGF0ZUVkaXRvci5yZW5kZXIoKS5lbCk7XHJcblxyXG4gICAgLy9TdG9yZSByZWZlcmVuY2VzIHRvIHNlbGVjdHNcclxuICAgIHRoaXMuJGhvdXIgPSAkZWwuZmluZCgnc2VsZWN0W2RhdGEtdHlwZT1cImhvdXJcIl0nKTtcclxuICAgIHRoaXMuJG1pbiA9ICRlbC5maW5kKCdzZWxlY3RbZGF0YS10eXBlPVwibWluXCJdJyk7XHJcblxyXG4gICAgLy9HZXQgdGhlIGhpZGRlbiBkYXRlIGZpZWxkIHRvIHN0b3JlIHZhbHVlcyBpbiBjYXNlIFBPU1RlZCB0byBzZXJ2ZXJcclxuICAgIHRoaXMuJGhpZGRlbiA9ICRlbC5maW5kKCdpbnB1dFt0eXBlPVwiaGlkZGVuXCJdJyk7XHJcblxyXG4gICAgLy9TZXQgdGltZVxyXG4gICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnZhbHVlKTtcclxuXHJcbiAgICB0aGlzLnNldEVsZW1lbnQoJGVsKTtcclxuICAgIHRoaXMuJGVsLmF0dHIoJ2lkJywgdGhpcy5pZCk7XHJcbiAgICB0aGlzLiRlbC5hdHRyKCduYW1lJywgdGhpcy5nZXROYW1lKCkpO1xyXG5cclxuICAgIGlmICh0aGlzLmhhc0ZvY3VzKSB0aGlzLnRyaWdnZXIoJ2JsdXInLCB0aGlzKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBAcmV0dXJuIHtEYXRlfSAgIFNlbGVjdGVkIGRhdGV0aW1lXHJcbiAgICovXHJcbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGRhdGUgPSB0aGlzLmRhdGVFZGl0b3IuZ2V0VmFsdWUoKTtcclxuXHJcbiAgICB2YXIgaG91ciA9IHRoaXMuJGhvdXIudmFsKCksXHJcbiAgICAgICAgbWluID0gdGhpcy4kbWluLnZhbCgpO1xyXG5cclxuICAgIGlmICghZGF0ZSB8fCAhaG91ciB8fCAhbWluKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBkYXRlLnNldEhvdXJzKGhvdXIpO1xyXG4gICAgZGF0ZS5zZXRNaW51dGVzKG1pbik7XHJcblxyXG4gICAgcmV0dXJuIGRhdGU7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtEYXRlfVxyXG4gICAqL1xyXG4gIHNldFZhbHVlOiBmdW5jdGlvbihkYXRlKSB7XHJcbiAgICBpZiAoIV8uaXNEYXRlKGRhdGUpKSBkYXRlID0gbmV3IERhdGUoZGF0ZSk7XHJcblxyXG4gICAgdGhpcy5kYXRlRWRpdG9yLnNldFZhbHVlKGRhdGUpO1xyXG5cclxuICAgIHRoaXMuJGhvdXIudmFsKGRhdGUuZ2V0SG91cnMoKSk7XHJcbiAgICB0aGlzLiRtaW4udmFsKGRhdGUuZ2V0TWludXRlcygpKTtcclxuXHJcbiAgICB0aGlzLnVwZGF0ZUhpZGRlbigpO1xyXG4gIH0sXHJcblxyXG4gIGZvY3VzOiBmdW5jdGlvbigpIHtcclxuICAgIGlmICh0aGlzLmhhc0ZvY3VzKSByZXR1cm47XHJcblxyXG4gICAgdGhpcy4kKCdzZWxlY3QnKS5maXJzdCgpLmZvY3VzKCk7XHJcbiAgfSxcclxuXHJcbiAgYmx1cjogZnVuY3Rpb24oKSB7XHJcbiAgICBpZiAoIXRoaXMuaGFzRm9jdXMpIHJldHVybjtcclxuXHJcbiAgICB0aGlzLiQoJ3NlbGVjdDpmb2N1cycpLmJsdXIoKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGhpZGRlbiBpbnB1dCB3aGljaCBpcyBtYWludGFpbmVkIGZvciB3aGVuIHN1Ym1pdHRpbmcgYSBmb3JtXHJcbiAgICogdmlhIGEgbm9ybWFsIGJyb3dzZXIgUE9TVFxyXG4gICAqL1xyXG4gIHVwZGF0ZUhpZGRlbjogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgdmFsID0gdGhpcy5nZXRWYWx1ZSgpO1xyXG4gICAgaWYgKF8uaXNEYXRlKHZhbCkpIHZhbCA9IHZhbC50b0lTT1N0cmluZygpO1xyXG5cclxuICAgIHRoaXMuJGhpZGRlbi52YWwodmFsKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIERhdGUgZWRpdG9yIGJlZm9yZSByZW1vdmluZyBzZWxmXHJcbiAgICovXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZGF0ZUVkaXRvci5yZW1vdmUoKTtcclxuXHJcbiAgICBGb3JtLmVkaXRvcnMuQmFzZS5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcyk7XHJcbiAgfVxyXG5cclxufSwge1xyXG4gIC8vU1RBVElDU1xyXG4gIHRlbXBsYXRlOiBfLnRlbXBsYXRlKCdcXFxyXG4gICAgPGRpdiBjbGFzcz1cImJiZi1kYXRldGltZVwiPlxcXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJiYmYtZGF0ZS1jb250YWluZXJcIiBkYXRhLWRhdGU+PC9kaXY+XFxcclxuICAgICAgPHNlbGVjdCBkYXRhLXR5cGU9XCJob3VyXCI+PCU9IGhvdXJzICU+PC9zZWxlY3Q+XFxcclxuICAgICAgOlxcXHJcbiAgICAgIDxzZWxlY3QgZGF0YS10eXBlPVwibWluXCI+PCU9IG1pbnMgJT48L3NlbGVjdD5cXFxyXG4gICAgPC9kaXY+XFxcclxuICAnLCBudWxsLCBGb3JtLnRlbXBsYXRlU2V0dGluZ3MpLFxyXG5cclxuICAvL1RoZSBkYXRlIGVkaXRvciB0byB1c2UgKGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBub3QgaW5zdGFuY2UpXHJcbiAgRGF0ZUVkaXRvcjogRm9ybS5lZGl0b3JzLkRhdGVcclxufSk7XHJcblxyXG5cclxuXHJcbiAgLy9NZXRhZGF0YVxyXG4gIEZvcm0uVkVSU0lPTiA9ICcwLjE0LjAnO1xyXG5cclxuXHJcbiAgLy9FeHBvcnRzXHJcbiAgQmFja2JvbmUuRm9ybSA9IEZvcm07XHJcbiAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSBtb2R1bGUuZXhwb3J0cyA9IEZvcm07XHJcblxyXG59KSh3aW5kb3cgfHwgZ2xvYmFsIHx8IHRoaXMpO1xyXG4iLCIvKiFcclxuICogYmFja2JvbmUubGF5b3V0bWFuYWdlci5qcyB2MC45LjVcclxuICogQ29weXJpZ2h0IDIwMTMsIFRpbSBCcmFueWVuIChAdGJyYW55ZW4pXHJcbiAqIGJhY2tib25lLmxheW91dG1hbmFnZXIuanMgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiAqL1xyXG4oZnVuY3Rpb24od2luZG93LCBmYWN0b3J5KSB7XHJcbiAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS4gIFdyYXAgaW4gZnVuY3Rpb24gc28gd2UgaGF2ZSBhY2Nlc3NcclxuICAvLyB0byByb290IHZpYSBgdGhpc2AuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICBkZWZpbmUoW1wiYmFja2JvbmVcIiwgXCJ1bmRlcnNjb3JlXCIsIFwianF1ZXJ5XCJdLCBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIGZhY3RvcnkuYXBwbHkod2luZG93LCBhcmd1bWVudHMpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXQgb25seSBDb21tb25KUy1saWtlXHJcbiAgLy8gZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cywgbGlrZSBOb2RlLlxyXG4gIGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICB2YXIgQmFja2JvbmUgPSByZXF1aXJlKFwiYmFja2JvbmVcIik7XHJcbiAgICB2YXIgXyA9IHJlcXVpcmUoXCJ1bmRlcnNjb3JlXCIpO1xyXG4gICAgLy8gSW4gYSBicm93c2VyaWZ5IGJ1aWxkLCBzaW5jZSB0aGlzIGlzIHRoZSBlbnRyeSBwb2ludCwgQmFja2JvbmUuJFxyXG4gICAgLy8gaXMgbm90IGJvdW5kLiBFbnN1cmUgdGhhdCBpdCBpcy5cclxuICAgIEJhY2tib25lLiQgPSBCYWNrYm9uZS4kIHx8IHJlcXVpcmUoXCJqcXVlcnlcIik7XHJcblxyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5LmNhbGwod2luZG93LCBCYWNrYm9uZSwgXywgQmFja2JvbmUuJCk7XHJcbiAgfVxyXG5cclxuICAvLyBCcm93c2VyIGdsb2JhbHMuXHJcbiAgZWxzZSB7XHJcbiAgICBmYWN0b3J5LmNhbGwod2luZG93LCB3aW5kb3cuQmFja2JvbmUsIHdpbmRvdy5fLCB3aW5kb3cuQmFja2JvbmUuJCk7XHJcbiAgfVxyXG59KHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0aGlzLCBmdW5jdGlvbiAoQmFja2JvbmUsIF8sICQpIHtcclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBDcmVhdGUgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuIEluIGJyb3dzZXJzLCBpdCB3aWxsIG1hcCB0byB0aGVcclxuLy8gYHdpbmRvd2Agb2JqZWN0OyBpbiBOb2RlLCBpdCB3aWxsIGJlIGBnbG9iYWxgLlxyXG52YXIgd2luZG93ID0gdGhpcztcclxuXHJcbi8vIE1haW50YWluIHJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgY29uc3RydWN0b3IuXHJcbnZhciBWaWV3Q29uc3RydWN0b3IgPSBCYWNrYm9uZS5WaWV3O1xyXG5cclxuLy8gQ2FjaGUgdGhlc2UgbWV0aG9kcyBmb3IgcGVyZm9ybWFuY2UuXHJcbnZhciBhUHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xyXG52YXIgYUNvbmNhdCA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQ7XHJcbnZhciBhU3BsaWNlID0gQXJyYXkucHJvdG90eXBlLnNwbGljZTtcclxudmFyIHRyaW0gPSBTdHJpbmcucHJvdG90eXBlLnRyaW0gP1xyXG4gIF8uYmluZChTdHJpbmcucHJvdG90eXBlLnRyaW0uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS50cmltKSA6XHJcbiAgJC50cmltO1xyXG5cclxuLy8gTGF5b3V0TWFuYWdlciBpcyBhIHdyYXBwZXIgYXJvdW5kIGEgYEJhY2tib25lLlZpZXdgLlxyXG4vLyBCYWNrYm9uZS5WaWV3LmV4dGVuZCB0YWtlcyBvcHRpb25zIChwcm90b1Byb3BzLCBzdGF0aWNQcm9wcylcclxudmFyIExheW91dE1hbmFnZXIgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgX3JlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAvLyBLZWVwIHRoZSB2aWV3IGNvbnNpc3RlbnQgYmV0d2VlbiBjYWxsYmFja3MgYW5kIGRlZmVycmVkcy5cclxuICAgIHZhciB2aWV3ID0gdGhpcztcclxuICAgIC8vIFNob3J0aGFuZCB0aGUgbWFuYWdlci5cclxuICAgIHZhciBtYW5hZ2VyID0gdmlldy5fX21hbmFnZXJfXztcclxuICAgIC8vIENhY2hlIHRoZXNlIHByb3BlcnRpZXMuXHJcbiAgICB2YXIgYmVmb3JlUmVuZGVyID0gdmlldy5iZWZvcmVSZW5kZXI7XHJcbiAgICAvLyBDcmVhdGUgYSBkZWZlcnJlZCBpbnN0ZWFkIG9mIGdvaW5nIG9mZlxyXG4gICAgdmFyIGRlZiA9IHZpZXcuZGVmZXJyZWQoKTtcclxuXHJcbiAgICAvLyBFbnN1cmUgYWxsIG5lc3RlZCBWaWV3cyBhcmUgcHJvcGVybHkgc2NydWJiZWQgaWYgcmUtcmVuZGVyaW5nLlxyXG4gICAgaWYgKHZpZXcuaGFzUmVuZGVyZWQpIHtcclxuICAgICAgdmlldy5fcmVtb3ZlVmlld3MoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGlzIGNvbnRpbnVlcyB0aGUgcmVuZGVyIGZsb3cgYWZ0ZXIgYGJlZm9yZVJlbmRlcmAgaGFzIGNvbXBsZXRlZC5cclxuICAgIG1hbmFnZXIuY2FsbGJhY2sgPSBmdW5jdGlvbigpIHtcclxuICAgICAgLy8gQ2xlYW4gdXAgYXN5bmNocm9ub3VzIG1hbmFnZXIgcHJvcGVydGllcy5cclxuICAgICAgZGVsZXRlIG1hbmFnZXIuaXNBc3luYztcclxuICAgICAgZGVsZXRlIG1hbmFnZXIuY2FsbGJhY2s7XHJcblxyXG4gICAgICAvLyBBbHdheXMgZW1pdCBhIGJlZm9yZVJlbmRlciBldmVudC5cclxuICAgICAgdmlldy50cmlnZ2VyKFwiYmVmb3JlUmVuZGVyXCIsIHZpZXcpO1xyXG5cclxuICAgICAgLy8gUmVuZGVyIVxyXG4gICAgICB2aWV3Ll92aWV3UmVuZGVyKG1hbmFnZXIpLnJlbmRlcigpLnRoZW4oZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gQ29tcGxldGUgdGhpcyBkZWZlcnJlZCBvbmNlIHJlc29sdmVkLlxyXG4gICAgICAgIGRlZi5yZXNvbHZlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBJZiBhIGJlZm9yZVJlbmRlciBmdW5jdGlvbiBpcyBkZWZpbmVkLCBjYWxsIGl0LlxyXG4gICAgaWYgKGJlZm9yZVJlbmRlcikge1xyXG4gICAgICBiZWZvcmVSZW5kZXIuY2FsbCh2aWV3LCB2aWV3KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIW1hbmFnZXIuaXNBc3luYykge1xyXG4gICAgICBtYW5hZ2VyLmNhbGxiYWNrKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmV0dXJuIHRoaXMgaW50ZXJtZWRpYXJ5IHByb21pc2UuXHJcbiAgICByZXR1cm4gZGVmLnByb21pc2UoKTtcclxuICB9LFxyXG5cclxuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBwYWlyaW5nIHRoZSByZW5kZXJlZCB0ZW1wbGF0ZSBpbnRvIHRoZVxyXG4gIC8vIERPTSBlbGVtZW50LlxyXG4gIF9hcHBseVRlbXBsYXRlOiBmdW5jdGlvbihyZW5kZXJlZCwgbWFuYWdlciwgZGVmKSB7XHJcbiAgICAvLyBBY3R1YWxseSBwdXQgdGhlIHJlbmRlcmVkIGNvbnRlbnRzIGludG8gdGhlIGVsZW1lbnQuXHJcbiAgICBpZiAoXy5pc1N0cmluZyhyZW5kZXJlZCkpIHtcclxuICAgICAgLy8gSWYgbm8gY29udGFpbmVyIGlzIHNwZWNpZmllZCwgd2UgbXVzdCByZXBsYWNlIHRoZSBjb250ZW50LlxyXG4gICAgICBpZiAobWFuYWdlci5ub2VsKSB7XHJcbiAgICAgICAgcmVuZGVyZWQgPSAkLnBhcnNlSFRNTChyZW5kZXJlZCwgdHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBleHRyYSByb290IGVsZW1lbnRzLlxyXG4gICAgICAgIHRoaXMuJGVsLnNsaWNlKDEpLnJlbW92ZSgpO1xyXG5cclxuICAgICAgICAvLyBTd2FwIG91dCB0aGUgVmlldyBvbiB0aGUgZmlyc3QgdG9wIGxldmVsIGVsZW1lbnQgdG8gYXZvaWRcclxuICAgICAgICAvLyBkdXBsaWNhdGlvbi5cclxuICAgICAgICB0aGlzLiRlbC5yZXBsYWNlV2l0aChyZW5kZXJlZCk7XHJcblxyXG4gICAgICAgIC8vIERvbid0IGRlbGVnYXRlIGV2ZW50cyBoZXJlIC0gd2UnbGwgZG8gdGhhdCBpbiByZXNvbHZlKClcclxuICAgICAgICB0aGlzLnNldEVsZW1lbnQocmVuZGVyZWQsIGZhbHNlKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aGlzLmh0bWwodGhpcy4kZWwsIHJlbmRlcmVkKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlc29sdmUgb25seSBhZnRlciBmZXRjaCBhbmQgcmVuZGVyIGhhdmUgc3VjY2VlZGVkLlxyXG4gICAgZGVmLnJlc29sdmVXaXRoKHRoaXMsIFt0aGlzXSk7XHJcbiAgfSxcclxuXHJcbiAgLy8gQ3JlYXRlcyBhIGRlZmVycmVkIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGZpbmlzaGVkLlxyXG4gIC8vIFRoaXMgZ2V0cyBwYXNzZWQgdG8gYWxsIF9yZW5kZXIgbWV0aG9kcy4gIFRoZSBgcm9vdGAgdmFsdWUgaGVyZSBpcyBwYXNzZWRcclxuICAvLyBmcm9tIHRoZSBgbWFuYWdlKHRoaXMpLnJlbmRlcigpYCBsaW5lIGluIHRoZSBgX3JlbmRlcmAgZnVuY3Rpb25cclxuICBfdmlld1JlbmRlcjogZnVuY3Rpb24obWFuYWdlcikge1xyXG4gICAgdmFyIHVybCwgY29udGVudHMsIGRlZjtcclxuICAgIHZhciByb290ID0gdGhpcztcclxuXHJcbiAgICAvLyBPbmNlIHRoZSB0ZW1wbGF0ZSBpcyBzdWNjZXNzZnVsbHkgZmV0Y2hlZCwgdXNlIGl0cyBjb250ZW50cyB0byBwcm9jZWVkLlxyXG4gICAgLy8gQ29udGV4dCBhcmd1bWVudCBpcyBmaXJzdCwgc2luY2UgaXQgaXMgYm91bmQgZm9yIHBhcnRpYWwgYXBwbGljYXRpb25cclxuICAgIC8vIHJlYXNvbnMuXHJcbiAgICBmdW5jdGlvbiBkb25lKGNvbnRleHQsIHRlbXBsYXRlKSB7XHJcbiAgICAgIC8vIFN0b3JlIHRoZSByZW5kZXJlZCB0ZW1wbGF0ZSBzb21lcGxhY2Ugc28gaXQgY2FuIGJlIHJlLWFzc2lnbmFibGUuXHJcbiAgICAgIHZhciByZW5kZXJlZDtcclxuXHJcbiAgICAgIC8vIFRyaWdnZXIgdGhpcyBvbmNlIHRoZSByZW5kZXIgbWV0aG9kIGhhcyBjb21wbGV0ZWQuXHJcbiAgICAgIG1hbmFnZXIuY2FsbGJhY2sgPSBmdW5jdGlvbihyZW5kZXJlZCkge1xyXG4gICAgICAgIC8vIENsZWFuIHVwIGFzeW5jaHJvbm91cyBtYW5hZ2VyIHByb3BlcnRpZXMuXHJcbiAgICAgICAgZGVsZXRlIG1hbmFnZXIuaXNBc3luYztcclxuICAgICAgICBkZWxldGUgbWFuYWdlci5jYWxsYmFjaztcclxuXHJcbiAgICAgICAgcm9vdC5fYXBwbHlUZW1wbGF0ZShyZW5kZXJlZCwgbWFuYWdlciwgZGVmKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIEVuc3VyZSB0aGUgY2FjaGUgaXMgdXAtdG8tZGF0ZS5cclxuICAgICAgTGF5b3V0TWFuYWdlci5jYWNoZSh1cmwsIHRlbXBsYXRlKTtcclxuXHJcbiAgICAgIC8vIFJlbmRlciB0aGUgVmlldyBpbnRvIHRoZSBlbCBwcm9wZXJ0eS5cclxuICAgICAgaWYgKHRlbXBsYXRlKSB7XHJcbiAgICAgICAgcmVuZGVyZWQgPSByb290LnJlbmRlclRlbXBsYXRlLmNhbGwocm9vdCwgdGVtcGxhdGUsIGNvbnRleHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB0aGUgZnVuY3Rpb24gd2FzIHN5bmNocm9ub3VzLCBjb250aW51ZSBleGVjdXRpb24uXHJcbiAgICAgIGlmICghbWFuYWdlci5pc0FzeW5jKSB7XHJcbiAgICAgICAgcm9vdC5fYXBwbHlUZW1wbGF0ZShyZW5kZXJlZCwgbWFuYWdlciwgZGVmKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIC8vIFRoaXMgYHJlbmRlcmAgZnVuY3Rpb24gaXMgd2hhdCBnZXRzIGNhbGxlZCBpbnNpZGUgb2YgdGhlIFZpZXcgcmVuZGVyLFxyXG4gICAgICAvLyB3aGVuIGBtYW5hZ2UodGhpcykucmVuZGVyYCBpcyBjYWxsZWQuICBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGNhbiBiZVxyXG4gICAgICAvLyB1c2VkIHRvIGtub3cgd2hlbiB0aGUgZWxlbWVudCBoYXMgYmVlbiByZW5kZXJlZCBpbnRvIGl0cyBwYXJlbnQuXHJcbiAgICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGNvbnRleHQgPSByb290LnNlcmlhbGl6ZTtcclxuICAgICAgICB2YXIgdGVtcGxhdGUgPSByb290LnRlbXBsYXRlO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYSBkZWZlcnJlZCBzcGVjaWZpY2FsbHkgZm9yIGZldGNoaW5nLlxyXG4gICAgICAgIGRlZiA9IHJvb3QuZGVmZXJyZWQoKTtcclxuXHJcbiAgICAgICAgLy8gSWYgZGF0YSBpcyBhIGZ1bmN0aW9uLCBpbW1lZGlhdGVseSBjYWxsIGl0LlxyXG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oY29udGV4dCkpIHtcclxuICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LmNhbGwocm9vdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIGludGVybmFsIGNhbGxiYWNrIHRvIHRyaWdnZXIgb25jZSB0aGUgYXN5bmNocm9ub3VzIG9yXHJcbiAgICAgICAgLy8gc3luY2hyb25vdXMgYmVoYXZpb3IgaGFzIGNvbXBsZXRlZC5cclxuICAgICAgICBtYW5hZ2VyLmNhbGxiYWNrID0gZnVuY3Rpb24oY29udGVudHMpIHtcclxuICAgICAgICAgIC8vIENsZWFuIHVwIGFzeW5jaHJvbm91cyBtYW5hZ2VyIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICBkZWxldGUgbWFuYWdlci5pc0FzeW5jO1xyXG4gICAgICAgICAgZGVsZXRlIG1hbmFnZXIuY2FsbGJhY2s7XHJcblxyXG4gICAgICAgICAgZG9uZShjb250ZXh0LCBjb250ZW50cyk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gU2V0IHRoZSB1cmwgdG8gdGhlIHByZWZpeCArIHRoZSB2aWV3J3MgdGVtcGxhdGUgcHJvcGVydHkuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgdXJsID0gcm9vdC5wcmVmaXggKyB0ZW1wbGF0ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIGNvbnRlbnRzIGFyZSBhbHJlYWR5IGNhY2hlZCBhbmQgaWYgdGhleSBhcmUsIHNpbXBseSBwcm9jZXNzXHJcbiAgICAgICAgLy8gdGhlIHRlbXBsYXRlIHdpdGggdGhlIGNvcnJlY3QgZGF0YS5cclxuICAgICAgICBpZiAoY29udGVudHMgPSBMYXlvdXRNYW5hZ2VyLmNhY2hlKHVybCkpIHtcclxuICAgICAgICAgIGRvbmUoY29udGV4dCwgY29udGVudHMsIHVybCk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGRlZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEZldGNoIGxheW91dCBhbmQgdGVtcGxhdGUgY29udGVudHMuXHJcbiAgICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgY29udGVudHMgPSByb290LmZldGNoVGVtcGxhdGUuY2FsbChyb290LCByb290LnByZWZpeCArXHJcbiAgICAgICAgICAgIHRlbXBsYXRlKTtcclxuICAgICAgICAvLyBJZiB0aGUgdGVtcGxhdGUgaXMgYWxyZWFkeSBhIGZ1bmN0aW9uLCBzaW1wbHkgY2FsbCBpdC5cclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICBjb250ZW50cyA9IHRlbXBsYXRlO1xyXG4gICAgICAgIC8vIElmIGl0cyBub3QgYSBzdHJpbmcgYW5kIG5vdCB1bmRlZmluZWQsIHBhc3MgdGhlIHZhbHVlIHRvIGBmZXRjaGAuXHJcbiAgICAgICAgfSBlbHNlIGlmICh0ZW1wbGF0ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICBjb250ZW50cyA9IHJvb3QuZmV0Y2hUZW1wbGF0ZS5jYWxsKHJvb3QsIHRlbXBsYXRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSBmdW5jdGlvbiB3YXMgc3luY2hyb25vdXMsIGNvbnRpbnVlIGV4ZWN1dGlvbi5cclxuICAgICAgICBpZiAoIW1hbmFnZXIuaXNBc3luYykge1xyXG4gICAgICAgICAgZG9uZShjb250ZXh0LCBjb250ZW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0sXHJcblxyXG4gIC8vIFRoaXMgbmFtZWQgZnVuY3Rpb24gYWxsb3dzIGZvciBzaWduaWZpY2FudGx5IGVhc2llciBkZWJ1Z2dpbmcuXHJcbiAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIExheW91dChvcHRpb25zKSB7XHJcbiAgICAvLyBHcmFudCB0aGlzIFZpZXcgc3VwZXJwb3dlcnMuXHJcbiAgICB0aGlzLm1hbmFnZSA9IHRydWU7XHJcblxyXG4gICAgLy8gR2l2ZSB0aGlzIFZpZXcgYWNjZXNzIHRvIGFsbCBwYXNzZWQgb3B0aW9ucyBhcyBpbnN0YW5jZSBwcm9wZXJ0aWVzLlxyXG4gICAgXy5leHRlbmQodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgLy8gSGF2ZSBCYWNrYm9uZSBzZXQgdXAgdGhlIHJlc3Qgb2YgdGhpcyBWaWV3LlxyXG4gICAgQmFja2JvbmUuVmlldy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH0sXHJcblxyXG4gIC8vIFRoaXMgbWV0aG9kIGlzIHVzZWQgd2l0aGluIHNwZWNpZmljIG1ldGhvZHMgdG8gaW5kaWNhdGUgdGhhdCB0aGV5IHNob3VsZFxyXG4gIC8vIGJlIHRyZWF0ZWQgYXMgYXN5bmNocm9ub3VzLiAgVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aXRoaW4gdGhlXHJcbiAgLy8gcmVuZGVyIGNoYWluLCBvdGhlcndpc2UgdW5leHBlY3RlZCBiZWhhdmlvciBtYXkgb2NjdXIuXHJcbiAgYXN5bmM6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIG1hbmFnZXIgPSB0aGlzLl9fbWFuYWdlcl9fO1xyXG5cclxuICAgIC8vIFNldCB0aGlzIFZpZXcncyBhY3Rpb24gdG8gYmUgYXN5bmNocm9ub3VzLlxyXG4gICAgbWFuYWdlci5pc0FzeW5jID0gdHJ1ZTtcclxuXHJcbiAgICAvLyBSZXR1cm4gdGhlIGNhbGxiYWNrLlxyXG4gICAgcmV0dXJuIG1hbmFnZXIuY2FsbGJhY2s7XHJcbiAgfSxcclxuXHJcbiAgcHJvbWlzZTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fX21hbmFnZXJfXy5yZW5kZXJEZWZlcnJlZC5wcm9taXNlKCk7XHJcbiAgfSxcclxuXHJcbiAgLy8gUHJveHkgYHRoZW5gIGZvciBlYXNpZXIgaW52b2NhdGlvbi5cclxuICB0aGVuOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnByb21pc2UoKS50aGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfSxcclxuXHJcbiAgLy8gU29tZXRpbWVzIGl0J3MgZGVzaXJhYmxlIHRvIG9ubHkgcmVuZGVyIHRoZSBjaGlsZCB2aWV3cyB1bmRlciB0aGUgcGFyZW50LlxyXG4gIC8vIFRoaXMgaXMgdHlwaWNhbCBmb3IgYSBsYXlvdXQgdGhhdCBkb2VzIG5vdCBjaGFuZ2UuICBUaGlzIG1ldGhvZCB3aWxsXHJcbiAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBwcm92aWRlZCB2aWV3cyBvciBkZWxlZ2F0ZSB0byBgZ2V0Vmlld3NgIHRvIGZldGNoIGNoaWxkXHJcbiAgLy8gVmlld3MgYW5kIGFnZ3JlZ2F0ZSBhbGwgcmVuZGVyIHByb21pc2VzIGFuZCByZXR1cm4gdGhlIHBhcmVudCBWaWV3LlxyXG4gIC8vIFRoZSBpbnRlcm5hbCBgcHJvbWlzZSgpYCBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIGFnZ3JlZ2F0ZSBwcm9taXNlIHRoYXRcclxuICAvLyByZXNvbHZlcyBvbmNlIGFsbCBjaGlsZHJlbiBoYXZlIGNvbXBsZXRlZCB0aGVpciByZW5kZXIuXHJcbiAgcmVuZGVyVmlld3M6IGZ1bmN0aW9uKHZpZXdzKSB7XHJcbiAgICB2YXIgcm9vdCA9IHRoaXM7XHJcbiAgICB2YXIgbWFuYWdlciA9IHJvb3QuX19tYW5hZ2VyX187XHJcbiAgICB2YXIgbmV3RGVmZXJyZWQgPSByb290LmRlZmVycmVkKCk7XHJcblxyXG4gICAgLy8gSWYgdGhlIGNhbGxlciBwcm92aWRlZCBhbiBhcnJheSBvZiB2aWV3cyB0aGVuIHJlbmRlciB0aG9zZSwgb3RoZXJ3aXNlXHJcbiAgICAvLyBkZWxlZ2F0ZSB0byBnZXRWaWV3cy5cclxuICAgIGlmICh2aWV3cyAmJiBfLmlzQXJyYXkodmlld3MpKSB7XHJcbiAgICAgIHZpZXdzID0gXy5jaGFpbih2aWV3cyk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2aWV3cyA9IHJvb3QuZ2V0Vmlld3Modmlld3MpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbGxlY3QgYWxsIHByb21pc2VzIGZyb20gcmVuZGVyaW5nIHRoZSBjaGlsZCB2aWV3cyBhbmQgd2FpdCB0aWxsIHRoZXlcclxuICAgIC8vIGFsbCBjb21wbGV0ZS5cclxuICAgIHZhciBwcm9taXNlcyA9IHZpZXdzLm1hcChmdW5jdGlvbih2aWV3KSB7XHJcbiAgICAgIHJldHVybiB2aWV3LnJlbmRlcigpLl9fbWFuYWdlcl9fLnJlbmRlckRlZmVycmVkO1xyXG4gICAgfSkudmFsdWUoKTtcclxuXHJcbiAgICAvLyBTaW11bGF0ZSBhIHBhcmVudCByZW5kZXIgdG8gcmVtYWluIGNvbnNpc3RlbnQuXHJcbiAgICBtYW5hZ2VyLnJlbmRlckRlZmVycmVkID0gbmV3RGVmZXJyZWQucHJvbWlzZSgpO1xyXG5cclxuICAgIC8vIE9uY2UgYWxsIGNoaWxkIHZpZXdzIGhhdmUgY29tcGxldGVkIHJlbmRlcmluZywgcmVzb2x2ZSBwYXJlbnQgZGVmZXJyZWRcclxuICAgIC8vIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dC5cclxuICAgIHJvb3Qud2hlbihwcm9taXNlcykudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgbmV3RGVmZXJyZWQucmVzb2x2ZVdpdGgocm9vdCwgW3Jvb3RdKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEFsbG93IHRoaXMgbWV0aG9kIHRvIGJlIGNoYWluZWQuXHJcbiAgICByZXR1cm4gcm9vdDtcclxuICB9LFxyXG5cclxuICAvLyBTaG9ydGhhbmQgdG8gYHNldFZpZXdgIGZ1bmN0aW9uIHdpdGggdGhlIGBpbnNlcnRgIGZsYWcgc2V0LlxyXG4gIGluc2VydFZpZXc6IGZ1bmN0aW9uKHNlbGVjdG9yLCB2aWV3KSB7XHJcbiAgICAvLyBJZiB0aGUgYHZpZXdgIGFyZ3VtZW50IGV4aXN0cywgdGhlbiBhIHNlbGVjdG9yIHdhcyBwYXNzZWQgaW4uICBUaGlzIGNvZGVcclxuICAgIC8vIHBhdGggd2lsbCBmb3J3YXJkIHRoZSBzZWxlY3RvciBvbiB0byBgc2V0Vmlld2AuXHJcbiAgICBpZiAodmlldykge1xyXG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3KHNlbGVjdG9yLCB2aWV3LCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBubyBgdmlld2AgYXJndW1lbnQgaXMgZGVmaW5lZCwgdGhlbiBhc3N1bWUgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZVxyXG4gICAgLy8gVmlldywgc29tZXdoYXQgbm93IGNvbmZ1c2luZ2x5IG5hbWVkIGBzZWxlY3RvcmAuXHJcbiAgICByZXR1cm4gdGhpcy5zZXRWaWV3KHNlbGVjdG9yLCB0cnVlKTtcclxuICB9LFxyXG5cclxuICAvLyBJdGVyYXRlIG92ZXIgYW4gb2JqZWN0IGFuZCBlbnN1cmUgZXZlcnkgdmFsdWUgaXMgd3JhcHBlZCBpbiBhbiBhcnJheSB0b1xyXG4gIC8vIGVuc3VyZSB0aGV5IHdpbGwgYmUgaW5zZXJ0ZWQsIHRoZW4gcGFzcyB0aGF0IG9iamVjdCB0byBgc2V0Vmlld3NgLlxyXG4gIGluc2VydFZpZXdzOiBmdW5jdGlvbih2aWV3cykge1xyXG4gICAgLy8gSWYgYW4gYXJyYXkgb2Ygdmlld3Mgd2FzIHBhc3NlZCBpdCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byB0aGVcclxuICAgIC8vIHJvb3Qgdmlldy4gTXVjaCBsaWtlIGNhbGxpbmcgaW5zZXJ0VmlldyB3aXRob3V0IGEgc2VsZWN0b3IuXHJcbiAgICBpZiAoXy5pc0FycmF5KHZpZXdzKSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zZXRWaWV3cyh7IFwiXCI6IHZpZXdzIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIF8uZWFjaCh2aWV3cywgZnVuY3Rpb24odmlldywgc2VsZWN0b3IpIHtcclxuICAgICAgdmlld3Nbc2VsZWN0b3JdID0gXy5pc0FycmF5KHZpZXcpID8gdmlldyA6IFt2aWV3XTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnNldFZpZXdzKHZpZXdzKTtcclxuICB9LFxyXG5cclxuICAvLyBSZXR1cm5zIHRoZSBWaWV3IHRoYXQgbWF0Y2hlcyB0aGUgYGdldFZpZXdzYCBmaWx0ZXIgZnVuY3Rpb24uXHJcbiAgZ2V0VmlldzogZnVuY3Rpb24oZm4pIHtcclxuICAgIC8vIElmIGBnZXRWaWV3YCBpcyBpbnZva2VkIHdpdGggdW5kZWZpbmVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlbiB0aGVcclxuICAgIC8vIHNlY29uZCBhcmd1bWVudCB3aWxsIGJlIHVzZWQgaW5zdGVhZC4gIFRoaXMgaXMgdG8gYWxsb3dcclxuICAgIC8vIGBnZXRWaWV3cyh1bmRlZmluZWQsIGZuKWAgdG8gd29yayBhcyBgZ2V0Vmlld3MoZm4pYC4gIFVzZWZ1bCBmb3Igd2hlblxyXG4gICAgLy8geW91IGFyZSBhbGxvd2luZyBhbiBvcHRpb25hbCBzZWxlY3Rvci5cclxuICAgIGlmIChmbiA9PSBudWxsKSB7XHJcbiAgICAgIGZuID0gYXJndW1lbnRzWzFdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmdldFZpZXdzKGZuKS5maXJzdCgpLnZhbHVlKCk7XHJcbiAgfSxcclxuXHJcbiAgLy8gUHJvdmlkZSBhIGZpbHRlciBmdW5jdGlvbiB0byBnZXQgYSBmbGF0dGVuZWQgYXJyYXkgb2YgYWxsIHRoZSBzdWJ2aWV3cy5cclxuICAvLyBJZiB0aGUgZmlsdGVyIGZ1bmN0aW9uIGlzIG9taXR0ZWQgaXQgd2lsbCByZXR1cm4gYWxsIHN1YnZpZXdzLiAgSWYgYVxyXG4gIC8vIFN0cmluZyBpcyBwYXNzZWQgaW5zdGVhZCwgaXQgd2lsbCByZXR1cm4gdGhlIFZpZXdzIGZvciB0aGF0IHNlbGVjdG9yLlxyXG4gIGdldFZpZXdzOiBmdW5jdGlvbihmbikge1xyXG4gICAgdmFyIHZpZXdzO1xyXG5cclxuICAgIC8vIElmIHRoZSBmaWx0ZXIgYXJndW1lbnQgaXMgYSBTdHJpbmcsIHRoZW4gcmV0dXJuIGEgY2hhaW5lZCBWZXJzaW9uIG9mIHRoZVxyXG4gICAgLy8gZWxlbWVudHMuIFRoZSB2YWx1ZSBhdCB0aGUgc3BlY2lmaWVkIGZpbHRlciBtYXkgYmUgdW5kZWZpbmVkLCBhIHNpbmdsZVxyXG4gICAgLy8gdmlldywgb3IgYW4gYXJyYXkgb2Ygdmlld3M7IGluIGFsbCBjYXNlcywgY2hhaW4gb24gYSBmbGF0IGFycmF5LlxyXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICBmbiA9IHRoaXMuc2VjdGlvbnNbZm5dIHx8IGZuO1xyXG4gICAgICB2aWV3cyA9IHRoaXMudmlld3NbZm5dIHx8IFtdO1xyXG5cclxuICAgICAgLy8gSWYgVmlld3MgaXMgdW5kZWZpbmVkIHlvdSBhcmUgY29uY2F0ZW5hdGluZyBhbiBgdW5kZWZpbmVkYCB0byBhbiBhcnJheVxyXG4gICAgICAvLyByZXN1bHRpbmcgaW4gYSB2YWx1ZSBiZWluZyByZXR1cm5lZC4gIERlZmF1bHRpbmcgdG8gYW4gYXJyYXkgcHJldmVudHNcclxuICAgICAgLy8gdGhpcy5cclxuICAgICAgLy9yZXR1cm4gXy5jaGFpbihbXS5jb25jYXQodmlld3MgfHwgW10pKTtcclxuICAgICAgcmV0dXJuIF8uY2hhaW4oW10uY29uY2F0KHZpZXdzKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgYW4gYXJyYXkgb2YgYWxsIHRvcCBsZXZlbCAobm8gZGVlcGx5IG5lc3RlZCkgVmlld3MgZmxhdHRlbmVkLlxyXG4gICAgdmlld3MgPSBfLmNoYWluKHRoaXMudmlld3MpLm1hcChmdW5jdGlvbih2aWV3KSB7XHJcbiAgICAgIHJldHVybiBfLmlzQXJyYXkodmlldykgPyB2aWV3IDogW3ZpZXddO1xyXG4gICAgfSwgdGhpcykuZmxhdHRlbigpO1xyXG5cclxuICAgIC8vIElmIHRoZSBhcmd1bWVudCBwYXNzZWQgaXMgYW4gT2JqZWN0LCB0aGVuIHBhc3MgaXQgdG8gYF8ud2hlcmVgLlxyXG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICByZXR1cm4gdmlld3Mud2hlcmUoZm4pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIGEgZmlsdGVyIGZ1bmN0aW9uIGlzIHByb3ZpZGVkLCBydW4gaXQgb24gYWxsIFZpZXdzIGFuZCByZXR1cm4gYVxyXG4gICAgLy8gd3JhcHBlZCBjaGFpbi4gT3RoZXJ3aXNlLCBzaW1wbHkgcmV0dXJuIGEgd3JhcHBlZCBjaGFpbiBvZiBhbGwgVmlld3MuXHJcbiAgICByZXR1cm4gdHlwZW9mIGZuID09PSBcImZ1bmN0aW9uXCIgPyB2aWV3cy5maWx0ZXIoZm4pIDogdmlld3M7XHJcbiAgfSxcclxuXHJcbiAgLy8gVXNlIHRoaXMgdG8gcmVtb3ZlIFZpZXdzLCBpbnRlcm5hbGx5IHVzZXMgYGdldFZpZXdzYCBzbyB5b3UgY2FuIHBhc3MgdGhlXHJcbiAgLy8gc2FtZSBhcmd1bWVudCBoZXJlIGFzIHlvdSB3b3VsZCB0byB0aGF0IG1ldGhvZC5cclxuICByZW1vdmVWaWV3OiBmdW5jdGlvbihmbikge1xyXG4gICAgLy8gQWxsb3cgYW4gb3B0aW9uYWwgc2VsZWN0b3Igb3IgZnVuY3Rpb24gdG8gZmluZCB0aGUgcmlnaHQgbW9kZWwgYW5kXHJcbiAgICAvLyByZW1vdmUgbmVzdGVkIFZpZXdzIGJhc2VkIG9mZiB0aGUgcmVzdWx0cyBvZiB0aGUgc2VsZWN0b3Igb3IgZmlsdGVyLlxyXG4gICAgcmV0dXJuIHRoaXMuZ2V0Vmlld3MoZm4pLmVhY2goZnVuY3Rpb24obmVzdGVkVmlldykge1xyXG4gICAgICBuZXN0ZWRWaWV3LnJlbW92ZSgpO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgLy8gVGhpcyB0YWtlcyBpbiBhIHBhcnRpYWwgbmFtZSBhbmQgdmlldyBpbnN0YW5jZSBhbmQgYXNzaWducyB0aGVtIHRvXHJcbiAgLy8gdGhlIGludGVybmFsIGNvbGxlY3Rpb24gb2Ygdmlld3MuICBJZiBhIHZpZXcgaXMgbm90IGEgTGF5b3V0TWFuYWdlclxyXG4gIC8vIGluc3RhbmNlLCB0aGVuIG1peCBpbiB0aGUgTGF5b3V0TWFuYWdlciBwcm90b3R5cGUuICBUaGlzIGVuc3VyZXNcclxuICAvLyBhbGwgVmlld3MgY2FuIGJlIHVzZWQgc3VjY2Vzc2Z1bGx5LlxyXG4gIC8vXHJcbiAgLy8gTXVzdCBkZWZpbml0ZWx5IHdyYXAgYW55IHJlbmRlciBtZXRob2QgcGFzc2VkIGluIG9yIGRlZmF1bHRzIHRvIGFcclxuICAvLyB0eXBpY2FsIHJlbmRlciBmdW5jdGlvbiBgcmV0dXJuIGxheW91dCh0aGlzKS5yZW5kZXIoKWAuXHJcbiAgc2V0VmlldzogZnVuY3Rpb24obmFtZSwgdmlldywgaW5zZXJ0KSB7XHJcbiAgICB2YXIgbWFuYWdlciwgc2VsZWN0b3I7XHJcbiAgICAvLyBQYXJlbnQgdmlldywgdGhlIG9uZSB5b3UgYXJlIHNldHRpbmcgYSBWaWV3IG9uLlxyXG4gICAgdmFyIHJvb3QgPSB0aGlzO1xyXG5cclxuICAgIC8vIElmIG5vIG5hbWUgd2FzIHBhc3NlZCwgdXNlIGFuIGVtcHR5IHN0cmluZyBhbmQgc2hpZnQgYWxsIGFyZ3VtZW50cy5cclxuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgICBpbnNlcnQgPSB2aWV3O1xyXG4gICAgICB2aWV3ID0gbmFtZTtcclxuICAgICAgbmFtZSA9IFwiXCI7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2hvcnRoYW5kIHRoZSBgX19tYW5hZ2VyX19gIHByb3BlcnR5LlxyXG4gICAgbWFuYWdlciA9IHZpZXcuX19tYW5hZ2VyX187XHJcblxyXG4gICAgLy8gSWYgdGhlIFZpZXcgaGFzIG5vdCBiZWVuIHByb3Blcmx5IHNldCB1cCwgdGhyb3cgYW4gRXJyb3IgbWVzc2FnZVxyXG4gICAgLy8gaW5kaWNhdGluZyB0aGF0IHRoZSBWaWV3IG5lZWRzIGBtYW5hZ2U6IHRydWVgIHNldC5cclxuICAgIGlmICghbWFuYWdlcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYXJndW1lbnQgYXNzb2NpYXRlZCB3aXRoIHNlbGVjdG9yICdcIiArIG5hbWUgK1xyXG4gICAgICAgIFwiJyBpcyBkZWZpbmVkIGFuZCBhIFZpZXcuICBTZXQgYG1hbmFnZWAgcHJvcGVydHkgdG8gdHJ1ZSBmb3IgXCIgK1xyXG4gICAgICAgIFwiQmFja2JvbmUuVmlldyBpbnN0YW5jZXMuXCIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFkZCByZWZlcmVuY2UgdG8gdGhlIHBhcmVudFZpZXcuXHJcbiAgICBtYW5hZ2VyLnBhcmVudCA9IHJvb3Q7XHJcblxyXG4gICAgLy8gQWRkIHJlZmVyZW5jZSB0byB0aGUgcGxhY2VtZW50IHNlbGVjdG9yIHVzZWQuXHJcbiAgICBzZWxlY3RvciA9IG1hbmFnZXIuc2VsZWN0b3IgPSByb290LnNlY3Rpb25zW25hbWVdIHx8IG5hbWU7XHJcblxyXG4gICAgLy8gQ29kZSBwYXRoIGlzIGxlc3MgY29tcGxleCBmb3IgVmlld3MgdGhhdCBhcmUgbm90IGJlaW5nIGluc2VydGVkLiAgU2ltcGx5XHJcbiAgICAvLyByZW1vdmUgZXhpc3RpbmcgVmlld3MgYW5kIGJhaWwgb3V0IHdpdGggdGhlIGFzc2lnbm1lbnQuXHJcbiAgICBpZiAoIWluc2VydCkge1xyXG4gICAgICAvLyBFbnN1cmUgcmVtb3ZlIGlzIGNhbGxlZCBvbmx5IHdoZW4gc3dhcHBpbmcgaW4gYSBuZXcgdmlldyAod2hlbiB0aGVcclxuICAgICAgLy8gdmlldyBpcyB0aGUgc2FtZSwgaXQgZG9lcyBub3QgbmVlZCB0byBiZSByZW1vdmVkIG9yIGNsZWFuZWQgdXApLlxyXG4gICAgICBpZiAocm9vdC5nZXRWaWV3KG5hbWUpICE9PSB2aWV3KSB7XHJcbiAgICAgICAgcm9vdC5yZW1vdmVWaWV3KG5hbWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBc3NpZ24gdG8gbWFpbiB2aWV3cyBvYmplY3QgYW5kIHJldHVybiBmb3IgY2hhaW5hYmlsaXR5LlxyXG4gICAgICByZXR1cm4gcm9vdC52aWV3c1tzZWxlY3Rvcl0gPSB2aWV3O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEVuc3VyZSB0aGlzLnZpZXdzW3NlbGVjdG9yXSBpcyBhbiBhcnJheSBhbmQgcHVzaCB0aGlzIFZpZXcgdG9cclxuICAgIC8vIHRoZSBlbmQuXHJcbiAgICByb290LnZpZXdzW3NlbGVjdG9yXSA9IGFDb25jYXQuY2FsbChbXSwgcm9vdC52aWV3c1tuYW1lXSB8fCBbXSwgdmlldyk7XHJcblxyXG4gICAgLy8gUHV0IHRoZSBwYXJlbnQgdmlldyBpbnRvIGBpbnNlcnRgIG1vZGUuXHJcbiAgICByb290Ll9fbWFuYWdlcl9fLmluc2VydCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIHZpZXc7XHJcbiAgfSxcclxuXHJcbiAgLy8gQWxsb3dzIHRoZSBzZXR0aW5nIG9mIG11bHRpcGxlIHZpZXdzIGluc3RlYWQgb2YgYSBzaW5nbGUgdmlldy5cclxuICBzZXRWaWV3czogZnVuY3Rpb24odmlld3MpIHtcclxuICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHZpZXdzIGFuZCB1c2UgdGhlIFZpZXcncyB2aWV3IG1ldGhvZCB0byBhc3NpZ24uXHJcbiAgICBfLmVhY2godmlld3MsIGZ1bmN0aW9uKHZpZXcsIG5hbWUpIHtcclxuICAgICAgLy8gSWYgdGhlIHZpZXcgaXMgYW4gYXJyYXkgcHV0IGFsbCB2aWV3cyBpbnRvIGluc2VydCBtb2RlLlxyXG4gICAgICBpZiAoXy5pc0FycmF5KHZpZXcpKSB7XHJcbiAgICAgICAgcmV0dXJuIF8uZWFjaCh2aWV3LCBmdW5jdGlvbih2aWV3KSB7XHJcbiAgICAgICAgICB0aGlzLmluc2VydFZpZXcobmFtZSwgdmlldyk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEFzc2lnbiBlYWNoIHZpZXcgdXNpbmcgdGhlIHZpZXcgZnVuY3Rpb24uXHJcbiAgICAgIHRoaXMuc2V0VmlldyhuYW1lLCB2aWV3KTtcclxuICAgIH0sIHRoaXMpO1xyXG5cclxuICAgIC8vIEFsbG93IGZvciBjaGFpbmluZ1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLy8gQnkgZGVmYXVsdCB0aGlzIHNob3VsZCBmaW5kIGFsbCBuZXN0ZWQgdmlld3MgYW5kIHJlbmRlciB0aGVtIGludG9cclxuICAvLyB0aGUgdGhpcy5lbCBhbmQgY2FsbCBkb25lIG9uY2UgYWxsIG9mIHRoZW0gaGF2ZSBzdWNjZXNzZnVsbHkgYmVlblxyXG4gIC8vIHJlc29sdmVkLlxyXG4gIC8vXHJcbiAgLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IGNhbiBiZSBjaGFpbmVkIHRvIGRldGVybWluZVxyXG4gIC8vIG9uY2UgYWxsIHN1YnZpZXdzIGFuZCBtYWluIHZpZXcgaGF2ZSBiZWVuIHJlbmRlcmVkIGludG8gdGhlIHZpZXcuZWwuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciByb290ID0gdGhpcztcclxuICAgIHZhciBtYW5hZ2VyID0gcm9vdC5fX21hbmFnZXJfXztcclxuICAgIHZhciBwYXJlbnQgPSBtYW5hZ2VyLnBhcmVudDtcclxuICAgIHZhciByZW50TWFuYWdlciA9IHBhcmVudCAmJiBwYXJlbnQuX19tYW5hZ2VyX187XHJcbiAgICB2YXIgZGVmID0gcm9vdC5kZWZlcnJlZCgpO1xyXG5cclxuICAgIC8vIFRyaWdnZXJlZCBvbmNlIHRoZSByZW5kZXIgaGFzIHN1Y2NlZWRlZC5cclxuICAgIGZ1bmN0aW9uIHJlc29sdmUoKSB7XHJcblxyXG4gICAgICAvLyBJbnNlcnQgYWxsIHN1YlZpZXdzIGludG8gdGhlIHBhcmVudCBhdCBvbmNlLlxyXG4gICAgICBfLmVhY2gocm9vdC52aWV3cywgZnVuY3Rpb24odmlld3MsIHNlbGVjdG9yKSB7XHJcbiAgICAgICAgLy8gRnJhZ21lbnRzIGFyZW4ndCB1c2VkIG9uIGFycmF5cyBvZiBzdWJ2aWV3cy5cclxuICAgICAgICBpZiAoXy5pc0FycmF5KHZpZXdzKSkge1xyXG4gICAgICAgICAgcm9vdC5odG1sQmF0Y2gocm9vdCwgdmlld3MsIHNlbGVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgLy8gSWYgdGhlcmUgaXMgYSBwYXJlbnQgYW5kIHdlIHdlcmVuJ3QgYXR0YWNoZWQgdG8gaXQgdmlhIHRoZSBwcmV2aW91c1xyXG4gICAgICAvLyBtZXRob2QgKHNpbmdsZSB2aWV3KSwgYXR0YWNoLlxyXG4gICAgICBpZiAocGFyZW50ICYmICFtYW5hZ2VyLmluc2VydGVkVmlhRnJhZ21lbnQpIHtcclxuICAgICAgICBpZiAoIXJvb3QuY29udGFpbnMocGFyZW50LmVsLCByb290LmVsKSkge1xyXG4gICAgICAgICAgLy8gQXBwbHkgdGhlIHBhcnRpYWwgdXNpbmcgcGFyZW50J3MgaHRtbCgpIG1ldGhvZC5cclxuICAgICAgICAgIHBhcmVudC5wYXJ0aWFsKHBhcmVudC4kZWwsIHJvb3QuJGVsLCByZW50TWFuYWdlciwgbWFuYWdlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBFbnN1cmUgZXZlbnRzIGFyZSBhbHdheXMgY29ycmVjdGx5IGJvdW5kIGFmdGVyIHJlbmRlcmluZy5cclxuICAgICAgcm9vdC5kZWxlZ2F0ZUV2ZW50cygpO1xyXG5cclxuICAgICAgLy8gU2V0IHRoaXMgVmlldyBhcyBzdWNjZXNzZnVsbHkgcmVuZGVyZWQuXHJcbiAgICAgIHJvb3QuaGFzUmVuZGVyZWQgPSB0cnVlO1xyXG4gICAgICBtYW5hZ2VyLnJlbmRlckluUHJvZ3Jlc3MgPSBmYWxzZTtcclxuXHJcbiAgICAgIC8vIENsZWFyIHRyaWdnZXJlZEJ5UkFGIGZsYWcuXHJcbiAgICAgIGRlbGV0ZSBtYW5hZ2VyLnRyaWdnZXJlZEJ5UkFGO1xyXG5cclxuICAgICAgLy8gT25seSBwcm9jZXNzIHRoZSBxdWV1ZSBpZiBpdCBleGlzdHMuXHJcbiAgICAgIGlmIChtYW5hZ2VyLnF1ZXVlICYmIG1hbmFnZXIucXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIG5leHQgcmVuZGVyIGlzIG9ubHkgY2FsbGVkIGFmdGVyIGFsbCBvdGhlclxyXG4gICAgICAgIC8vIGBkb25lYCBoYW5kbGVycyBoYXZlIGNvbXBsZXRlZC4gIFRoaXMgd2lsbCBwcmV2ZW50IGByZW5kZXJgXHJcbiAgICAgICAgLy8gY2FsbGJhY2tzIGZyb20gZmlyaW5nIG91dCBvZiBvcmRlci5cclxuICAgICAgICAobWFuYWdlci5xdWV1ZS5zaGlmdCgpKSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE9uY2UgdGhlIHF1ZXVlIGlzIGRlcGxldGVkLCByZW1vdmUgaXQsIHRoZSByZW5kZXIgcHJvY2VzcyBoYXNcclxuICAgICAgICAvLyBjb21wbGV0ZWQuXHJcbiAgICAgICAgZGVsZXRlIG1hbmFnZXIucXVldWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJldXNhYmxlIGZ1bmN0aW9uIGZvciB0cmlnZ2VyaW5nIHRoZSBhZnRlclJlbmRlciBjYWxsYmFjayBhbmQgZXZlbnQuXHJcbiAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlUmVuZGVyKCkge1xyXG4gICAgICAgIHZhciBjb25zb2xlID0gd2luZG93LmNvbnNvbGU7XHJcbiAgICAgICAgdmFyIGFmdGVyUmVuZGVyID0gcm9vdC5hZnRlclJlbmRlcjtcclxuXHJcbiAgICAgICAgaWYgKGFmdGVyUmVuZGVyKSB7XHJcbiAgICAgICAgICBhZnRlclJlbmRlci5jYWxsKHJvb3QsIHJvb3QpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWx3YXlzIGVtaXQgYW4gYWZ0ZXJSZW5kZXIgZXZlbnQuXHJcbiAgICAgICAgcm9vdC50cmlnZ2VyKFwiYWZ0ZXJSZW5kZXJcIiwgcm9vdCk7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSB0b3AgbGV2ZWwgZWxlbWVudHMgYW5kIGBlbDogZmFsc2VgIGlzIHVzZWQsXHJcbiAgICAgICAgLy8gZGlzcGxheSBhIHdhcm5pbmcgbWVzc2FnZSBhbmQgYSBzdGFjayB0cmFjZS5cclxuICAgICAgICBpZiAobWFuYWdlci5ub2VsICYmIHJvb3QuJGVsLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgIC8vIERvIG5vdCBkaXNwbGF5IGEgd2FybmluZyB3aGlsZSB0ZXN0aW5nIG9yIGlmIHdhcm5pbmcgc3VwcHJlc3Npb25cclxuICAgICAgICAgIC8vIGlzIGVuYWJsZWQuXHJcbiAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNvbnNvbGUud2FybikgJiYgIXJvb3Quc3VwcHJlc3NXYXJuaW5ncykge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJgZWw6IGZhbHNlYCB3aXRoIG11bHRpcGxlIHRvcCBsZXZlbCBlbGVtZW50cyBpcyBcIiArXHJcbiAgICAgICAgICAgICAgXCJub3Qgc3VwcG9ydGVkLlwiKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFByb3ZpZGUgYSBzdGFjayB0cmFjZSBpZiBhdmFpbGFibGUgdG8gYWlkIHdpdGggZGVidWdnaW5nLlxyXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKGNvbnNvbGUudHJhY2UpKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS50cmFjZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB0aGUgcGFyZW50IGlzIGN1cnJlbnRseSByZW5kZXJpbmcsIHdhaXQgdW50aWwgaXQgaGFzIGNvbXBsZXRlZFxyXG4gICAgICAvLyB1bnRpbCBjYWxsaW5nIHRoZSBuZXN0ZWQgVmlldydzIGBhZnRlclJlbmRlcmAuXHJcbiAgICAgIGlmIChyZW50TWFuYWdlciAmJiAocmVudE1hbmFnZXIucmVuZGVySW5Qcm9ncmVzcyB8fCByZW50TWFuYWdlci5xdWV1ZSkpIHtcclxuICAgICAgICAvLyBXYWl0IHVudGlsIHRoZSBwYXJlbnQgVmlldyBoYXMgZmluaXNoZWQgcmVuZGVyaW5nLCB3aGljaCBjb3VsZCBiZVxyXG4gICAgICAgIC8vIGFzeW5jaHJvbm91cywgYW5kIHRyaWdnZXIgYWZ0ZXJSZW5kZXIgb24gdGhpcyBWaWV3IG9uY2UgaXQgaGFzXHJcbiAgICAgICAgLy8gY29tcGxldGVkLlxyXG4gICAgICAgIHBhcmVudC5vbmNlKFwiYWZ0ZXJSZW5kZXJcIiwgY29tcGxldGVSZW5kZXIpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIFRoaXMgVmlldyBhbmQgaXRzIHBhcmVudCBoYXZlIGJvdGggcmVuZGVyZWQuXHJcbiAgICAgICAgY29tcGxldGVSZW5kZXIoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGRlZi5yZXNvbHZlV2l0aChyb290LCBbcm9vdF0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFjdHVhbGx5IGZhY2lsaXRhdGUgYSByZW5kZXIuXHJcbiAgICBmdW5jdGlvbiBhY3R1YWxseVJlbmRlcigpIHtcclxuXHJcbiAgICAgIC8vIFRoZSBgX3ZpZXdSZW5kZXJgIG1ldGhvZCBpcyBicm9rZW4gb3V0IHRvIGFic3RyYWN0IGF3YXkgZnJvbSBoYXZpbmdcclxuICAgICAgLy8gdG9vIG11Y2ggY29kZSBpbiBgYWN0dWFsbHlSZW5kZXJgLlxyXG4gICAgICByb290Ll9yZW5kZXIoKS5kb25lKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBjaGlsZHJlbiB0byB3b3JyeSBhYm91dCwgY29tcGxldGUgdGhlIHJlbmRlclxyXG4gICAgICAgIC8vIGluc3RhbnRseS5cclxuICAgICAgICBpZiAoIV8ua2V5cyhyb290LnZpZXdzKS5sZW5ndGgpIHtcclxuICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYSBsaXN0IG9mIHByb21pc2VzIHRvIHdhaXQgb24gdW50aWwgcmVuZGVyaW5nIGlzIGRvbmUuXHJcbiAgICAgICAgLy8gU2luY2UgdGhpcyBtZXRob2Qgd2lsbCBydW4gb24gYWxsIGNoaWxkcmVuIGFzIHdlbGwsIGl0cyBzdWZmaWNpZW50XHJcbiAgICAgICAgLy8gZm9yIGEgZnVsbCBoaWVyYXJjaGljYWwuXHJcbiAgICAgICAgdmFyIHByb21pc2VzID0gXy5tYXAocm9vdC52aWV3cywgZnVuY3Rpb24odmlldykge1xyXG4gICAgICAgICAgdmFyIGluc2VydCA9IF8uaXNBcnJheSh2aWV3KTtcclxuXHJcbiAgICAgICAgICAvLyBJZiBpdGVtcyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIHRoZXkgd2lsbCBiZSBpbiBhIG5vbi16ZXJvIGxlbmd0aFxyXG4gICAgICAgICAgLy8gQXJyYXkuXHJcbiAgICAgICAgICBpZiAoaW5zZXJ0ICYmIHZpZXcubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIE1hcmsgZWFjaCBzdWJ2aWV3J3MgbWFuYWdlciBzbyB0aGV5IGRvbid0IGF0dGVtcHQgdG8gYXR0YWNoIGJ5XHJcbiAgICAgICAgICAgIC8vIHRoZW1zZWx2ZXMuICBSZXR1cm4gYSBzaW5nbGUgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIGVudGlyZVxyXG4gICAgICAgICAgICAvLyByZW5kZXIuXHJcbiAgICAgICAgICAgIHJldHVybiByb290LndoZW4oXy5tYXAodmlldywgZnVuY3Rpb24oc3ViVmlldykge1xyXG4gICAgICAgICAgICAgIHN1YlZpZXcuX19tYW5hZ2VyX18uaW5zZXJ0ZWRWaWFGcmFnbWVudCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIHN1YlZpZXcucmVuZGVyKCkuX19tYW5hZ2VyX18ucmVuZGVyRGVmZXJyZWQ7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBPbmx5IHJldHVybiB0aGUgZmV0Y2ggZGVmZXJyZWQsIHJlc29sdmUgdGhlIG1haW4gZGVmZXJyZWQgYWZ0ZXJcclxuICAgICAgICAgIC8vIHRoZSBlbGVtZW50IGhhcyBiZWVuIGF0dGFjaGVkIHRvIGl0J3MgcGFyZW50LlxyXG4gICAgICAgICAgcmV0dXJuICFpbnNlcnQgPyB2aWV3LnJlbmRlcigpLl9fbWFuYWdlcl9fLnJlbmRlckRlZmVycmVkIDogdmlldztcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gT25jZSBhbGwgbmVzdGVkIFZpZXdzIGhhdmUgYmVlbiByZW5kZXJlZCwgcmVzb2x2ZSB0aGlzIFZpZXcnc1xyXG4gICAgICAgIC8vIGRlZmVycmVkLlxyXG4gICAgICAgIHJvb3Qud2hlbihwcm9taXNlcykuZG9uZShyZXNvbHZlKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFyayB0aGlzIHJlbmRlciBhcyBpbiBwcm9ncmVzcy4gVGhpcyB3aWxsIHByZXZlbnRcclxuICAgIC8vIGFmdGVyUmVuZGVyIGZyb20gYmVpbmcgZmlyZWQgdW50aWwgdGhlIGVudGlyZSBjaGFpbiBoYXMgcmVuZGVyZWQuXHJcbiAgICBtYW5hZ2VyLnJlbmRlckluUHJvZ3Jlc3MgPSB0cnVlO1xyXG5cclxuICAgIC8vIFN0YXJ0IHRoZSByZW5kZXIuXHJcbiAgICAvLyBSZWdpc3RlciB0aGlzIHJlcXVlc3QgJiBjYW5jZWwgYW55IHRoYXQgY29uZmxpY3QuXHJcbiAgICByb290Ll9yZWdpc3RlcldpdGhSQUYoYWN0dWFsbHlSZW5kZXIsIGRlZik7XHJcblxyXG4gICAgLy8gUHV0IHRoZSBkZWZlcnJlZCBpbnNpZGUgb2YgdGhlIGBfX21hbmFnZXJfX2Agb2JqZWN0LCBzaW5jZSB3ZSBkb24ndCB3YW50XHJcbiAgICAvLyBlbmQgdXNlcnMgYWNjZXNzaW5nIHRoaXMgZGlyZWN0bHkgYW55bW9yZSBpbiBmYXZvciBvZiB0aGUgYGFmdGVyUmVuZGVyYFxyXG4gICAgLy8gZXZlbnQuICBTbyBpbnN0ZWFkIG9mIGRvaW5nIGByZW5kZXIoKS50aGVuKC4uLmAgZG9cclxuICAgIC8vIGByZW5kZXIoKS5vbmNlKFwiYWZ0ZXJSZW5kZXJcIiwgLi4uYC5cclxuICAgIC8vIEZJWE1FOiBJIHRoaW5rIHdlIG5lZWQgdG8gbW92ZSBiYWNrIHRvIHByb21pc2VzIHNvIHRoYXQgd2UgZG9uJ3RcclxuICAgIC8vIG1pc3MgZXZlbnRzLCByZWdhcmRsZXNzIG9mIHN5bmMvYXN5bmMgKHVzZVJBRiBzZXR0aW5nKVxyXG4gICAgbWFuYWdlci5yZW5kZXJEZWZlcnJlZCA9IGRlZjtcclxuXHJcbiAgICAvLyBSZXR1cm4gdGhlIGFjdHVhbCBWaWV3IGZvciBjaGFpbmFiaWxpdHkgcHVycG9zZXMuXHJcbiAgICByZXR1cm4gcm9vdDtcclxuICB9LFxyXG5cclxuICAvLyBFbnN1cmUgdGhlIGNsZWFudXAgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIHJlbW92ZSBpcyBjYWxsZWQuXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgIC8vIEZvcmNlIHJlbW92ZSBpdHNlbGYgZnJvbSBpdHMgcGFyZW50LlxyXG4gICAgTGF5b3V0TWFuYWdlci5fcmVtb3ZlVmlldyh0aGlzLCB0cnVlKTtcclxuXHJcbiAgICAvLyBDYWxsIHRoZSBvcmlnaW5hbCByZW1vdmUgZnVuY3Rpb24uXHJcbiAgICByZXR1cm4gdGhpcy5fcmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfSxcclxuXHJcbiAgLy8gUmVnaXN0ZXIgYSB2aWV3IHJlbmRlciB3aXRoIFJBRi5cclxuICBfcmVnaXN0ZXJXaXRoUkFGOiBmdW5jdGlvbihjYWxsYmFjaywgZGVmZXJyZWQpIHtcclxuICAgIHZhciByb290ID0gdGhpcztcclxuICAgIHZhciBtYW5hZ2VyID0gcm9vdC5fX21hbmFnZXJfXztcclxuICAgIHZhciByZW50TWFuYWdlciA9IG1hbmFnZXIucGFyZW50ICYmIG1hbmFnZXIucGFyZW50Ll9fbWFuYWdlcl9fO1xyXG5cclxuICAgIC8vIEFsbG93IFJBRiBwcm9jZXNzaW5nIHRvIGJlIHNodXQgb2ZmIHVzaW5nIGB1c2VSQUZgOmZhbHNlLlxyXG4gICAgaWYgKHRoaXMudXNlUkFGID09PSBmYWxzZSkge1xyXG4gICAgICBpZiAobWFuYWdlci5xdWV1ZSkge1xyXG4gICAgICAgIGFQdXNoLmNhbGwobWFuYWdlci5xdWV1ZSwgY2FsbGJhY2spO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1hbmFnZXIucXVldWUgPSBbXTtcclxuICAgICAgICBjYWxsYmFjaygpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBLZWVwIHRyYWNrIG9mIGFsbCBkZWZlcnJlZHMgc28gd2UgY2FuIHJlc29sdmUgdGhlbS5cclxuICAgIG1hbmFnZXIuZGVmZXJyZWRzID0gbWFuYWdlci5kZWZlcnJlZHMgfHwgW107XHJcbiAgICBtYW5hZ2VyLmRlZmVycmVkcy5wdXNoKGRlZmVycmVkKTtcclxuXHJcbiAgICAvLyBTY2hlZHVsZSByZXNvbHZpbmcgYWxsIGRlZmVycmVkcyB0aGF0IGFyZSB3YWl0aW5nLlxyXG4gICAgZGVmZXJyZWQuZG9uZShyZXNvbHZlRGVmZXJyZWRzKTtcclxuXHJcbiAgICAvLyBDYW5jZWwgYW55IG90aGVyIHJlbmRlcnMgb24gdGhpcyB2aWV3IHRoYXQgYXJlIHF1ZXVlZCB0byBleGVjdXRlLlxyXG4gICAgdGhpcy5fY2FuY2VsUXVldWVkUkFGUmVuZGVyKCk7XHJcblxyXG4gICAgLy8gVHJpZ2dlciBpbW1lZGlhdGVseSBpZiB0aGUgcGFyZW50IHdhcyB0cmlnZ2VyZWQgYnkgUkFGLlxyXG4gICAgLy8gVGhlIGZsYWcgcHJvcGFnYXRlcyBkb3dud2FyZCBzbyB0aGlzIHZpZXcncyBjaGlsZHJlbiBhcmUgYWxzb1xyXG4gICAgLy8gcmVuZGVyZWQgaW1tZWRpYXRlbHkuXHJcbiAgICBpZiAocmVudE1hbmFnZXIgJiYgcmVudE1hbmFnZXIudHJpZ2dlcmVkQnlSQUYpIHtcclxuICAgICAgcmV0dXJuIGZpbmlzaCgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlZ2lzdGVyIHRoaXMgcmVxdWVzdCB3aXRoIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cclxuICAgIG1hbmFnZXIucmFmSUQgPSByb290LnJlcXVlc3RBbmltYXRpb25GcmFtZShmaW5pc2gpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHtcclxuICAgICAgLy8gUmVtb3ZlIHRoaXMgSUQgYXMgaXQgaXMgbm8gbG9uZ2VyIHZhbGlkLlxyXG4gICAgICBtYW5hZ2VyLnJhZklEID0gbnVsbDtcclxuXHJcbiAgICAgIC8vIFNldCBmbGFnICh3aWxsIHByb3BhZ2F0ZSB0byBjaGlsZHJlbikgc28gdGhleSByZW5kZXJcclxuICAgICAgLy8gd2l0aG91dCB3YWl0aW5nIGZvciBSQUYuXHJcbiAgICAgIG1hbmFnZXIudHJpZ2dlcmVkQnlSQUYgPSB0cnVlO1xyXG5cclxuICAgICAgLy8gQ2FsbCBvcmlnaW5hbCBjYi5cclxuICAgICAgY2FsbGJhY2soKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNvbHZlIGFsbCBkZWZlcnJlZHMgdGhhdCB3ZXJlIGNhbmNlbGxlZCBwcmV2aW91c2x5LCBpZiBhbnkuXHJcbiAgICAvLyBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBiaW5kIGNhbGxiYWNrcyB0byBhbnkgcmVuZGVyIGNhbGxiYWNrLFxyXG4gICAgLy8gZXZlbiBpZiBpdCB3YXMgY2FuY2VsbGVkIGFib3ZlLlxyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZURlZmVycmVkcygpIHtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYW5hZ2VyLmRlZmVycmVkcy5sZW5ndGg7IGkrKyl7XHJcbiAgICAgICAgbWFuYWdlci5kZWZlcnJlZHNbaV0ucmVzb2x2ZVdpdGgocm9vdCwgW3Jvb3RdKTtcclxuICAgICAgfVxyXG4gICAgICBtYW5hZ2VyLmRlZmVycmVkcyA9IFtdO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8vIENhbmNlbCBhbnkgcXVldWVkIHJlbmRlciByZXF1ZXN0cy5cclxuICBfY2FuY2VsUXVldWVkUkFGUmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciByb290ID0gdGhpcztcclxuICAgIHZhciBtYW5hZ2VyID0gcm9vdC5fX21hbmFnZXJfXztcclxuICAgIGlmIChtYW5hZ2VyLnJhZklEICE9IG51bGwpIHtcclxuICAgICAgcm9vdC5jYW5jZWxBbmltYXRpb25GcmFtZShtYW5hZ2VyLnJhZklEKTtcclxuICAgIH1cclxuICB9XHJcbn0sXHJcblxyXG4vLyBTdGF0aWMgUHJvcGVydGllc1xyXG57XHJcbiAgLy8gQ2xlYXJhYmxlIGNhY2hlLlxyXG4gIF9jYWNoZToge30sXHJcblxyXG4gIC8vIFJlbW92ZSBhbGwgbmVzdGVkIFZpZXdzLlxyXG4gIF9yZW1vdmVWaWV3czogZnVuY3Rpb24ocm9vdCwgZm9yY2UpIHtcclxuICAgIC8vIFNoaWZ0IGFyZ3VtZW50cyBhcm91bmQuXHJcbiAgICBpZiAodHlwZW9mIHJvb3QgPT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgIGZvcmNlID0gcm9vdDtcclxuICAgICAgcm9vdCA9IHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWxsb3cgcmVtb3ZlVmlldyB0byBiZSBjYWxsZWQgb24gaW5zdGFuY2VzLlxyXG4gICAgcm9vdCA9IHJvb3QgfHwgdGhpcztcclxuXHJcbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIG9mIHRoZSBuZXN0ZWQgVmlldydzIGFuZCByZW1vdmUuXHJcbiAgICByb290LmdldFZpZXdzKCkuZWFjaChmdW5jdGlvbih2aWV3KSB7XHJcbiAgICAgIC8vIEZvcmNlIGRvZXNuJ3QgY2FyZSBhYm91dCBpZiBhIFZpZXcgaGFzIHJlbmRlcmVkIG9yIG5vdC5cclxuICAgICAgaWYgKHZpZXcuaGFzUmVuZGVyZWQgfHwgZm9yY2UpIHtcclxuICAgICAgICBMYXlvdXRNYW5hZ2VyLl9yZW1vdmVWaWV3KHZpZXcsIGZvcmNlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgLy8gUmVtb3ZlIGEgc2luZ2xlIG5lc3RlZCBWaWV3LlxyXG4gIF9yZW1vdmVWaWV3OiBmdW5jdGlvbih2aWV3LCBmb3JjZSkge1xyXG4gICAgdmFyIHBhcmVudFZpZXdzO1xyXG4gICAgLy8gU2hvcnRoYW5kIHRoZSBtYW5hZ2VycyBmb3IgZWFzaWVyIGFjY2Vzcy5cclxuICAgIHZhciBtYW5hZ2VyID0gdmlldy5fX21hbmFnZXJfXztcclxuICAgIHZhciByZW50TWFuYWdlciA9IG1hbmFnZXIucGFyZW50ICYmIG1hbmFnZXIucGFyZW50Ll9fbWFuYWdlcl9fO1xyXG4gICAgLy8gVGVzdCBmb3Iga2VlcC5cclxuICAgIHZhciBrZWVwID0gdHlwZW9mIHZpZXcua2VlcCA9PT0gXCJib29sZWFuXCIgPyB2aWV3LmtlZXAgOiB2aWV3Lm9wdGlvbnMua2VlcDtcclxuXHJcbiAgICAvLyBJbiBpbnNlcnQgbW9kZSwgcmVtb3ZlIHZpZXdzIHRoYXQgZG8gbm90IGhhdmUgYGtlZXBgIGF0dHJpYnV0ZSBzZXQsXHJcbiAgICAvLyB1bmxlc3MgdGhlIGZvcmNlIGZsYWcgaXMgc2V0LlxyXG4gICAgaWYgKCgha2VlcCAmJiByZW50TWFuYWdlciAmJiByZW50TWFuYWdlci5pbnNlcnQgPT09IHRydWUpIHx8IGZvcmNlKSB7XHJcbiAgICAgIC8vIENsZWFuIG91dCB0aGUgZXZlbnRzLlxyXG4gICAgICBMYXlvdXRNYW5hZ2VyLmNsZWFuVmlld3Modmlldyk7XHJcblxyXG4gICAgICAvLyBTaW5jZSB3ZSBhcmUgcmVtb3ZpbmcgdGhpcyB2aWV3LCBmb3JjZSBzdWJ2aWV3cyB0byByZW1vdmVcclxuICAgICAgdmlldy5fcmVtb3ZlVmlld3ModHJ1ZSk7XHJcblxyXG4gICAgICAvLyBSZW1vdmUgdGhlIFZpZXcgY29tcGxldGVseS5cclxuICAgICAgdmlldy4kZWwucmVtb3ZlKCk7XHJcblxyXG4gICAgICAvLyBDYW5jZWwgYW55IHBlbmRpbmcgcmVuZGVycywgaWYgcHJlc2VudC5cclxuICAgICAgdmlldy5fY2FuY2VsUXVldWVkUkFGUmVuZGVyKCk7XHJcblxyXG4gICAgICAvLyBCYWlsIG91dCBlYXJseSBpZiBubyBwYXJlbnQgZXhpc3RzLlxyXG4gICAgICBpZiAoIW1hbmFnZXIucGFyZW50KSB7IHJldHVybjsgfVxyXG5cclxuICAgICAgLy8gQXNzaWduIChpZiB0aGV5IGV4aXN0KSB0aGUgc2libGluZyBWaWV3cyB0byBhIHByb3BlcnR5LlxyXG4gICAgICBwYXJlbnRWaWV3cyA9IG1hbmFnZXIucGFyZW50LnZpZXdzW21hbmFnZXIuc2VsZWN0b3JdO1xyXG5cclxuICAgICAgLy8gSWYgdGhpcyBpcyBhbiBhcnJheSBvZiBpdGVtcyByZW1vdmUgaXRlbXMgdGhhdCBhcmUgbm90IG1hcmtlZCB0b1xyXG4gICAgICAvLyBrZWVwLlxyXG4gICAgICBpZiAoXy5pc0FycmF5KHBhcmVudFZpZXdzKSkge1xyXG4gICAgICAgIC8vIFJlbW92ZSBkdXBsaWNhdGUgVmlld3MuXHJcbiAgICAgICAgcmV0dXJuIF8uZWFjaChfLmNsb25lKHBhcmVudFZpZXdzKSwgZnVuY3Rpb24odmlldywgaSkge1xyXG4gICAgICAgICAgLy8gSWYgdGhlIG1hbmFnZXJzIG1hdGNoLCBzcGxpY2Ugb2ZmIHRoaXMgVmlldy5cclxuICAgICAgICAgIGlmICh2aWV3ICYmIHZpZXcuX19tYW5hZ2VyX18gPT09IG1hbmFnZXIpIHtcclxuICAgICAgICAgICAgYVNwbGljZS5jYWxsKHBhcmVudFZpZXdzLCBpLCAxKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gT3RoZXJ3aXNlIGRlbGV0ZSB0aGUgcGFyZW50IHNlbGVjdG9yLlxyXG4gICAgICBkZWxldGUgbWFuYWdlci5wYXJlbnQudmlld3NbbWFuYWdlci5zZWxlY3Rvcl07XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gQ2FjaGUgdGVtcGxhdGVzIGludG8gTGF5b3V0TWFuYWdlci5fY2FjaGUuXHJcbiAgY2FjaGU6IGZ1bmN0aW9uKHBhdGgsIGNvbnRlbnRzKSB7XHJcbiAgICAvLyBJZiB0ZW1wbGF0ZSBwYXRoIGlzIGZvdW5kIGluIHRoZSBjYWNoZSwgcmV0dXJuIHRoZSBjb250ZW50cy5cclxuICAgIGlmIChwYXRoIGluIHRoaXMuX2NhY2hlICYmIGNvbnRlbnRzID09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW3BhdGhdO1xyXG4gICAgLy8gRW5zdXJlIHBhdGggYW5kIGNvbnRlbnRzIGFyZW4ndCB1bmRlZmluZWQuXHJcbiAgICB9IGVsc2UgaWYgKHBhdGggIT0gbnVsbCAmJiBjb250ZW50cyAhPSBudWxsKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZVtwYXRoXSA9IGNvbnRlbnRzO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZSB0ZW1wbGF0ZSBpcyBub3QgaW4gdGhlIGNhY2hlLCByZXR1cm4gdW5kZWZpbmVkLlxyXG4gIH0sXHJcblxyXG4gIC8vIEFjY2VwdCBlaXRoZXIgYSBzaW5nbGUgdmlldyBvciBhbiBhcnJheSBvZiB2aWV3cyB0byBjbGVhbiBvZiBhbGwgRE9NXHJcbiAgLy8gZXZlbnRzIGludGVybmFsIG1vZGVsIGFuZCBjb2xsZWN0aW9uIHJlZmVyZW5jZXMgYW5kIGFsbCBCYWNrYm9uZS5FdmVudHMuXHJcbiAgY2xlYW5WaWV3czogZnVuY3Rpb24odmlld3MpIHtcclxuICAgIC8vIENsZWFyIG91dCBhbGwgZXhpc3Rpbmcgdmlld3MuXHJcbiAgICBfLmVhY2goYUNvbmNhdC5jYWxsKFtdLCB2aWV3cyksIGZ1bmN0aW9uKHZpZXcpIHtcclxuICAgICAgLy8gUmVtb3ZlIGFsbCBjdXN0b20gZXZlbnRzIGF0dGFjaGVkIHRvIHRoaXMgVmlldy5cclxuICAgICAgdmlldy51bmJpbmQoKTtcclxuXHJcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgdW5iaW5kIGBtb2RlbGAuXHJcbiAgICAgIGlmICh2aWV3Lm1vZGVsIGluc3RhbmNlb2YgQmFja2JvbmUuTW9kZWwpIHtcclxuICAgICAgICB2aWV3Lm1vZGVsLm9mZihudWxsLCBudWxsLCB2aWV3KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQXV0b21hdGljYWxseSB1bmJpbmQgYGNvbGxlY3Rpb25gLlxyXG4gICAgICBpZiAodmlldy5jb2xsZWN0aW9uIGluc3RhbmNlb2YgQmFja2JvbmUuQ29sbGVjdGlvbikge1xyXG4gICAgICAgIHZpZXcuY29sbGVjdGlvbi5vZmYobnVsbCwgbnVsbCwgdmlldyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgdW5iaW5kIGV2ZW50cyBib3VuZCB0byB0aGlzIFZpZXcuXHJcbiAgICAgIHZpZXcuc3RvcExpc3RlbmluZygpO1xyXG5cclxuICAgICAgLy8gSWYgYSBjdXN0b20gY2xlYW51cCBtZXRob2Qgd2FzIHByb3ZpZGVkIG9uIHRoZSB2aWV3LCBjYWxsIGl0IGFmdGVyXHJcbiAgICAgIC8vIHRoZSBpbml0aWFsIGNsZWFudXAgaXMgZG9uZVxyXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKHZpZXcuY2xlYW51cCkpIHtcclxuICAgICAgICB2aWV3LmNsZWFudXAoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgLy8gVGhpcyBzdGF0aWMgbWV0aG9kIGFsbG93cyBmb3IgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb2YgTGF5b3V0TWFuYWdlci5cclxuICBjb25maWd1cmU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIF8uZXh0ZW5kKExheW91dE1hbmFnZXIucHJvdG90eXBlLCBvcHRpb25zKTtcclxuXHJcbiAgICAvLyBBbGxvdyBMYXlvdXRNYW5hZ2VyIHRvIG1hbmFnZSBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5cclxuICAgIGlmIChvcHRpb25zLm1hbmFnZSkge1xyXG4gICAgICBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5tYW5hZ2UgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERpc2FibGUgdGhlIGVsZW1lbnQgZ2xvYmFsbHkuXHJcbiAgICBpZiAob3B0aW9ucy5lbCA9PT0gZmFsc2UpIHtcclxuICAgICAgQmFja2JvbmUuVmlldy5wcm90b3R5cGUuZWwgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBbGxvdyBnbG9iYWwgY29uZmlndXJhdGlvbiBvZiBgc3VwcHJlc3NXYXJuaW5nc2AuXHJcbiAgICBpZiAob3B0aW9ucy5zdXBwcmVzc1dhcm5pbmdzID09PSB0cnVlKSB7XHJcbiAgICAgIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnN1cHByZXNzV2FybmluZ3MgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEFsbG93IGdsb2JhbCBjb25maWd1cmF0aW9uIG9mIGB1c2VSQUZgLlxyXG4gICAgaWYgKG9wdGlvbnMudXNlUkFGID09PSBmYWxzZSkge1xyXG4gICAgICBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS51c2VSQUYgPSBmYWxzZTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvLyBDb25maWd1cmUgYSBWaWV3IHRvIHdvcmsgd2l0aCB0aGUgTGF5b3V0TWFuYWdlciBwbHVnaW4uXHJcbiAgc2V0dXBWaWV3OiBmdW5jdGlvbih2aWV3cywgb3B0aW9ucykge1xyXG4gICAgLy8gRW5zdXJlIHRoYXQgb3B0aW9ucyBpcyBhbHdheXMgYW4gb2JqZWN0LCBhbmQgY2xvbmUgaXQgc28gdGhhdFxyXG4gICAgLy8gY2hhbmdlcyB0byB0aGUgb3JpZ2luYWwgb2JqZWN0IGRvbid0IHNjcmV3IHVwIHRoaXMgdmlldy5cclxuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7fSwgb3B0aW9ucyk7XHJcblxyXG4gICAgLy8gU2V0IHVwIGFsbCBWaWV3cyBwYXNzZWQuXHJcbiAgICBfLmVhY2goYUNvbmNhdC5jYWxsKFtdLCB2aWV3cyksIGZ1bmN0aW9uKHZpZXcpIHtcclxuICAgICAgLy8gSWYgdGhlIFZpZXcgaGFzIGFscmVhZHkgYmVlbiBzZXR1cCwgbm8gbmVlZCB0byBkbyBpdCBhZ2Fpbi5cclxuICAgICAgaWYgKHZpZXcuX19tYW5hZ2VyX18pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciB2aWV3cywgZGVjbGFyZWRWaWV3cztcclxuICAgICAgdmFyIHByb3RvID0gTGF5b3V0TWFuYWdlci5wcm90b3R5cGU7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgbmVjZXNzYXJ5IHByb3BlcnRpZXMgYXJlIHNldC5cclxuICAgICAgXy5kZWZhdWx0cyh2aWV3LCB7XHJcbiAgICAgICAgLy8gRW5zdXJlIGEgdmlldyBhbHdheXMgaGFzIGEgdmlld3Mgb2JqZWN0LlxyXG4gICAgICAgIHZpZXdzOiB7fSxcclxuXHJcbiAgICAgICAgLy8gRW5zdXJlIGEgdmlldyBhbHdheXMgaGFzIGEgc2VjdGlvbnMgb2JqZWN0LlxyXG4gICAgICAgIHNlY3Rpb25zOiB7fSxcclxuXHJcbiAgICAgICAgLy8gSW50ZXJuYWwgc3RhdGUgb2JqZWN0IHVzZWQgdG8gc3RvcmUgd2hldGhlciBvciBub3QgYSBWaWV3IGhhcyBiZWVuXHJcbiAgICAgICAgLy8gdGFrZW4gb3ZlciBieSBsYXlvdXQgbWFuYWdlciBhbmQgaWYgaXQgaGFzIGJlZW4gcmVuZGVyZWQgaW50byB0aGVcclxuICAgICAgICAvLyBET00uXHJcbiAgICAgICAgX19tYW5hZ2VyX186IHt9LFxyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIGFiaWxpdHkgdG8gcmVtb3ZlIGFsbCBWaWV3cy5cclxuICAgICAgICBfcmVtb3ZlVmlld3M6IExheW91dE1hbmFnZXIuX3JlbW92ZVZpZXdzLFxyXG5cclxuICAgICAgICAvLyBBZGQgdGhlIGFiaWxpdHkgdG8gcmVtb3ZlIGl0c2VsZi5cclxuICAgICAgICBfcmVtb3ZlVmlldzogTGF5b3V0TWFuYWdlci5fcmVtb3ZlVmlld1xyXG5cclxuICAgICAgLy8gTWl4IGluIGFsbCBMYXlvdXRNYW5hZ2VyIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFzIHdlbGwuXHJcbiAgICAgIH0sIExheW91dE1hbmFnZXIucHJvdG90eXBlKTtcclxuXHJcbiAgICAgIC8vIEFzc2lnbiBwYXNzZWQgb3B0aW9ucy5cclxuICAgICAgdmlldy5vcHRpb25zID0gb3B0aW9ucztcclxuXHJcbiAgICAgIC8vIE1lcmdlIHRoZSBWaWV3IG9wdGlvbnMgaW50byB0aGUgVmlldy5cclxuICAgICAgXy5leHRlbmQodmlldywgb3B0aW9ucyk7XHJcblxyXG4gICAgICAvLyBCeSBkZWZhdWx0IHRoZSBvcmlnaW5hbCBSZW1vdmUgZnVuY3Rpb24gaXMgdGhlIEJhY2tib25lLlZpZXcgb25lLlxyXG4gICAgICB2aWV3Ll9yZW1vdmUgPSBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5yZW1vdmU7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgdGhlIHJlbmRlciBpcyBhbHdheXMgc2V0IGNvcnJlY3RseS5cclxuICAgICAgdmlldy5yZW5kZXIgPSBMYXlvdXRNYW5hZ2VyLnByb3RvdHlwZS5yZW5kZXI7XHJcblxyXG4gICAgICAvLyBJZiB0aGUgdXNlciBwcm92aWRlZCB0aGVpciBvd24gcmVtb3ZlIG92ZXJyaWRlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mXHJcbiAgICAgIC8vIHRoZSBkZWZhdWx0LlxyXG4gICAgICBpZiAodmlldy5yZW1vdmUgIT09IHByb3RvLnJlbW92ZSkge1xyXG4gICAgICAgIHZpZXcuX3JlbW92ZSA9IHZpZXcucmVtb3ZlO1xyXG4gICAgICAgIHZpZXcucmVtb3ZlID0gcHJvdG8ucmVtb3ZlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBOb3JtYWxpemUgdmlld3MgdG8gZXhpc3Qgb24gZWl0aGVyIGluc3RhbmNlIG9yIG9wdGlvbnMsIGRlZmF1bHQgdG9cclxuICAgICAgLy8gb3B0aW9ucy5cclxuICAgICAgdmlld3MgPSBvcHRpb25zLnZpZXdzIHx8IHZpZXcudmlld3M7XHJcblxyXG4gICAgICAvLyBTZXQgdGhlIGludGVybmFsIHZpZXdzLCBvbmx5IGlmIHNlbGVjdG9ycyBoYXZlIGJlZW4gcHJvdmlkZWQuXHJcbiAgICAgIGlmIChfLmtleXModmlld3MpLmxlbmd0aCkge1xyXG4gICAgICAgIC8vIEtlZXAgb3JpZ2luYWwgb2JqZWN0IGRlY2xhcmVkIGNvbnRhaW5pbmcgVmlld3MuXHJcbiAgICAgICAgZGVjbGFyZWRWaWV3cyA9IHZpZXdzO1xyXG5cclxuICAgICAgICAvLyBSZXNldCB0aGUgcHJvcGVydHkgdG8gYXZvaWQgZHVwbGljYXRpb24gb3Igb3ZlcndyaXR0aW5nLlxyXG4gICAgICAgIHZpZXcudmlld3MgPSB7fTtcclxuXHJcbiAgICAgICAgLy8gSWYgYW55IGRlY2xhcmVkIHZpZXcgaXMgd3JhcHBlZCBpbiBhIGZ1bmN0aW9uLCBpbnZva2UgaXQuXHJcbiAgICAgICAgXy5lYWNoKGRlY2xhcmVkVmlld3MsIGZ1bmN0aW9uKGRlY2xhcmVkVmlldywga2V5KSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGRlY2xhcmVkVmlldyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIGRlY2xhcmVkVmlld3Nba2V5XSA9IGRlY2xhcmVkVmlldy5jYWxsKHZpZXcsIHZpZXcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBTZXQgdGhlIGRlY2xhcmVkIFZpZXdzLlxyXG4gICAgICAgIHZpZXcuc2V0Vmlld3MoZGVjbGFyZWRWaWV3cyk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxufSk7XHJcblxyXG5MYXlvdXRNYW5hZ2VyLlZFUlNJT04gPSBcIjAuOS41XCI7XHJcblxyXG4vLyBFeHBvc2UgdGhyb3VnaCBCYWNrYm9uZSBvYmplY3QuXHJcbkJhY2tib25lLkxheW91dCA9IExheW91dE1hbmFnZXI7XHJcblxyXG4vLyBPdmVycmlkZSBfY29uZmlndXJlIHRvIHByb3ZpZGUgZXh0cmEgZnVuY3Rpb25hbGl0eSB0aGF0IGlzIG5lY2Vzc2FyeSBpblxyXG4vLyBvcmRlciBmb3IgdGhlIHJlbmRlciBmdW5jdGlvbiByZWZlcmVuY2UgdG8gYmUgYm91bmQgZHVyaW5nIGluaXRpYWxpemUuXHJcbkJhY2tib25lLlZpZXcucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gIHZhciBub2VsO1xyXG5cclxuICAvLyBFbnN1cmUgb3B0aW9ucyBpcyBhbHdheXMgYW4gb2JqZWN0LlxyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuICAvLyBSZW1vdmUgdGhlIGNvbnRhaW5lciBlbGVtZW50IHByb3ZpZGVkIGJ5IEJhY2tib25lLlxyXG4gIGlmIChcImVsXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZWwgPT09IGZhbHNlIDogdGhpcy5lbCA9PT0gZmFsc2UpIHtcclxuICAgIG5vZWwgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLy8gSWYgbWFuYWdlIGlzIHNldCwgZG8gaXQhXHJcbiAgaWYgKG9wdGlvbnMubWFuYWdlIHx8IHRoaXMubWFuYWdlKSB7XHJcbiAgICAvLyBTZXQgdXAgdGhpcyBWaWV3LlxyXG4gICAgTGF5b3V0TWFuYWdlci5zZXR1cFZpZXcodGhpcywgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvLyBBc3NpZ24gdGhlIGBub2VsYCBwcm9wZXJ0eSBvbmNlIHdlJ3JlIHN1cmUgdGhlIFZpZXcgd2UncmUgd29ya2luZyB3aXRoIGlzXHJcbiAgLy8gbWFuYWdlZCBieSBMYXlvdXRNYW5hZ2VyLlxyXG4gIGlmICh0aGlzLl9fbWFuYWdlcl9fKSB7XHJcbiAgICB0aGlzLl9fbWFuYWdlcl9fLm5vZWwgPSBub2VsO1xyXG4gICAgdGhpcy5fX21hbmFnZXJfXy5zdXBwcmVzc1dhcm5pbmdzID0gb3B0aW9ucy5zdXBwcmVzc1dhcm5pbmdzO1xyXG4gIH1cclxuXHJcbiAgLy8gQWN0IGxpa2Ugbm90aGluZyBoYXBwZW5lZC5cclxuICBWaWV3Q29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbkJhY2tib25lLlZpZXcgPSBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5jb25zdHJ1Y3RvcjtcclxuXHJcbi8vIENvcHkgb3ZlciB0aGUgZXh0ZW5kIG1ldGhvZC5cclxuQmFja2JvbmUuVmlldy5leHRlbmQgPSBWaWV3Q29uc3RydWN0b3IuZXh0ZW5kO1xyXG5cclxuLy8gQ29weSBvdmVyIHRoZSBwcm90b3R5cGUgYXMgd2VsbC5cclxuQmFja2JvbmUuVmlldy5wcm90b3R5cGUgPSBWaWV3Q29uc3RydWN0b3IucHJvdG90eXBlO1xyXG5cclxuLy8gRGVmYXVsdCBjb25maWd1cmF0aW9uIG9wdGlvbnM7IGRlc2lnbmVkIHRvIGJlIG92ZXJyaWRlbi5cclxudmFyIGRlZmF1bHRPcHRpb25zID0ge1xyXG4gIC8vIFByZWZpeCB0ZW1wbGF0ZS9sYXlvdXQgcGF0aHMuXHJcbiAgcHJlZml4OiBcIlwiLFxyXG5cclxuICAvLyBVc2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvIHF1ZXVlIHVwIHZpZXcgcmVuZGVyaW5nIGFuZCBjYW5jZWxcclxuICAvLyByZXBlYXQgcmVxdWVzdHMuIExlYXZlIG9uIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXHJcbiAgdXNlUkFGOiB0cnVlLFxyXG5cclxuICAvLyBDYW4gYmUgdXNlZCB0byBzdXBwbHkgYSBkaWZmZXJlbnQgZGVmZXJyZWQgaW1wbGVtZW50YXRpb24uXHJcbiAgZGVmZXJyZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuICQuRGVmZXJyZWQoKTtcclxuICB9LFxyXG5cclxuICAvLyBGZXRjaCBpcyBwYXNzZWQgYSBwYXRoIGFuZCBpcyBleHBlY3RlZCB0byByZXR1cm4gdGVtcGxhdGUgY29udGVudHMgYXMgYVxyXG4gIC8vIGZ1bmN0aW9uIG9yIHN0cmluZy5cclxuICBmZXRjaFRlbXBsYXRlOiBmdW5jdGlvbihwYXRoKSB7XHJcbiAgICByZXR1cm4gXy50ZW1wbGF0ZSgkKHBhdGgpLmh0bWwoKSk7XHJcbiAgfSxcclxuXHJcbiAgLy8gQnkgZGVmYXVsdCwgcmVuZGVyIHVzaW5nIHVuZGVyc2NvcmUncyB0ZW1wbGF0aW5nIGFuZCB0cmltIG91dHB1dC5cclxuICByZW5kZXJUZW1wbGF0ZTogZnVuY3Rpb24odGVtcGxhdGUsIGNvbnRleHQpIHtcclxuICAgIHJldHVybiB0cmltKHRlbXBsYXRlLmNhbGwodGhpcywgY29udGV4dCkpO1xyXG4gIH0sXHJcblxyXG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbW9kZWwgYXR0cmlidXRlcyB0byB0aGUgdGVtcGxhdGVzXHJcbiAgc2VyaWFsaXplOiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLm1vZGVsID8gXy5jbG9uZSh0aGlzLm1vZGVsLmF0dHJpYnV0ZXMpIDoge307XHJcbiAgfSxcclxuXHJcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBjb21tb24gd2F5IHlvdSB3aWxsIHdhbnQgdG8gcGFydGlhbGx5IGFwcGx5IGEgdmlldyBpbnRvXHJcbiAgLy8gYSBsYXlvdXQuXHJcbiAgcGFydGlhbDogZnVuY3Rpb24oJHJvb3QsICRlbCwgcmVudE1hbmFnZXIsIG1hbmFnZXIpIHtcclxuICAgIHZhciAkZmlsdGVyZWQ7XHJcblxyXG4gICAgLy8gSWYgc2VsZWN0b3IgaXMgc3BlY2lmaWVkLCBhdHRlbXB0IHRvIGZpbmQgaXQuXHJcbiAgICBpZiAobWFuYWdlci5zZWxlY3Rvcikge1xyXG4gICAgICBpZiAocmVudE1hbmFnZXIubm9lbCkge1xyXG4gICAgICAgICRmaWx0ZXJlZCA9ICRyb290LmZpbHRlcihtYW5hZ2VyLnNlbGVjdG9yKTtcclxuICAgICAgICAkcm9vdCA9ICRmaWx0ZXJlZC5sZW5ndGggPyAkZmlsdGVyZWQgOiAkcm9vdC5maW5kKG1hbmFnZXIuc2VsZWN0b3IpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgICRyb290ID0gJHJvb3QuZmluZChtYW5hZ2VyLnNlbGVjdG9yKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFVzZSB0aGUgaW5zZXJ0IG1ldGhvZCBpZiB0aGUgcGFyZW50J3MgYGluc2VydGAgYXJndW1lbnQgaXMgdHJ1ZS5cclxuICAgIGlmIChyZW50TWFuYWdlci5pbnNlcnQpIHtcclxuICAgICAgdGhpcy5pbnNlcnQoJHJvb3QsICRlbCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmh0bWwoJHJvb3QsICRlbCk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLy8gT3ZlcnJpZGUgdGhpcyB3aXRoIGEgY3VzdG9tIEhUTUwgbWV0aG9kLCBwYXNzZWQgYSByb290IGVsZW1lbnQgYW5kIGNvbnRlbnRcclxuICAvLyAoYSBqUXVlcnkgY29sbGVjdGlvbiBvciBhIHN0cmluZykgdG8gcmVwbGFjZSB0aGUgaW5uZXJIVE1MIHdpdGguXHJcbiAgaHRtbDogZnVuY3Rpb24oJHJvb3QsIGNvbnRlbnQpIHtcclxuICAgICRyb290Lmh0bWwoY29udGVudCk7XHJcbiAgfSxcclxuXHJcbiAgLy8gVXNlZCBmb3IgaW5zZXJ0aW5nIHN1YlZpZXdzIGluIGEgc2luZ2xlIGJhdGNoLiAgVGhpcyBnaXZlcyBhIHNtYWxsXHJcbiAgLy8gcGVyZm9ybWFuY2UgYm9vc3QgYXMgd2Ugd3JpdGUgdG8gYSBkaXNjb25uZWN0ZWQgZnJhZ21lbnQgaW5zdGVhZCBvZiB0byB0aGVcclxuICAvLyBET00gZGlyZWN0bHkuIFNtYXJ0ZXIgYnJvd3NlcnMgbGlrZSBDaHJvbWUgd2lsbCBiYXRjaCB3cml0ZXMgaW50ZXJuYWxseVxyXG4gIC8vIGFuZCBsYXlvdXQgYXMgc2VsZG9tIGFzIHBvc3NpYmxlLCBidXQgZXZlbiBpbiB0aGF0IGNhc2UgdGhpcyBwcm92aWRlcyBhXHJcbiAgLy8gZGVjZW50IGJvb3N0LiAgalF1ZXJ5IHdpbGwgdXNlIGEgRG9jdW1lbnRGcmFnbWVudCBmb3IgdGhlIGJhdGNoIHVwZGF0ZSxcclxuICAvLyBidXQgQ2hlZXJpbyBpbiBOb2RlIHdpbGwgbm90LlxyXG4gIGh0bWxCYXRjaDogZnVuY3Rpb24ocm9vdFZpZXcsIHN1YlZpZXdzLCBzZWxlY3Rvcikge1xyXG4gICAgLy8gU2hvcnRoYW5kIHRoZSBwYXJlbnQgbWFuYWdlciBvYmplY3QuXHJcbiAgICB2YXIgcmVudE1hbmFnZXIgPSByb290Vmlldy5fX21hbmFnZXJfXztcclxuICAgIC8vIENyZWF0ZSBhIHNpbXBsaWZpZWQgbWFuYWdlciBvYmplY3QgdGhhdCB0ZWxscyBwYXJ0aWFsKCkgd2hlcmVcclxuICAgIC8vIHBsYWNlIHRoZSBlbGVtZW50cy5cclxuICAgIHZhciBtYW5hZ2VyID0geyBzZWxlY3Rvcjogc2VsZWN0b3IgfTtcclxuXHJcbiAgICAvLyBHZXQgdGhlIGVsZW1lbnRzIHRvIGJlIGluc2VydGVkIGludG8gdGhlIHJvb3Qgdmlldy5cclxuICAgIHZhciBlbHMgPSBfLnJlZHVjZShzdWJWaWV3cywgZnVuY3Rpb24obWVtbywgc3ViKSB7XHJcbiAgICAgIC8vIENoZWNrIGlmIGtlZXAgaXMgcHJlc2VudCAtIGRvIGJvb2xlYW4gY2hlY2sgaW4gY2FzZSB0aGUgdXNlclxyXG4gICAgICAvLyBoYXMgY3JlYXRlZCBhIGBrZWVwYCBmdW5jdGlvbi5cclxuICAgICAgdmFyIGtlZXAgPSB0eXBlb2Ygc3ViLmtlZXAgPT09IFwiYm9vbGVhblwiID8gc3ViLmtlZXAgOiBzdWIub3B0aW9ucy5rZWVwO1xyXG4gICAgICAvLyBJZiBhIHN1YlZpZXcgaXMgcHJlc2VudCwgZG9uJ3QgcHVzaCBpdC4gIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmXHJcbiAgICAgIC8vIGBrZWVwOiB0cnVlYC4gIFdlIGRvIHRoZSBrZWVwIGNoZWNrIGZvciBzcGVlZCBhcyAkLmNvbnRhaW5zIGlzIG5vdFxyXG4gICAgICAvLyBjaGVhcC5cclxuICAgICAgdmFyIGV4aXN0cyA9IGtlZXAgJiYgJC5jb250YWlucyhyb290Vmlldy5lbCwgc3ViLmVsKTtcclxuXHJcbiAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGVsZW1lbnQgYW5kIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdCBpbiBvdXIgc3RydWN0dXJlXHJcbiAgICAgIC8vIGF0dGFjaCBpdC5cclxuICAgICAgaWYgKHN1Yi5lbCAmJiAhZXhpc3RzKSB7XHJcbiAgICAgICAgbWVtby5wdXNoKHN1Yi5lbCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBtZW1vO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIC8vIFVzZSBwYXJ0aWFsIHRvIGFwcGx5IHRoZSBlbGVtZW50cy4gV3JhcCBlbHMgaW4galEgb2JqIGZvciBjaGVlcmlvLlxyXG4gICAgcmV0dXJuIHRoaXMucGFydGlhbChyb290Vmlldy4kZWwsICQoZWxzKSwgcmVudE1hbmFnZXIsIG1hbmFnZXIpO1xyXG4gIH0sXHJcblxyXG4gIC8vIFZlcnkgc2ltaWxhciB0byBIVE1MIGV4Y2VwdCB0aGlzIG9uZSB3aWxsIGFwcGVuZENoaWxkIGJ5IGRlZmF1bHQuXHJcbiAgaW5zZXJ0OiBmdW5jdGlvbigkcm9vdCwgJGVsKSB7XHJcbiAgICAkcm9vdC5hcHBlbmQoJGVsKTtcclxuICB9LFxyXG5cclxuICAvLyBSZXR1cm4gYSBkZWZlcnJlZCBmb3Igd2hlbiBhbGwgcHJvbWlzZXMgcmVzb2x2ZS9yZWplY3QuXHJcbiAgd2hlbjogZnVuY3Rpb24ocHJvbWlzZXMpIHtcclxuICAgIHJldHVybiAkLndoZW4uYXBwbHkobnVsbCwgcHJvbWlzZXMpO1xyXG4gIH0sXHJcblxyXG4gIC8vIEEgbWV0aG9kIHRvIGRldGVybWluZSBpZiBhIFZpZXcgY29udGFpbnMgYW5vdGhlci5cclxuICBjb250YWluczogZnVuY3Rpb24ocGFyZW50LCBjaGlsZCkge1xyXG4gICAgcmV0dXJuICQuY29udGFpbnMocGFyZW50LCBjaGlsZCk7XHJcbiAgfSxcclxuXHJcbiAgLy8gQmFzZWQgb246XHJcbiAgLy8gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cclxuICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcG9seWZpbGwgYnkgRXJpayBNw7ZsbGVyLiBmaXhlcyBmcm9tIFBhdWwgSXJpc2ggYW5kXHJcbiAgLy8gVGlubyBaaWpkZWwuXHJcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiAoZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbGFzdFRpbWUgPSAwO1xyXG4gICAgdmFyIHZlbmRvcnMgPSBbXCJtc1wiLCBcIm1velwiLCBcIndlYmtpdFwiLCBcIm9cIl07XHJcbiAgICB2YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK2kpIHtcclxuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93W3ZlbmRvcnNbaV0gKyBcIlJlcXVlc3RBbmltYXRpb25GcmFtZVwiXTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXJlcXVlc3RBbmltYXRpb25GcmFtZSl7XHJcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGN1cnJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgdmFyIHRpbWVUb0NhbGwgPSBNYXRoLm1heCgwLCAxNiAtIChjdXJyVGltZSAtIGxhc3RUaW1lKSk7XHJcbiAgICAgICAgdmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xyXG4gICAgICAgIH0sIHRpbWVUb0NhbGwpO1xyXG4gICAgICAgIGxhc3RUaW1lID0gY3VyclRpbWUgKyB0aW1lVG9DYWxsO1xyXG4gICAgICAgIHJldHVybiBpZDtcclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gXy5iaW5kKHJlcXVlc3RBbmltYXRpb25GcmFtZSwgd2luZG93KTtcclxuICB9KSgpLFxyXG5cclxuICBjYW5jZWxBbmltYXRpb25GcmFtZTogKGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZlbmRvcnMgPSBbXCJtc1wiLCBcIm1velwiLCBcIndlYmtpdFwiLCBcIm9cIl07XHJcbiAgICB2YXIgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWU7XHJcblxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZW5kb3JzLmxlbmd0aCAmJiAhd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTsgKytpKSB7XHJcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lID1cclxuICAgICAgICB3aW5kb3dbdmVuZG9yc1tpXSArIFwiQ2FuY2VsQW5pbWF0aW9uRnJhbWVcIl0gfHxcclxuICAgICAgICB3aW5kb3dbdmVuZG9yc1tpXSArIFwiQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lXCJdO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcclxuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihpZCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIF8uYmluZChjYW5jZWxBbmltYXRpb25GcmFtZSwgd2luZG93KTtcclxuICB9KSgpXHJcbn07XHJcblxyXG4vLyBFeHRlbmQgTGF5b3V0TWFuYWdlciB3aXRoIGRlZmF1bHQgb3B0aW9ucy5cclxuXy5leHRlbmQoTGF5b3V0TWFuYWdlci5wcm90b3R5cGUsIGRlZmF1bHRPcHRpb25zKTtcclxuXHJcbi8vIEFzc2lnbiBgTGF5b3V0TWFuYWdlcmAgb2JqZWN0IGZvciBBTUQgbG9hZGVycy5cclxucmV0dXJuIExheW91dE1hbmFnZXI7XHJcblxyXG59KSk7XHJcbiIsIi8qXHJcbiAgYmFja2JvbmUucGFnaW5hdG9yIDIuMC4wXHJcbiAgaHR0cDovL2dpdGh1Yi5jb20vYmFja2JvbmUtcGFnaW5hdG9yL2JhY2tib25lLnBhZ2luYXRvclxyXG5cclxuICBDb3B5cmlnaHQgKGMpIDIwMTMgSmltbXkgWXVlbiBIbyBXb25nIGFuZCBjb250cmlidXRvcnNcclxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIEBsaWNlbnNlLlxyXG4qL1xyXG5cclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcblxyXG4gIC8vIENvbW1vbkpTXHJcbiAgaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIpIHtcclxuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwidW5kZXJzY29yZVwiKSwgcmVxdWlyZShcImJhY2tib25lXCIpKTtcclxuICB9XHJcbiAgLy8gQU1EXHJcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKFtcInVuZGVyc2NvcmVcIiwgXCJiYWNrYm9uZVwiXSwgZmFjdG9yeSk7XHJcbiAgfVxyXG4gIC8vIEJyb3dzZXJcclxuICBlbHNlIGlmICh0eXBlb2YgXyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgQmFja2JvbmUgIT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHZhciBvbGRQYWdlYWJsZUNvbGxlY3Rpb24gPSBCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb247XHJcbiAgICB2YXIgUGFnZWFibGVDb2xsZWN0aW9uID0gZmFjdG9yeShfLCBCYWNrYm9uZSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBfX0JST1dTRVIgT05MWV9fXHJcblxyXG4gICAgICAgSWYgeW91IGFscmVhZHkgaGF2ZSBhbiBvYmplY3QgbmFtZWQgYFBhZ2VhYmxlQ29sbGVjdGlvbmAgYXR0YWNoZWQgdG8gdGhlXHJcbiAgICAgICBgQmFja2JvbmVgIG1vZHVsZSwgeW91IGNhbiB1c2UgdGhpcyB0byByZXR1cm4gYSBsb2NhbCByZWZlcmVuY2UgdG8gdGhpc1xyXG4gICAgICAgQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uIGNsYXNzIGFuZCByZXNldCB0aGUgbmFtZVxyXG4gICAgICAgQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uIHRvIGl0cyBwcmV2aW91cyBkZWZpbml0aW9uLlxyXG5cclxuICAgICAgICAgICAvLyBUaGUgbGVmdCBoYW5kIHNpZGUgZ2l2ZXMgeW91IGEgcmVmZXJlbmNlIHRvIHRoaXNcclxuICAgICAgICAgICAvLyBCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb24gaW1wbGVtZW50YXRpb24sIHRoZSByaWdodCBoYW5kIHNpZGVcclxuICAgICAgICAgICAvLyByZXNldHMgQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uIHRvIHlvdXIgb3RoZXJcclxuICAgICAgICAgICAvLyBCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb24uXHJcbiAgICAgICAgICAgdmFyIFBhZ2VhYmxlQ29sbGVjdGlvbiA9IEJhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbi5ub0NvbmZsaWN0KCk7XHJcblxyXG4gICAgICAgQHN0YXRpY1xyXG4gICAgICAgQG1lbWJlciBCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb25cclxuICAgICAgIEByZXR1cm4ge0JhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbn1cclxuICAgICovXHJcbiAgICBCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb24ubm9Db25mbGljdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uID0gb2xkUGFnZWFibGVDb2xsZWN0aW9uO1xyXG4gICAgICByZXR1cm4gUGFnZWFibGVDb2xsZWN0aW9uO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG59KGZ1bmN0aW9uIChfLCBCYWNrYm9uZSkge1xyXG5cclxuICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgdmFyIF9leHRlbmQgPSBfLmV4dGVuZDtcclxuICB2YXIgX29taXQgPSBfLm9taXQ7XHJcbiAgdmFyIF9jbG9uZSA9IF8uY2xvbmU7XHJcbiAgdmFyIF9lYWNoID0gXy5lYWNoO1xyXG4gIHZhciBfcGljayA9IF8ucGljaztcclxuICB2YXIgX2NvbnRhaW5zID0gXy5jb250YWlucztcclxuICB2YXIgX2lzRW1wdHkgPSBfLmlzRW1wdHk7XHJcbiAgdmFyIF9wYWlycyA9IF8ucGFpcnM7XHJcbiAgdmFyIF9pbnZlcnQgPSBfLmludmVydDtcclxuICB2YXIgX2lzQXJyYXkgPSBfLmlzQXJyYXk7XHJcbiAgdmFyIF9pc0Z1bmN0aW9uID0gXy5pc0Z1bmN0aW9uO1xyXG4gIHZhciBfaXNPYmplY3QgPSBfLmlzT2JqZWN0O1xyXG4gIHZhciBfa2V5cyA9IF8ua2V5cztcclxuICB2YXIgX2lzVW5kZWZpbmVkID0gXy5pc1VuZGVmaW5lZDtcclxuICB2YXIgY2VpbCA9IE1hdGguY2VpbDtcclxuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xyXG4gIHZhciBtYXggPSBNYXRoLm1heDtcclxuXHJcbiAgdmFyIEJCQ29sUHJvdG8gPSBCYWNrYm9uZS5Db2xsZWN0aW9uLnByb3RvdHlwZTtcclxuXHJcbiAgZnVuY3Rpb24gZmluaXRlSW50ICh2YWwsIG5hbWUpIHtcclxuICAgIGlmICghXy5pc051bWJlcih2YWwpIHx8IF8uaXNOYU4odmFsKSB8fCAhXy5pc0Zpbml0ZSh2YWwpIHx8IH5+dmFsICE9PSB2YWwpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImBcIiArIG5hbWUgKyBcImAgbXVzdCBiZSBhIGZpbml0ZSBpbnRlZ2VyXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHF1ZXJ5U3RyaW5nVG9QYXJhbXMgKHFzKSB7XHJcbiAgICB2YXIga3ZwLCBrLCB2LCBscywgcGFyYW1zID0ge30sIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcclxuICAgIHZhciBrdnBzID0gcXMuc3BsaXQoJyYnKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsID0ga3Zwcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgdmFyIHBhcmFtID0ga3Zwc1tpXTtcclxuICAgICAga3ZwID0gcGFyYW0uc3BsaXQoJz0nKSwgayA9IGt2cFswXSwgdiA9IGt2cFsxXSB8fCB0cnVlO1xyXG4gICAgICBrID0gZGVjb2RlKGspLCB2ID0gZGVjb2RlKHYpLCBscyA9IHBhcmFtc1trXTtcclxuICAgICAgaWYgKF9pc0FycmF5KGxzKSkgbHMucHVzaCh2KTtcclxuICAgICAgZWxzZSBpZiAobHMpIHBhcmFtc1trXSA9IFtscywgdl07XHJcbiAgICAgIGVsc2UgcGFyYW1zW2tdID0gdjtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJhbXM7XHJcbiAgfVxyXG5cclxuICAvLyBoYWNrIHRvIG1ha2Ugc3VyZSB0aGUgd2hhdGV2ZXIgZXZlbnQgaGFuZGxlcnMgZm9yIHRoaXMgZXZlbnQgaXMgcnVuXHJcbiAgLy8gYmVmb3JlIGZ1bmMgaXMsIGFuZCB0aGUgZXZlbnQgaGFuZGxlcnMgdGhhdCBmdW5jIHdpbGwgdHJpZ2dlci5cclxuICBmdW5jdGlvbiBydW5PbmNlQXRMYXN0SGFuZGxlciAoY29sLCBldmVudCwgZnVuYykge1xyXG4gICAgdmFyIGV2ZW50SGFuZGxlcnMgPSBjb2wuX2V2ZW50c1tldmVudF07XHJcbiAgICBpZiAoZXZlbnRIYW5kbGVycyAmJiBldmVudEhhbmRsZXJzLmxlbmd0aCkge1xyXG4gICAgICB2YXIgbGFzdEhhbmRsZXIgPSBldmVudEhhbmRsZXJzW2V2ZW50SGFuZGxlcnMubGVuZ3RoIC0gMV07XHJcbiAgICAgIHZhciBvbGRDYWxsYmFjayA9IGxhc3RIYW5kbGVyLmNhbGxiYWNrO1xyXG4gICAgICBsYXN0SGFuZGxlci5jYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgb2xkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgIGZ1bmMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgbGFzdEhhbmRsZXIuY2FsbGJhY2sgPSBvbGRDYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGZ1bmMoKTtcclxuICB9XHJcblxyXG4gIHZhciBQQVJBTV9UUklNX1JFID0gL1tcXHMnXCJdL2c7XHJcbiAgdmFyIFVSTF9UUklNX1JFID0gL1s8PlxccydcIl0vZztcclxuXHJcbiAgLyoqXHJcbiAgICAgRHJvcC1pbiByZXBsYWNlbWVudCBmb3IgQmFja2JvbmUuQ29sbGVjdGlvbi4gU3VwcG9ydHMgc2VydmVyLXNpZGUgYW5kXHJcbiAgICAgY2xpZW50LXNpZGUgcGFnaW5hdGlvbiBhbmQgc29ydGluZy4gQ2xpZW50LXNpZGUgbW9kZSBhbHNvIHN1cHBvcnQgZnVsbHlcclxuICAgICBtdWx0aS1kaXJlY3Rpb25hbCBzeW5jaHJvbml6YXRpb24gb2YgY2hhbmdlcyBiZXR3ZWVuIHBhZ2VzLlxyXG5cclxuICAgICBAY2xhc3MgQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uXHJcbiAgICAgQGV4dGVuZHMgQmFja2JvbmUuQ29sbGVjdGlvblxyXG4gICovXHJcbiAgdmFyIFBhZ2VhYmxlQ29sbGVjdGlvbiA9IEJhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbiA9IEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHtcclxuXHJcbiAgICAvKipcclxuICAgICAgIFRoZSBjb250YWluZXIgb2JqZWN0IHRvIHN0b3JlIGFsbCBwYWdpbmF0aW9uIHN0YXRlcy5cclxuXHJcbiAgICAgICBZb3UgY2FuIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHN0YXRlIGJ5IGV4dGVuZGluZyB0aGlzIGNsYXNzIG9yIHNwZWNpZnlpbmdcclxuICAgICAgIHRoZW0gaW4gYW4gYG9wdGlvbnNgIGhhc2ggdG8gdGhlIGNvbnN0cnVjdG9yLlxyXG5cclxuICAgICAgIEBwcm9wZXJ0eSB7T2JqZWN0fSBzdGF0ZVxyXG5cclxuICAgICAgIEBwcm9wZXJ0eSB7MHwxfSBbc3RhdGUuZmlyc3RQYWdlPTFdIFRoZSBmaXJzdCBwYWdlIGluZGV4LiBTZXQgdG8gMCBpZlxyXG4gICAgICAgeW91ciBzZXJ2ZXIgQVBJIHVzZXMgMC1iYXNlZCBpbmRpY2VzLiBZb3Ugc2hvdWxkIG9ubHkgb3ZlcnJpZGUgdGhpcyB2YWx1ZVxyXG4gICAgICAgZHVyaW5nIGV4dGVuc2lvbiwgaW5pdGlhbGl6YXRpb24gb3IgcmVzZXQgYnkgdGhlIHNlcnZlciBhZnRlclxyXG4gICAgICAgZmV0Y2hpbmcuIFRoaXMgdmFsdWUgc2hvdWxkIGJlIHJlYWQgb25seSBhdCBvdGhlciB0aW1lcy5cclxuXHJcbiAgICAgICBAcHJvcGVydHkge251bWJlcn0gW3N0YXRlLmxhc3RQYWdlPW51bGxdIFRoZSBsYXN0IHBhZ2UgaW5kZXguIFRoaXMgdmFsdWVcclxuICAgICAgIGlzIF9fcmVhZCBvbmx5X18gYW5kIGl0J3MgY2FsY3VsYXRlZCBiYXNlZCBvbiB3aGV0aGVyIGBmaXJzdFBhZ2VgIGlzIDAgb3JcclxuICAgICAgIDEsIGR1cmluZyBib290c3RyYXBwaW5nLCBmZXRjaGluZyBhbmQgcmVzZXR0aW5nLiBQbGVhc2UgZG9uJ3QgY2hhbmdlIHRoaXNcclxuICAgICAgIHZhbHVlIHVuZGVyIGFueSBjaXJjdW1zdGFuY2VzLlxyXG5cclxuICAgICAgIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc3RhdGUuY3VycmVudFBhZ2U9bnVsbF0gVGhlIGN1cnJlbnQgcGFnZSBpbmRleC4gWW91XHJcbiAgICAgICBzaG91bGQgb25seSBvdmVycmlkZSB0aGlzIHZhbHVlIGR1cmluZyBleHRlbnNpb24sIGluaXRpYWxpemF0aW9uIG9yIHJlc2V0XHJcbiAgICAgICBieSB0aGUgc2VydmVyIGFmdGVyIGZldGNoaW5nLiBUaGlzIHZhbHVlIHNob3VsZCBiZSByZWFkIG9ubHkgYXQgb3RoZXJcclxuICAgICAgIHRpbWVzLiBDYW4gYmUgYSAwLWJhc2VkIG9yIDEtYmFzZWQgaW5kZXgsIGRlcGVuZGluZyBvbiB3aGV0aGVyXHJcbiAgICAgICBgZmlyc3RQYWdlYCBpcyAwIG9yIDEuIElmIGxlZnQgYXMgZGVmYXVsdCwgaXQgd2lsbCBiZSBzZXQgdG8gYGZpcnN0UGFnZWBcclxuICAgICAgIG9uIGluaXRpYWxpemF0aW9uLlxyXG5cclxuICAgICAgIEBwcm9wZXJ0eSB7bnVtYmVyfSBbc3RhdGUucGFnZVNpemU9MjVdIEhvdyBtYW55IHJlY29yZHMgdG8gc2hvdyBwZXJcclxuICAgICAgIHBhZ2UuIFRoaXMgdmFsdWUgaXMgX19yZWFkIG9ubHlfXyBhZnRlciBpbml0aWFsaXphdGlvbiwgaWYgeW91IHdhbnQgdG9cclxuICAgICAgIGNoYW5nZSB0aGUgcGFnZSBzaXplIGFmdGVyIGluaXRpYWxpemF0aW9uLCB5b3UgbXVzdCBjYWxsICNzZXRQYWdlU2l6ZS5cclxuXHJcbiAgICAgICBAcHJvcGVydHkge251bWJlcn0gW3N0YXRlLnRvdGFsUGFnZXM9bnVsbF0gSG93IG1hbnkgcGFnZXMgdGhlcmUgYXJlLiBUaGlzXHJcbiAgICAgICB2YWx1ZSBpcyBfX3JlYWQgb25seV9fIGFuZCBpdCBpcyBjYWxjdWxhdGVkIGZyb20gYHRvdGFsUmVjb3Jkc2AuXHJcblxyXG4gICAgICAgQHByb3BlcnR5IHtudW1iZXJ9IFtzdGF0ZS50b3RhbFJlY29yZHM9bnVsbF0gSG93IG1hbnkgcmVjb3JkcyB0aGVyZVxyXG4gICAgICAgYXJlLiBUaGlzIHZhbHVlIGlzIF9fcmVxdWlyZWRfXyB1bmRlciBzZXJ2ZXIgbW9kZS4gVGhpcyB2YWx1ZSBpcyBvcHRpb25hbFxyXG4gICAgICAgZm9yIGNsaWVudCBtb2RlIGFzIHRoZSBudW1iZXIgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIG1vZGVsc1xyXG4gICAgICAgZHVyaW5nIGJvb3RzdHJhcHBpbmcgYW5kIGR1cmluZyBmZXRjaGluZywgZWl0aGVyIHN1cHBsaWVkIGJ5IHRoZSBzZXJ2ZXJcclxuICAgICAgIGluIHRoZSBtZXRhZGF0YSwgb3IgY2FsY3VsYXRlZCBmcm9tIHRoZSBzaXplIG9mIHRoZSByZXNwb25zZS5cclxuXHJcbiAgICAgICBAcHJvcGVydHkge3N0cmluZ30gW3N0YXRlLnNvcnRLZXk9bnVsbF0gVGhlIG1vZGVsIGF0dHJpYnV0ZSB0byB1c2UgZm9yXHJcbiAgICAgICBzb3J0aW5nLlxyXG5cclxuICAgICAgIEBwcm9wZXJ0eSB7LTF8MHwxfSBbc3RhdGUub3JkZXI9LTFdIFRoZSBvcmRlciB0byB1c2UgZm9yIHNvcnRpbmcuIFNwZWNpZnlcclxuICAgICAgIC0xIGZvciBhc2NlbmRpbmcgb3JkZXIgb3IgMSBmb3IgZGVzY2VuZGluZyBvcmRlci4gSWYgMCwgbm8gY2xpZW50IHNpZGVcclxuICAgICAgIHNvcnRpbmcgd2lsbCBiZSBkb25lIGFuZCB0aGUgb3JkZXIgcXVlcnkgcGFyYW1ldGVyIHdpbGwgbm90IGJlIHNlbnQgdG9cclxuICAgICAgIHRoZSBzZXJ2ZXIgZHVyaW5nIGEgZmV0Y2guXHJcbiAgICAqL1xyXG4gICAgc3RhdGU6IHtcclxuICAgICAgZmlyc3RQYWdlOiAxLFxyXG4gICAgICBsYXN0UGFnZTogbnVsbCxcclxuICAgICAgY3VycmVudFBhZ2U6IG51bGwsXHJcbiAgICAgIHBhZ2VTaXplOiAyNSxcclxuICAgICAgdG90YWxQYWdlczogbnVsbCxcclxuICAgICAgdG90YWxSZWNvcmRzOiBudWxsLFxyXG4gICAgICBzb3J0S2V5OiBudWxsLFxyXG4gICAgICBvcmRlcjogLTFcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBAcHJvcGVydHkge1wic2VydmVyXCJ8XCJjbGllbnRcInxcImluZmluaXRlXCJ9IFttb2RlPVwic2VydmVyXCJdIFRoZSBtb2RlIG9mXHJcbiAgICAgICBvcGVyYXRpb25zIGZvciB0aGlzIGNvbGxlY3Rpb24uIGBcInNlcnZlclwiYCBwYWdpbmF0ZXMgb24gdGhlIHNlcnZlci1zaWRlLFxyXG4gICAgICAgYFwiY2xpZW50XCJgIHBhZ2luYXRlcyBvbiB0aGUgY2xpZW50LXNpZGUgYW5kIGBcImluZmluaXRlXCJgIHBhZ2luYXRlcyBvbiB0aGVcclxuICAgICAgIHNlcnZlci1zaWRlIGZvciBBUElzIHRoYXQgZG8gbm90IHN1cHBvcnQgYHRvdGFsUmVjb3Jkc2AuXHJcbiAgICAqL1xyXG4gICAgbW9kZTogXCJzZXJ2ZXJcIixcclxuXHJcbiAgICAvKipcclxuICAgICAgIEEgdHJhbnNsYXRpb24gbWFwIHRvIGNvbnZlcnQgQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uIHN0YXRlIGF0dHJpYnV0ZXNcclxuICAgICAgIHRvIHRoZSBxdWVyeSBwYXJhbWV0ZXJzIGFjY2VwdGVkIGJ5IHlvdXIgc2VydmVyIEFQSS5cclxuXHJcbiAgICAgICBZb3UgY2FuIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHN0YXRlIGJ5IGV4dGVuZGluZyB0aGlzIGNsYXNzIG9yIHNwZWNpZnlpbmdcclxuICAgICAgIHRoZW0gaW4gYG9wdGlvbnMucXVlcnlQYXJhbXNgIG9iamVjdCBoYXNoIHRvIHRoZSBjb25zdHJ1Y3Rvci5cclxuXHJcbiAgICAgICBAcHJvcGVydHkge09iamVjdH0gcXVlcnlQYXJhbXNcclxuICAgICAgIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcXVlcnlQYXJhbXMuY3VycmVudFBhZ2U9XCJwYWdlXCJdXHJcbiAgICAgICBAcHJvcGVydHkge3N0cmluZ30gW3F1ZXJ5UGFyYW1zLnBhZ2VTaXplPVwicGVyX3BhZ2VcIl1cclxuICAgICAgIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcXVlcnlQYXJhbXMudG90YWxQYWdlcz1cInRvdGFsX3BhZ2VzXCJdXHJcbiAgICAgICBAcHJvcGVydHkge3N0cmluZ30gW3F1ZXJ5UGFyYW1zLnRvdGFsUmVjb3Jkcz1cInRvdGFsX2VudHJpZXNcIl1cclxuICAgICAgIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcXVlcnlQYXJhbXMuc29ydEtleT1cInNvcnRfYnlcIl1cclxuICAgICAgIEBwcm9wZXJ0eSB7c3RyaW5nfSBbcXVlcnlQYXJhbXMub3JkZXI9XCJvcmRlclwiXVxyXG4gICAgICAgQHByb3BlcnR5IHtzdHJpbmd9IFtxdWVyeVBhcmFtcy5kaXJlY3Rpb25zPXtcIi0xXCI6IFwiYXNjXCIsIFwiMVwiOiBcImRlc2NcIn1dIEFcclxuICAgICAgIG1hcCBmb3IgdHJhbnNsYXRpbmcgYSBCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb24jc3RhdGUub3JkZXIgY29uc3RhbnQgdG9cclxuICAgICAgIHRoZSBvbmVzIHlvdXIgc2VydmVyIEFQSSBhY2NlcHRzLlxyXG4gICAgKi9cclxuICAgIHF1ZXJ5UGFyYW1zOiB7XHJcbiAgICAgIGN1cnJlbnRQYWdlOiBcInBhZ2VcIixcclxuICAgICAgcGFnZVNpemU6IFwicGVyX3BhZ2VcIixcclxuICAgICAgdG90YWxQYWdlczogXCJ0b3RhbF9wYWdlc1wiLFxyXG4gICAgICB0b3RhbFJlY29yZHM6IFwidG90YWxfZW50cmllc1wiLFxyXG4gICAgICBzb3J0S2V5OiBcInNvcnRfYnlcIixcclxuICAgICAgb3JkZXI6IFwib3JkZXJcIixcclxuICAgICAgZGlyZWN0aW9uczoge1xyXG4gICAgICAgIFwiLTFcIjogXCJhc2NcIixcclxuICAgICAgICBcIjFcIjogXCJkZXNjXCJcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAgIF9fQ0xJRU5UIE1PREUgT05MWV9fXHJcblxyXG4gICAgICAgVGhpcyBjb2xsZWN0aW9uIGlzIHRoZSBpbnRlcm5hbCBzdG9yYWdlIGZvciB0aGUgYm9vdHN0cmFwcGVkIG9yIGZldGNoZWRcclxuICAgICAgIG1vZGVscy4gWW91IGNhbiB1c2UgdGhpcyBpZiB5b3Ugd2FudCB0byBvcGVyYXRlIG9uIGFsbCB0aGUgcGFnZXMuXHJcblxyXG4gICAgICAgQHByb3BlcnR5IHtCYWNrYm9uZS5Db2xsZWN0aW9ufSBmdWxsQ29sbGVjdGlvblxyXG4gICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAgIEdpdmVuIGEgbGlzdCBvZiBtb2RlbHMgb3IgbW9kZWwgYXR0cmlidXR1ZXMsIGJvb3RzdHJhcHMgdGhlIGZ1bGxcclxuICAgICAgIGNvbGxlY3Rpb24gaW4gY2xpZW50IG1vZGUgb3IgaW5maW5pdGUgbW9kZSwgb3IganVzdCB0aGUgcGFnZSB5b3Ugd2FudCBpblxyXG4gICAgICAgc2VydmVyIG1vZGUuXHJcblxyXG4gICAgICAgSWYgeW91IHdhbnQgdG8gaW5pdGlhbGl6ZSBhIGNvbGxlY3Rpb24gdG8gYSBkaWZmZXJlbnQgc3RhdGUgdGhhbiB0aGVcclxuICAgICAgIGRlZmF1bHQsIHlvdSBjYW4gc3BlY2lmeSB0aGVtIGluIGBvcHRpb25zLnN0YXRlYC4gQW55IHN0YXRlIHBhcmFtZXRlcnNcclxuICAgICAgIHN1cHBsaWVkIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGRlZmF1bHQuIElmIHlvdSB3YW50IHRvIGNoYW5nZSB0aGVcclxuICAgICAgIGRlZmF1bHQgbWFwcGluZyBmcm9tICNzdGF0ZSBrZXlzIHRvIHlvdXIgc2VydmVyIEFQSSdzIHF1ZXJ5IHBhcmFtZXRlclxyXG4gICAgICAgbmFtZXMsIHlvdSBjYW4gc3BlY2lmaXkgYW4gb2JqZWN0IGhhc2ggaW4gYG9wdGlvbi5xdWVyeVBhcmFtc2AuIExpa2V3aXNlLFxyXG4gICAgICAgYW55IG1hcHBpbmcgcHJvdmlkZWQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdC4gTGFzdGx5LCBhbGxcclxuICAgICAgIEJhY2tib25lLkNvbGxlY3Rpb24gY29uc3RydWN0b3Igb3B0aW9ucyBhcmUgYWxzbyBhY2NlcHRlZC5cclxuXHJcbiAgICAgICBTZWU6XHJcblxyXG4gICAgICAgLSBCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb24jc3RhdGVcclxuICAgICAgIC0gQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uI3F1ZXJ5UGFyYW1zXHJcbiAgICAgICAtIFtCYWNrYm9uZS5Db2xsZWN0aW9uI2luaXRpYWxpemVdKGh0dHA6Ly9iYWNrYm9uZWpzLm9yZy8jQ29sbGVjdGlvbi1jb25zdHJ1Y3RvcilcclxuXHJcbiAgICAgICBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbbW9kZWxzXVxyXG5cclxuICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuXHJcbiAgICAgICBAcGFyYW0ge2Z1bmN0aW9uKCosICopOiBudW1iZXJ9IFtvcHRpb25zLmNvbXBhcmF0b3JdIElmIHNwZWNpZmllZCwgdGhpc1xyXG4gICAgICAgY29tcGFyYXRvciBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgcGFnZSB1bmRlciBzZXJ2ZXIgbW9kZSwgb3IgdGhlICNmdWxsQ29sbGVjdGlvblxyXG4gICAgICAgb3RoZXJ3aXNlLlxyXG5cclxuICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZnVsbF0gSWYgYGZhbHNlYCBhbmQgZWl0aGVyIGFcclxuICAgICAgIGBvcHRpb25zLmNvbXBhcmF0b3JgIG9yIGBzb3J0S2V5YCBpcyBkZWZpbmVkLCB0aGUgY29tcGFyYXRvciBpcyBhdHRhY2hlZFxyXG4gICAgICAgdG8gdGhlIGN1cnJlbnQgcGFnZS4gRGVmYXVsdCBpcyBgdHJ1ZWAgdW5kZXIgY2xpZW50IG9yIGluZmluaXRlIG1vZGUgYW5kXHJcbiAgICAgICB0aGUgY29tcGFyYXRvciB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSAjZnVsbENvbGxlY3Rpb24uXHJcblxyXG4gICAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnN0YXRlXSBUaGUgc3RhdGUgYXR0cmlidXRlcyBvdmVycmlkaW5nIHRoZSBkZWZhdWx0cy5cclxuXHJcbiAgICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuc3RhdGUuc29ydEtleV0gVGhlIG1vZGVsIGF0dHJpYnV0ZSB0byB1c2UgZm9yXHJcbiAgICAgICBzb3J0aW5nLiBJZiBzcGVjaWZpZWQgaW5zdGVhZCBvZiBgb3B0aW9ucy5jb21wYXJhdG9yYCwgYSBjb21wYXJhdG9yIHdpbGxcclxuICAgICAgIGJlIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCB1c2luZyB0aGlzIHZhbHVlLCBhbmQgb3B0aW9uYWxseSBhIHNvcnRpbmcgb3JkZXJcclxuICAgICAgIHNwZWNpZmllZCBpbiBgb3B0aW9ucy5zdGF0ZS5vcmRlcmAuIFRoZSBjb21wYXJhdG9yIGlzIHRoZW4gYXR0YWNoZWQgdG9cclxuICAgICAgIHRoZSBuZXcgY29sbGVjdGlvbiBpbnN0YW5jZS5cclxuXHJcbiAgICAgICBAcGFyYW0gey0xfDF9IFtvcHRpb25zLnN0YXRlLm9yZGVyXSBUaGUgb3JkZXIgdG8gdXNlIGZvciBzb3J0aW5nLiBTcGVjaWZ5XHJcbiAgICAgICAtMSBmb3IgYXNjZW5kaW5nIG9yZGVyIGFuZCAxIGZvciBkZXNjZW5kaW5nIG9yZGVyLlxyXG5cclxuICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5xdWVyeVBhcmFtXVxyXG4gICAgKi9cclxuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAobW9kZWxzLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICBCQkNvbFByb3RvLmNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgIHZhciBtb2RlID0gdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBQYWdlYWJsZVByb3RvLm1vZGU7XHJcblxyXG4gICAgICB2YXIgcXVlcnlQYXJhbXMgPSBfZXh0ZW5kKHt9LCBQYWdlYWJsZVByb3RvLnF1ZXJ5UGFyYW1zLCB0aGlzLnF1ZXJ5UGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucXVlcnlQYXJhbXMgfHwge30pO1xyXG5cclxuICAgICAgcXVlcnlQYXJhbXMuZGlyZWN0aW9ucyA9IF9leHRlbmQoe30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFBhZ2VhYmxlUHJvdG8ucXVlcnlQYXJhbXMuZGlyZWN0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5xdWVyeVBhcmFtcy5kaXJlY3Rpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeVBhcmFtcy5kaXJlY3Rpb25zIHx8IHt9KTtcclxuXHJcbiAgICAgIHRoaXMucXVlcnlQYXJhbXMgPSBxdWVyeVBhcmFtcztcclxuXHJcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUgPSBfZXh0ZW5kKHt9LCBQYWdlYWJsZVByb3RvLnN0YXRlLCB0aGlzLnN0YXRlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXRlIHx8IHt9KTtcclxuXHJcbiAgICAgIHN0YXRlLmN1cnJlbnRQYWdlID0gc3RhdGUuY3VycmVudFBhZ2UgPT0gbnVsbCA/XHJcbiAgICAgICAgc3RhdGUuZmlyc3RQYWdlIDpcclxuICAgICAgICBzdGF0ZS5jdXJyZW50UGFnZTtcclxuXHJcbiAgICAgIGlmICghX2lzQXJyYXkobW9kZWxzKSkgbW9kZWxzID0gbW9kZWxzID8gW21vZGVsc10gOiBbXTtcclxuICAgICAgbW9kZWxzID0gbW9kZWxzLnNsaWNlKCk7XHJcblxyXG4gICAgICBpZiAobW9kZSAhPSBcInNlcnZlclwiICYmIHN0YXRlLnRvdGFsUmVjb3JkcyA9PSBudWxsICYmICFfaXNFbXB0eShtb2RlbHMpKSB7XHJcbiAgICAgICAgc3RhdGUudG90YWxSZWNvcmRzID0gbW9kZWxzLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zd2l0Y2hNb2RlKG1vZGUsIF9leHRlbmQoe2ZldGNoOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0U3RhdGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxzOiBtb2RlbHN9LCBvcHRpb25zKSk7XHJcblxyXG4gICAgICB2YXIgY29tcGFyYXRvciA9IG9wdGlvbnMuY29tcGFyYXRvcjtcclxuXHJcbiAgICAgIGlmIChzdGF0ZS5zb3J0S2V5ICYmICFjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTb3J0aW5nKHN0YXRlLnNvcnRLZXksIHN0YXRlLm9yZGVyLCBvcHRpb25zKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG1vZGUgIT0gXCJzZXJ2ZXJcIikge1xyXG4gICAgICAgIHZhciBmdWxsQ29sbGVjdGlvbiA9IHRoaXMuZnVsbENvbGxlY3Rpb247XHJcblxyXG4gICAgICAgIGlmIChjb21wYXJhdG9yICYmIG9wdGlvbnMuZnVsbCkge1xyXG4gICAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gbnVsbDtcclxuICAgICAgICAgIGZ1bGxDb2xsZWN0aW9uLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuZnVsbCkgZnVsbENvbGxlY3Rpb24uc29ydCgpO1xyXG5cclxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIG1vZGVscyBpbiB0aGUgY3VycmVudCBwYWdlIGFuZCBmdWxsIGNvbGxlY3Rpb24gaGF2ZSB0aGVcclxuICAgICAgICAvLyBzYW1lIHJlZmVyZW5jZXNcclxuICAgICAgICBpZiAobW9kZWxzICYmICFfaXNFbXB0eShtb2RlbHMpKSB7XHJcbiAgICAgICAgICB0aGlzLnJlc2V0KG1vZGVscywgX2V4dGVuZCh7c2lsZW50OiB0cnVlfSwgb3B0aW9ucykpO1xyXG4gICAgICAgICAgdGhpcy5nZXRQYWdlKHN0YXRlLmN1cnJlbnRQYWdlKTtcclxuICAgICAgICAgIG1vZGVscy5zcGxpY2UuYXBwbHkobW9kZWxzLCBbMCwgbW9kZWxzLmxlbmd0aF0uY29uY2F0KHRoaXMubW9kZWxzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLl9pbml0U3RhdGUgPSBfY2xvbmUodGhpcy5zdGF0ZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgTWFrZXMgYSBCYWNrYm9uZS5Db2xsZWN0aW9uIHRoYXQgY29udGFpbnMgYWxsIHRoZSBwYWdlcy5cclxuXHJcbiAgICAgICBAcHJpdmF0ZVxyXG4gICAgICAgQHBhcmFtIHtBcnJheS48T2JqZWN0fEJhY2tib25lLk1vZGVsPn0gbW9kZWxzXHJcbiAgICAgICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIGZvciBCYWNrYm9uZS5Db2xsZWN0aW9uIGNvbnN0cnVjdG9yLlxyXG4gICAgICAgQHJldHVybiB7QmFja2JvbmUuQ29sbGVjdGlvbn1cclxuICAgICovXHJcbiAgICBfbWFrZUZ1bGxDb2xsZWN0aW9uOiBmdW5jdGlvbiAobW9kZWxzLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICB2YXIgcHJvcGVydGllcyA9IFtcInVybFwiLCBcIm1vZGVsXCIsIFwic3luY1wiLCBcImNvbXBhcmF0b3JcIl07XHJcbiAgICAgIHZhciB0aGlzUHJvdG8gPSB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcclxuICAgICAgdmFyIGksIGxlbmd0aCwgcHJvcDtcclxuXHJcbiAgICAgIHZhciBwcm90byA9IHt9O1xyXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgcHJvcCA9IHByb3BlcnRpZXNbaV07XHJcbiAgICAgICAgaWYgKCFfaXNVbmRlZmluZWQodGhpc1Byb3RvW3Byb3BdKSkge1xyXG4gICAgICAgICAgcHJvdG9bcHJvcF0gPSB0aGlzUHJvdG9bcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZnVsbENvbGxlY3Rpb24gPSBuZXcgKEJhY2tib25lLkNvbGxlY3Rpb24uZXh0ZW5kKHByb3RvKSkobW9kZWxzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwcm9wID0gcHJvcGVydGllc1tpXTtcclxuICAgICAgICBpZiAodGhpc1twcm9wXSAhPT0gdGhpc1Byb3RvW3Byb3BdKSB7XHJcbiAgICAgICAgICBmdWxsQ29sbGVjdGlvbltwcm9wXSA9IHRoaXNbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gZnVsbENvbGxlY3Rpb247XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgRmFjdG9yeSBtZXRob2QgdGhhdCByZXR1cm5zIGEgQmFja2JvbmUgZXZlbnQgaGFuZGxlciB0aGF0IHJlc3BvbnNlcyB0b1xyXG4gICAgICAgdGhlIGBhZGRgLCBgcmVtb3ZlYCwgYHJlc2V0YCwgYW5kIHRoZSBgc29ydGAgZXZlbnRzLiBUaGUgcmV0dXJuZWQgZXZlbnRcclxuICAgICAgIGhhbmRsZXIgd2lsbCBzeW5jaHJvbml6ZSB0aGUgY3VycmVudCBwYWdlIGNvbGxlY3Rpb24gYW5kIHRoZSBmdWxsXHJcbiAgICAgICBjb2xsZWN0aW9uJ3MgbW9kZWxzLlxyXG5cclxuICAgICAgIEBwcml2YXRlXHJcblxyXG4gICAgICAgQHBhcmFtIHtCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb259IHBhZ2VDb2xcclxuICAgICAgIEBwYXJhbSB7QmFja2JvbmUuQ29sbGVjdGlvbn0gZnVsbENvbFxyXG5cclxuICAgICAgIEByZXR1cm4ge2Z1bmN0aW9uKHN0cmluZywgQmFja2JvbmUuTW9kZWwsIEJhY2tib25lLkNvbGxlY3Rpb24sIE9iamVjdCl9XHJcbiAgICAgICBDb2xsZWN0aW9uIGV2ZW50IGhhbmRsZXJcclxuICAgICovXHJcbiAgICBfbWFrZUNvbGxlY3Rpb25FdmVudEhhbmRsZXI6IGZ1bmN0aW9uIChwYWdlQ29sLCBmdWxsQ29sKSB7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gY29sbGVjdGlvbkV2ZW50SGFuZGxlciAoZXZlbnQsIG1vZGVsLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XHJcblxyXG4gICAgICAgIHZhciBoYW5kbGVycyA9IHBhZ2VDb2wuX2hhbmRsZXJzO1xyXG4gICAgICAgIF9lYWNoKF9rZXlzKGhhbmRsZXJzKSwgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICB2YXIgaGFuZGxlciA9IGhhbmRsZXJzW2V2ZW50XTtcclxuICAgICAgICAgIHBhZ2VDb2wub2ZmKGV2ZW50LCBoYW5kbGVyKTtcclxuICAgICAgICAgIGZ1bGxDb2wub2ZmKGV2ZW50LCBoYW5kbGVyKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgdmFyIHN0YXRlID0gX2Nsb25lKHBhZ2VDb2wuc3RhdGUpO1xyXG4gICAgICAgIHZhciBmaXJzdFBhZ2UgPSBzdGF0ZS5maXJzdFBhZ2U7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRQYWdlID0gZmlyc3RQYWdlID09PSAwID9cclxuICAgICAgICAgIHN0YXRlLmN1cnJlbnRQYWdlIDpcclxuICAgICAgICAgIHN0YXRlLmN1cnJlbnRQYWdlIC0gMTtcclxuICAgICAgICB2YXIgcGFnZVNpemUgPSBzdGF0ZS5wYWdlU2l6ZTtcclxuICAgICAgICB2YXIgcGFnZVN0YXJ0ID0gY3VycmVudFBhZ2UgKiBwYWdlU2l6ZSwgcGFnZUVuZCA9IHBhZ2VTdGFydCArIHBhZ2VTaXplO1xyXG5cclxuICAgICAgICBpZiAoZXZlbnQgPT0gXCJhZGRcIikge1xyXG4gICAgICAgICAgdmFyIHBhZ2VJbmRleCwgZnVsbEluZGV4LCBhZGRBdCwgY29sVG9BZGQsIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gZnVsbENvbCkge1xyXG4gICAgICAgICAgICBmdWxsSW5kZXggPSBmdWxsQ29sLmluZGV4T2YobW9kZWwpO1xyXG4gICAgICAgICAgICBpZiAoZnVsbEluZGV4ID49IHBhZ2VTdGFydCAmJiBmdWxsSW5kZXggPCBwYWdlRW5kKSB7XHJcbiAgICAgICAgICAgICAgY29sVG9BZGQgPSBwYWdlQ29sO1xyXG4gICAgICAgICAgICAgIHBhZ2VJbmRleCA9IGFkZEF0ID0gZnVsbEluZGV4IC0gcGFnZVN0YXJ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFnZUluZGV4ID0gcGFnZUNvbC5pbmRleE9mKG1vZGVsKTtcclxuICAgICAgICAgICAgZnVsbEluZGV4ID0gcGFnZVN0YXJ0ICsgcGFnZUluZGV4O1xyXG4gICAgICAgICAgICBjb2xUb0FkZCA9IGZ1bGxDb2w7XHJcbiAgICAgICAgICAgIHZhciBhZGRBdCA9ICFfaXNVbmRlZmluZWQob3B0aW9ucy5hdCkgP1xyXG4gICAgICAgICAgICAgIG9wdGlvbnMuYXQgKyBwYWdlU3RhcnQgOlxyXG4gICAgICAgICAgICAgIGZ1bGxJbmRleDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBpZiAoIW9wdGlvbnMub25SZW1vdmUpIHtcclxuICAgICAgICAgICAgKytzdGF0ZS50b3RhbFJlY29yZHM7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLm9uUmVtb3ZlO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHBhZ2VDb2wuc3RhdGUgPSBwYWdlQ29sLl9jaGVja1N0YXRlKHN0YXRlKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29sVG9BZGQpIHtcclxuICAgICAgICAgICAgY29sVG9BZGQuYWRkKG1vZGVsLCBfZXh0ZW5kKHt9LCBvcHRpb25zIHx8IHt9LCB7YXQ6IGFkZEF0fSkpO1xyXG4gICAgICAgICAgICB2YXIgbW9kZWxUb1JlbW92ZSA9IHBhZ2VJbmRleCA+PSBwYWdlU2l6ZSA/XHJcbiAgICAgICAgICAgICAgbW9kZWwgOlxyXG4gICAgICAgICAgICAgICFfaXNVbmRlZmluZWQob3B0aW9ucy5hdCkgJiYgYWRkQXQgPCBwYWdlRW5kICYmIHBhZ2VDb2wubGVuZ3RoID4gcGFnZVNpemUgP1xyXG4gICAgICAgICAgICAgIHBhZ2VDb2wuYXQocGFnZVNpemUpIDpcclxuICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgICAgICBpZiAobW9kZWxUb1JlbW92ZSkge1xyXG4gICAgICAgICAgICAgIHJ1bk9uY2VBdExhc3RIYW5kbGVyKGNvbGxlY3Rpb24sIGV2ZW50LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBwYWdlQ29sLnJlbW92ZShtb2RlbFRvUmVtb3ZlLCB7b25BZGQ6IHRydWV9KTtcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBtb2RlbCBmcm9tIHRoZSBvdGhlciBjb2xsZWN0aW9uIGFzIHdlbGxcclxuICAgICAgICBpZiAoZXZlbnQgPT0gXCJyZW1vdmVcIikge1xyXG4gICAgICAgICAgaWYgKCFvcHRpb25zLm9uQWRkKSB7XHJcbiAgICAgICAgICAgIC8vIGRlY3JlbWVudCB0b3RhbFJlY29yZHMgYW5kIHVwZGF0ZSB0b3RhbFBhZ2VzIGFuZCBsYXN0UGFnZVxyXG4gICAgICAgICAgICBpZiAoIS0tc3RhdGUudG90YWxSZWNvcmRzKSB7XHJcbiAgICAgICAgICAgICAgc3RhdGUudG90YWxSZWNvcmRzID0gbnVsbDtcclxuICAgICAgICAgICAgICBzdGF0ZS50b3RhbFBhZ2VzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICB2YXIgdG90YWxQYWdlcyA9IHN0YXRlLnRvdGFsUGFnZXMgPSBjZWlsKHN0YXRlLnRvdGFsUmVjb3JkcyAvIHBhZ2VTaXplKTtcclxuICAgICAgICAgICAgICBzdGF0ZS5sYXN0UGFnZSA9IGZpcnN0UGFnZSA9PT0gMCA/IHRvdGFsUGFnZXMgLSAxIDogdG90YWxQYWdlcyB8fCBmaXJzdFBhZ2U7XHJcbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmN1cnJlbnRQYWdlID4gdG90YWxQYWdlcykgc3RhdGUuY3VycmVudFBhZ2UgPSBzdGF0ZS5sYXN0UGFnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYWdlQ29sLnN0YXRlID0gcGFnZUNvbC5fY2hlY2tTdGF0ZShzdGF0ZSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbmV4dE1vZGVsLCByZW1vdmVkSW5kZXggPSBvcHRpb25zLmluZGV4O1xyXG4gICAgICAgICAgICBpZiAoY29sbGVjdGlvbiA9PSBwYWdlQ29sKSB7XHJcbiAgICAgICAgICAgICAgaWYgKG5leHRNb2RlbCA9IGZ1bGxDb2wuYXQocGFnZUVuZCkpIHtcclxuICAgICAgICAgICAgICAgIHJ1bk9uY2VBdExhc3RIYW5kbGVyKHBhZ2VDb2wsIGV2ZW50LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgIHBhZ2VDb2wucHVzaChuZXh0TW9kZWwsIHtvblJlbW92ZTogdHJ1ZX0pO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGVsc2UgaWYgKCFwYWdlQ29sLmxlbmd0aCAmJiBzdGF0ZS50b3RhbFJlY29yZHMpIHtcclxuICAgICAgICAgICAgICAgIHBhZ2VDb2wucmVzZXQoZnVsbENvbC5tb2RlbHMuc2xpY2UocGFnZVN0YXJ0IC0gcGFnZVNpemUsIHBhZ2VFbmQgLSBwYWdlU2l6ZSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9leHRlbmQoe30sIG9wdGlvbnMsIHtwYXJzZTogZmFsc2V9KSk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGZ1bGxDb2wucmVtb3ZlKG1vZGVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyZW1vdmVkSW5kZXggPj0gcGFnZVN0YXJ0ICYmIHJlbW92ZWRJbmRleCA8IHBhZ2VFbmQpIHtcclxuICAgICAgICAgICAgICBpZiAobmV4dE1vZGVsID0gZnVsbENvbC5hdChwYWdlRW5kIC0gMSkpIHtcclxuICAgICAgICAgICAgICAgIHJ1bk9uY2VBdExhc3RIYW5kbGVyKHBhZ2VDb2wsIGV2ZW50LCBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgcGFnZUNvbC5wdXNoKG5leHRNb2RlbCwge29uUmVtb3ZlOiB0cnVlfSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgcGFnZUNvbC5yZW1vdmUobW9kZWwpO1xyXG4gICAgICAgICAgICAgIGlmICghcGFnZUNvbC5sZW5ndGggJiYgc3RhdGUudG90YWxSZWNvcmRzKSB7XHJcbiAgICAgICAgICAgICAgICBwYWdlQ29sLnJlc2V0KGZ1bGxDb2wubW9kZWxzLnNsaWNlKHBhZ2VTdGFydCAtIHBhZ2VTaXplLCBwYWdlRW5kIC0gcGFnZVNpemUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZXh0ZW5kKHt9LCBvcHRpb25zLCB7cGFyc2U6IGZhbHNlfSkpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBkZWxldGUgb3B0aW9ucy5vbkFkZDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChldmVudCA9PSBcInJlc2V0XCIpIHtcclxuICAgICAgICAgIG9wdGlvbnMgPSBjb2xsZWN0aW9uO1xyXG4gICAgICAgICAgY29sbGVjdGlvbiA9IG1vZGVsO1xyXG5cclxuICAgICAgICAgIC8vIFJlc2V0IHRoYXQncyBub3QgYSByZXN1bHQgb2YgZ2V0UGFnZVxyXG4gICAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gcGFnZUNvbCAmJiBvcHRpb25zLmZyb20gPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgIG9wdGlvbnMudG8gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgaGVhZCA9IGZ1bGxDb2wubW9kZWxzLnNsaWNlKDAsIHBhZ2VTdGFydCk7XHJcbiAgICAgICAgICAgIHZhciB0YWlsID0gZnVsbENvbC5tb2RlbHMuc2xpY2UocGFnZVN0YXJ0ICsgcGFnZUNvbC5tb2RlbHMubGVuZ3RoKTtcclxuICAgICAgICAgICAgZnVsbENvbC5yZXNldChoZWFkLmNvbmNhdChwYWdlQ29sLm1vZGVscykuY29uY2F0KHRhaWwpLCBvcHRpb25zKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGVsc2UgaWYgKGNvbGxlY3Rpb24gPT0gZnVsbENvbCkge1xyXG4gICAgICAgICAgICBpZiAoIShzdGF0ZS50b3RhbFJlY29yZHMgPSBmdWxsQ29sLm1vZGVscy5sZW5ndGgpKSB7XHJcbiAgICAgICAgICAgICAgc3RhdGUudG90YWxSZWNvcmRzID0gbnVsbDtcclxuICAgICAgICAgICAgICBzdGF0ZS50b3RhbFBhZ2VzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocGFnZUNvbC5tb2RlID09IFwiY2xpZW50XCIpIHtcclxuICAgICAgICAgICAgICBzdGF0ZS5sYXN0UGFnZSA9IHN0YXRlLmN1cnJlbnRQYWdlID0gc3RhdGUuZmlyc3RQYWdlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBhZ2VDb2wuc3RhdGUgPSBwYWdlQ29sLl9jaGVja1N0YXRlKHN0YXRlKTtcclxuICAgICAgICAgICAgcGFnZUNvbC5yZXNldChmdWxsQ29sLm1vZGVscy5zbGljZShwYWdlU3RhcnQsIHBhZ2VFbmQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9leHRlbmQoe30sIG9wdGlvbnMsIHtwYXJzZTogZmFsc2V9KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoZXZlbnQgPT0gXCJzb3J0XCIpIHtcclxuICAgICAgICAgIG9wdGlvbnMgPSBjb2xsZWN0aW9uO1xyXG4gICAgICAgICAgY29sbGVjdGlvbiA9IG1vZGVsO1xyXG4gICAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT09IGZ1bGxDb2wpIHtcclxuICAgICAgICAgICAgcGFnZUNvbC5yZXNldChmdWxsQ29sLm1vZGVscy5zbGljZShwYWdlU3RhcnQsIHBhZ2VFbmQpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9leHRlbmQoe30sIG9wdGlvbnMsIHtwYXJzZTogZmFsc2V9KSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBfZWFjaChfa2V5cyhoYW5kbGVycyksIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgdmFyIGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudF07XHJcbiAgICAgICAgICBfZWFjaChbcGFnZUNvbCwgZnVsbENvbF0sIGZ1bmN0aW9uIChjb2wpIHtcclxuICAgICAgICAgICAgY29sLm9uKGV2ZW50LCBoYW5kbGVyKTtcclxuICAgICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IGNvbC5fZXZlbnRzW2V2ZW50XSB8fCBbXTtcclxuICAgICAgICAgICAgY2FsbGJhY2tzLnVuc2hpZnQoY2FsbGJhY2tzLnBvcCgpKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAgIFNhbml0eSBjaGVjayB0aGlzIGNvbGxlY3Rpb24ncyBwYWdpbmF0aW9uIHN0YXRlcy4gT25seSBwZXJmb3JtIGNoZWNrc1xyXG4gICAgICAgd2hlbiBhbGwgdGhlIHJlcXVpcmVkIHBhZ2luYXRpb24gc3RhdGUgdmFsdWVzIGFyZSBkZWZpbmVkIGFuZCBub3QgbnVsbC5cclxuICAgICAgIElmIGB0b3RhbFBhZ2VzYCBpcyB1bmRlZmluZWQgb3IgbnVsbCwgaXQgaXMgc2V0IHRvIGB0b3RhbFJlY29yZHNgIC9cclxuICAgICAgIGBwYWdlU2l6ZWAuIGBsYXN0UGFnZWAgaXMgc2V0IGFjY29yZGluZyB0byB3aGV0aGVyIGBmaXJzdFBhZ2VgIGlzIDAgb3IgMVxyXG4gICAgICAgd2hlbiBubyBlcnJvciBvY2N1cnMuXHJcblxyXG4gICAgICAgQHByaXZhdGVcclxuXHJcbiAgICAgICBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGB0b3RhbFJlY29yZHNgLCBgcGFnZVNpemVgLCBgY3VycmVudFBhZ2VgIG9yXHJcbiAgICAgICBgZmlyc3RQYWdlYCBpcyBub3QgYSBmaW5pdGUgaW50ZWdlci5cclxuXHJcbiAgICAgICBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcGFnZVNpemVgLCBgY3VycmVudFBhZ2VgIG9yIGBmaXJzdFBhZ2VgIGlzIG91dFxyXG4gICAgICAgb2YgYm91bmRzLlxyXG5cclxuICAgICAgIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgYHN0YXRlYCBvYmplY3QgaWYgbm8gZXJyb3Igd2FzIGZvdW5kLlxyXG4gICAgKi9cclxuICAgIF9jaGVja1N0YXRlOiBmdW5jdGlvbiAoc3RhdGUpIHtcclxuXHJcbiAgICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xyXG4gICAgICB2YXIgbGlua3MgPSB0aGlzLmxpbmtzO1xyXG4gICAgICB2YXIgdG90YWxSZWNvcmRzID0gc3RhdGUudG90YWxSZWNvcmRzO1xyXG4gICAgICB2YXIgcGFnZVNpemUgPSBzdGF0ZS5wYWdlU2l6ZTtcclxuICAgICAgdmFyIGN1cnJlbnRQYWdlID0gc3RhdGUuY3VycmVudFBhZ2U7XHJcbiAgICAgIHZhciBmaXJzdFBhZ2UgPSBzdGF0ZS5maXJzdFBhZ2U7XHJcbiAgICAgIHZhciB0b3RhbFBhZ2VzID0gc3RhdGUudG90YWxQYWdlcztcclxuXHJcbiAgICAgIGlmICh0b3RhbFJlY29yZHMgIT0gbnVsbCAmJiBwYWdlU2l6ZSAhPSBudWxsICYmIGN1cnJlbnRQYWdlICE9IG51bGwgJiZcclxuICAgICAgICAgIGZpcnN0UGFnZSAhPSBudWxsICYmIChtb2RlID09IFwiaW5maW5pdGVcIiA/IGxpbmtzIDogdHJ1ZSkpIHtcclxuXHJcbiAgICAgICAgdG90YWxSZWNvcmRzID0gZmluaXRlSW50KHRvdGFsUmVjb3JkcywgXCJ0b3RhbFJlY29yZHNcIik7XHJcbiAgICAgICAgcGFnZVNpemUgPSBmaW5pdGVJbnQocGFnZVNpemUsIFwicGFnZVNpemVcIik7XHJcbiAgICAgICAgY3VycmVudFBhZ2UgPSBmaW5pdGVJbnQoY3VycmVudFBhZ2UsIFwiY3VycmVudFBhZ2VcIik7XHJcbiAgICAgICAgZmlyc3RQYWdlID0gZmluaXRlSW50KGZpcnN0UGFnZSwgXCJmaXJzdFBhZ2VcIik7XHJcblxyXG4gICAgICAgIGlmIChwYWdlU2l6ZSA8IDEpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYHBhZ2VTaXplYCBtdXN0IGJlID49IDFcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0b3RhbFBhZ2VzID0gc3RhdGUudG90YWxQYWdlcyA9IGNlaWwodG90YWxSZWNvcmRzIC8gcGFnZVNpemUpO1xyXG5cclxuICAgICAgICBpZiAoZmlyc3RQYWdlIDwgMCB8fCBmaXJzdFBhZ2UgPiAxKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImBmaXJzdFBhZ2UgbXVzdCBiZSAwIG9yIDFgXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RhdGUubGFzdFBhZ2UgPSBmaXJzdFBhZ2UgPT09IDAgPyBtYXgoMCwgdG90YWxQYWdlcyAtIDEpIDogdG90YWxQYWdlcyB8fCBmaXJzdFBhZ2U7XHJcblxyXG4gICAgICAgIGlmIChtb2RlID09IFwiaW5maW5pdGVcIikge1xyXG4gICAgICAgICAgaWYgKCFsaW5rc1tjdXJyZW50UGFnZSArICcnXSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIGxpbmsgZm91bmQgZm9yIHBhZ2UgXCIgKyBjdXJyZW50UGFnZSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRQYWdlIDwgZmlyc3RQYWdlIHx8XHJcbiAgICAgICAgICAgICAgICAgKHRvdGFsUGFnZXMgPiAwICYmXHJcbiAgICAgICAgICAgICAgICAgIChmaXJzdFBhZ2UgPyBjdXJyZW50UGFnZSA+IHRvdGFsUGFnZXMgOiBjdXJyZW50UGFnZSA+PSB0b3RhbFBhZ2VzKSkpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYGN1cnJlbnRQYWdlYCBtdXN0IGJlIGZpcnN0UGFnZSA8PSBjdXJyZW50UGFnZSBcIiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmlyc3RQYWdlID8gXCI+XCIgOiBcIj49XCIpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiIHRvdGFsUGFnZXMgaWYgXCIgKyBmaXJzdFBhZ2UgKyBcIi1iYXNlZC4gR290IFwiICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQYWdlICsgJy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdGF0ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBDaGFuZ2UgdGhlIHBhZ2Ugc2l6ZSBvZiB0aGlzIGNvbGxlY3Rpb24uXHJcblxyXG4gICAgICAgVW5kZXIgbW9zdCBpZiBub3QgYWxsIGNpcmN1bXN0YW5jZXMsIHlvdSBzaG91bGQgY2FsbCB0aGlzIG1ldGhvZCB0b1xyXG4gICAgICAgY2hhbmdlIHRoZSBwYWdlIHNpemUgb2YgYSBwYWdlYWJsZSBjb2xsZWN0aW9uIGJlY2F1c2UgaXQgd2lsbCBrZWVwIHRoZVxyXG4gICAgICAgcGFnaW5hdGlvbiBzdGF0ZSBzYW5lLiBCeSBkZWZhdWx0LCB0aGUgbWV0aG9kIHdpbGwgcmVjYWxjdWxhdGUgdGhlXHJcbiAgICAgICBjdXJyZW50IHBhZ2UgbnVtYmVyIHRvIG9uZSB0aGF0IHdpbGwgcmV0YWluIHRoZSBjdXJyZW50IHBhZ2UncyBtb2RlbHNcclxuICAgICAgIHdoZW4gaW5jcmVhc2luZyB0aGUgcGFnZSBzaXplLiBXaGVuIGRlY3JlYXNpbmcgdGhlIHBhZ2Ugc2l6ZSwgdGhpcyBtZXRob2RcclxuICAgICAgIHdpbGwgcmV0YWluIHRoZSBsYXN0IG1vZGVscyB0byB0aGUgY3VycmVudCBwYWdlIHRoYXQgd2lsbCBmaXQgaW50byB0aGVcclxuICAgICAgIHNtYWxsZXIgcGFnZSBzaXplLlxyXG5cclxuICAgICAgIElmIGBvcHRpb25zLmZpcnN0YCBpcyB0cnVlLCBjaGFuZ2luZyB0aGUgcGFnZSBzaXplIHdpbGwgYWxzbyByZXNldCB0aGVcclxuICAgICAgIGN1cnJlbnQgcGFnZSBiYWNrIHRvIHRoZSBmaXJzdCBwYWdlIGluc3RlYWQgb2YgdHJ5aW5nIHRvIGJlIHNtYXJ0LlxyXG5cclxuICAgICAgIEZvciBzZXJ2ZXIgbW9kZSBvcGVyYXRpb25zLCBjaGFuZ2luZyB0aGUgcGFnZSBzaXplIHdpbGwgdHJpZ2dlciBhICNmZXRjaFxyXG4gICAgICAgYW5kIHN1YnNlcXVlbnRseSBhIGByZXNldGAgZXZlbnQuXHJcblxyXG4gICAgICAgRm9yIGNsaWVudCBtb2RlIG9wZXJhdGlvbnMsIGNoYW5naW5nIHRoZSBwYWdlIHNpemUgd2lsbCBgcmVzZXRgIHRoZVxyXG4gICAgICAgY3VycmVudCBwYWdlIGJ5IHJlY2FsY3VsYXRpbmcgdGhlIGN1cnJlbnQgcGFnZSBib3VuZGFyeSBvbiB0aGUgY2xpZW50XHJcbiAgICAgICBzaWRlLlxyXG5cclxuICAgICAgIElmIGBvcHRpb25zLmZldGNoYCBpcyB0cnVlLCBhIGZldGNoIGNhbiBiZSBmb3JjZWQgaWYgdGhlIGNvbGxlY3Rpb24gaXMgaW5cclxuICAgICAgIGNsaWVudCBtb2RlLlxyXG5cclxuICAgICAgIEBwYXJhbSB7bnVtYmVyfSBwYWdlU2l6ZSBUaGUgbmV3IHBhZ2Ugc2l6ZSB0byBzZXQgdG8gI3N0YXRlLlxyXG4gICAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSB7QGxpbmsgI2ZldGNofSBvcHRpb25zLlxyXG4gICAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5maXJzdD1mYWxzZV0gUmVzZXQgdGhlIGN1cnJlbnQgcGFnZSBudW1iZXIgdG9cclxuICAgICAgIHRoZSBmaXJzdCBwYWdlIGlmIGB0cnVlYC5cclxuICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmV0Y2hdIElmIGB0cnVlYCwgZm9yY2UgYSBmZXRjaCBpbiBjbGllbnQgbW9kZS5cclxuXHJcbiAgICAgICBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBwYWdlU2l6ZWAgaXMgbm90IGEgZmluaXRlIGludGVnZXIuXHJcbiAgICAgICBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBgcGFnZVNpemVgIGlzIGxlc3MgdGhhbiAxLlxyXG5cclxuICAgICAgIEBjaGFpbmFibGVcclxuICAgICAgIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fEJhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbn0gVGhlIFhNTEh0dHBSZXF1ZXN0XHJcbiAgICAgICBmcm9tIGZldGNoIG9yIHRoaXMuXHJcbiAgICAqL1xyXG4gICAgc2V0UGFnZVNpemU6IGZ1bmN0aW9uIChwYWdlU2l6ZSwgb3B0aW9ucykge1xyXG4gICAgICBwYWdlU2l6ZSA9IGZpbml0ZUludChwYWdlU2l6ZSwgXCJwYWdlU2l6ZVwiKTtcclxuXHJcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHtmaXJzdDogZmFsc2V9O1xyXG5cclxuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgdmFyIHRvdGFsUGFnZXMgPSBjZWlsKHN0YXRlLnRvdGFsUmVjb3JkcyAvIHBhZ2VTaXplKTtcclxuICAgICAgdmFyIGN1cnJlbnRQYWdlID0gdG90YWxQYWdlcyA/XHJcbiAgICAgICAgICBtYXgoc3RhdGUuZmlyc3RQYWdlLCBmbG9vcih0b3RhbFBhZ2VzICogc3RhdGUuY3VycmVudFBhZ2UgLyBzdGF0ZS50b3RhbFBhZ2VzKSkgOlxyXG4gICAgICAgIHN0YXRlLmZpcnN0UGFnZTtcclxuXHJcbiAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZSA9IHRoaXMuX2NoZWNrU3RhdGUoX2V4dGVuZCh7fSwgc3RhdGUsIHtcclxuICAgICAgICBwYWdlU2l6ZTogcGFnZVNpemUsXHJcbiAgICAgICAgY3VycmVudFBhZ2U6IG9wdGlvbnMuZmlyc3QgPyBzdGF0ZS5maXJzdFBhZ2UgOiBjdXJyZW50UGFnZSxcclxuICAgICAgICB0b3RhbFBhZ2VzOiB0b3RhbFBhZ2VzXHJcbiAgICAgIH0pKTtcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmdldFBhZ2Uoc3RhdGUuY3VycmVudFBhZ2UsIF9vbWl0KG9wdGlvbnMsIFtcImZpcnN0XCJdKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgU3dpdGNoaW5nIGJldHdlZW4gY2xpZW50LCBzZXJ2ZXIgYW5kIGluZmluaXRlIG1vZGUuXHJcblxyXG4gICAgICAgSWYgc3dpdGNoaW5nIGZyb20gY2xpZW50IHRvIHNlcnZlciBtb2RlLCB0aGUgI2Z1bGxDb2xsZWN0aW9uIGlzIGVtcHRpZWRcclxuICAgICAgIGZpcnN0IGFuZCB0aGVuIGRlbGV0ZWQgYW5kIGEgZmV0Y2ggaXMgaW1tZWRpYXRlbHkgaXNzdWVkIGZvciB0aGUgY3VycmVudFxyXG4gICAgICAgcGFnZSBmcm9tIHRoZSBzZXJ2ZXIuIFBhc3MgYGZhbHNlYCB0byBgb3B0aW9ucy5mZXRjaGAgdG8gc2tpcCBmZXRjaGluZy5cclxuXHJcbiAgICAgICBJZiBzd2l0Y2hpbmcgdG8gaW5maW5pdGUgbW9kZSwgYW5kIGlmIGBvcHRpb25zLm1vZGVsc2AgaXMgZ2l2ZW4gZm9yIGFuXHJcbiAgICAgICBhcnJheSBvZiBtb2RlbHMsICNsaW5rcyB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIGEgVVJMIHBlciBwYWdlLCB1c2luZyB0aGVcclxuICAgICAgIGRlZmF1bHQgVVJMIGZvciB0aGlzIGNvbGxlY3Rpb24uXHJcblxyXG4gICAgICAgSWYgc3dpdGNoaW5nIGZyb20gc2VydmVyIHRvIGNsaWVudCBtb2RlLCBhbGwgb2YgdGhlIHBhZ2VzIGFyZSBpbW1lZGlhdGVseVxyXG4gICAgICAgcmVmZXRjaGVkLiBJZiB5b3UgaGF2ZSB0b28gbWFueSBwYWdlcywgeW91IGNhbiBwYXNzIGBmYWxzZWAgdG9cclxuICAgICAgIGBvcHRpb25zLmZldGNoYCB0byBza2lwIGZldGNoaW5nLlxyXG5cclxuICAgICAgIElmIHN3aXRjaGluZyB0byBhbnkgbW9kZSBmcm9tIGluZmluaXRlIG1vZGUsIHRoZSAjbGlua3Mgd2lsbCBiZSBkZWxldGVkLlxyXG5cclxuICAgICAgIEBwYXJhbSB7XCJzZXJ2ZXJcInxcImNsaWVudFwifFwiaW5maW5pdGVcIn0gW21vZGVdIFRoZSBtb2RlIHRvIHN3aXRjaCB0by5cclxuXHJcbiAgICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcblxyXG4gICAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mZXRjaD10cnVlXSBJZiBgZmFsc2VgLCBubyBmZXRjaGluZyBpcyBkb25lLlxyXG5cclxuICAgICAgIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVzZXRTdGF0ZT10cnVlXSBJZiAnZmFsc2UnLCB0aGUgc3RhdGUgaXMgbm90XHJcbiAgICAgICByZXNldCwgYnV0IGNoZWNrZWQgZm9yIHNhbml0eSBpbnN0ZWFkLlxyXG5cclxuICAgICAgIEBjaGFpbmFibGVcclxuICAgICAgIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fEJhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbn0gVGhlIFhNTEh0dHBSZXF1ZXN0XHJcbiAgICAgICBmcm9tIGZldGNoIG9yIHRoaXMgaWYgYG9wdGlvbnMuZmV0Y2hgIGlzIGBmYWxzZWAuXHJcbiAgICAqL1xyXG4gICAgc3dpdGNoTW9kZTogZnVuY3Rpb24gKG1vZGUsIG9wdGlvbnMpIHtcclxuXHJcbiAgICAgIGlmICghX2NvbnRhaW5zKFtcInNlcnZlclwiLCBcImNsaWVudFwiLCBcImluZmluaXRlXCJdLCBtb2RlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Btb2RlYCBtdXN0IGJlIG9uZSBvZiBcInNlcnZlclwiLCBcImNsaWVudFwiIG9yIFwiaW5maW5pdGVcIicpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7ZmV0Y2g6IHRydWUsIHJlc2V0U3RhdGU6IHRydWV9O1xyXG5cclxuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZSA9IG9wdGlvbnMucmVzZXRTdGF0ZSA/XHJcbiAgICAgICAgX2Nsb25lKHRoaXMuX2luaXRTdGF0ZSkgOlxyXG4gICAgICAgIHRoaXMuX2NoZWNrU3RhdGUoX2V4dGVuZCh7fSwgdGhpcy5zdGF0ZSkpO1xyXG5cclxuICAgICAgdGhpcy5tb2RlID0gbW9kZTtcclxuXHJcbiAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgdmFyIGZ1bGxDb2xsZWN0aW9uID0gdGhpcy5mdWxsQ29sbGVjdGlvbjtcclxuICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5faGFuZGxlcnMgPSB0aGlzLl9oYW5kbGVycyB8fCB7fSwgaGFuZGxlcjtcclxuICAgICAgaWYgKG1vZGUgIT0gXCJzZXJ2ZXJcIiAmJiAhZnVsbENvbGxlY3Rpb24pIHtcclxuICAgICAgICBmdWxsQ29sbGVjdGlvbiA9IHRoaXMuX21ha2VGdWxsQ29sbGVjdGlvbihvcHRpb25zLm1vZGVscyB8fCBbXSwgb3B0aW9ucyk7XHJcbiAgICAgICAgZnVsbENvbGxlY3Rpb24ucGFnZWFibGVDb2xsZWN0aW9uID0gdGhpcztcclxuICAgICAgICB0aGlzLmZ1bGxDb2xsZWN0aW9uID0gZnVsbENvbGxlY3Rpb247XHJcbiAgICAgICAgdmFyIGFsbEhhbmRsZXIgPSB0aGlzLl9tYWtlQ29sbGVjdGlvbkV2ZW50SGFuZGxlcih0aGlzLCBmdWxsQ29sbGVjdGlvbik7XHJcbiAgICAgICAgX2VhY2goW1wiYWRkXCIsIFwicmVtb3ZlXCIsIFwicmVzZXRcIiwgXCJzb3J0XCJdLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICAgIGhhbmRsZXJzW2V2ZW50XSA9IGhhbmRsZXIgPSBfLmJpbmQoYWxsSGFuZGxlciwge30sIGV2ZW50KTtcclxuICAgICAgICAgIHNlbGYub24oZXZlbnQsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgZnVsbENvbGxlY3Rpb24ub24oZXZlbnQsIGhhbmRsZXIpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGZ1bGxDb2xsZWN0aW9uLmNvbXBhcmF0b3IgPSB0aGlzLl9mdWxsQ29tcGFyYXRvcjtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmIChtb2RlID09IFwic2VydmVyXCIgJiYgZnVsbENvbGxlY3Rpb24pIHtcclxuICAgICAgICBfZWFjaChfa2V5cyhoYW5kbGVycyksIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgaGFuZGxlciA9IGhhbmRsZXJzW2V2ZW50XTtcclxuICAgICAgICAgIHNlbGYub2ZmKGV2ZW50LCBoYW5kbGVyKTtcclxuICAgICAgICAgIGZ1bGxDb2xsZWN0aW9uLm9mZihldmVudCwgaGFuZGxlcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2hhbmRsZXJzO1xyXG4gICAgICAgIHRoaXMuX2Z1bGxDb21wYXJhdG9yID0gZnVsbENvbGxlY3Rpb24uY29tcGFyYXRvcjtcclxuICAgICAgICBkZWxldGUgdGhpcy5mdWxsQ29sbGVjdGlvbjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKG1vZGUgPT0gXCJpbmZpbml0ZVwiKSB7XHJcbiAgICAgICAgdmFyIGxpbmtzID0gdGhpcy5saW5rcyA9IHt9O1xyXG4gICAgICAgIHZhciBmaXJzdFBhZ2UgPSBzdGF0ZS5maXJzdFBhZ2U7XHJcbiAgICAgICAgdmFyIHRvdGFsUGFnZXMgPSBjZWlsKHN0YXRlLnRvdGFsUmVjb3JkcyAvIHN0YXRlLnBhZ2VTaXplKTtcclxuICAgICAgICB2YXIgbGFzdFBhZ2UgPSBmaXJzdFBhZ2UgPT09IDAgPyBtYXgoMCwgdG90YWxQYWdlcyAtIDEpIDogdG90YWxQYWdlcyB8fCBmaXJzdFBhZ2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IHN0YXRlLmZpcnN0UGFnZTsgaSA8PSBsYXN0UGFnZTsgaSsrKSB7XHJcbiAgICAgICAgICBsaW5rc1tpXSA9IHRoaXMudXJsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICh0aGlzLmxpbmtzKSBkZWxldGUgdGhpcy5saW5rcztcclxuXHJcbiAgICAgIHJldHVybiBvcHRpb25zLmZldGNoID9cclxuICAgICAgICB0aGlzLmZldGNoKF9vbWl0KG9wdGlvbnMsIFwiZmV0Y2hcIiwgXCJyZXNldFN0YXRlXCIpKSA6XHJcbiAgICAgICAgdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhpcyBjb2xsZWN0aW9uIGNhbiBwYWdlIGJhY2t3YXJkLCBgZmFsc2VgXHJcbiAgICAgICBvdGhlcndpc2UuXHJcbiAgICAqL1xyXG4gICAgaGFzUHJldmlvdXNQYWdlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcbiAgICAgIHZhciBjdXJyZW50UGFnZSA9IHN0YXRlLmN1cnJlbnRQYWdlO1xyXG4gICAgICBpZiAodGhpcy5tb2RlICE9IFwiaW5maW5pdGVcIikgcmV0dXJuIGN1cnJlbnRQYWdlID4gc3RhdGUuZmlyc3RQYWdlO1xyXG4gICAgICByZXR1cm4gISF0aGlzLmxpbmtzW2N1cnJlbnRQYWdlIC0gMV07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoaXMgY29sbGVjdGlvbiBjYW4gcGFnZSBmb3J3YXJkLCBgZmFsc2VgXHJcbiAgICAgICBvdGhlcndpc2UuXHJcbiAgICAqL1xyXG4gICAgaGFzTmV4dFBhZ2U6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuICAgICAgdmFyIGN1cnJlbnRQYWdlID0gdGhpcy5zdGF0ZS5jdXJyZW50UGFnZTtcclxuICAgICAgaWYgKHRoaXMubW9kZSAhPSBcImluZmluaXRlXCIpIHJldHVybiBjdXJyZW50UGFnZSA8IHN0YXRlLmxhc3RQYWdlO1xyXG4gICAgICByZXR1cm4gISF0aGlzLmxpbmtzW2N1cnJlbnRQYWdlICsgMV07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgRmV0Y2ggdGhlIGZpcnN0IHBhZ2UgaW4gc2VydmVyIG1vZGUsIG9yIHJlc2V0IHRoZSBjdXJyZW50IHBhZ2Ugb2YgdGhpc1xyXG4gICAgICAgY29sbGVjdGlvbiB0byB0aGUgZmlyc3QgcGFnZSBpbiBjbGllbnQgb3IgaW5maW5pdGUgbW9kZS5cclxuXHJcbiAgICAgICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB7QGxpbmsgI2dldFBhZ2V9IG9wdGlvbnMuXHJcblxyXG4gICAgICAgQGNoYWluYWJsZVxyXG4gICAgICAgQHJldHVybiB7WE1MSHR0cFJlcXVlc3R8QmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9ufSBUaGUgWE1MSHR0cFJlcXVlc3RcclxuICAgICAgIGZyb20gZmV0Y2ggb3IgdGhpcy5cclxuICAgICovXHJcbiAgICBnZXRGaXJzdFBhZ2U6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldFBhZ2UoXCJmaXJzdFwiLCBvcHRpb25zKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBGZXRjaCB0aGUgcHJldmlvdXMgcGFnZSBpbiBzZXJ2ZXIgbW9kZSwgb3IgcmVzZXQgdGhlIGN1cnJlbnQgcGFnZSBvZiB0aGlzXHJcbiAgICAgICBjb2xsZWN0aW9uIHRvIHRoZSBwcmV2aW91cyBwYWdlIGluIGNsaWVudCBvciBpbmZpbml0ZSBtb2RlLlxyXG5cclxuICAgICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHtAbGluayAjZ2V0UGFnZX0gb3B0aW9ucy5cclxuXHJcbiAgICAgICBAY2hhaW5hYmxlXHJcbiAgICAgICBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdHxCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb259IFRoZSBYTUxIdHRwUmVxdWVzdFxyXG4gICAgICAgZnJvbSBmZXRjaCBvciB0aGlzLlxyXG4gICAgKi9cclxuICAgIGdldFByZXZpb3VzUGFnZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0UGFnZShcInByZXZcIiwgb3B0aW9ucyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgRmV0Y2ggdGhlIG5leHQgcGFnZSBpbiBzZXJ2ZXIgbW9kZSwgb3IgcmVzZXQgdGhlIGN1cnJlbnQgcGFnZSBvZiB0aGlzXHJcbiAgICAgICBjb2xsZWN0aW9uIHRvIHRoZSBuZXh0IHBhZ2UgaW4gY2xpZW50IG1vZGUuXHJcblxyXG4gICAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMge0BsaW5rICNnZXRQYWdlfSBvcHRpb25zLlxyXG5cclxuICAgICAgIEBjaGFpbmFibGVcclxuICAgICAgIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fEJhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbn0gVGhlIFhNTEh0dHBSZXF1ZXN0XHJcbiAgICAgICBmcm9tIGZldGNoIG9yIHRoaXMuXHJcbiAgICAqL1xyXG4gICAgZ2V0TmV4dFBhZ2U6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldFBhZ2UoXCJuZXh0XCIsIG9wdGlvbnMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAgIEZldGNoIHRoZSBsYXN0IHBhZ2UgaW4gc2VydmVyIG1vZGUsIG9yIHJlc2V0IHRoZSBjdXJyZW50IHBhZ2Ugb2YgdGhpc1xyXG4gICAgICAgY29sbGVjdGlvbiB0byB0aGUgbGFzdCBwYWdlIGluIGNsaWVudCBtb2RlLlxyXG5cclxuICAgICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHtAbGluayAjZ2V0UGFnZX0gb3B0aW9ucy5cclxuXHJcbiAgICAgICBAY2hhaW5hYmxlXHJcbiAgICAgICBAcmV0dXJuIHtYTUxIdHRwUmVxdWVzdHxCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb259IFRoZSBYTUxIdHRwUmVxdWVzdFxyXG4gICAgICAgZnJvbSBmZXRjaCBvciB0aGlzLlxyXG4gICAgKi9cclxuICAgIGdldExhc3RQYWdlOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRQYWdlKFwibGFzdFwiLCBvcHRpb25zKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBHaXZlbiBhIHBhZ2UgaW5kZXgsIHNldCAjc3RhdGUuY3VycmVudFBhZ2UgdG8gdGhhdCBpbmRleC4gSWYgdGhpc1xyXG4gICAgICAgY29sbGVjdGlvbiBpcyBpbiBzZXJ2ZXIgbW9kZSwgZmV0Y2ggdGhlIHBhZ2UgdXNpbmcgdGhlIHVwZGF0ZWQgc3RhdGUsXHJcbiAgICAgICBvdGhlcndpc2UsIHJlc2V0IHRoZSBjdXJyZW50IHBhZ2Ugb2YgdGhpcyBjb2xsZWN0aW9uIHRvIHRoZSBwYWdlXHJcbiAgICAgICBzcGVjaWZpZWQgYnkgYGluZGV4YCBpbiBjbGllbnQgbW9kZS4gSWYgYG9wdGlvbnMuZmV0Y2hgIGlzIHRydWUsIGEgZmV0Y2hcclxuICAgICAgIGNhbiBiZSBmb3JjZWQgaW4gY2xpZW50IG1vZGUgYmVmb3JlIHJlc2V0dGluZyB0aGUgY3VycmVudCBwYWdlLiBVbmRlclxyXG4gICAgICAgaW5maW5pdGUgbW9kZSwgaWYgdGhlIGluZGV4IGlzIGxlc3MgdGhhbiB0aGUgY3VycmVudCBwYWdlLCBhIHJlc2V0IGlzXHJcbiAgICAgICBkb25lIGFzIGluIGNsaWVudCBtb2RlLiBJZiB0aGUgaW5kZXggaXMgZ3JlYXRlciB0aGFuIHRoZSBjdXJyZW50IHBhZ2VcclxuICAgICAgIG51bWJlciwgYSBmZXRjaCBpcyBtYWRlIHdpdGggdGhlIHJlc3VsdHMgKiphcHBlbmRlZCoqIHRvICNmdWxsQ29sbGVjdGlvbi5cclxuICAgICAgIFRoZSBjdXJyZW50IHBhZ2Ugd2lsbCB0aGVuIGJlIHJlc2V0IGFmdGVyIGZldGNoaW5nLlxyXG5cclxuICAgICAgIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gaW5kZXggVGhlIHBhZ2UgaW5kZXggdG8gZ28gdG8sIG9yIHRoZSBwYWdlIG5hbWUgdG9cclxuICAgICAgIGxvb2sgdXAgZnJvbSAjbGlua3MgaW4gaW5maW5pdGUgbW9kZS5cclxuICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10ge0BsaW5rICNmZXRjaH0gb3B0aW9ucyBvclxyXG4gICAgICAgW3Jlc2V0XShodHRwOi8vYmFja2JvbmVqcy5vcmcvI0NvbGxlY3Rpb24tcmVzZXQpIG9wdGlvbnMgZm9yIGNsaWVudCBtb2RlXHJcbiAgICAgICB3aGVuIGBvcHRpb25zLmZldGNoYCBpcyBgZmFsc2VgLlxyXG4gICAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mZXRjaD1mYWxzZV0gSWYgdHJ1ZSwgZm9yY2UgYSB7QGxpbmsgI2ZldGNofSBpblxyXG4gICAgICAgY2xpZW50IG1vZGUuXHJcblxyXG4gICAgICAgQHRocm93cyB7VHlwZUVycm9yfSBJZiBgaW5kZXhgIGlzIG5vdCBhIGZpbml0ZSBpbnRlZ2VyIHVuZGVyIHNlcnZlciBvclxyXG4gICAgICAgY2xpZW50IG1vZGUsIG9yIGRvZXMgbm90IHlpZWxkIGEgVVJMIGZyb20gI2xpbmtzIHVuZGVyIGluZmluaXRlIG1vZGUuXHJcblxyXG4gICAgICAgQHRocm93cyB7UmFuZ2VFcnJvcn0gSWYgYGluZGV4YCBpcyBvdXQgb2YgYm91bmRzLlxyXG5cclxuICAgICAgIEBjaGFpbmFibGVcclxuICAgICAgIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fEJhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbn0gVGhlIFhNTEh0dHBSZXF1ZXN0XHJcbiAgICAgICBmcm9tIGZldGNoIG9yIHRoaXMuXHJcbiAgICAqL1xyXG4gICAgZ2V0UGFnZTogZnVuY3Rpb24gKGluZGV4LCBvcHRpb25zKSB7XHJcblxyXG4gICAgICB2YXIgbW9kZSA9IHRoaXMubW9kZSwgZnVsbENvbGxlY3Rpb24gPSB0aGlzLmZ1bGxDb2xsZWN0aW9uO1xyXG5cclxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge2ZldGNoOiBmYWxzZX07XHJcblxyXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlLFxyXG4gICAgICBmaXJzdFBhZ2UgPSBzdGF0ZS5maXJzdFBhZ2UsXHJcbiAgICAgIGN1cnJlbnRQYWdlID0gc3RhdGUuY3VycmVudFBhZ2UsXHJcbiAgICAgIGxhc3RQYWdlID0gc3RhdGUubGFzdFBhZ2UsXHJcbiAgICAgIHBhZ2VTaXplID0gc3RhdGUucGFnZVNpemU7XHJcblxyXG4gICAgICB2YXIgcGFnZU51bSA9IGluZGV4O1xyXG4gICAgICBzd2l0Y2ggKGluZGV4KSB7XHJcbiAgICAgICAgY2FzZSBcImZpcnN0XCI6IHBhZ2VOdW0gPSBmaXJzdFBhZ2U7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJwcmV2XCI6IHBhZ2VOdW0gPSBjdXJyZW50UGFnZSAtIDE7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJuZXh0XCI6IHBhZ2VOdW0gPSBjdXJyZW50UGFnZSArIDE7IGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJsYXN0XCI6IHBhZ2VOdW0gPSBsYXN0UGFnZTsgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDogcGFnZU51bSA9IGZpbml0ZUludChpbmRleCwgXCJpbmRleFwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuX2NoZWNrU3RhdGUoX2V4dGVuZCh7fSwgc3RhdGUsIHtjdXJyZW50UGFnZTogcGFnZU51bX0pKTtcclxuXHJcbiAgICAgIG9wdGlvbnMuZnJvbSA9IGN1cnJlbnRQYWdlLCBvcHRpb25zLnRvID0gcGFnZU51bTtcclxuXHJcbiAgICAgIHZhciBwYWdlU3RhcnQgPSAoZmlyc3RQYWdlID09PSAwID8gcGFnZU51bSA6IHBhZ2VOdW0gLSAxKSAqIHBhZ2VTaXplO1xyXG4gICAgICB2YXIgcGFnZU1vZGVscyA9IGZ1bGxDb2xsZWN0aW9uICYmIGZ1bGxDb2xsZWN0aW9uLmxlbmd0aCA/XHJcbiAgICAgICAgZnVsbENvbGxlY3Rpb24ubW9kZWxzLnNsaWNlKHBhZ2VTdGFydCwgcGFnZVN0YXJ0ICsgcGFnZVNpemUpIDpcclxuICAgICAgICBbXTtcclxuICAgICAgaWYgKChtb2RlID09IFwiY2xpZW50XCIgfHwgKG1vZGUgPT0gXCJpbmZpbml0ZVwiICYmICFfaXNFbXB0eShwYWdlTW9kZWxzKSkpICYmXHJcbiAgICAgICAgICAhb3B0aW9ucy5mZXRjaCkge1xyXG4gICAgICAgIHRoaXMucmVzZXQocGFnZU1vZGVscywgX29taXQob3B0aW9ucywgXCJmZXRjaFwiKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtb2RlID09IFwiaW5maW5pdGVcIikgb3B0aW9ucy51cmwgPSB0aGlzLmxpbmtzW3BhZ2VOdW1dO1xyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goX29taXQob3B0aW9ucywgXCJmZXRjaFwiKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgRmV0Y2ggdGhlIHBhZ2UgZm9yIHRoZSBwcm92aWRlZCBpdGVtIG9mZnNldCBpbiBzZXJ2ZXIgbW9kZSwgb3IgcmVzZXQgdGhlIGN1cnJlbnQgcGFnZSBvZiB0aGlzXHJcbiAgICAgICBjb2xsZWN0aW9uIHRvIHRoZSBwYWdlIGZvciB0aGUgcHJvdmlkZWQgaXRlbSBvZmZzZXQgaW4gY2xpZW50IG1vZGUuXHJcblxyXG4gICAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMge0BsaW5rICNnZXRQYWdlfSBvcHRpb25zLlxyXG5cclxuICAgICAgIEBjaGFpbmFibGVcclxuICAgICAgIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fEJhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbn0gVGhlIFhNTEh0dHBSZXF1ZXN0XHJcbiAgICAgICBmcm9tIGZldGNoIG9yIHRoaXMuXHJcbiAgICAqL1xyXG4gICAgZ2V0UGFnZUJ5T2Zmc2V0OiBmdW5jdGlvbiAob2Zmc2V0LCBvcHRpb25zKSB7XHJcbiAgICAgIGlmIChvZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJgb2Zmc2V0IG11c3QgYmUgPiAwYFwiKTtcclxuICAgICAgfVxyXG4gICAgICBvZmZzZXQgPSBmaW5pdGVJbnQob2Zmc2V0KTtcclxuXHJcbiAgICAgIHZhciBwYWdlID0gZmxvb3Iob2Zmc2V0IC8gdGhpcy5zdGF0ZS5wYWdlU2l6ZSk7XHJcbiAgICAgIGlmICh0aGlzLnN0YXRlLmZpcnN0UGFnZSAhPT0gMCkgcGFnZSsrO1xyXG4gICAgICBpZiAocGFnZSA+IHRoaXMuc3RhdGUubGFzdFBhZ2UpIHBhZ2UgPSB0aGlzLnN0YXRlLmxhc3RQYWdlO1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRQYWdlKHBhZ2UsIG9wdGlvbnMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAgIE92ZXJpZGRlbiB0byBtYWtlIGBnZXRQYWdlYCBjb21wYXRpYmxlIHdpdGggWmVwdG8uXHJcblxyXG4gICAgICAgQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxyXG4gICAgICAgQHBhcmFtIHtCYWNrYm9uZS5Nb2RlbHxCYWNrYm9uZS5Db2xsZWN0aW9ufSBtb2RlbFxyXG4gICAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxyXG5cclxuICAgICAgIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fVxyXG4gICAgKi9cclxuICAgIHN5bmM6IGZ1bmN0aW9uIChtZXRob2QsIG1vZGVsLCBvcHRpb25zKSB7XHJcbiAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgaWYgKHNlbGYubW9kZSA9PSBcImluZmluaXRlXCIpIHtcclxuICAgICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcclxuICAgICAgICB2YXIgY3VycmVudFBhZ2UgPSBzZWxmLnN0YXRlLmN1cnJlbnRQYWdlO1xyXG4gICAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uIChyZXNwLCBzdGF0dXMsIHhocikge1xyXG4gICAgICAgICAgdmFyIGxpbmtzID0gc2VsZi5saW5rcztcclxuICAgICAgICAgIHZhciBuZXdMaW5rcyA9IHNlbGYucGFyc2VMaW5rcyhyZXNwLCBfZXh0ZW5kKHt4aHI6IHhocn0sIG9wdGlvbnMpKTtcclxuICAgICAgICAgIGlmIChuZXdMaW5rcy5maXJzdCkgbGlua3Nbc2VsZi5zdGF0ZS5maXJzdFBhZ2VdID0gbmV3TGlua3MuZmlyc3Q7XHJcbiAgICAgICAgICBpZiAobmV3TGlua3MucHJldikgbGlua3NbY3VycmVudFBhZ2UgLSAxXSA9IG5ld0xpbmtzLnByZXY7XHJcbiAgICAgICAgICBpZiAobmV3TGlua3MubmV4dCkgbGlua3NbY3VycmVudFBhZ2UgKyAxXSA9IG5ld0xpbmtzLm5leHQ7XHJcbiAgICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2VzcyhyZXNwLCBzdGF0dXMsIHhocik7XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIChCQkNvbFByb3RvLnN5bmMgfHwgQmFja2JvbmUuc3luYykuY2FsbChzZWxmLCBtZXRob2QsIG1vZGVsLCBvcHRpb25zKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBQYXJzZSBwYWdpbmF0aW9uIGxpbmtzIGZyb20gdGhlIHNlcnZlciByZXNwb25zZS4gT25seSB2YWxpZCB1bmRlclxyXG4gICAgICAgaW5maW5pdGUgbW9kZS5cclxuXHJcbiAgICAgICBHaXZlbiBhIHJlc3BvbnNlIGJvZHkgYW5kIGEgWE1MSHR0cFJlcXVlc3Qgb2JqZWN0LCBleHRyYWN0IHBhZ2luYXRpb25cclxuICAgICAgIGxpbmtzIGZyb20gdGhlbSBmb3IgaW5maW5pdGUgcGFnaW5nLlxyXG5cclxuICAgICAgIFRoaXMgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBwYXJzZXMgdGhlIFJGQyA1OTg4IGBMaW5rYCBoZWFkZXIgYW5kIGV4dHJhY3RcclxuICAgICAgIDMgbGlua3MgZnJvbSBpdCAtIGBmaXJzdGAsIGBwcmV2YCwgYG5leHRgLiBBbnkgc3ViY2xhc3NlcyBvdmVycmlkaW5nIHRoaXNcclxuICAgICAgIG1ldGhvZCBfX211c3RfXyByZXR1cm4gYW4gb2JqZWN0IGhhc2ggaGF2aW5nIG9ubHkgdGhlIGtleXNcclxuICAgICAgIGFib3ZlLiBIb3dldmVyLCBzaW1wbHkgcmV0dXJuaW5nIGEgYG5leHRgIGxpbmsgb3IgYW4gZW1wdHkgaGFzaCBpZiB0aGVyZVxyXG4gICAgICAgYXJlIG5vIG1vcmUgbGlua3Mgc2hvdWxkIGJlIGVub3VnaCBmb3IgbW9zdCBpbXBsZW1lbnRhdGlvbnMuXHJcblxyXG4gICAgICAgQHBhcmFtIHsqfSByZXNwIFRoZSBkZXNlcmlhbGl6ZWQgcmVzcG9uc2UgYm9keS5cclxuICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cclxuICAgICAgIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IFtvcHRpb25zLnhocl0gVGhlIFhNTEh0dHBSZXF1ZXN0IG9iamVjdCBmb3IgdGhpc1xyXG4gICAgICAgcmVzcG9uc2UuXHJcbiAgICAgICBAcmV0dXJuIHtPYmplY3R9XHJcbiAgICAqL1xyXG4gICAgcGFyc2VMaW5rczogZnVuY3Rpb24gKHJlc3AsIG9wdGlvbnMpIHtcclxuICAgICAgdmFyIGxpbmtzID0ge307XHJcbiAgICAgIHZhciBsaW5rSGVhZGVyID0gb3B0aW9ucy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMaW5rXCIpO1xyXG4gICAgICBpZiAobGlua0hlYWRlcikge1xyXG4gICAgICAgIHZhciByZWxhdGlvbnMgPSBbXCJmaXJzdFwiLCBcInByZXZcIiwgXCJuZXh0XCJdO1xyXG4gICAgICAgIF9lYWNoKGxpbmtIZWFkZXIuc3BsaXQoXCIsXCIpLCBmdW5jdGlvbiAobGlua1ZhbHVlKSB7XHJcbiAgICAgICAgICB2YXIgbGlua1BhcnRzID0gbGlua1ZhbHVlLnNwbGl0KFwiO1wiKTtcclxuICAgICAgICAgIHZhciB1cmwgPSBsaW5rUGFydHNbMF0ucmVwbGFjZShVUkxfVFJJTV9SRSwgJycpO1xyXG4gICAgICAgICAgdmFyIHBhcmFtcyA9IGxpbmtQYXJ0cy5zbGljZSgxKTtcclxuICAgICAgICAgIF9lYWNoKHBhcmFtcywgZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbVBhcnRzID0gcGFyYW0uc3BsaXQoXCI9XCIpO1xyXG4gICAgICAgICAgICB2YXIga2V5ID0gcGFyYW1QYXJ0c1swXS5yZXBsYWNlKFBBUkFNX1RSSU1fUkUsICcnKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1QYXJ0c1sxXS5yZXBsYWNlKFBBUkFNX1RSSU1fUkUsICcnKTtcclxuICAgICAgICAgICAgaWYgKGtleSA9PSBcInJlbFwiICYmIF9jb250YWlucyhyZWxhdGlvbnMsIHZhbHVlKSkgbGlua3NbdmFsdWVdID0gdXJsO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBsaW5rcztcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBQYXJzZSBzZXJ2ZXIgcmVzcG9uc2UgZGF0YS5cclxuXHJcbiAgICAgICBUaGlzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGUgcmVzcG9uc2UgZGF0YSBpcyBpbiBvbmUgb2YgdHdvXHJcbiAgICAgICBzdHJ1Y3R1cmVzOlxyXG5cclxuICAgICAgICAgICBbXHJcbiAgICAgICAgICAgICB7fSwgLy8gWW91ciBuZXcgcGFnaW5hdGlvbiBzdGF0ZVxyXG4gICAgICAgICAgICAgW3t9LCAuLi5dIC8vIEFuIGFycmF5IG9mIEpTT04gb2JqZWN0c1xyXG4gICAgICAgICAgIF1cclxuXHJcbiAgICAgICBPcixcclxuXHJcbiAgICAgICAgICAgW3t9XSAvLyBBbiBhcnJheSBvZiBKU09OIG9iamVjdHNcclxuXHJcbiAgICAgICBUaGUgZmlyc3Qgc3RydWN0dXJlIGlzIHRoZSBwcmVmZXJyZWQgZm9ybSBiZWNhdXNlIHRoZSBwYWdpbmF0aW9uIHN0YXRlc1xyXG4gICAgICAgbWF5IGhhdmUgYmVlbiB1cGRhdGVkIG9uIHRoZSBzZXJ2ZXIgc2lkZSwgc2VuZGluZyB0aGVtIGRvd24gYWdhaW4gYWxsb3dzXHJcbiAgICAgICB0aGlzIGNvbGxlY3Rpb24gdG8gdXBkYXRlIGl0cyBzdGF0ZXMuIElmIHRoZSByZXNwb25zZSBoYXMgYSBwYWdpbmF0aW9uXHJcbiAgICAgICBzdGF0ZSBvYmplY3QsIGl0IGlzIGNoZWNrZWQgZm9yIGVycm9ycy5cclxuXHJcbiAgICAgICBUaGUgc2Vjb25kIHN0cnVjdHVyZSBpcyB0aGVcclxuICAgICAgIFtCYWNrYm9uZS5Db2xsZWN0aW9uI3BhcnNlXShodHRwOi8vYmFja2JvbmVqcy5vcmcvI0NvbGxlY3Rpb24tcGFyc2UpXHJcbiAgICAgICBkZWZhdWx0LlxyXG5cclxuICAgICAgICoqTm90ZToqKiB0aGlzIG1ldGhvZCBoYXMgYmVlbiBmdXJ0aGVyIHNpbXBsaWZpZWQgc2luY2UgMS4xLjcuIFdoaWxlXHJcbiAgICAgICBleGlzdGluZyAjcGFyc2UgaW1wbGVtZW50YXRpb25zIHdpbGwgY29udGludWUgdG8gd29yaywgbmV3IGNvZGUgaXNcclxuICAgICAgIGVuY291cmFnZWQgdG8gb3ZlcnJpZGUgI3BhcnNlU3RhdGUgYW5kICNwYXJzZVJlY29yZHMgaW5zdGVhZC5cclxuXHJcbiAgICAgICBAcGFyYW0ge09iamVjdH0gcmVzcCBUaGUgZGVzZXJpYWxpemVkIHJlc3BvbnNlIGRhdGEgZnJvbSB0aGUgc2VydmVyLlxyXG4gICAgICAgQHBhcmFtIHtPYmplY3R9IHRoZSBvcHRpb25zIGZvciB0aGUgYWpheCByZXF1ZXN0XHJcblxyXG4gICAgICAgQHJldHVybiB7QXJyYXkuPE9iamVjdD59IEFuIGFycmF5IG9mIG1vZGVsIG9iamVjdHNcclxuICAgICovXHJcbiAgICBwYXJzZTogZnVuY3Rpb24gKHJlc3AsIG9wdGlvbnMpIHtcclxuICAgICAgdmFyIG5ld1N0YXRlID0gdGhpcy5wYXJzZVN0YXRlKHJlc3AsIF9jbG9uZSh0aGlzLnF1ZXJ5UGFyYW1zKSwgX2Nsb25lKHRoaXMuc3RhdGUpLCBvcHRpb25zKTtcclxuICAgICAgaWYgKG5ld1N0YXRlKSB0aGlzLnN0YXRlID0gdGhpcy5fY2hlY2tTdGF0ZShfZXh0ZW5kKHt9LCB0aGlzLnN0YXRlLCBuZXdTdGF0ZSkpO1xyXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVJlY29yZHMocmVzcCwgb3B0aW9ucyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgUGFyc2Ugc2VydmVyIHJlc3BvbnNlIGZvciBzZXJ2ZXIgcGFnaW5hdGlvbiBzdGF0ZSB1cGRhdGVzLiBOb3QgYXBwbGljYWJsZVxyXG4gICAgICAgdW5kZXIgaW5maW5pdGUgbW9kZS5cclxuXHJcbiAgICAgICBUaGlzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZmlyc3QgY2hlY2tzIHdoZXRoZXIgdGhlIHJlc3BvbnNlIGhhcyBhbnlcclxuICAgICAgIHN0YXRlIG9iamVjdCBhcyBkb2N1bWVudGVkIGluICNwYXJzZS4gSWYgaXQgZXhpc3RzLCBhIHN0YXRlIG9iamVjdCBpc1xyXG4gICAgICAgcmV0dXJuZWQgYnkgbWFwcGluZyB0aGUgc2VydmVyIHN0YXRlIGtleXMgdG8gdGhpcyBwYWdlYWJsZSBjb2xsZWN0aW9uXHJcbiAgICAgICBpbnN0YW5jZSdzIHF1ZXJ5IHBhcmFtZXRlciBrZXlzIHVzaW5nIGBxdWVyeVBhcmFtc2AuXHJcblxyXG4gICAgICAgSXQgaXMgX19OT1RfXyBuZWNjZXNzYXJ5IHRvIHJldHVybiBhIGZ1bGwgc3RhdGUgb2JqZWN0IGNvbXBsZXRlIHdpdGggYWxsXHJcbiAgICAgICB0aGUgbWFwcGluZ3MgZGVmaW5lZCBpbiAjcXVlcnlQYXJhbXMuIEFueSBzdGF0ZSBvYmplY3QgcmVzdWx0ZWQgaXMgbWVyZ2VkXHJcbiAgICAgICB3aXRoIGEgY29weSBvZiB0aGUgY3VycmVudCBwYWdlYWJsZSBjb2xsZWN0aW9uIHN0YXRlIGFuZCBjaGVja2VkIGZvclxyXG4gICAgICAgc2FuaXR5IGJlZm9yZSBhY3R1YWxseSB1cGRhdGluZy4gTW9zdCBvZiB0aGUgdGltZSwgc2ltcGx5IHByb3ZpZGluZyBhIG5ld1xyXG4gICAgICAgYHRvdGFsUmVjb3Jkc2AgdmFsdWUgaXMgZW5vdWdoIHRvIHRyaWdnZXIgYSBmdWxsIHBhZ2luYXRpb24gc3RhdGVcclxuICAgICAgIHJlY2FsY3VsYXRpb24uXHJcblxyXG4gICAgICAgICAgIHBhcnNlU3RhdGU6IGZ1bmN0aW9uIChyZXNwLCBxdWVyeVBhcmFtcywgc3RhdGUsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgIHJldHVybiB7dG90YWxSZWNvcmRzOiByZXNwLnRvdGFsX2VudHJpZXN9O1xyXG4gICAgICAgICAgIH1cclxuXHJcbiAgICAgICBJZiB5b3Ugd2FudCB0byB1c2UgaGVhZGVyIGZpZWxkcyB1c2U6XHJcblxyXG4gICAgICAgICAgIHBhcnNlU3RhdGU6IGZ1bmN0aW9uIChyZXNwLCBxdWVyeVBhcmFtcywgc3RhdGUsIG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgcmV0dXJuIHt0b3RhbFJlY29yZHM6IG9wdGlvbnMueGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiWC10b3RhbFwiKX07XHJcbiAgICAgICAgICAgfVxyXG5cclxuICAgICAgIFRoaXMgbWV0aG9kIF9fTVVTVF9fIHJldHVybiBhIG5ldyBzdGF0ZSBvYmplY3QgaW5zdGVhZCBvZiBkaXJlY3RseVxyXG4gICAgICAgbW9kaWZ5aW5nIHRoZSAjc3RhdGUgb2JqZWN0LiBUaGUgYmVoYXZpb3Igb2YgZGlyZWN0bHkgbW9kaWZ5aW5nICNzdGF0ZSBpc1xyXG4gICAgICAgdW5kZWZpbmVkLlxyXG5cclxuICAgICAgIEBwYXJhbSB7T2JqZWN0fSByZXNwIFRoZSBkZXNlcmlhbGl6ZWQgcmVzcG9uc2UgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICBAcGFyYW0ge09iamVjdH0gcXVlcnlQYXJhbXMgQSBjb3B5IG9mICNxdWVyeVBhcmFtcy5cclxuICAgICAgIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZSBBIGNvcHkgb2YgI3N0YXRlLlxyXG4gICAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBUaGUgb3B0aW9ucyBwYXNzZWQgdGhyb3VnaCBmcm9tXHJcbiAgICAgICBgcGFyc2VgLiAoYmFja2JvbmUgPj0gMC45LjEwIG9ubHkpXHJcblxyXG4gICAgICAgQHJldHVybiB7T2JqZWN0fSBBIG5ldyAocGFydGlhbCkgc3RhdGUgb2JqZWN0LlxyXG4gICAgICovXHJcbiAgICBwYXJzZVN0YXRlOiBmdW5jdGlvbiAocmVzcCwgcXVlcnlQYXJhbXMsIHN0YXRlLCBvcHRpb25zKSB7XHJcbiAgICAgIGlmIChyZXNwICYmIHJlc3AubGVuZ3RoID09PSAyICYmIF9pc09iamVjdChyZXNwWzBdKSAmJiBfaXNBcnJheShyZXNwWzFdKSkge1xyXG5cclxuICAgICAgICB2YXIgbmV3U3RhdGUgPSBfY2xvbmUoc3RhdGUpO1xyXG4gICAgICAgIHZhciBzZXJ2ZXJTdGF0ZSA9IHJlc3BbMF07XHJcblxyXG4gICAgICAgIF9lYWNoKF9wYWlycyhfb21pdChxdWVyeVBhcmFtcywgXCJkaXJlY3Rpb25zXCIpKSwgZnVuY3Rpb24gKGt2cCkge1xyXG4gICAgICAgICAgdmFyIGsgPSBrdnBbMF0sIHYgPSBrdnBbMV07XHJcbiAgICAgICAgICB2YXIgc2VydmVyVmFsID0gc2VydmVyU3RhdGVbdl07XHJcbiAgICAgICAgICBpZiAoIV9pc1VuZGVmaW5lZChzZXJ2ZXJWYWwpICYmICFfLmlzTnVsbChzZXJ2ZXJWYWwpKSBuZXdTdGF0ZVtrXSA9IHNlcnZlclN0YXRlW3ZdO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoc2VydmVyU3RhdGUub3JkZXIpIHtcclxuICAgICAgICAgIG5ld1N0YXRlLm9yZGVyID0gX2ludmVydChxdWVyeVBhcmFtcy5kaXJlY3Rpb25zKVtzZXJ2ZXJTdGF0ZS5vcmRlcl0gKiAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgUGFyc2Ugc2VydmVyIHJlc3BvbnNlIGZvciBhbiBhcnJheSBvZiBtb2RlbCBvYmplY3RzLlxyXG5cclxuICAgICAgIFRoaXMgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBmaXJzdCBjaGVja3Mgd2hldGhlciB0aGUgcmVzcG9uc2UgaGFzIGFueVxyXG4gICAgICAgc3RhdGUgb2JqZWN0IGFzIGRvY3VtZW50ZWQgaW4gI3BhcnNlLiBJZiBpdCBleGlzdHMsIHRoZSBhcnJheSBvZiBtb2RlbFxyXG4gICAgICAgb2JqZWN0cyBpcyBhc3N1bWVkIHRvIGJlIHRoZSBzZWNvbmQgZWxlbWVudCwgb3RoZXJ3aXNlIHRoZSBlbnRpcmVcclxuICAgICAgIHJlc3BvbnNlIGlzIHJldHVybmVkIGRpcmVjdGx5LlxyXG5cclxuICAgICAgIEBwYXJhbSB7T2JqZWN0fSByZXNwIFRoZSBkZXNlcmlhbGl6ZWQgcmVzcG9uc2UgZGF0YSBmcm9tIHRoZSBzZXJ2ZXIuXHJcbiAgICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIHBhc3NlZCB0aHJvdWdoIGZyb20gdGhlXHJcbiAgICAgICBgcGFyc2VgLiAoYmFja2JvbmUgPj0gMC45LjEwIG9ubHkpXHJcblxyXG4gICAgICAgQHJldHVybiB7QXJyYXkuPE9iamVjdD59IEFuIGFycmF5IG9mIG1vZGVsIG9iamVjdHNcclxuICAgICAqL1xyXG4gICAgcGFyc2VSZWNvcmRzOiBmdW5jdGlvbiAocmVzcCwgb3B0aW9ucykge1xyXG4gICAgICBpZiAocmVzcCAmJiByZXNwLmxlbmd0aCA9PT0gMiAmJiBfaXNPYmplY3QocmVzcFswXSkgJiYgX2lzQXJyYXkocmVzcFsxXSkpIHtcclxuICAgICAgICByZXR1cm4gcmVzcFsxXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJlc3A7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgRmV0Y2ggYSBwYWdlIGZyb20gdGhlIHNlcnZlciBpbiBzZXJ2ZXIgbW9kZSwgb3IgYWxsIHRoZSBwYWdlcyBpbiBjbGllbnRcclxuICAgICAgIG1vZGUuIFVuZGVyIGluZmluaXRlIG1vZGUsIHRoZSBjdXJyZW50IHBhZ2UgaXMgcmVmZXRjaGVkIGJ5IGRlZmF1bHQgYW5kXHJcbiAgICAgICB0aGVuIHJlc2V0LlxyXG5cclxuICAgICAgIFRoZSBxdWVyeSBzdHJpbmcgaXMgY29uc3RydWN0ZWQgYnkgdHJhbnNsYXRpbmcgdGhlIGN1cnJlbnQgcGFnaW5hdGlvblxyXG4gICAgICAgc3RhdGUgdG8geW91ciBzZXJ2ZXIgQVBJIHF1ZXJ5IHBhcmFtZXRlciB1c2luZyAjcXVlcnlQYXJhbXMuIFRoZSBjdXJyZW50XHJcbiAgICAgICBwYWdlIHdpbGwgcmVzZXQgYWZ0ZXIgZmV0Y2guXHJcblxyXG4gICAgICAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBY2NlcHRzIGFsbFxyXG4gICAgICAgW0JhY2tib25lLkNvbGxlY3Rpb24jZmV0Y2hdKGh0dHA6Ly9iYWNrYm9uZWpzLm9yZy8jQ29sbGVjdGlvbi1mZXRjaClcclxuICAgICAgIG9wdGlvbnMuXHJcblxyXG4gICAgICAgQHJldHVybiB7WE1MSHR0cFJlcXVlc3R9XHJcbiAgICAqL1xyXG4gICAgZmV0Y2g6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX2NoZWNrU3RhdGUodGhpcy5zdGF0ZSk7XHJcblxyXG4gICAgICB2YXIgbW9kZSA9IHRoaXMubW9kZTtcclxuXHJcbiAgICAgIGlmIChtb2RlID09IFwiaW5maW5pdGVcIiAmJiAhb3B0aW9ucy51cmwpIHtcclxuICAgICAgICBvcHRpb25zLnVybCA9IHRoaXMubGlua3Nbc3RhdGUuY3VycmVudFBhZ2VdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgZGF0YSA9IG9wdGlvbnMuZGF0YSB8fCB7fTtcclxuXHJcbiAgICAgIC8vIGRlZHVwIHF1ZXJ5IHBhcmFtc1xyXG4gICAgICB2YXIgdXJsID0gb3B0aW9ucy51cmwgfHwgdGhpcy51cmwgfHwgXCJcIjtcclxuICAgICAgaWYgKF9pc0Z1bmN0aW9uKHVybCkpIHVybCA9IHVybC5jYWxsKHRoaXMpO1xyXG4gICAgICB2YXIgcXNpID0gdXJsLmluZGV4T2YoJz8nKTtcclxuICAgICAgaWYgKHFzaSAhPSAtMSkge1xyXG4gICAgICAgIF9leHRlbmQoZGF0YSwgcXVlcnlTdHJpbmdUb1BhcmFtcyh1cmwuc2xpY2UocXNpICsgMSkpKTtcclxuICAgICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgcXNpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgb3B0aW9ucy51cmwgPSB1cmw7XHJcbiAgICAgIG9wdGlvbnMuZGF0YSA9IGRhdGE7XHJcblxyXG4gICAgICAvLyBtYXAgcGFyYW1zIGV4Y2VwdCBkaXJlY3Rpb25zXHJcbiAgICAgIHZhciBxdWVyeVBhcmFtcyA9IHRoaXMubW9kZSA9PSBcImNsaWVudFwiID9cclxuICAgICAgICBfcGljayh0aGlzLnF1ZXJ5UGFyYW1zLCBcInNvcnRLZXlcIiwgXCJvcmRlclwiKSA6XHJcbiAgICAgICAgX29taXQoX3BpY2sodGhpcy5xdWVyeVBhcmFtcywgX2tleXMoUGFnZWFibGVQcm90by5xdWVyeVBhcmFtcykpLFxyXG4gICAgICAgICAgICAgIFwiZGlyZWN0aW9uc1wiKTtcclxuXHJcbiAgICAgIHZhciBpLCBrdnAsIGssIHYsIGt2cHMgPSBfcGFpcnMocXVlcnlQYXJhbXMpLCB0aGlzQ29weSA9IF9jbG9uZSh0aGlzKTtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGt2cHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBrdnAgPSBrdnBzW2ldLCBrID0ga3ZwWzBdLCB2ID0ga3ZwWzFdO1xyXG4gICAgICAgIHYgPSBfaXNGdW5jdGlvbih2KSA/IHYuY2FsbCh0aGlzQ29weSkgOiB2O1xyXG4gICAgICAgIGlmIChzdGF0ZVtrXSAhPSBudWxsICYmIHYgIT0gbnVsbCkge1xyXG4gICAgICAgICAgZGF0YVt2XSA9IHN0YXRlW2tdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gZml4IHVwIHNvcnRpbmcgcGFyYW1ldGVyc1xyXG4gICAgICBpZiAoc3RhdGUuc29ydEtleSAmJiBzdGF0ZS5vcmRlcikge1xyXG4gICAgICAgIHZhciBvID0gX2lzRnVuY3Rpb24ocXVlcnlQYXJhbXMub3JkZXIpID9cclxuICAgICAgICAgIHF1ZXJ5UGFyYW1zLm9yZGVyLmNhbGwodGhpc0NvcHkpIDpcclxuICAgICAgICAgIHF1ZXJ5UGFyYW1zLm9yZGVyO1xyXG4gICAgICAgIGRhdGFbb10gPSB0aGlzLnF1ZXJ5UGFyYW1zLmRpcmVjdGlvbnNbc3RhdGUub3JkZXIgKyBcIlwiXTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGlmICghc3RhdGUuc29ydEtleSkgZGVsZXRlIGRhdGFbcXVlcnlQYXJhbXMub3JkZXJdO1xyXG5cclxuICAgICAgLy8gbWFwIGV4dHJhIHF1ZXJ5IHBhcmFtZXRlcnNcclxuICAgICAgdmFyIGV4dHJhS3ZwcyA9IF9wYWlycyhfb21pdCh0aGlzLnF1ZXJ5UGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9rZXlzKFBhZ2VhYmxlUHJvdG8ucXVlcnlQYXJhbXMpKSk7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBleHRyYUt2cHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBrdnAgPSBleHRyYUt2cHNbaV07XHJcbiAgICAgICAgdiA9IGt2cFsxXTtcclxuICAgICAgICB2ID0gX2lzRnVuY3Rpb24odikgPyB2LmNhbGwodGhpc0NvcHkpIDogdjtcclxuICAgICAgICBpZiAodiAhPSBudWxsKSBkYXRhW2t2cFswXV0gPSB2O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobW9kZSAhPSBcInNlcnZlclwiKSB7XHJcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzLCBmdWxsQ29sID0gdGhpcy5mdWxsQ29sbGVjdGlvbjtcclxuICAgICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcclxuICAgICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbiAoY29sLCByZXNwLCBvcHRzKSB7XHJcblxyXG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBjYWxsZXIncyBpbnRlbnQgaXMgb2JleWVkXHJcbiAgICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcclxuICAgICAgICAgIGlmIChfaXNVbmRlZmluZWQob3B0aW9ucy5zaWxlbnQpKSBkZWxldGUgb3B0cy5zaWxlbnQ7XHJcbiAgICAgICAgICBlbHNlIG9wdHMuc2lsZW50ID0gb3B0aW9ucy5zaWxlbnQ7XHJcblxyXG4gICAgICAgICAgdmFyIG1vZGVscyA9IGNvbC5tb2RlbHM7XHJcbiAgICAgICAgICBpZiAobW9kZSA9PSBcImNsaWVudFwiKSBmdWxsQ29sLnJlc2V0KG1vZGVscywgb3B0cyk7XHJcbiAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZnVsbENvbC5hZGQobW9kZWxzLCBfZXh0ZW5kKHthdDogZnVsbENvbC5sZW5ndGh9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2V4dGVuZChvcHRzLCB7cGFyc2U6IGZhbHNlfSkpKTtcclxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKFwicmVzZXRcIiwgc2VsZiwgb3B0cyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MoY29sLCByZXNwLCBvcHRzKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBzaWxlbnQgdGhlIGZpcnN0IHJlc2V0IGZyb20gYmFja2JvbmVcclxuICAgICAgICByZXR1cm4gQkJDb2xQcm90by5mZXRjaC5jYWxsKHRoaXMsIF9leHRlbmQoe30sIG9wdGlvbnMsIHtzaWxlbnQ6IHRydWV9KSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBCQkNvbFByb3RvLmZldGNoLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgQ29udmVuaWVudCBtZXRob2QgZm9yIG1ha2luZyBhIGBjb21wYXJhdG9yYCBzb3J0ZWQgYnkgYSBtb2RlbCBhdHRyaWJ1dGVcclxuICAgICAgIGlkZW50aWZpZWQgYnkgYHNvcnRLZXlgIGFuZCBvcmRlcmVkIGJ5IGBvcmRlcmAuXHJcblxyXG4gICAgICAgTGlrZSBhIEJhY2tib25lLkNvbGxlY3Rpb24sIGEgQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uIHdpbGwgbWFpbnRhaW5cclxuICAgICAgIHRoZSBfX2N1cnJlbnQgcGFnZV9fIGluIHNvcnRlZCBvcmRlciBvbiB0aGUgY2xpZW50IHNpZGUgaWYgYSBgY29tcGFyYXRvcmBcclxuICAgICAgIGlzIGF0dGFjaGVkIHRvIGl0LiBJZiB0aGUgY29sbGVjdGlvbiBpcyBpbiBjbGllbnQgbW9kZSwgeW91IGNhbiBhdHRhY2ggYVxyXG4gICAgICAgY29tcGFyYXRvciB0byAjZnVsbENvbGxlY3Rpb24gdG8gaGF2ZSBhbGwgdGhlIHBhZ2VzIHJlZmxlY3QgdGhlIGdsb2JhbFxyXG4gICAgICAgc29ydGluZyBvcmRlciBieSBzcGVjaWZ5aW5nIGFuIG9wdGlvbiBgZnVsbGAgdG8gYHRydWVgLiBZb3UgX19tdXN0X18gY2FsbFxyXG4gICAgICAgYHNvcnRgIG1hbnVhbGx5IG9yICNmdWxsQ29sbGVjdGlvbi5zb3J0IGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgdG9cclxuICAgICAgIGZvcmNlIGEgcmVzb3J0LlxyXG5cclxuICAgICAgIFdoaWxlIHlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIHNvcnQgdGhlIGN1cnJlbnQgcGFnZSBpbiBzZXJ2ZXIgbW9kZSxcclxuICAgICAgIHRoZSBzb3J0aW5nIG9yZGVyIG1heSBub3QgcmVmbGVjdCB0aGUgZ2xvYmFsIHNvcnRpbmcgb3JkZXIgZHVlIHRvIHRoZVxyXG4gICAgICAgYWRkaXRpb25zIG9yIHJlbW92YWxzIG9mIHRoZSByZWNvcmRzIG9uIHRoZSBzZXJ2ZXIgc2luY2UgdGhlIGxhc3RcclxuICAgICAgIGZldGNoLiBJZiB5b3Ugd2FudCB0aGUgbW9zdCB1cGRhdGVkIHBhZ2UgaW4gYSBnbG9iYWwgc29ydGluZyBvcmRlciwgaXQgaXNcclxuICAgICAgIHJlY29tbWVuZGVkIHRoYXQgeW91IHNldCAjc3RhdGUuc29ydEtleSBhbmQgb3B0aW9uYWxseSAjc3RhdGUub3JkZXIsIGFuZFxyXG4gICAgICAgdGhlbiBjYWxsICNmZXRjaC5cclxuXHJcbiAgICAgICBAcHJvdGVjdGVkXHJcblxyXG4gICAgICAgQHBhcmFtIHtzdHJpbmd9IFtzb3J0S2V5PXRoaXMuc3RhdGUuc29ydEtleV0gU2VlIGBzdGF0ZS5zb3J0S2V5YC5cclxuICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbb3JkZXI9dGhpcy5zdGF0ZS5vcmRlcl0gU2VlIGBzdGF0ZS5vcmRlcmAuXHJcbiAgICAgICBAcGFyYW0geyhmdW5jdGlvbihCYWNrYm9uZS5Nb2RlbCwgc3RyaW5nKTogT2JqZWN0KSB8IHN0cmluZ30gW3NvcnRWYWx1ZV0gU2VlICNzZXRTb3J0aW5nLlxyXG5cclxuICAgICAgIFNlZSBbQmFja2JvbmUuQ29sbGVjdGlvbi5jb21wYXJhdG9yXShodHRwOi8vYmFja2JvbmVqcy5vcmcvI0NvbGxlY3Rpb24tY29tcGFyYXRvcikuXHJcbiAgICAqL1xyXG4gICAgX21ha2VDb21wYXJhdG9yOiBmdW5jdGlvbiAoc29ydEtleSwgb3JkZXIsIHNvcnRWYWx1ZSkge1xyXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xyXG5cclxuICAgICAgc29ydEtleSA9IHNvcnRLZXkgfHwgc3RhdGUuc29ydEtleTtcclxuICAgICAgb3JkZXIgPSBvcmRlciB8fCBzdGF0ZS5vcmRlcjtcclxuXHJcbiAgICAgIGlmICghc29ydEtleSB8fCAhb3JkZXIpIHJldHVybjtcclxuXHJcbiAgICAgIGlmICghc29ydFZhbHVlKSBzb3J0VmFsdWUgPSBmdW5jdGlvbiAobW9kZWwsIGF0dHIpIHtcclxuICAgICAgICByZXR1cm4gbW9kZWwuZ2V0KGF0dHIpO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHZhciBsID0gc29ydFZhbHVlKGxlZnQsIHNvcnRLZXkpLCByID0gc29ydFZhbHVlKHJpZ2h0LCBzb3J0S2V5KSwgdDtcclxuICAgICAgICBpZiAob3JkZXIgPT09IDEpIHQgPSBsLCBsID0gciwgciA9IHQ7XHJcbiAgICAgICAgaWYgKGwgPT09IHIpIHJldHVybiAwO1xyXG4gICAgICAgIGVsc2UgaWYgKGwgPCByKSByZXR1cm4gLTE7XHJcbiAgICAgICAgcmV0dXJuIDE7XHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgQWRqdXN0cyB0aGUgc29ydGluZyBmb3IgdGhpcyBwYWdlYWJsZSBjb2xsZWN0aW9uLlxyXG5cclxuICAgICAgIEdpdmVuIGEgYHNvcnRLZXlgIGFuZCBhbiBgb3JkZXJgLCBzZXRzIGBzdGF0ZS5zb3J0S2V5YCBhbmRcclxuICAgICAgIGBzdGF0ZS5vcmRlcmAuIEEgY29tcGFyYXRvciBjYW4gYmUgYXBwbGllZCBvbiB0aGUgY2xpZW50IHNpZGUgdG8gc29ydCBpblxyXG4gICAgICAgdGhlIG9yZGVyIGRlZmluZWQgaWYgYG9wdGlvbnMuc2lkZWAgaXMgYFwiY2xpZW50XCJgLiBCeSBkZWZhdWx0IHRoZVxyXG4gICAgICAgY29tcGFyYXRvciBpcyBhcHBsaWVkIHRvIHRoZSAjZnVsbENvbGxlY3Rpb24uIFNldCBgb3B0aW9ucy5mdWxsYCB0b1xyXG4gICAgICAgYGZhbHNlYCB0byBhcHBseSBhIGNvbXBhcmF0b3IgdG8gdGhlIGN1cnJlbnQgcGFnZSB1bmRlciBhbnkgbW9kZS4gU2V0dGluZ1xyXG4gICAgICAgYHNvcnRLZXlgIHRvIGBudWxsYCByZW1vdmVzIHRoZSBjb21wYXJhdG9yIGZyb20gYm90aCB0aGUgY3VycmVudCBwYWdlIGFuZFxyXG4gICAgICAgdGhlIGZ1bGwgY29sbGVjdGlvbi5cclxuXHJcbiAgICAgICBJZiBhIGBzb3J0VmFsdWVgIGZ1bmN0aW9uIGlzIGdpdmVuLCBpdCB3aWxsIGJlIHBhc3NlZCB0aGUgYChtb2RlbCxcclxuICAgICAgIHNvcnRLZXkpYCBhcmd1bWVudHMgYW5kIGlzIHVzZWQgdG8gZXh0cmFjdCBhIHZhbHVlIGZyb20gdGhlIG1vZGVsIGR1cmluZ1xyXG4gICAgICAgY29tcGFyaXNvbiBzb3J0cy4gSWYgYHNvcnRWYWx1ZWAgaXMgbm90IGdpdmVuLCBgbW9kZWwuZ2V0KHNvcnRLZXkpYCBpc1xyXG4gICAgICAgdXNlZCBmb3Igc29ydGluZy5cclxuXHJcbiAgICAgICBAY2hhaW5hYmxlXHJcblxyXG4gICAgICAgQHBhcmFtIHtzdHJpbmd9IHNvcnRLZXkgU2VlIGBzdGF0ZS5zb3J0S2V5YC5cclxuICAgICAgIEBwYXJhbSB7bnVtYmVyfSBbb3JkZXI9dGhpcy5zdGF0ZS5vcmRlcl0gU2VlIGBzdGF0ZS5vcmRlcmAuXHJcbiAgICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgICBAcGFyYW0ge1wic2VydmVyXCJ8XCJjbGllbnRcIn0gW29wdGlvbnMuc2lkZV0gQnkgZGVmYXVsdCwgYFwiY2xpZW50XCJgIGlmXHJcbiAgICAgICBgbW9kZWAgaXMgYFwiY2xpZW50XCJgLCBgXCJzZXJ2ZXJcImAgb3RoZXJ3aXNlLlxyXG4gICAgICAgQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mdWxsPXRydWVdXHJcbiAgICAgICBAcGFyYW0geyhmdW5jdGlvbihCYWNrYm9uZS5Nb2RlbCwgc3RyaW5nKTogT2JqZWN0KSB8IHN0cmluZ30gW29wdGlvbnMuc29ydFZhbHVlXVxyXG4gICAgKi9cclxuICAgIHNldFNvcnRpbmc6IGZ1bmN0aW9uIChzb3J0S2V5LCBvcmRlciwgb3B0aW9ucykge1xyXG5cclxuICAgICAgdmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuXHJcbiAgICAgIHN0YXRlLnNvcnRLZXkgPSBzb3J0S2V5O1xyXG4gICAgICBzdGF0ZS5vcmRlciA9IG9yZGVyID0gb3JkZXIgfHwgc3RhdGUub3JkZXI7XHJcblxyXG4gICAgICB2YXIgZnVsbENvbGxlY3Rpb24gPSB0aGlzLmZ1bGxDb2xsZWN0aW9uO1xyXG5cclxuICAgICAgdmFyIGRlbENvbXAgPSBmYWxzZSwgZGVsRnVsbENvbXAgPSBmYWxzZTtcclxuXHJcbiAgICAgIGlmICghc29ydEtleSkgZGVsQ29tcCA9IGRlbEZ1bGxDb21wID0gdHJ1ZTtcclxuXHJcbiAgICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xyXG4gICAgICBvcHRpb25zID0gX2V4dGVuZCh7c2lkZTogbW9kZSA9PSBcImNsaWVudFwiID8gbW9kZSA6IFwic2VydmVyXCIsIGZ1bGw6IHRydWV9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zKTtcclxuXHJcbiAgICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5fbWFrZUNvbXBhcmF0b3Ioc29ydEtleSwgb3JkZXIsIG9wdGlvbnMuc29ydFZhbHVlKTtcclxuXHJcbiAgICAgIHZhciBmdWxsID0gb3B0aW9ucy5mdWxsLCBzaWRlID0gb3B0aW9ucy5zaWRlO1xyXG5cclxuICAgICAgaWYgKHNpZGUgPT0gXCJjbGllbnRcIikge1xyXG4gICAgICAgIGlmIChmdWxsKSB7XHJcbiAgICAgICAgICBpZiAoZnVsbENvbGxlY3Rpb24pIGZ1bGxDb2xsZWN0aW9uLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xyXG4gICAgICAgICAgZGVsQ29tcCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcclxuICAgICAgICAgIGRlbEZ1bGxDb21wID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoc2lkZSA9PSBcInNlcnZlclwiICYmICFmdWxsKSB7XHJcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGRlbENvbXApIHRoaXMuY29tcGFyYXRvciA9IG51bGw7XHJcbiAgICAgIGlmIChkZWxGdWxsQ29tcCAmJiBmdWxsQ29sbGVjdGlvbikgZnVsbENvbGxlY3Rpb24uY29tcGFyYXRvciA9IG51bGw7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIHZhciBQYWdlYWJsZVByb3RvID0gUGFnZWFibGVDb2xsZWN0aW9uLnByb3RvdHlwZTtcclxuXHJcbiAgcmV0dXJuIFBhZ2VhYmxlQ29sbGVjdGlvbjtcclxuXHJcbn0pKTtcclxuIiwiLy8gICAgIFVuZGVyc2NvcmUuanMgMS43LjBcclxuLy8gICAgIGh0dHA6Ly91bmRlcnNjb3JlanMub3JnXHJcbi8vICAgICAoYykgMjAwOS0yMDE0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXHJcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cclxuICAvLyBCYXNlbGluZSBzZXR1cFxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIEVzdGFibGlzaCB0aGUgcm9vdCBvYmplY3QsIGB3aW5kb3dgIGluIHRoZSBicm93c2VyLCBvciBgZXhwb3J0c2Agb24gdGhlIHNlcnZlci5cclxuICB2YXIgcm9vdCA9IHRoaXM7XHJcblxyXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXHJcbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcclxuXHJcbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcclxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XHJcblxyXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxyXG4gIHZhclxyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcclxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxyXG4gICAgY29uY2F0ICAgICAgICAgICA9IEFycmF5UHJvdG8uY29uY2F0LFxyXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxyXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xyXG5cclxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcclxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cclxuICB2YXJcclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXHJcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcclxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kO1xyXG5cclxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cclxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XHJcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xyXG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcclxuICB9O1xyXG5cclxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxyXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cclxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QuXHJcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLl8gPSBfO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByb290Ll8gPSBfO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxyXG4gIF8uVkVSU0lPTiA9ICcxLjcuMCc7XHJcblxyXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cclxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxyXG4gIC8vIGZ1bmN0aW9ucy5cclxuICB2YXIgY3JlYXRlQ2FsbGJhY2sgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0LCBhcmdDb3VudCkge1xyXG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XHJcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcclxuICAgICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcclxuICAgICAgfTtcclxuICAgICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xyXG4gICAgICB9O1xyXG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XHJcbiAgICAgIH07XHJcbiAgICAgIGNhc2UgNDogcmV0dXJuIGZ1bmN0aW9uKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBBIG1vc3RseS1pbnRlcm5hbCBmdW5jdGlvbiB0byBnZW5lcmF0ZSBjYWxsYmFja3MgdGhhdCBjYW4gYmUgYXBwbGllZFxyXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxyXG4gIC8vIGlkZW50aXR5LCBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cclxuICBfLml0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XHJcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIF8uaWRlbnRpdHk7XHJcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIGNyZWF0ZUNhbGxiYWNrKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCk7XHJcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXModmFsdWUpO1xyXG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xyXG4gIH07XHJcblxyXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXHJcbiAgLy8gSGFuZGxlcyByYXcgb2JqZWN0cyBpbiBhZGRpdGlvbiB0byBhcnJheS1saWtlcy4gVHJlYXRzIGFsbFxyXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXHJcbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xyXG4gICAgaXRlcmF0ZWUgPSBjcmVhdGVDYWxsYmFjayhpdGVyYXRlZSwgY29udGV4dCk7XHJcbiAgICB2YXIgaSwgbGVuZ3RoID0gb2JqLmxlbmd0aDtcclxuICAgIGlmIChsZW5ndGggPT09ICtsZW5ndGgpIHtcclxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaXRlcmF0ZWUob2JqW2ldLCBpLCBvYmopO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xyXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxyXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gW107XHJcbiAgICBpdGVyYXRlZSA9IF8uaXRlcmF0ZWUoaXRlcmF0ZWUsIGNvbnRleHQpO1xyXG4gICAgdmFyIGtleXMgPSBvYmoubGVuZ3RoICE9PSArb2JqLmxlbmd0aCAmJiBfLmtleXMob2JqKSxcclxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcclxuICAgICAgICByZXN1bHRzID0gQXJyYXkobGVuZ3RoKSxcclxuICAgICAgICBjdXJyZW50S2V5O1xyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XHJcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfTtcclxuXHJcbiAgdmFyIHJlZHVjZUVycm9yID0gJ1JlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWUnO1xyXG5cclxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXHJcbiAgLy8gb3IgYGZvbGRsYC5cclxuICBfLnJlZHVjZSA9IF8uZm9sZGwgPSBfLmluamVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcclxuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XHJcbiAgICBpdGVyYXRlZSA9IGNyZWF0ZUNhbGxiYWNrKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcclxuICAgIHZhciBrZXlzID0gb2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGggJiYgXy5rZXlzKG9iaiksXHJcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXHJcbiAgICAgICAgaW5kZXggPSAwLCBjdXJyZW50S2V5O1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XHJcbiAgICAgIGlmICghbGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcclxuICAgICAgbWVtbyA9IG9ialtrZXlzID8ga2V5c1tpbmRleCsrXSA6IGluZGV4KytdO1xyXG4gICAgfVxyXG4gICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcclxuICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtZW1vO1xyXG4gIH07XHJcblxyXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxyXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xyXG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcclxuICAgIGl0ZXJhdGVlID0gY3JlYXRlQ2FsbGJhY2soaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xyXG4gICAgdmFyIGtleXMgPSBvYmoubGVuZ3RoICE9PSArIG9iai5sZW5ndGggJiYgXy5rZXlzKG9iaiksXHJcbiAgICAgICAgaW5kZXggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcclxuICAgICAgICBjdXJyZW50S2V5O1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XHJcbiAgICAgIGlmICghaW5kZXgpIHRocm93IG5ldyBUeXBlRXJyb3IocmVkdWNlRXJyb3IpO1xyXG4gICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzWy0taW5kZXhdIDogLS1pbmRleF07XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoaW5kZXgtLSkge1xyXG4gICAgICBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XHJcbiAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVtbztcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXHJcbiAgXy5maW5kID0gXy5kZXRlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xyXG4gICAgdmFyIHJlc3VsdDtcclxuICAgIHByZWRpY2F0ZSA9IF8uaXRlcmF0ZWUocHJlZGljYXRlLCBjb250ZXh0KTtcclxuICAgIF8uc29tZShvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgbGlzdCkpIHtcclxuICAgICAgICByZXN1bHQgPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXHJcbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cclxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcclxuICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHRzO1xyXG4gICAgcHJlZGljYXRlID0gXy5pdGVyYXRlZShwcmVkaWNhdGUsIGNvbnRleHQpO1xyXG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgZm9yIHdoaWNoIGEgdHJ1dGggdGVzdCBmYWlscy5cclxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XHJcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShfLml0ZXJhdGVlKHByZWRpY2F0ZSkpLCBjb250ZXh0KTtcclxuICB9O1xyXG5cclxuICAvLyBEZXRlcm1pbmUgd2hldGhlciBhbGwgb2YgdGhlIGVsZW1lbnRzIG1hdGNoIGEgdHJ1dGggdGVzdC5cclxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxyXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XHJcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gICAgcHJlZGljYXRlID0gXy5pdGVyYXRlZShwcmVkaWNhdGUsIGNvbnRleHQpO1xyXG4gICAgdmFyIGtleXMgPSBvYmoubGVuZ3RoICE9PSArb2JqLmxlbmd0aCAmJiBfLmtleXMob2JqKSxcclxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcclxuICAgICAgICBpbmRleCwgY3VycmVudEtleTtcclxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XHJcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIGlmIGF0IGxlYXN0IG9uZSBlbGVtZW50IGluIHRoZSBvYmplY3QgbWF0Y2hlcyBhIHRydXRoIHRlc3QuXHJcbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cclxuICBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XHJcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBmYWxzZTtcclxuICAgIHByZWRpY2F0ZSA9IF8uaXRlcmF0ZWUocHJlZGljYXRlLCBjb250ZXh0KTtcclxuICAgIHZhciBrZXlzID0gb2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGggJiYgXy5rZXlzKG9iaiksXHJcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXHJcbiAgICAgICAgaW5kZXgsIGN1cnJlbnRLZXk7XHJcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xyXG4gICAgICBpZiAocHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfTtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiB2YWx1ZSAodXNpbmcgYD09PWApLlxyXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVgLlxyXG4gIF8uY29udGFpbnMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIHRhcmdldCkge1xyXG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAob2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGgpIG9iaiA9IF8udmFsdWVzKG9iaik7XHJcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgdGFyZ2V0KSA+PSAwO1xyXG4gIH07XHJcblxyXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxyXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcclxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xyXG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgcmV0dXJuIChpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdKS5hcHBseSh2YWx1ZSwgYXJncyk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxyXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xyXG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgXy5wcm9wZXJ0eShrZXkpKTtcclxuICB9O1xyXG5cclxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaWx0ZXJgOiBzZWxlY3Rpbmcgb25seSBvYmplY3RzXHJcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cclxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xyXG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5tYXRjaGVzKGF0dHJzKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmluZGA6IGdldHRpbmcgdGhlIGZpcnN0IG9iamVjdFxyXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXHJcbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XHJcbiAgICByZXR1cm4gXy5maW5kKG9iaiwgXy5tYXRjaGVzKGF0dHJzKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxyXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5LFxyXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcclxuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XHJcbiAgICAgIG9iaiA9IG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoID8gb2JqIDogXy52YWx1ZXMob2JqKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xyXG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpdGVyYXRlZSA9IF8uaXRlcmF0ZWUoaXRlcmF0ZWUsIGNvbnRleHQpO1xyXG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XHJcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgICAgbGFzdENvbXB1dGVkID0gY29tcHV0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxyXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IEluZmluaXR5LCBsYXN0Q29tcHV0ZWQgPSBJbmZpbml0eSxcclxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XHJcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xyXG4gICAgICBvYmogPSBvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCA/IG9iaiA6IF8udmFsdWVzKG9iaik7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcclxuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcclxuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaXRlcmF0ZWUgPSBfLml0ZXJhdGVlKGl0ZXJhdGVlLCBjb250ZXh0KTtcclxuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xyXG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XHJcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG5cclxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbiwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxyXG4gIC8vIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXLigJNZYXRlc19zaHVmZmxlKS5cclxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciBzZXQgPSBvYmogJiYgb2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGggPyBvYmogOiBfLnZhbHVlcyhvYmopO1xyXG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XHJcbiAgICB2YXIgc2h1ZmZsZWQgPSBBcnJheShsZW5ndGgpO1xyXG4gICAgZm9yICh2YXIgaW5kZXggPSAwLCByYW5kOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xyXG4gICAgICBpZiAocmFuZCAhPT0gaW5kZXgpIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xyXG4gICAgICBzaHVmZmxlZFtyYW5kXSA9IHNldFtpbmRleF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2h1ZmZsZWQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXHJcbiAgLy8gSWYgKipuKiogaXMgbm90IHNwZWNpZmllZCwgcmV0dXJucyBhIHNpbmdsZSByYW5kb20gZWxlbWVudC5cclxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxyXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xyXG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkge1xyXG4gICAgICBpZiAob2JqLmxlbmd0aCAhPT0gK29iai5sZW5ndGgpIG9iaiA9IF8udmFsdWVzKG9iaik7XHJcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcclxuICAgIH1cclxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxyXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgaXRlcmF0ZWUgPSBfLml0ZXJhdGVlKGl0ZXJhdGVlLCBjb250ZXh0KTtcclxuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgICBjcml0ZXJpYTogaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KVxyXG4gICAgICB9O1xyXG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xyXG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XHJcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XHJcbiAgICAgIGlmIChhICE9PSBiKSB7XHJcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XHJcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XHJcbiAgICB9KSwgJ3ZhbHVlJyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxyXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgIGl0ZXJhdGVlID0gXy5pdGVyYXRlZShpdGVyYXRlZSwgY29udGV4dCk7XHJcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xyXG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XHJcbiAgICAgICAgYmVoYXZpb3IocmVzdWx0LCB2YWx1ZSwga2V5KTtcclxuICAgICAgfSk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcclxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cclxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcclxuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldLnB1c2godmFsdWUpOyBlbHNlIHJlc3VsdFtrZXldID0gW3ZhbHVlXTtcclxuICB9KTtcclxuXHJcbiAgLy8gSW5kZXhlcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLCBzaW1pbGFyIHRvIGBncm91cEJ5YCwgYnV0IGZvclxyXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cclxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcclxuICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XHJcbiAgfSk7XHJcblxyXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xyXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxyXG4gIC8vIGNyaXRlcmlvbi5cclxuICBfLmNvdW50QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcclxuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xyXG4gIH0pO1xyXG5cclxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXHJcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxyXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgaXRlcmF0ZWUgPSBfLml0ZXJhdGVlKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcclxuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdGVlKG9iaik7XHJcbiAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5Lmxlbmd0aDtcclxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XHJcbiAgICAgIHZhciBtaWQgPSBsb3cgKyBoaWdoID4+PiAxO1xyXG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxvdztcclxuICB9O1xyXG5cclxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxyXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcclxuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcclxuICAgIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XHJcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXHJcbiAgXy5zaXplID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xyXG4gICAgcmV0dXJuIG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcclxuICB9O1xyXG5cclxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXHJcbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxyXG4gIF8ucGFydGl0aW9uID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcclxuICAgIHByZWRpY2F0ZSA9IF8uaXRlcmF0ZWUocHJlZGljYXRlLCBjb250ZXh0KTtcclxuICAgIHZhciBwYXNzID0gW10sIGZhaWwgPSBbXTtcclxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xyXG4gICAgICAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iaikgPyBwYXNzIDogZmFpbCkucHVzaCh2YWx1ZSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBbcGFzcywgZmFpbF07XHJcbiAgfTtcclxuXHJcbiAgLy8gQXJyYXkgRnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxyXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcclxuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXHJcbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xyXG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XHJcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSByZXR1cm4gYXJyYXlbMF07XHJcbiAgICBpZiAobiA8IDApIHJldHVybiBbXTtcclxuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBuKTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cclxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxyXG4gIC8vIHRoZSBhcnJheSwgZXhjbHVkaW5nIHRoZSBsYXN0IE4uIFRoZSAqKmd1YXJkKiogY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aFxyXG4gIC8vIGBfLm1hcGAuXHJcbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XHJcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xyXG4gIH07XHJcblxyXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cclxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cclxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcclxuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xyXG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xyXG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIE1hdGgubWF4KGFycmF5Lmxlbmd0aCAtIG4sIDApKTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXHJcbiAgLy8gRXNwZWNpYWxseSB1c2VmdWwgb24gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgYW4gKipuKiogd2lsbCByZXR1cm5cclxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZSAqKmd1YXJkKipcclxuICAvLyBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXHJcbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XHJcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgbiA9PSBudWxsIHx8IGd1YXJkID8gMSA6IG4pO1xyXG4gIH07XHJcblxyXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cclxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xyXG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcclxuICB9O1xyXG5cclxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXHJcbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihpbnB1dCwgc2hhbGxvdywgc3RyaWN0LCBvdXRwdXQpIHtcclxuICAgIGlmIChzaGFsbG93ICYmIF8uZXZlcnkoaW5wdXQsIF8uaXNBcnJheSkpIHtcclxuICAgICAgcmV0dXJuIGNvbmNhdC5hcHBseShvdXRwdXQsIGlucHV0KTtcclxuICAgIH1cclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcclxuICAgICAgaWYgKCFfLmlzQXJyYXkodmFsdWUpICYmICFfLmlzQXJndW1lbnRzKHZhbHVlKSkge1xyXG4gICAgICAgIGlmICghc3RyaWN0KSBvdXRwdXQucHVzaCh2YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2hhbGxvdykge1xyXG4gICAgICAgIHB1c2guYXBwbHkob3V0cHV0LCB2YWx1ZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0LCBvdXRwdXQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG4gIH07XHJcblxyXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cclxuICBfLmZsYXR0ZW4gPSBmdW5jdGlvbihhcnJheSwgc2hhbGxvdykge1xyXG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlLCBbXSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXHJcbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcclxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXHJcbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cclxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcclxuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gW107XHJcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xyXG4gICAgICBjb250ZXh0ID0gaXRlcmF0ZWU7XHJcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XHJcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBfLml0ZXJhdGVlKGl0ZXJhdGVlLCBjb250ZXh0KTtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIHZhciBzZWVuID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV07XHJcbiAgICAgIGlmIChpc1NvcnRlZCkge1xyXG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSB2YWx1ZSkgcmVzdWx0LnB1c2godmFsdWUpO1xyXG4gICAgICAgIHNlZW4gPSB2YWx1ZTtcclxuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xyXG4gICAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSk7XHJcbiAgICAgICAgaWYgKF8uaW5kZXhPZihzZWVuLCBjb21wdXRlZCkgPCAwKSB7XHJcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xyXG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmIChfLmluZGV4T2YocmVzdWx0LCB2YWx1ZSkgPCAwKSB7XHJcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxyXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxyXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUsIFtdKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGV2ZXJ5IGl0ZW0gc2hhcmVkIGJldHdlZW4gYWxsIHRoZVxyXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXHJcbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xyXG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiBbXTtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIHZhciBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICB2YXIgaXRlbSA9IGFycmF5W2ldO1xyXG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcclxuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBpZiAoIV8uY29udGFpbnMoYXJndW1lbnRzW2pdLCBpdGVtKSkgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGogPT09IGFyZ3NMZW5ndGgpIHJlc3VsdC5wdXNoKGl0ZW0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG5cclxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXHJcbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cclxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xyXG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSwgdHJ1ZSwgdHJ1ZSwgW10pO1xyXG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvLyBaaXAgdG9nZXRoZXIgbXVsdGlwbGUgbGlzdHMgaW50byBhIHNpbmdsZSBhcnJheSAtLSBlbGVtZW50cyB0aGF0IHNoYXJlXHJcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXHJcbiAgXy56aXAgPSBmdW5jdGlvbihhcnJheSkge1xyXG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiBbXTtcclxuICAgIHZhciBsZW5ndGggPSBfLm1heChhcmd1bWVudHMsICdsZW5ndGgnKS5sZW5ndGg7XHJcbiAgICB2YXIgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHJlc3VsdHNbaV0gPSBfLnBsdWNrKGFyZ3VtZW50cywgaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9O1xyXG5cclxuICAvLyBDb252ZXJ0cyBsaXN0cyBpbnRvIG9iamVjdHMuIFBhc3MgZWl0aGVyIGEgc2luZ2xlIGFycmF5IG9mIGBba2V5LCB2YWx1ZV1gXHJcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXHJcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxyXG4gIF8ub2JqZWN0ID0gZnVuY3Rpb24obGlzdCwgdmFsdWVzKSB7XHJcbiAgICBpZiAobGlzdCA9PSBudWxsKSByZXR1cm4ge307XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBpZiAodmFsdWVzKSB7XHJcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxyXG4gIC8vIG9yIC0xIGlmIHRoZSBpdGVtIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGUgYXJyYXkuXHJcbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXHJcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cclxuICBfLmluZGV4T2YgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgaXNTb3J0ZWQpIHtcclxuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gLTE7XHJcbiAgICB2YXIgaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcclxuICAgIGlmIChpc1NvcnRlZCkge1xyXG4gICAgICBpZiAodHlwZW9mIGlzU29ydGVkID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgaSA9IGlzU29ydGVkIDwgMCA/IE1hdGgubWF4KDAsIGxlbmd0aCArIGlzU29ydGVkKSA6IGlzU29ydGVkO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcclxuICAgICAgICByZXR1cm4gYXJyYXlbaV0gPT09IGl0ZW0gPyBpIDogLTE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfTtcclxuXHJcbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tKSB7XHJcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xyXG4gICAgdmFyIGlkeCA9IGFycmF5Lmxlbmd0aDtcclxuICAgIGlmICh0eXBlb2YgZnJvbSA9PSAnbnVtYmVyJykge1xyXG4gICAgICBpZHggPSBmcm9tIDwgMCA/IGlkeCArIGZyb20gKyAxIDogTWF0aC5taW4oaWR4LCBmcm9tICsgMSk7XHJcbiAgICB9XHJcbiAgICB3aGlsZSAoLS1pZHggPj0gMCkgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfTtcclxuXHJcbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxyXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXHJcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cclxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XHJcbiAgICAgIHN0YXJ0ID0gMDtcclxuICAgIH1cclxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XHJcblxyXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWF4KE1hdGguY2VpbCgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXApLCAwKTtcclxuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XHJcblxyXG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgbGVuZ3RoOyBpZHgrKywgc3RhcnQgKz0gc3RlcCkge1xyXG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJhbmdlO1xyXG4gIH07XHJcblxyXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gUmV1c2FibGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHByb3RvdHlwZSBzZXR0aW5nLlxyXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xyXG5cclxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcclxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXHJcbiAgLy8gYXZhaWxhYmxlLlxyXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcclxuICAgIHZhciBhcmdzLCBib3VuZDtcclxuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcclxuICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICBib3VuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYm91bmQpKSByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcclxuICAgICAgQ3Rvci5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcclxuICAgICAgdmFyIHNlbGYgPSBuZXcgQ3RvcjtcclxuICAgICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xyXG4gICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcclxuICAgICAgaWYgKF8uaXNPYmplY3QocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGJvdW5kO1xyXG4gIH07XHJcblxyXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcclxuICAvLyBhcmd1bWVudHMgcHJlLWZpbGxlZCwgd2l0aG91dCBjaGFuZ2luZyBpdHMgZHluYW1pYyBgdGhpc2AgY29udGV4dC4gXyBhY3RzXHJcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxyXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICAgIHZhciBib3VuZEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBwb3NpdGlvbiA9IDA7XHJcbiAgICAgIHZhciBhcmdzID0gYm91bmRBcmdzLnNsaWNlKCk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBhcmdzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyZ3NbaV0gPT09IF8pIGFyZ3NbaV0gPSBhcmd1bWVudHNbcG9zaXRpb24rK107XHJcbiAgICAgIH1cclxuICAgICAgd2hpbGUgKHBvc2l0aW9uIDwgYXJndW1lbnRzLmxlbmd0aCkgYXJncy5wdXNoKGFyZ3VtZW50c1twb3NpdGlvbisrXSk7XHJcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBCaW5kIGEgbnVtYmVyIG9mIGFuIG9iamVjdCdzIG1ldGhvZHMgdG8gdGhhdCBvYmplY3QuIFJlbWFpbmluZyBhcmd1bWVudHNcclxuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcclxuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXHJcbiAgXy5iaW5kQWxsID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xyXG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcclxuICAgIGZvciAoaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iajtcclxuICB9O1xyXG5cclxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxyXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xyXG4gICAgdmFyIG1lbW9pemUgPSBmdW5jdGlvbihrZXkpIHtcclxuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcclxuICAgICAgdmFyIGFkZHJlc3MgPSBoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleTtcclxuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XHJcbiAgICB9O1xyXG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xyXG4gICAgcmV0dXJuIG1lbW9pemU7XHJcbiAgfTtcclxuXHJcbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xyXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cclxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xyXG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcclxuICAgIH0sIHdhaXQpO1xyXG4gIH07XHJcblxyXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xyXG4gIC8vIGNsZWFyZWQuXHJcbiAgXy5kZWZlciA9IGZ1bmN0aW9uKGZ1bmMpIHtcclxuICAgIHJldHVybiBfLmRlbGF5LmFwcGx5KF8sIFtmdW5jLCAxXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXHJcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXHJcbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xyXG4gIC8vIGJ1dCBpZiB5b3UnZCBsaWtlIHRvIGRpc2FibGUgdGhlIGV4ZWN1dGlvbiBvbiB0aGUgbGVhZGluZyBlZGdlLCBwYXNzXHJcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXHJcbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcclxuICAgIHZhciBjb250ZXh0LCBhcmdzLCByZXN1bHQ7XHJcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XHJcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xyXG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XHJcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XHJcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xyXG4gICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHByZXZpb3VzID0gbm93O1xyXG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XHJcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xyXG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICBwcmV2aW91cyA9IG5vdztcclxuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xyXG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxyXG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcclxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxyXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcclxuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcclxuXHJcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xyXG5cclxuICAgICAgaWYgKGxhc3QgPCB3YWl0ICYmIGxhc3QgPiAwKSB7XHJcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xyXG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICB0aW1lc3RhbXAgPSBfLm5vdygpO1xyXG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcclxuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XHJcbiAgICAgIGlmIChjYWxsTm93KSB7XHJcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGZ1bmN0aW9uIHBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgc2Vjb25kLFxyXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcclxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxyXG4gIF8ud3JhcCA9IGZ1bmN0aW9uKGZ1bmMsIHdyYXBwZXIpIHtcclxuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cclxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxyXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXHJcbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuICAgIHZhciBzdGFydCA9IGFyZ3MubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGkgPSBzdGFydDtcclxuICAgICAgdmFyIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYWZ0ZXIgYmVpbmcgY2FsbGVkIE4gdGltZXMuXHJcbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xyXG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGJlZm9yZSBiZWluZyBjYWxsZWQgTiB0aW1lcy5cclxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XHJcbiAgICB2YXIgbWVtbztcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XHJcbiAgICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmdW5jID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWVtbztcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBhdCBtb3N0IG9uZSB0aW1lLCBubyBtYXR0ZXIgaG93XHJcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cclxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xyXG5cclxuICAvLyBPYmplY3QgRnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cclxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXHJcbiAgXy5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xyXG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XHJcbiAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XHJcbiAgICByZXR1cm4ga2V5cztcclxuICB9O1xyXG5cclxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXHJcbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XHJcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlcztcclxuICB9O1xyXG5cclxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cclxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xyXG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xyXG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcclxuICAgIH1cclxuICAgIHJldHVybiBwYWlycztcclxuICB9O1xyXG5cclxuICAvLyBJbnZlcnQgdGhlIGtleXMgYW5kIHZhbHVlcyBvZiBhbiBvYmplY3QuIFRoZSB2YWx1ZXMgbXVzdCBiZSBzZXJpYWxpemFibGUuXHJcbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cclxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxyXG4gIF8uZnVuY3Rpb25zID0gXy5tZXRob2RzID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIgbmFtZXMgPSBbXTtcclxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgaWYgKF8uaXNGdW5jdGlvbihvYmpba2V5XSkpIG5hbWVzLnB1c2goa2V5KTtcclxuICAgIH1cclxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XHJcbiAgfTtcclxuXHJcbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXHJcbiAgXy5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xyXG4gICAgdmFyIHNvdXJjZSwgcHJvcDtcclxuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICBmb3IgKHByb3AgaW4gc291cmNlKSB7XHJcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBwcm9wKSkge1xyXG4gICAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXHJcbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9LCBrZXk7XHJcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XHJcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xyXG4gICAgICBpdGVyYXRlZSA9IGNyZWF0ZUNhbGxiYWNrKGl0ZXJhdGVlLCBjb250ZXh0KTtcclxuICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XHJcbiAgICAgICAgaWYgKGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iaikpIHJlc3VsdFtrZXldID0gdmFsdWU7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBrZXlzID0gY29uY2F0LmFwcGx5KFtdLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gICAgICBvYmogPSBuZXcgT2JqZWN0KG9iaik7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcclxuICAgICAgICBpZiAoa2V5IGluIG9iaikgcmVzdWx0W2tleV0gPSBvYmpba2V5XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9O1xyXG5cclxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXHJcbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xyXG4gICAgaWYgKF8uaXNGdW5jdGlvbihpdGVyYXRlZSkpIHtcclxuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB2YXIga2V5cyA9IF8ubWFwKGNvbmNhdC5hcHBseShbXSwgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSwgU3RyaW5nKTtcclxuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xyXG4gIH07XHJcblxyXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXHJcbiAgXy5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XHJcbiAgICBmb3IgKHZhciBpID0gMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XHJcbiAgICAgICAgaWYgKG9ialtwcm9wXSA9PT0gdm9pZCAwKSBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBvYmo7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxyXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xyXG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcclxuICB9O1xyXG5cclxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXHJcbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXHJcbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXHJcbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XHJcbiAgICBpbnRlcmNlcHRvcihvYmopO1xyXG4gICAgcmV0dXJuIG9iajtcclxuICB9O1xyXG5cclxuICAvLyBJbnRlcm5hbCByZWN1cnNpdmUgY29tcGFyaXNvbiBmdW5jdGlvbiBmb3IgYGlzRXF1YWxgLlxyXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XHJcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXHJcbiAgICAvLyBTZWUgdGhlIFtIYXJtb255IGBlZ2FsYCBwcm9wb3NhbF0oaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsKS5cclxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XHJcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXHJcbiAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkgcmV0dXJuIGEgPT09IGI7XHJcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cclxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XHJcbiAgICBpZiAoYiBpbnN0YW5jZW9mIF8pIGIgPSBiLl93cmFwcGVkO1xyXG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cclxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xyXG4gICAgaWYgKGNsYXNzTmFtZSAhPT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcclxuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXHJcbiAgICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6XHJcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXHJcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XHJcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcclxuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXHJcbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xyXG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxyXG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXHJcbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cclxuICAgICAgICBpZiAoK2EgIT09ICthKSByZXR1cm4gK2IgIT09ICtiO1xyXG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXHJcbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcclxuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XHJcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxyXG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXHJcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxyXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGEgIT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgIT0gJ29iamVjdCcpIHJldHVybiBmYWxzZTtcclxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcclxuICAgIC8vIHN0cnVjdHVyZXMgaXMgYWRhcHRlZCBmcm9tIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMsIGFic3RyYWN0IG9wZXJhdGlvbiBgSk9gLlxyXG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XHJcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcclxuICAgICAgLy8gTGluZWFyIHNlYXJjaC4gUGVyZm9ybWFuY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mXHJcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cclxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XHJcbiAgICB9XHJcbiAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHNcclxuICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXHJcbiAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XHJcbiAgICBpZiAoXHJcbiAgICAgIGFDdG9yICE9PSBiQ3RvciAmJlxyXG4gICAgICAvLyBIYW5kbGUgT2JqZWN0LmNyZWF0ZSh4KSBjYXNlc1xyXG4gICAgICAnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiICYmXHJcbiAgICAgICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXHJcbiAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cclxuICAgIGFTdGFjay5wdXNoKGEpO1xyXG4gICAgYlN0YWNrLnB1c2goYik7XHJcbiAgICB2YXIgc2l6ZSwgcmVzdWx0O1xyXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXHJcbiAgICBpZiAoY2xhc3NOYW1lID09PSAnW29iamVjdCBBcnJheV0nKSB7XHJcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxyXG4gICAgICBzaXplID0gYS5sZW5ndGg7XHJcbiAgICAgIHJlc3VsdCA9IHNpemUgPT09IGIubGVuZ3RoO1xyXG4gICAgICBpZiAocmVzdWx0KSB7XHJcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cclxuICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XHJcbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBlcShhW3NpemVdLCBiW3NpemVdLCBhU3RhY2ssIGJTdGFjaykpKSBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxyXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xyXG4gICAgICBzaXplID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cclxuICAgICAgcmVzdWx0ID0gXy5rZXlzKGIpLmxlbmd0aCA9PT0gc2l6ZTtcclxuICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcclxuICAgICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlclxyXG4gICAgICAgICAga2V5ID0ga2V5c1tzaXplXTtcclxuICAgICAgICAgIGlmICghKHJlc3VsdCA9IF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gUmVtb3ZlIHRoZSBmaXJzdCBvYmplY3QgZnJvbSB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXHJcbiAgICBhU3RhY2sucG9wKCk7XHJcbiAgICBiU3RhY2sucG9wKCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxyXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcclxuICAgIHJldHVybiBlcShhLCBiLCBbXSwgW10pO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xyXG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXHJcbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xyXG4gICAgaWYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpIHJldHVybiBvYmoubGVuZ3RoID09PSAwO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xyXG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cclxuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxyXG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xyXG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcclxuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLlxyXG4gIF8uZWFjaChbJ0FyZ3VtZW50cycsICdGdW5jdGlvbicsICdTdHJpbmcnLCAnTnVtYmVyJywgJ0RhdGUnLCAnUmVnRXhwJ10sIGZ1bmN0aW9uKG5hbWUpIHtcclxuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSksIHdoZXJlXHJcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cclxuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xyXG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gXy5oYXMob2JqLCAnY2FsbGVlJyk7XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gT3B0aW1pemUgYGlzRnVuY3Rpb25gIGlmIGFwcHJvcHJpYXRlLiBXb3JrIGFyb3VuZCBhbiBJRSAxMSBidWcuXHJcbiAgaWYgKHR5cGVvZiAvLi8gIT09ICdmdW5jdGlvbicpIHtcclxuICAgIF8uaXNGdW5jdGlvbiA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cclxuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcclxuICB9O1xyXG5cclxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXHJcbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT09ICtvYmo7XHJcbiAgfTtcclxuXHJcbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIGJvb2xlYW4/XHJcbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcclxuICB9O1xyXG5cclxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XHJcbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBvYmogPT09IG51bGw7XHJcbiAgfTtcclxuXHJcbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XHJcbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xyXG4gIH07XHJcblxyXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcclxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxyXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcclxuICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcclxuICB9O1xyXG5cclxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcclxuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXHJcbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9O1xyXG5cclxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxyXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH07XHJcblxyXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcclxuXHJcbiAgXy5wcm9wZXJ0eSA9IGZ1bmN0aW9uKGtleSkge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gb2JqW2tleV07XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cclxuICBfLm1hdGNoZXMgPSBmdW5jdGlvbihhdHRycykge1xyXG4gICAgdmFyIHBhaXJzID0gXy5wYWlycyhhdHRycyksIGxlbmd0aCA9IHBhaXJzLmxlbmd0aDtcclxuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcclxuICAgICAgb2JqID0gbmV3IE9iamVjdChvYmopO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpXSwga2V5ID0gcGFpclswXTtcclxuICAgICAgICBpZiAocGFpclsxXSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cclxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcclxuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcclxuICAgIGl0ZXJhdGVlID0gY3JlYXRlQ2FsbGJhY2soaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XHJcbiAgICByZXR1cm4gYWNjdW07XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cclxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XHJcbiAgICBpZiAobWF4ID09IG51bGwpIHtcclxuICAgICAgbWF4ID0gbWluO1xyXG4gICAgICBtaW4gPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxyXG4gIF8ubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgfTtcclxuXHJcbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXHJcbiAgdmFyIGVzY2FwZU1hcCA9IHtcclxuICAgICcmJzogJyZhbXA7JyxcclxuICAgICc8JzogJyZsdDsnLFxyXG4gICAgJz4nOiAnJmd0OycsXHJcbiAgICAnXCInOiAnJnF1b3Q7JyxcclxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcclxuICAgICdgJzogJyYjeDYwOydcclxuICB9O1xyXG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XHJcblxyXG4gIC8vIEZ1bmN0aW9ucyBmb3IgZXNjYXBpbmcgYW5kIHVuZXNjYXBpbmcgc3RyaW5ncyB0by9mcm9tIEhUTUwgaW50ZXJwb2xhdGlvbi5cclxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xyXG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xyXG4gICAgICByZXR1cm4gbWFwW21hdGNoXTtcclxuICAgIH07XHJcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcclxuICAgIHZhciBzb3VyY2UgPSAnKD86JyArIF8ua2V5cyhtYXApLmpvaW4oJ3wnKSArICcpJztcclxuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XHJcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XHJcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcclxuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XHJcbiAgICB9O1xyXG4gIH07XHJcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XHJcbiAgXy51bmVzY2FwZSA9IGNyZWF0ZUVzY2FwZXIodW5lc2NhcGVNYXApO1xyXG5cclxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxyXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxyXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xyXG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcclxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gb2JqZWN0W3Byb3BlcnR5XSgpIDogdmFsdWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cclxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxyXG4gIHZhciBpZENvdW50ZXIgPSAwO1xyXG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcclxuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XHJcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcclxuICB9O1xyXG5cclxuICAvLyBCeSBkZWZhdWx0LCBVbmRlcnNjb3JlIHVzZXMgRVJCLXN0eWxlIHRlbXBsYXRlIGRlbGltaXRlcnMsIGNoYW5nZSB0aGVcclxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXHJcbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xyXG4gICAgZXZhbHVhdGUgICAgOiAvPCUoW1xcc1xcU10rPyklPi9nLFxyXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcclxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcclxuICB9O1xyXG5cclxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXHJcbiAgLy8gaW50ZXJwb2xhdGlvbiwgZXZhbHVhdGlvbiBvciBlc2NhcGluZyByZWdleCwgd2UgbmVlZCBvbmUgdGhhdCBpc1xyXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxyXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xyXG5cclxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxyXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxyXG4gIHZhciBlc2NhcGVzID0ge1xyXG4gICAgXCInXCI6ICAgICAgXCInXCIsXHJcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXHJcbiAgICAnXFxyJzogICAgICdyJyxcclxuICAgICdcXG4nOiAgICAgJ24nLFxyXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxyXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXHJcbiAgfTtcclxuXHJcbiAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx1MjAyOHxcXHUyMDI5L2c7XHJcblxyXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcclxuICAgIHJldHVybiAnXFxcXCcgKyBlc2NhcGVzW21hdGNoXTtcclxuICB9O1xyXG5cclxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxyXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcclxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cclxuICAvLyBOQjogYG9sZFNldHRpbmdzYCBvbmx5IGV4aXN0cyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXHJcbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xyXG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcclxuICAgIHNldHRpbmdzID0gXy5kZWZhdWx0cyh7fSwgc2V0dGluZ3MsIF8udGVtcGxhdGVTZXR0aW5ncyk7XHJcblxyXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXHJcbiAgICB2YXIgbWF0Y2hlciA9IFJlZ0V4cChbXHJcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxyXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxyXG4gICAgICAoc2V0dGluZ3MuZXZhbHVhdGUgfHwgbm9NYXRjaCkuc291cmNlXHJcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XHJcblxyXG4gICAgLy8gQ29tcGlsZSB0aGUgdGVtcGxhdGUgc291cmNlLCBlc2NhcGluZyBzdHJpbmcgbGl0ZXJhbHMgYXBwcm9wcmlhdGVseS5cclxuICAgIHZhciBpbmRleCA9IDA7XHJcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcclxuICAgIHRleHQucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlLCBpbnRlcnBvbGF0ZSwgZXZhbHVhdGUsIG9mZnNldCkge1xyXG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xyXG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcclxuXHJcbiAgICAgIGlmIChlc2NhcGUpIHtcclxuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xyXG4gICAgICB9IGVsc2UgaWYgKGludGVycG9sYXRlKSB7XHJcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XHJcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcclxuICAgICAgICBzb3VyY2UgKz0gXCInO1xcblwiICsgZXZhbHVhdGUgKyBcIlxcbl9fcCs9J1wiO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBZG9iZSBWTXMgbmVlZCB0aGUgbWF0Y2ggcmV0dXJuZWQgdG8gcHJvZHVjZSB0aGUgY29ycmVjdCBvZmZlc3QuXHJcbiAgICAgIHJldHVybiBtYXRjaDtcclxuICAgIH0pO1xyXG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcclxuXHJcbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxyXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcclxuXHJcbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXHJcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXHJcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBlLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxyXG4gICAgdmFyIGFyZ3VtZW50ID0gc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaic7XHJcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcclxuXHJcbiAgICByZXR1cm4gdGVtcGxhdGU7XHJcbiAgfTtcclxuXHJcbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLiBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXHJcbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xyXG4gICAgaW5zdGFuY2UuX2NoYWluID0gdHJ1ZTtcclxuICAgIHJldHVybiBpbnN0YW5jZTtcclxuICB9O1xyXG5cclxuICAvLyBPT1BcclxuICAvLyAtLS0tLS0tLS0tLS0tLS1cclxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxyXG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXHJcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cclxuXHJcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxyXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiB0aGlzLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cclxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XHJcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XHJcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cclxuICBfLm1peGluKF8pO1xyXG5cclxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxyXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcclxuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xyXG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xyXG4gICAgICBpZiAoKG5hbWUgPT09ICdzaGlmdCcgfHwgbmFtZSA9PT0gJ3NwbGljZScpICYmIG9iai5sZW5ndGggPT09IDApIGRlbGV0ZSBvYmpbMF07XHJcbiAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBvYmopO1xyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXHJcbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XHJcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXHJcbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xyXG4gIH07XHJcblxyXG4gIC8vIEFNRCByZWdpc3RyYXRpb24gaGFwcGVucyBhdCB0aGUgZW5kIGZvciBjb21wYXRpYmlsaXR5IHdpdGggQU1EIGxvYWRlcnNcclxuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcclxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXHJcbiAgLy8gYXMgYSBuYW1lZCBtb2R1bGUgYmVjYXVzZSwgbGlrZSBqUXVlcnksIGl0IGlzIGEgYmFzZSBsaWJyYXJ5IHRoYXQgaXNcclxuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcclxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXHJcbiAgLy8gYW5vbnltb3VzIGRlZmluZSgpIGlzIGNhbGxlZCBvdXRzaWRlIG9mIGEgbG9hZGVyIHJlcXVlc3QuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gXztcclxuICAgIH0pO1xyXG4gIH1cclxufS5jYWxsKHRoaXMpKTtcclxuIiwiLy8gICAgIEJhY2tib25lLmpzIDEuMS4yXHJcblxyXG4vLyAgICAgKGMpIDIwMTAtMjAxNCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xyXG4vLyAgICAgQmFja2JvbmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbi8vICAgICBGb3IgYWxsIGRldGFpbHMgYW5kIGRvY3VtZW50YXRpb246XHJcbi8vICAgICBodHRwOi8vYmFja2JvbmVqcy5vcmdcclxuXHJcbihmdW5jdGlvbihyb290LCBmYWN0b3J5KSB7XHJcblxyXG4gIC8vIFNldCB1cCBCYWNrYm9uZSBhcHByb3ByaWF0ZWx5IGZvciB0aGUgZW52aXJvbm1lbnQuIFN0YXJ0IHdpdGggQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShbJ3VuZGVyc2NvcmUnLCAnanF1ZXJ5JywgJ2V4cG9ydHMnXSwgZnVuY3Rpb24oXywgJCwgZXhwb3J0cykge1xyXG4gICAgICAvLyBFeHBvcnQgZ2xvYmFsIGV2ZW4gaW4gQU1EIGNhc2UgaW4gY2FzZSB0aGlzIHNjcmlwdCBpcyBsb2FkZWQgd2l0aFxyXG4gICAgICAvLyBvdGhlcnMgdGhhdCBtYXkgc3RpbGwgZXhwZWN0IGEgZ2xvYmFsIEJhY2tib25lLlxyXG4gICAgICByb290LkJhY2tib25lID0gZmFjdG9yeShyb290LCBleHBvcnRzLCBfLCAkKTtcclxuICAgIH0pO1xyXG5cclxuICAvLyBOZXh0IGZvciBOb2RlLmpzIG9yIENvbW1vbkpTLiBqUXVlcnkgbWF5IG5vdCBiZSBuZWVkZWQgYXMgYSBtb2R1bGUuXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIHZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG4gICAgZmFjdG9yeShyb290LCBleHBvcnRzLCBfKTtcclxuXHJcbiAgLy8gRmluYWxseSwgYXMgYSBicm93c2VyIGdsb2JhbC5cclxuICB9IGVsc2Uge1xyXG4gICAgcm9vdC5CYWNrYm9uZSA9IGZhY3Rvcnkocm9vdCwge30sIHJvb3QuXywgKHJvb3QualF1ZXJ5IHx8IHJvb3QuWmVwdG8gfHwgcm9vdC5lbmRlciB8fCByb290LiQpKTtcclxuICB9XHJcblxyXG59KHRoaXMsIGZ1bmN0aW9uKHJvb3QsIEJhY2tib25lLCBfLCAkKSB7XHJcblxyXG4gIC8vIEluaXRpYWwgU2V0dXBcclxuICAvLyAtLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgQmFja2JvbmVgIHZhcmlhYmxlLCBzbyB0aGF0IGl0IGNhbiBiZVxyXG4gIC8vIHJlc3RvcmVkIGxhdGVyIG9uLCBpZiBgbm9Db25mbGljdGAgaXMgdXNlZC5cclxuICB2YXIgcHJldmlvdXNCYWNrYm9uZSA9IHJvb3QuQmFja2JvbmU7XHJcblxyXG4gIC8vIENyZWF0ZSBsb2NhbCByZWZlcmVuY2VzIHRvIGFycmF5IG1ldGhvZHMgd2UnbGwgd2FudCB0byB1c2UgbGF0ZXIuXHJcbiAgdmFyIGFycmF5ID0gW107XHJcbiAgdmFyIHB1c2ggPSBhcnJheS5wdXNoO1xyXG4gIHZhciBzbGljZSA9IGFycmF5LnNsaWNlO1xyXG4gIHZhciBzcGxpY2UgPSBhcnJheS5zcGxpY2U7XHJcblxyXG4gIC8vIEN1cnJlbnQgdmVyc2lvbiBvZiB0aGUgbGlicmFyeS4gS2VlcCBpbiBzeW5jIHdpdGggYHBhY2thZ2UuanNvbmAuXHJcbiAgQmFja2JvbmUuVkVSU0lPTiA9ICcxLjEuMic7XHJcblxyXG4gIC8vIEZvciBCYWNrYm9uZSdzIHB1cnBvc2VzLCBqUXVlcnksIFplcHRvLCBFbmRlciwgb3IgTXkgTGlicmFyeSAoa2lkZGluZykgb3duc1xyXG4gIC8vIHRoZSBgJGAgdmFyaWFibGUuXHJcbiAgQmFja2JvbmUuJCA9ICQ7XHJcblxyXG4gIC8vIFJ1bnMgQmFja2JvbmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYEJhY2tib25lYCB2YXJpYWJsZVxyXG4gIC8vIHRvIGl0cyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIEJhY2tib25lIG9iamVjdC5cclxuICBCYWNrYm9uZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XHJcbiAgICByb290LkJhY2tib25lID0gcHJldmlvdXNCYWNrYm9uZTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH07XHJcblxyXG4gIC8vIFR1cm4gb24gYGVtdWxhdGVIVFRQYCB0byBzdXBwb3J0IGxlZ2FjeSBIVFRQIHNlcnZlcnMuIFNldHRpbmcgdGhpcyBvcHRpb25cclxuICAvLyB3aWxsIGZha2UgYFwiUEFUQ0hcImAsIGBcIlBVVFwiYCBhbmQgYFwiREVMRVRFXCJgIHJlcXVlc3RzIHZpYSB0aGUgYF9tZXRob2RgIHBhcmFtZXRlciBhbmRcclxuICAvLyBzZXQgYSBgWC1IdHRwLU1ldGhvZC1PdmVycmlkZWAgaGVhZGVyLlxyXG4gIEJhY2tib25lLmVtdWxhdGVIVFRQID0gZmFsc2U7XHJcblxyXG4gIC8vIFR1cm4gb24gYGVtdWxhdGVKU09OYCB0byBzdXBwb3J0IGxlZ2FjeSBzZXJ2ZXJzIHRoYXQgY2FuJ3QgZGVhbCB3aXRoIGRpcmVjdFxyXG4gIC8vIGBhcHBsaWNhdGlvbi9qc29uYCByZXF1ZXN0cyAuLi4gd2lsbCBlbmNvZGUgdGhlIGJvZHkgYXNcclxuICAvLyBgYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkYCBpbnN0ZWFkIGFuZCB3aWxsIHNlbmQgdGhlIG1vZGVsIGluIGFcclxuICAvLyBmb3JtIHBhcmFtIG5hbWVkIGBtb2RlbGAuXHJcbiAgQmFja2JvbmUuZW11bGF0ZUpTT04gPSBmYWxzZTtcclxuXHJcbiAgLy8gQmFja2JvbmUuRXZlbnRzXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIEEgbW9kdWxlIHRoYXQgY2FuIGJlIG1peGVkIGluIHRvICphbnkgb2JqZWN0KiBpbiBvcmRlciB0byBwcm92aWRlIGl0IHdpdGhcclxuICAvLyBjdXN0b20gZXZlbnRzLiBZb3UgbWF5IGJpbmQgd2l0aCBgb25gIG9yIHJlbW92ZSB3aXRoIGBvZmZgIGNhbGxiYWNrXHJcbiAgLy8gZnVuY3Rpb25zIHRvIGFuIGV2ZW50OyBgdHJpZ2dlcmAtaW5nIGFuIGV2ZW50IGZpcmVzIGFsbCBjYWxsYmFja3MgaW5cclxuICAvLyBzdWNjZXNzaW9uLlxyXG4gIC8vXHJcbiAgLy8gICAgIHZhciBvYmplY3QgPSB7fTtcclxuICAvLyAgICAgXy5leHRlbmQob2JqZWN0LCBCYWNrYm9uZS5FdmVudHMpO1xyXG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcclxuICAvLyAgICAgb2JqZWN0LnRyaWdnZXIoJ2V4cGFuZCcpO1xyXG4gIC8vXHJcbiAgdmFyIEV2ZW50cyA9IEJhY2tib25lLkV2ZW50cyA9IHtcclxuXHJcbiAgICAvLyBCaW5kIGFuIGV2ZW50IHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi4gUGFzc2luZyBgXCJhbGxcImAgd2lsbCBiaW5kXHJcbiAgICAvLyB0aGUgY2FsbGJhY2sgdG8gYWxsIGV2ZW50cyBmaXJlZC5cclxuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgICBpZiAoIWV2ZW50c0FwaSh0aGlzLCAnb24nLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSB8fCAhY2FsbGJhY2spIHJldHVybiB0aGlzO1xyXG4gICAgICB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KTtcclxuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXSB8fCAodGhpcy5fZXZlbnRzW25hbWVdID0gW10pO1xyXG4gICAgICBldmVudHMucHVzaCh7Y2FsbGJhY2s6IGNhbGxiYWNrLCBjb250ZXh0OiBjb250ZXh0LCBjdHg6IGNvbnRleHQgfHwgdGhpc30pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQmluZCBhbiBldmVudCB0byBvbmx5IGJlIHRyaWdnZXJlZCBhIHNpbmdsZSB0aW1lLiBBZnRlciB0aGUgZmlyc3QgdGltZVxyXG4gICAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZC5cclxuICAgIG9uY2U6IGZ1bmN0aW9uKG5hbWUsIGNhbGxiYWNrLCBjb250ZXh0KSB7XHJcbiAgICAgIGlmICghZXZlbnRzQXBpKHRoaXMsICdvbmNlJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcclxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgICB2YXIgb25jZSA9IF8ub25jZShmdW5jdGlvbigpIHtcclxuICAgICAgICBzZWxmLm9mZihuYW1lLCBvbmNlKTtcclxuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB9KTtcclxuICAgICAgb25jZS5fY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgb25jZSwgY29udGV4dCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxyXG4gICAgLy8gY2FsbGJhY2tzIHdpdGggdGhhdCBmdW5jdGlvbi4gSWYgYGNhbGxiYWNrYCBpcyBudWxsLCByZW1vdmVzIGFsbFxyXG4gICAgLy8gY2FsbGJhY2tzIGZvciB0aGUgZXZlbnQuIElmIGBuYW1lYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZFxyXG4gICAgLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxyXG4gICAgb2ZmOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xyXG4gICAgICB2YXIgcmV0YWluLCBldiwgZXZlbnRzLCBuYW1lcywgaSwgbCwgaiwgaztcclxuICAgICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIWV2ZW50c0FwaSh0aGlzLCAnb2ZmJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkpIHJldHVybiB0aGlzO1xyXG4gICAgICBpZiAoIW5hbWUgJiYgIWNhbGxiYWNrICYmICFjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdm9pZCAwO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICB9XHJcbiAgICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IF8ua2V5cyh0aGlzLl9ldmVudHMpO1xyXG4gICAgICBmb3IgKGkgPSAwLCBsID0gbmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgbmFtZSA9IG5hbWVzW2ldO1xyXG4gICAgICAgIGlmIChldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0pIHtcclxuICAgICAgICAgIHRoaXMuX2V2ZW50c1tuYW1lXSA9IHJldGFpbiA9IFtdO1xyXG4gICAgICAgICAgaWYgKGNhbGxiYWNrIHx8IGNvbnRleHQpIHtcclxuICAgICAgICAgICAgZm9yIChqID0gMCwgayA9IGV2ZW50cy5sZW5ndGg7IGogPCBrOyBqKyspIHtcclxuICAgICAgICAgICAgICBldiA9IGV2ZW50c1tqXTtcclxuICAgICAgICAgICAgICBpZiAoKGNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBldi5jYWxsYmFjayAmJiBjYWxsYmFjayAhPT0gZXYuY2FsbGJhY2suX2NhbGxiYWNrKSB8fFxyXG4gICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBldi5jb250ZXh0KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0YWluLnB1c2goZXYpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKCFyZXRhaW4ubGVuZ3RoKSBkZWxldGUgdGhpcy5fZXZlbnRzW25hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxyXG4gICAgLy8gcGFzc2VkIHRoZSBzYW1lIGFyZ3VtZW50cyBhcyBgdHJpZ2dlcmAgaXMsIGFwYXJ0IGZyb20gdGhlIGV2ZW50IG5hbWVcclxuICAgIC8vICh1bmxlc3MgeW91J3JlIGxpc3RlbmluZyBvbiBgXCJhbGxcImAsIHdoaWNoIHdpbGwgY2F1c2UgeW91ciBjYWxsYmFjayB0b1xyXG4gICAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxyXG4gICAgdHJpZ2dlcjogZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICBpZiAoIXRoaXMuX2V2ZW50cykgcmV0dXJuIHRoaXM7XHJcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgICBpZiAoIWV2ZW50c0FwaSh0aGlzLCAndHJpZ2dlcicsIG5hbWUsIGFyZ3MpKSByZXR1cm4gdGhpcztcclxuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXTtcclxuICAgICAgdmFyIGFsbEV2ZW50cyA9IHRoaXMuX2V2ZW50cy5hbGw7XHJcbiAgICAgIGlmIChldmVudHMpIHRyaWdnZXJFdmVudHMoZXZlbnRzLCBhcmdzKTtcclxuICAgICAgaWYgKGFsbEV2ZW50cykgdHJpZ2dlckV2ZW50cyhhbGxFdmVudHMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXHJcbiAgICAvLyB0byBldmVyeSBvYmplY3QgaXQncyBjdXJyZW50bHkgbGlzdGVuaW5nIHRvLlxyXG4gICAgc3RvcExpc3RlbmluZzogZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xyXG4gICAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbztcclxuICAgICAgaWYgKCFsaXN0ZW5pbmdUbykgcmV0dXJuIHRoaXM7XHJcbiAgICAgIHZhciByZW1vdmUgPSAhbmFtZSAmJiAhY2FsbGJhY2s7XHJcbiAgICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXM7XHJcbiAgICAgIGlmIChvYmopIChsaXN0ZW5pbmdUbyA9IHt9KVtvYmouX2xpc3RlbklkXSA9IG9iajtcclxuICAgICAgZm9yICh2YXIgaWQgaW4gbGlzdGVuaW5nVG8pIHtcclxuICAgICAgICBvYmogPSBsaXN0ZW5pbmdUb1tpZF07XHJcbiAgICAgICAgb2JqLm9mZihuYW1lLCBjYWxsYmFjaywgdGhpcyk7XHJcbiAgICAgICAgaWYgKHJlbW92ZSB8fCBfLmlzRW1wdHkob2JqLl9ldmVudHMpKSBkZWxldGUgdGhpcy5fbGlzdGVuaW5nVG9baWRdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICB9O1xyXG5cclxuICAvLyBSZWd1bGFyIGV4cHJlc3Npb24gdXNlZCB0byBzcGxpdCBldmVudCBzdHJpbmdzLlxyXG4gIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xyXG5cclxuICAvLyBJbXBsZW1lbnQgZmFuY3kgZmVhdHVyZXMgb2YgdGhlIEV2ZW50cyBBUEkgc3VjaCBhcyBtdWx0aXBsZSBldmVudFxyXG4gIC8vIG5hbWVzIGBcImNoYW5nZSBibHVyXCJgIGFuZCBqUXVlcnktc3R5bGUgZXZlbnQgbWFwcyBge2NoYW5nZTogYWN0aW9ufWBcclxuICAvLyBpbiB0ZXJtcyBvZiB0aGUgZXhpc3RpbmcgQVBJLlxyXG4gIHZhciBldmVudHNBcGkgPSBmdW5jdGlvbihvYmosIGFjdGlvbiwgbmFtZSwgcmVzdCkge1xyXG4gICAgaWYgKCFuYW1lKSByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAvLyBIYW5kbGUgZXZlbnQgbWFwcy5cclxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgZm9yICh2YXIga2V5IGluIG5hbWUpIHtcclxuICAgICAgICBvYmpbYWN0aW9uXS5hcHBseShvYmosIFtrZXksIG5hbWVba2V5XV0uY29uY2F0KHJlc3QpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSGFuZGxlIHNwYWNlIHNlcGFyYXRlZCBldmVudCBuYW1lcy5cclxuICAgIGlmIChldmVudFNwbGl0dGVyLnRlc3QobmFtZSkpIHtcclxuICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChldmVudFNwbGl0dGVyKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuYW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBvYmpbYWN0aW9uXS5hcHBseShvYmosIFtuYW1lc1tpXV0uY29uY2F0KHJlc3QpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gQSBkaWZmaWN1bHQtdG8tYmVsaWV2ZSwgYnV0IG9wdGltaXplZCBpbnRlcm5hbCBkaXNwYXRjaCBmdW5jdGlvbiBmb3JcclxuICAvLyB0cmlnZ2VyaW5nIGV2ZW50cy4gVHJpZXMgdG8ga2VlcCB0aGUgdXN1YWwgY2FzZXMgc3BlZWR5IChtb3N0IGludGVybmFsXHJcbiAgLy8gQmFja2JvbmUgZXZlbnRzIGhhdmUgMyBhcmd1bWVudHMpLlxyXG4gIHZhciB0cmlnZ2VyRXZlbnRzID0gZnVuY3Rpb24oZXZlbnRzLCBhcmdzKSB7XHJcbiAgICB2YXIgZXYsIGkgPSAtMSwgbCA9IGV2ZW50cy5sZW5ndGgsIGExID0gYXJnc1swXSwgYTIgPSBhcmdzWzFdLCBhMyA9IGFyZ3NbMl07XHJcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XHJcbiAgICAgIGNhc2UgMDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgpOyByZXR1cm47XHJcbiAgICAgIGNhc2UgMTogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExKTsgcmV0dXJuO1xyXG4gICAgICBjYXNlIDI6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIpOyByZXR1cm47XHJcbiAgICAgIGNhc2UgMzogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suY2FsbChldi5jdHgsIGExLCBhMiwgYTMpOyByZXR1cm47XHJcbiAgICAgIGRlZmF1bHQ6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmFwcGx5KGV2LmN0eCwgYXJncyk7IHJldHVybjtcclxuICAgIH1cclxuICB9O1xyXG5cclxuICB2YXIgbGlzdGVuTWV0aG9kcyA9IHtsaXN0ZW5UbzogJ29uJywgbGlzdGVuVG9PbmNlOiAnb25jZSd9O1xyXG5cclxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gIGFuZCBgb25jZWAuIFRlbGwgKnRoaXMqIG9iamVjdCB0b1xyXG4gIC8vIGxpc3RlbiB0byBhbiBldmVudCBpbiBhbm90aGVyIG9iamVjdCAuLi4ga2VlcGluZyB0cmFjayBvZiB3aGF0IGl0J3NcclxuICAvLyBsaXN0ZW5pbmcgdG8uXHJcbiAgXy5lYWNoKGxpc3Rlbk1ldGhvZHMsIGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBtZXRob2QpIHtcclxuICAgIEV2ZW50c1ttZXRob2RdID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBjYWxsYmFjaykge1xyXG4gICAgICB2YXIgbGlzdGVuaW5nVG8gPSB0aGlzLl9saXN0ZW5pbmdUbyB8fCAodGhpcy5fbGlzdGVuaW5nVG8gPSB7fSk7XHJcbiAgICAgIHZhciBpZCA9IG9iai5fbGlzdGVuSWQgfHwgKG9iai5fbGlzdGVuSWQgPSBfLnVuaXF1ZUlkKCdsJykpO1xyXG4gICAgICBsaXN0ZW5pbmdUb1tpZF0gPSBvYmo7XHJcbiAgICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXM7XHJcbiAgICAgIG9ialtpbXBsZW1lbnRhdGlvbl0obmFtZSwgY2FsbGJhY2ssIHRoaXMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgfSk7XHJcblxyXG4gIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxyXG4gIEV2ZW50cy5iaW5kICAgPSBFdmVudHMub247XHJcbiAgRXZlbnRzLnVuYmluZCA9IEV2ZW50cy5vZmY7XHJcblxyXG4gIC8vIEFsbG93IHRoZSBgQmFja2JvbmVgIG9iamVjdCB0byBzZXJ2ZSBhcyBhIGdsb2JhbCBldmVudCBidXMsIGZvciBmb2xrcyB3aG9cclxuICAvLyB3YW50IGdsb2JhbCBcInB1YnN1YlwiIGluIGEgY29udmVuaWVudCBwbGFjZS5cclxuICBfLmV4dGVuZChCYWNrYm9uZSwgRXZlbnRzKTtcclxuXHJcbiAgLy8gQmFja2JvbmUuTW9kZWxcclxuICAvLyAtLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBCYWNrYm9uZSAqKk1vZGVscyoqIGFyZSB0aGUgYmFzaWMgZGF0YSBvYmplY3QgaW4gdGhlIGZyYW1ld29yayAtLVxyXG4gIC8vIGZyZXF1ZW50bHkgcmVwcmVzZW50aW5nIGEgcm93IGluIGEgdGFibGUgaW4gYSBkYXRhYmFzZSBvbiB5b3VyIHNlcnZlci5cclxuICAvLyBBIGRpc2NyZXRlIGNodW5rIG9mIGRhdGEgYW5kIGEgYnVuY2ggb2YgdXNlZnVsLCByZWxhdGVkIG1ldGhvZHMgZm9yXHJcbiAgLy8gcGVyZm9ybWluZyBjb21wdXRhdGlvbnMgYW5kIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGF0IGRhdGEuXHJcblxyXG4gIC8vIENyZWF0ZSBhIG5ldyBtb2RlbCB3aXRoIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlcy4gQSBjbGllbnQgaWQgKGBjaWRgKVxyXG4gIC8vIGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGFuZCBhc3NpZ25lZCBmb3IgeW91LlxyXG4gIHZhciBNb2RlbCA9IEJhY2tib25lLk1vZGVsID0gZnVuY3Rpb24oYXR0cmlidXRlcywgb3B0aW9ucykge1xyXG4gICAgdmFyIGF0dHJzID0gYXR0cmlidXRlcyB8fCB7fTtcclxuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XHJcbiAgICB0aGlzLmNpZCA9IF8udW5pcXVlSWQoJ2MnKTtcclxuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgaWYgKG9wdGlvbnMuY29sbGVjdGlvbikgdGhpcy5jb2xsZWN0aW9uID0gb3B0aW9ucy5jb2xsZWN0aW9uO1xyXG4gICAgaWYgKG9wdGlvbnMucGFyc2UpIGF0dHJzID0gdGhpcy5wYXJzZShhdHRycywgb3B0aW9ucykgfHwge307XHJcbiAgICBhdHRycyA9IF8uZGVmYXVsdHMoe30sIGF0dHJzLCBfLnJlc3VsdCh0aGlzLCAnZGVmYXVsdHMnKSk7XHJcbiAgICB0aGlzLnNldChhdHRycywgb3B0aW9ucyk7XHJcbiAgICB0aGlzLmNoYW5nZWQgPSB7fTtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH07XHJcblxyXG4gIC8vIEF0dGFjaCBhbGwgaW5oZXJpdGFibGUgbWV0aG9kcyB0byB0aGUgTW9kZWwgcHJvdG90eXBlLlxyXG4gIF8uZXh0ZW5kKE1vZGVsLnByb3RvdHlwZSwgRXZlbnRzLCB7XHJcblxyXG4gICAgLy8gQSBoYXNoIG9mIGF0dHJpYnV0ZXMgd2hvc2UgY3VycmVudCBhbmQgcHJldmlvdXMgdmFsdWUgZGlmZmVyLlxyXG4gICAgY2hhbmdlZDogbnVsbCxcclxuXHJcbiAgICAvLyBUaGUgdmFsdWUgcmV0dXJuZWQgZHVyaW5nIHRoZSBsYXN0IGZhaWxlZCB2YWxpZGF0aW9uLlxyXG4gICAgdmFsaWRhdGlvbkVycm9yOiBudWxsLFxyXG5cclxuICAgIC8vIFRoZSBkZWZhdWx0IG5hbWUgZm9yIHRoZSBKU09OIGBpZGAgYXR0cmlidXRlIGlzIGBcImlkXCJgLiBNb25nb0RCIGFuZFxyXG4gICAgLy8gQ291Y2hEQiB1c2VycyBtYXkgd2FudCB0byBzZXQgdGhpcyB0byBgXCJfaWRcImAuXHJcbiAgICBpZEF0dHJpYnV0ZTogJ2lkJyxcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cclxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxyXG5cclxuICAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG1vZGVsJ3MgYGF0dHJpYnV0ZXNgIG9iamVjdC5cclxuICAgIHRvSlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdCAtLSBidXQgb3ZlcnJpZGUgdGhpcyBpZiB5b3UgbmVlZFxyXG4gICAgLy8gY3VzdG9tIHN5bmNpbmcgc2VtYW50aWNzIGZvciAqdGhpcyogcGFydGljdWxhciBtb2RlbC5cclxuICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHZXQgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cclxuICAgIGdldDogZnVuY3Rpb24oYXR0cikge1xyXG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2F0dHJdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHZXQgdGhlIEhUTUwtZXNjYXBlZCB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUuXHJcbiAgICBlc2NhcGU6IGZ1bmN0aW9uKGF0dHIpIHtcclxuICAgICAgcmV0dXJuIF8uZXNjYXBlKHRoaXMuZ2V0KGF0dHIpKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGF0dHJpYnV0ZSBjb250YWlucyBhIHZhbHVlIHRoYXQgaXMgbm90IG51bGxcclxuICAgIC8vIG9yIHVuZGVmaW5lZC5cclxuICAgIGhhczogZnVuY3Rpb24oYXR0cikge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXQoYXR0cikgIT0gbnVsbDtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gU2V0IGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzIG9uIHRoZSBvYmplY3QsIGZpcmluZyBgXCJjaGFuZ2VcImAuIFRoaXMgaXNcclxuICAgIC8vIHRoZSBjb3JlIHByaW1pdGl2ZSBvcGVyYXRpb24gb2YgYSBtb2RlbCwgdXBkYXRpbmcgdGhlIGRhdGEgYW5kIG5vdGlmeWluZ1xyXG4gICAgLy8gYW55b25lIHdobyBuZWVkcyB0byBrbm93IGFib3V0IHRoZSBjaGFuZ2UgaW4gc3RhdGUuIFRoZSBoZWFydCBvZiB0aGUgYmVhc3QuXHJcbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsLCBvcHRpb25zKSB7XHJcbiAgICAgIHZhciBhdHRyLCBhdHRycywgdW5zZXQsIGNoYW5nZXMsIHNpbGVudCwgY2hhbmdpbmcsIHByZXYsIGN1cnJlbnQ7XHJcbiAgICAgIGlmIChrZXkgPT0gbnVsbCkgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgICAvLyBIYW5kbGUgYm90aCBgXCJrZXlcIiwgdmFsdWVgIGFuZCBge2tleTogdmFsdWV9YCAtc3R5bGUgYXJndW1lbnRzLlxyXG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBhdHRycyA9IGtleTtcclxuICAgICAgICBvcHRpb25zID0gdmFsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIChhdHRycyA9IHt9KVtrZXldID0gdmFsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xyXG5cclxuICAgICAgLy8gUnVuIHZhbGlkYXRpb24uXHJcbiAgICAgIGlmICghdGhpcy5fdmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgICAvLyBFeHRyYWN0IGF0dHJpYnV0ZXMgYW5kIG9wdGlvbnMuXHJcbiAgICAgIHVuc2V0ICAgICAgICAgICA9IG9wdGlvbnMudW5zZXQ7XHJcbiAgICAgIHNpbGVudCAgICAgICAgICA9IG9wdGlvbnMuc2lsZW50O1xyXG4gICAgICBjaGFuZ2VzICAgICAgICAgPSBbXTtcclxuICAgICAgY2hhbmdpbmcgICAgICAgID0gdGhpcy5fY2hhbmdpbmc7XHJcbiAgICAgIHRoaXMuX2NoYW5naW5nICA9IHRydWU7XHJcblxyXG4gICAgICBpZiAoIWNoYW5naW5nKSB7XHJcbiAgICAgICAgdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzID0gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xyXG4gICAgICAgIHRoaXMuY2hhbmdlZCA9IHt9O1xyXG4gICAgICB9XHJcbiAgICAgIGN1cnJlbnQgPSB0aGlzLmF0dHJpYnV0ZXMsIHByZXYgPSB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXM7XHJcblxyXG4gICAgICAvLyBDaGVjayBmb3IgY2hhbmdlcyBvZiBgaWRgLlxyXG4gICAgICBpZiAodGhpcy5pZEF0dHJpYnV0ZSBpbiBhdHRycykgdGhpcy5pZCA9IGF0dHJzW3RoaXMuaWRBdHRyaWJ1dGVdO1xyXG5cclxuICAgICAgLy8gRm9yIGVhY2ggYHNldGAgYXR0cmlidXRlLCB1cGRhdGUgb3IgZGVsZXRlIHRoZSBjdXJyZW50IHZhbHVlLlxyXG4gICAgICBmb3IgKGF0dHIgaW4gYXR0cnMpIHtcclxuICAgICAgICB2YWwgPSBhdHRyc1thdHRyXTtcclxuICAgICAgICBpZiAoIV8uaXNFcXVhbChjdXJyZW50W2F0dHJdLCB2YWwpKSBjaGFuZ2VzLnB1c2goYXR0cik7XHJcbiAgICAgICAgaWYgKCFfLmlzRXF1YWwocHJldlthdHRyXSwgdmFsKSkge1xyXG4gICAgICAgICAgdGhpcy5jaGFuZ2VkW2F0dHJdID0gdmFsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBkZWxldGUgdGhpcy5jaGFuZ2VkW2F0dHJdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1bnNldCA/IGRlbGV0ZSBjdXJyZW50W2F0dHJdIDogY3VycmVudFthdHRyXSA9IHZhbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVHJpZ2dlciBhbGwgcmVsZXZhbnQgYXR0cmlidXRlIGNoYW5nZXMuXHJcbiAgICAgIGlmICghc2lsZW50KSB7XHJcbiAgICAgICAgaWYgKGNoYW5nZXMubGVuZ3RoKSB0aGlzLl9wZW5kaW5nID0gb3B0aW9ucztcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoYW5nZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTonICsgY2hhbmdlc1tpXSwgdGhpcywgY3VycmVudFtjaGFuZ2VzW2ldXSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBZb3UgbWlnaHQgYmUgd29uZGVyaW5nIHdoeSB0aGVyZSdzIGEgYHdoaWxlYCBsb29wIGhlcmUuIENoYW5nZXMgY2FuXHJcbiAgICAgIC8vIGJlIHJlY3Vyc2l2ZWx5IG5lc3RlZCB3aXRoaW4gYFwiY2hhbmdlXCJgIGV2ZW50cy5cclxuICAgICAgaWYgKGNoYW5naW5nKSByZXR1cm4gdGhpcztcclxuICAgICAgaWYgKCFzaWxlbnQpIHtcclxuICAgICAgICB3aGlsZSAodGhpcy5fcGVuZGluZykge1xyXG4gICAgICAgICAgb3B0aW9ucyA9IHRoaXMuX3BlbmRpbmc7XHJcbiAgICAgICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9wZW5kaW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2NoYW5naW5nID0gZmFsc2U7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLiBgdW5zZXRgIGlzIGEgbm9vcFxyXG4gICAgLy8gaWYgdGhlIGF0dHJpYnV0ZSBkb2Vzbid0IGV4aXN0LlxyXG4gICAgdW5zZXQ6IGZ1bmN0aW9uKGF0dHIsIG9wdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHIsIHZvaWQgMCwgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2xlYXIgYWxsIGF0dHJpYnV0ZXMgb24gdGhlIG1vZGVsLCBmaXJpbmcgYFwiY2hhbmdlXCJgLlxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgdmFyIGF0dHJzID0ge307XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmF0dHJpYnV0ZXMpIGF0dHJzW2tleV0gPSB2b2lkIDA7XHJcbiAgICAgIHJldHVybiB0aGlzLnNldChhdHRycywgXy5leHRlbmQoe30sIG9wdGlvbnMsIHt1bnNldDogdHJ1ZX0pKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtb2RlbCBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBgXCJjaGFuZ2VcImAgZXZlbnQuXHJcbiAgICAvLyBJZiB5b3Ugc3BlY2lmeSBhbiBhdHRyaWJ1dGUgbmFtZSwgZGV0ZXJtaW5lIGlmIHRoYXQgYXR0cmlidXRlIGhhcyBjaGFuZ2VkLlxyXG4gICAgaGFzQ2hhbmdlZDogZnVuY3Rpb24oYXR0cikge1xyXG4gICAgICBpZiAoYXR0ciA9PSBudWxsKSByZXR1cm4gIV8uaXNFbXB0eSh0aGlzLmNoYW5nZWQpO1xyXG4gICAgICByZXR1cm4gXy5oYXModGhpcy5jaGFuZ2VkLCBhdHRyKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgYXR0cmlidXRlcyB0aGF0IGhhdmUgY2hhbmdlZCwgb3JcclxuICAgIC8vIGZhbHNlIGlmIHRoZXJlIGFyZSBubyBjaGFuZ2VkIGF0dHJpYnV0ZXMuIFVzZWZ1bCBmb3IgZGV0ZXJtaW5pbmcgd2hhdFxyXG4gICAgLy8gcGFydHMgb2YgYSB2aWV3IG5lZWQgdG8gYmUgdXBkYXRlZCBhbmQvb3Igd2hhdCBhdHRyaWJ1dGVzIG5lZWQgdG8gYmVcclxuICAgIC8vIHBlcnNpc3RlZCB0byB0aGUgc2VydmVyLiBVbnNldCBhdHRyaWJ1dGVzIHdpbGwgYmUgc2V0IHRvIHVuZGVmaW5lZC5cclxuICAgIC8vIFlvdSBjYW4gYWxzbyBwYXNzIGFuIGF0dHJpYnV0ZXMgb2JqZWN0IHRvIGRpZmYgYWdhaW5zdCB0aGUgbW9kZWwsXHJcbiAgICAvLyBkZXRlcm1pbmluZyBpZiB0aGVyZSAqd291bGQgYmUqIGEgY2hhbmdlLlxyXG4gICAgY2hhbmdlZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGRpZmYpIHtcclxuICAgICAgaWYgKCFkaWZmKSByZXR1cm4gdGhpcy5oYXNDaGFuZ2VkKCkgPyBfLmNsb25lKHRoaXMuY2hhbmdlZCkgOiBmYWxzZTtcclxuICAgICAgdmFyIHZhbCwgY2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICB2YXIgb2xkID0gdGhpcy5fY2hhbmdpbmcgPyB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMgOiB0aGlzLmF0dHJpYnV0ZXM7XHJcbiAgICAgIGZvciAodmFyIGF0dHIgaW4gZGlmZikge1xyXG4gICAgICAgIGlmIChfLmlzRXF1YWwob2xkW2F0dHJdLCAodmFsID0gZGlmZlthdHRyXSkpKSBjb250aW51ZTtcclxuICAgICAgICAoY2hhbmdlZCB8fCAoY2hhbmdlZCA9IHt9KSlbYXR0cl0gPSB2YWw7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNoYW5nZWQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEdldCB0aGUgcHJldmlvdXMgdmFsdWUgb2YgYW4gYXR0cmlidXRlLCByZWNvcmRlZCBhdCB0aGUgdGltZSB0aGUgbGFzdFxyXG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50IHdhcyBmaXJlZC5cclxuICAgIHByZXZpb3VzOiBmdW5jdGlvbihhdHRyKSB7XHJcbiAgICAgIGlmIChhdHRyID09IG51bGwgfHwgIXRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcykgcmV0dXJuIG51bGw7XHJcbiAgICAgIHJldHVybiB0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXNbYXR0cl07XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEdldCBhbGwgb2YgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG1vZGVsIGF0IHRoZSB0aW1lIG9mIHRoZSBwcmV2aW91c1xyXG4gICAgLy8gYFwiY2hhbmdlXCJgIGV2ZW50LlxyXG4gICAgcHJldmlvdXNBdHRyaWJ1dGVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRmV0Y2ggdGhlIG1vZGVsIGZyb20gdGhlIHNlcnZlci4gSWYgdGhlIHNlcnZlcidzIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxyXG4gICAgLy8gbW9kZWwgZGlmZmVycyBmcm9tIGl0cyBjdXJyZW50IGF0dHJpYnV0ZXMsIHRoZXkgd2lsbCBiZSBvdmVycmlkZGVuLFxyXG4gICAgLy8gdHJpZ2dlcmluZyBhIGBcImNoYW5nZVwiYCBldmVudC5cclxuICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xyXG4gICAgICBpZiAob3B0aW9ucy5wYXJzZSA9PT0gdm9pZCAwKSBvcHRpb25zLnBhcnNlID0gdHJ1ZTtcclxuICAgICAgdmFyIG1vZGVsID0gdGhpcztcclxuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XHJcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3ApIHtcclxuICAgICAgICBpZiAoIW1vZGVsLnNldChtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKSwgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAoc3VjY2Vzcykgc3VjY2Vzcyhtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XHJcbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcclxuICAgICAgfTtcclxuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICByZXR1cm4gdGhpcy5zeW5jKCdyZWFkJywgdGhpcywgb3B0aW9ucyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcywgYW5kIHN5bmMgdGhlIG1vZGVsIHRvIHRoZSBzZXJ2ZXIuXHJcbiAgICAvLyBJZiB0aGUgc2VydmVyIHJldHVybnMgYW4gYXR0cmlidXRlcyBoYXNoIHRoYXQgZGlmZmVycywgdGhlIG1vZGVsJ3NcclxuICAgIC8vIHN0YXRlIHdpbGwgYmUgYHNldGAgYWdhaW4uXHJcbiAgICBzYXZlOiBmdW5jdGlvbihrZXksIHZhbCwgb3B0aW9ucykge1xyXG4gICAgICB2YXIgYXR0cnMsIG1ldGhvZCwgeGhyLCBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xyXG5cclxuICAgICAgLy8gSGFuZGxlIGJvdGggYFwia2V5XCIsIHZhbHVlYCBhbmQgYHtrZXk6IHZhbHVlfWAgLXN0eWxlIGFyZ3VtZW50cy5cclxuICAgICAgaWYgKGtleSA9PSBudWxsIHx8IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgYXR0cnMgPSBrZXk7XHJcbiAgICAgICAgb3B0aW9ucyA9IHZhbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAoYXR0cnMgPSB7fSlba2V5XSA9IHZhbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHt2YWxpZGF0ZTogdHJ1ZX0sIG9wdGlvbnMpO1xyXG5cclxuICAgICAgLy8gSWYgd2UncmUgbm90IHdhaXRpbmcgYW5kIGF0dHJpYnV0ZXMgZXhpc3QsIHNhdmUgYWN0cyBhc1xyXG4gICAgICAvLyBgc2V0KGF0dHIpLnNhdmUobnVsbCwgb3B0cylgIHdpdGggdmFsaWRhdGlvbi4gT3RoZXJ3aXNlLCBjaGVjayBpZlxyXG4gICAgICAvLyB0aGUgbW9kZWwgd2lsbCBiZSB2YWxpZCB3aGVuIHRoZSBhdHRyaWJ1dGVzLCBpZiBhbnksIGFyZSBzZXQuXHJcbiAgICAgIGlmIChhdHRycyAmJiAhb3B0aW9ucy53YWl0KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNldChhdHRycywgb3B0aW9ucykpIHJldHVybiBmYWxzZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTZXQgdGVtcG9yYXJ5IGF0dHJpYnV0ZXMgaWYgYHt3YWl0OiB0cnVlfWAuXHJcbiAgICAgIGlmIChhdHRycyAmJiBvcHRpb25zLndhaXQpIHtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBfLmV4dGVuZCh7fSwgYXR0cmlidXRlcywgYXR0cnMpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBBZnRlciBhIHN1Y2Nlc3NmdWwgc2VydmVyLXNpZGUgc2F2ZSwgdGhlIGNsaWVudCBpcyAob3B0aW9uYWxseSlcclxuICAgICAgLy8gdXBkYXRlZCB3aXRoIHRoZSBzZXJ2ZXItc2lkZSBzdGF0ZS5cclxuICAgICAgaWYgKG9wdGlvbnMucGFyc2UgPT09IHZvaWQgMCkgb3B0aW9ucy5wYXJzZSA9IHRydWU7XHJcbiAgICAgIHZhciBtb2RlbCA9IHRoaXM7XHJcbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xyXG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XHJcbiAgICAgICAgLy8gRW5zdXJlIGF0dHJpYnV0ZXMgYXJlIHJlc3RvcmVkIGR1cmluZyBzeW5jaHJvbm91cyBzYXZlcy5cclxuICAgICAgICBtb2RlbC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuICAgICAgICB2YXIgc2VydmVyQXR0cnMgPSBtb2RlbC5wYXJzZShyZXNwLCBvcHRpb25zKTtcclxuICAgICAgICBpZiAob3B0aW9ucy53YWl0KSBzZXJ2ZXJBdHRycyA9IF8uZXh0ZW5kKGF0dHJzIHx8IHt9LCBzZXJ2ZXJBdHRycyk7XHJcbiAgICAgICAgaWYgKF8uaXNPYmplY3Qoc2VydmVyQXR0cnMpICYmICFtb2RlbC5zZXQoc2VydmVyQXR0cnMsIG9wdGlvbnMpKSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcclxuICAgICAgICBtb2RlbC50cmlnZ2VyKCdzeW5jJywgbW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xyXG4gICAgICB9O1xyXG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XHJcblxyXG4gICAgICBtZXRob2QgPSB0aGlzLmlzTmV3KCkgPyAnY3JlYXRlJyA6IChvcHRpb25zLnBhdGNoID8gJ3BhdGNoJyA6ICd1cGRhdGUnKTtcclxuICAgICAgaWYgKG1ldGhvZCA9PT0gJ3BhdGNoJykgb3B0aW9ucy5hdHRycyA9IGF0dHJzO1xyXG4gICAgICB4aHIgPSB0aGlzLnN5bmMobWV0aG9kLCB0aGlzLCBvcHRpb25zKTtcclxuXHJcbiAgICAgIC8vIFJlc3RvcmUgYXR0cmlidXRlcy5cclxuICAgICAgaWYgKGF0dHJzICYmIG9wdGlvbnMud2FpdCkgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcclxuXHJcbiAgICAgIHJldHVybiB4aHI7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIERlc3Ryb3kgdGhpcyBtb2RlbCBvbiB0aGUgc2VydmVyIGlmIGl0IHdhcyBhbHJlYWR5IHBlcnNpc3RlZC5cclxuICAgIC8vIE9wdGltaXN0aWNhbGx5IHJlbW92ZXMgdGhlIG1vZGVsIGZyb20gaXRzIGNvbGxlY3Rpb24sIGlmIGl0IGhhcyBvbmUuXHJcbiAgICAvLyBJZiBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCB3YWl0cyBmb3IgdGhlIHNlcnZlciB0byByZXNwb25kIGJlZm9yZSByZW1vdmFsLlxyXG4gICAgZGVzdHJveTogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IF8uY2xvbmUob3B0aW9ucykgOiB7fTtcclxuICAgICAgdmFyIG1vZGVsID0gdGhpcztcclxuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XHJcblxyXG4gICAgICB2YXIgZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ2Rlc3Ryb3knLCBtb2RlbCwgbW9kZWwuY29sbGVjdGlvbiwgb3B0aW9ucyk7XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMud2FpdCB8fCBtb2RlbC5pc05ldygpKSBkZXN0cm95KCk7XHJcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHN1Y2Nlc3MobW9kZWwsIHJlc3AsIG9wdGlvbnMpO1xyXG4gICAgICAgIGlmICghbW9kZWwuaXNOZXcoKSkgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXNwLCBvcHRpb25zKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmlzTmV3KCkpIHtcclxuICAgICAgICBvcHRpb25zLnN1Y2Nlc3MoKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgd3JhcEVycm9yKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgdmFyIHhociA9IHRoaXMuc3luYygnZGVsZXRlJywgdGhpcywgb3B0aW9ucyk7XHJcbiAgICAgIGlmICghb3B0aW9ucy53YWl0KSBkZXN0cm95KCk7XHJcbiAgICAgIHJldHVybiB4aHI7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIERlZmF1bHQgVVJMIGZvciB0aGUgbW9kZWwncyByZXByZXNlbnRhdGlvbiBvbiB0aGUgc2VydmVyIC0tIGlmIHlvdSdyZVxyXG4gICAgLy8gdXNpbmcgQmFja2JvbmUncyByZXN0ZnVsIG1ldGhvZHMsIG92ZXJyaWRlIHRoaXMgdG8gY2hhbmdlIHRoZSBlbmRwb2ludFxyXG4gICAgLy8gdGhhdCB3aWxsIGJlIGNhbGxlZC5cclxuICAgIHVybDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBiYXNlID1cclxuICAgICAgICBfLnJlc3VsdCh0aGlzLCAndXJsUm9vdCcpIHx8XHJcbiAgICAgICAgXy5yZXN1bHQodGhpcy5jb2xsZWN0aW9uLCAndXJsJykgfHxcclxuICAgICAgICB1cmxFcnJvcigpO1xyXG4gICAgICBpZiAodGhpcy5pc05ldygpKSByZXR1cm4gYmFzZTtcclxuICAgICAgcmV0dXJuIGJhc2UucmVwbGFjZSgvKFteXFwvXSkkLywgJyQxLycpICsgZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuaWQpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAqKnBhcnNlKiogY29udmVydHMgYSByZXNwb25zZSBpbnRvIHRoZSBoYXNoIG9mIGF0dHJpYnV0ZXMgdG8gYmUgYHNldGAgb25cclxuICAgIC8vIHRoZSBtb2RlbC4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaXMganVzdCB0byBwYXNzIHRoZSByZXNwb25zZSBhbG9uZy5cclxuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiByZXNwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBDcmVhdGUgYSBuZXcgbW9kZWwgd2l0aCBpZGVudGljYWwgYXR0cmlidXRlcyB0byB0aGlzIG9uZS5cclxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuYXR0cmlidXRlcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEEgbW9kZWwgaXMgbmV3IGlmIGl0IGhhcyBuZXZlciBiZWVuIHNhdmVkIHRvIHRoZSBzZXJ2ZXIsIGFuZCBsYWNrcyBhbiBpZC5cclxuICAgIGlzTmV3OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuICF0aGlzLmhhcyh0aGlzLmlkQXR0cmlidXRlKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIG1vZGVsIGlzIGN1cnJlbnRseSBpbiBhIHZhbGlkIHN0YXRlLlxyXG4gICAgaXNWYWxpZDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdGUoe30sIF8uZXh0ZW5kKG9wdGlvbnMgfHwge30sIHsgdmFsaWRhdGU6IHRydWUgfSkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBSdW4gdmFsaWRhdGlvbiBhZ2FpbnN0IHRoZSBuZXh0IGNvbXBsZXRlIHNldCBvZiBtb2RlbCBhdHRyaWJ1dGVzLFxyXG4gICAgLy8gcmV0dXJuaW5nIGB0cnVlYCBpZiBhbGwgaXMgd2VsbC4gT3RoZXJ3aXNlLCBmaXJlIGFuIGBcImludmFsaWRcImAgZXZlbnQuXHJcbiAgICBfdmFsaWRhdGU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XHJcbiAgICAgIGlmICghb3B0aW9ucy52YWxpZGF0ZSB8fCAhdGhpcy52YWxpZGF0ZSkgcmV0dXJuIHRydWU7XHJcbiAgICAgIGF0dHJzID0gXy5leHRlbmQoe30sIHRoaXMuYXR0cmlidXRlcywgYXR0cnMpO1xyXG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRpb25FcnJvciA9IHRoaXMudmFsaWRhdGUoYXR0cnMsIG9wdGlvbnMpIHx8IG51bGw7XHJcbiAgICAgIGlmICghZXJyb3IpIHJldHVybiB0cnVlO1xyXG4gICAgICB0aGlzLnRyaWdnZXIoJ2ludmFsaWQnLCB0aGlzLCBlcnJvciwgXy5leHRlbmQob3B0aW9ucywge3ZhbGlkYXRpb25FcnJvcjogZXJyb3J9KSk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBNb2RlbC5cclxuICB2YXIgbW9kZWxNZXRob2RzID0gWydrZXlzJywgJ3ZhbHVlcycsICdwYWlycycsICdpbnZlcnQnLCAncGljaycsICdvbWl0J107XHJcblxyXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYE1vZGVsI2F0dHJpYnV0ZXNgLlxyXG4gIF8uZWFjaChtb2RlbE1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xyXG4gICAgTW9kZWwucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcclxuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XHJcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLmF0dHJpYnV0ZXMpO1xyXG4gICAgICByZXR1cm4gX1ttZXRob2RdLmFwcGx5KF8sIGFyZ3MpO1xyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgLy8gQmFja2JvbmUuQ29sbGVjdGlvblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gSWYgbW9kZWxzIHRlbmQgdG8gcmVwcmVzZW50IGEgc2luZ2xlIHJvdyBvZiBkYXRhLCBhIEJhY2tib25lIENvbGxlY3Rpb24gaXNcclxuICAvLyBtb3JlIGFuYWxhZ291cyB0byBhIHRhYmxlIGZ1bGwgb2YgZGF0YSAuLi4gb3IgYSBzbWFsbCBzbGljZSBvciBwYWdlIG9mIHRoYXRcclxuICAvLyB0YWJsZSwgb3IgYSBjb2xsZWN0aW9uIG9mIHJvd3MgdGhhdCBiZWxvbmcgdG9nZXRoZXIgZm9yIGEgcGFydGljdWxhciByZWFzb25cclxuICAvLyAtLSBhbGwgb2YgdGhlIG1lc3NhZ2VzIGluIHRoaXMgcGFydGljdWxhciBmb2xkZXIsIGFsbCBvZiB0aGUgZG9jdW1lbnRzXHJcbiAgLy8gYmVsb25naW5nIHRvIHRoaXMgcGFydGljdWxhciBhdXRob3IsIGFuZCBzbyBvbi4gQ29sbGVjdGlvbnMgbWFpbnRhaW5cclxuICAvLyBpbmRleGVzIG9mIHRoZWlyIG1vZGVscywgYm90aCBpbiBvcmRlciwgYW5kIGZvciBsb29rdXAgYnkgYGlkYC5cclxuXHJcbiAgLy8gQ3JlYXRlIGEgbmV3ICoqQ29sbGVjdGlvbioqLCBwZXJoYXBzIHRvIGNvbnRhaW4gYSBzcGVjaWZpYyB0eXBlIG9mIGBtb2RlbGAuXHJcbiAgLy8gSWYgYSBgY29tcGFyYXRvcmAgaXMgc3BlY2lmaWVkLCB0aGUgQ29sbGVjdGlvbiB3aWxsIG1haW50YWluXHJcbiAgLy8gaXRzIG1vZGVscyBpbiBzb3J0IG9yZGVyLCBhcyB0aGV5J3JlIGFkZGVkIGFuZCByZW1vdmVkLlxyXG4gIHZhciBDb2xsZWN0aW9uID0gQmFja2JvbmUuQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcclxuICAgIGlmIChvcHRpb25zLm1vZGVsKSB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcclxuICAgIGlmIChvcHRpb25zLmNvbXBhcmF0b3IgIT09IHZvaWQgMCkgdGhpcy5jb21wYXJhdG9yID0gb3B0aW9ucy5jb21wYXJhdG9yO1xyXG4gICAgdGhpcy5fcmVzZXQoKTtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgaWYgKG1vZGVscykgdGhpcy5yZXNldChtb2RlbHMsIF8uZXh0ZW5kKHtzaWxlbnQ6IHRydWV9LCBvcHRpb25zKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gRGVmYXVsdCBvcHRpb25zIGZvciBgQ29sbGVjdGlvbiNzZXRgLlxyXG4gIHZhciBzZXRPcHRpb25zID0ge2FkZDogdHJ1ZSwgcmVtb3ZlOiB0cnVlLCBtZXJnZTogdHJ1ZX07XHJcbiAgdmFyIGFkZE9wdGlvbnMgPSB7YWRkOiB0cnVlLCByZW1vdmU6IGZhbHNlfTtcclxuXHJcbiAgLy8gRGVmaW5lIHRoZSBDb2xsZWN0aW9uJ3MgaW5oZXJpdGFibGUgbWV0aG9kcy5cclxuICBfLmV4dGVuZChDb2xsZWN0aW9uLnByb3RvdHlwZSwgRXZlbnRzLCB7XHJcblxyXG4gICAgLy8gVGhlIGRlZmF1bHQgbW9kZWwgZm9yIGEgY29sbGVjdGlvbiBpcyBqdXN0IGEgKipCYWNrYm9uZS5Nb2RlbCoqLlxyXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBtb3N0IGNhc2VzLlxyXG4gICAgbW9kZWw6IE1vZGVsLFxyXG5cclxuICAgIC8vIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxyXG4gICAgLy8gaW5pdGlhbGl6YXRpb24gbG9naWMuXHJcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpe30sXHJcblxyXG4gICAgLy8gVGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBDb2xsZWN0aW9uIGlzIGFuIGFycmF5IG9mIHRoZVxyXG4gICAgLy8gbW9kZWxzJyBhdHRyaWJ1dGVzLlxyXG4gICAgdG9KU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihtb2RlbCl7IHJldHVybiBtb2RlbC50b0pTT04ob3B0aW9ucyk7IH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBQcm94eSBgQmFja2JvbmUuc3luY2AgYnkgZGVmYXVsdC5cclxuICAgIHN5bmM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gQmFja2JvbmUuc3luYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBBZGQgYSBtb2RlbCwgb3IgbGlzdCBvZiBtb2RlbHMgdG8gdGhlIHNldC5cclxuICAgIGFkZDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNldChtb2RlbHMsIF8uZXh0ZW5kKHttZXJnZTogZmFsc2V9LCBvcHRpb25zLCBhZGRPcHRpb25zKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJlbW92ZSBhIG1vZGVsLCBvciBhIGxpc3Qgb2YgbW9kZWxzIGZyb20gdGhlIHNldC5cclxuICAgIHJlbW92ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XHJcbiAgICAgIHZhciBzaW5ndWxhciA9ICFfLmlzQXJyYXkobW9kZWxzKTtcclxuICAgICAgbW9kZWxzID0gc2luZ3VsYXIgPyBbbW9kZWxzXSA6IF8uY2xvbmUobW9kZWxzKTtcclxuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcclxuICAgICAgdmFyIGksIGwsIGluZGV4LCBtb2RlbDtcclxuICAgICAgZm9yIChpID0gMCwgbCA9IG1vZGVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBtb2RlbCA9IG1vZGVsc1tpXSA9IHRoaXMuZ2V0KG1vZGVsc1tpXSk7XHJcbiAgICAgICAgaWYgKCFtb2RlbCkgY29udGludWU7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwuaWRdO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9ieUlkW21vZGVsLmNpZF07XHJcbiAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4T2YobW9kZWwpO1xyXG4gICAgICAgIHRoaXMubW9kZWxzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcclxuICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XHJcbiAgICAgICAgICBvcHRpb25zLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdyZW1vdmUnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlbW92ZVJlZmVyZW5jZShtb2RlbCwgb3B0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNpbmd1bGFyID8gbW9kZWxzWzBdIDogbW9kZWxzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBVcGRhdGUgYSBjb2xsZWN0aW9uIGJ5IGBzZXRgLWluZyBhIG5ldyBsaXN0IG9mIG1vZGVscywgYWRkaW5nIG5ldyBvbmVzLFxyXG4gICAgLy8gcmVtb3ZpbmcgbW9kZWxzIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LCBhbmQgbWVyZ2luZyBtb2RlbHMgdGhhdFxyXG4gICAgLy8gYWxyZWFkeSBleGlzdCBpbiB0aGUgY29sbGVjdGlvbiwgYXMgbmVjZXNzYXJ5LiBTaW1pbGFyIHRvICoqTW9kZWwjc2V0KiosXHJcbiAgICAvLyB0aGUgY29yZSBvcGVyYXRpb24gZm9yIHVwZGF0aW5nIHRoZSBkYXRhIGNvbnRhaW5lZCBieSB0aGUgY29sbGVjdGlvbi5cclxuICAgIHNldDogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XHJcbiAgICAgIG9wdGlvbnMgPSBfLmRlZmF1bHRzKHt9LCBvcHRpb25zLCBzZXRPcHRpb25zKTtcclxuICAgICAgaWYgKG9wdGlvbnMucGFyc2UpIG1vZGVscyA9IHRoaXMucGFyc2UobW9kZWxzLCBvcHRpb25zKTtcclxuICAgICAgdmFyIHNpbmd1bGFyID0gIV8uaXNBcnJheShtb2RlbHMpO1xyXG4gICAgICBtb2RlbHMgPSBzaW5ndWxhciA/IChtb2RlbHMgPyBbbW9kZWxzXSA6IFtdKSA6IF8uY2xvbmUobW9kZWxzKTtcclxuICAgICAgdmFyIGksIGwsIGlkLCBtb2RlbCwgYXR0cnMsIGV4aXN0aW5nLCBzb3J0O1xyXG4gICAgICB2YXIgYXQgPSBvcHRpb25zLmF0O1xyXG4gICAgICB2YXIgdGFyZ2V0TW9kZWwgPSB0aGlzLm1vZGVsO1xyXG4gICAgICB2YXIgc29ydGFibGUgPSB0aGlzLmNvbXBhcmF0b3IgJiYgKGF0ID09IG51bGwpICYmIG9wdGlvbnMuc29ydCAhPT0gZmFsc2U7XHJcbiAgICAgIHZhciBzb3J0QXR0ciA9IF8uaXNTdHJpbmcodGhpcy5jb21wYXJhdG9yKSA/IHRoaXMuY29tcGFyYXRvciA6IG51bGw7XHJcbiAgICAgIHZhciB0b0FkZCA9IFtdLCB0b1JlbW92ZSA9IFtdLCBtb2RlbE1hcCA9IHt9O1xyXG4gICAgICB2YXIgYWRkID0gb3B0aW9ucy5hZGQsIG1lcmdlID0gb3B0aW9ucy5tZXJnZSwgcmVtb3ZlID0gb3B0aW9ucy5yZW1vdmU7XHJcbiAgICAgIHZhciBvcmRlciA9ICFzb3J0YWJsZSAmJiBhZGQgJiYgcmVtb3ZlID8gW10gOiBmYWxzZTtcclxuXHJcbiAgICAgIC8vIFR1cm4gYmFyZSBvYmplY3RzIGludG8gbW9kZWwgcmVmZXJlbmNlcywgYW5kIHByZXZlbnQgaW52YWxpZCBtb2RlbHNcclxuICAgICAgLy8gZnJvbSBiZWluZyBhZGRlZC5cclxuICAgICAgZm9yIChpID0gMCwgbCA9IG1vZGVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBhdHRycyA9IG1vZGVsc1tpXSB8fCB7fTtcclxuICAgICAgICBpZiAoYXR0cnMgaW5zdGFuY2VvZiBNb2RlbCkge1xyXG4gICAgICAgICAgaWQgPSBtb2RlbCA9IGF0dHJzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZCA9IGF0dHJzW3RhcmdldE1vZGVsLnByb3RvdHlwZS5pZEF0dHJpYnV0ZSB8fCAnaWQnXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIGEgZHVwbGljYXRlIGlzIGZvdW5kLCBwcmV2ZW50IGl0IGZyb20gYmVpbmcgYWRkZWQgYW5kXHJcbiAgICAgICAgLy8gb3B0aW9uYWxseSBtZXJnZSBpdCBpbnRvIHRoZSBleGlzdGluZyBtb2RlbC5cclxuICAgICAgICBpZiAoZXhpc3RpbmcgPSB0aGlzLmdldChpZCkpIHtcclxuICAgICAgICAgIGlmIChyZW1vdmUpIG1vZGVsTWFwW2V4aXN0aW5nLmNpZF0gPSB0cnVlO1xyXG4gICAgICAgICAgaWYgKG1lcmdlKSB7XHJcbiAgICAgICAgICAgIGF0dHJzID0gYXR0cnMgPT09IG1vZGVsID8gbW9kZWwuYXR0cmlidXRlcyA6IGF0dHJzO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wYXJzZSkgYXR0cnMgPSBleGlzdGluZy5wYXJzZShhdHRycywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGV4aXN0aW5nLnNldChhdHRycywgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgIGlmIChzb3J0YWJsZSAmJiAhc29ydCAmJiBleGlzdGluZy5oYXNDaGFuZ2VkKHNvcnRBdHRyKSkgc29ydCA9IHRydWU7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBtb2RlbHNbaV0gPSBleGlzdGluZztcclxuXHJcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBhIG5ldywgdmFsaWQgbW9kZWwsIHB1c2ggaXQgdG8gdGhlIGB0b0FkZGAgbGlzdC5cclxuICAgICAgICB9IGVsc2UgaWYgKGFkZCkge1xyXG4gICAgICAgICAgbW9kZWwgPSBtb2RlbHNbaV0gPSB0aGlzLl9wcmVwYXJlTW9kZWwoYXR0cnMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgaWYgKCFtb2RlbCkgY29udGludWU7XHJcbiAgICAgICAgICB0b0FkZC5wdXNoKG1vZGVsKTtcclxuICAgICAgICAgIHRoaXMuX2FkZFJlZmVyZW5jZShtb2RlbCwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEbyBub3QgYWRkIG11bHRpcGxlIG1vZGVscyB3aXRoIHRoZSBzYW1lIGBpZGAuXHJcbiAgICAgICAgbW9kZWwgPSBleGlzdGluZyB8fCBtb2RlbDtcclxuICAgICAgICBpZiAob3JkZXIgJiYgKG1vZGVsLmlzTmV3KCkgfHwgIW1vZGVsTWFwW21vZGVsLmlkXSkpIG9yZGVyLnB1c2gobW9kZWwpO1xyXG4gICAgICAgIG1vZGVsTWFwW21vZGVsLmlkXSA9IHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBub25leGlzdGVudCBtb2RlbHMgaWYgYXBwcm9wcmlhdGUuXHJcbiAgICAgIGlmIChyZW1vdmUpIHtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyArK2kpIHtcclxuICAgICAgICAgIGlmICghbW9kZWxNYXBbKG1vZGVsID0gdGhpcy5tb2RlbHNbaV0pLmNpZF0pIHRvUmVtb3ZlLnB1c2gobW9kZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodG9SZW1vdmUubGVuZ3RoKSB0aGlzLnJlbW92ZSh0b1JlbW92ZSwgb3B0aW9ucyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNlZSBpZiBzb3J0aW5nIGlzIG5lZWRlZCwgdXBkYXRlIGBsZW5ndGhgIGFuZCBzcGxpY2UgaW4gbmV3IG1vZGVscy5cclxuICAgICAgaWYgKHRvQWRkLmxlbmd0aCB8fCAob3JkZXIgJiYgb3JkZXIubGVuZ3RoKSkge1xyXG4gICAgICAgIGlmIChzb3J0YWJsZSkgc29ydCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gdG9BZGQubGVuZ3RoO1xyXG4gICAgICAgIGlmIChhdCAhPSBudWxsKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdG9BZGQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMubW9kZWxzLnNwbGljZShhdCArIGksIDAsIHRvQWRkW2ldKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKG9yZGVyKSB0aGlzLm1vZGVscy5sZW5ndGggPSAwO1xyXG4gICAgICAgICAgdmFyIG9yZGVyZWRNb2RlbHMgPSBvcmRlciB8fCB0b0FkZDtcclxuICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBvcmRlcmVkTW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLm1vZGVscy5wdXNoKG9yZGVyZWRNb2RlbHNbaV0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gU2lsZW50bHkgc29ydCB0aGUgY29sbGVjdGlvbiBpZiBhcHByb3ByaWF0ZS5cclxuICAgICAgaWYgKHNvcnQpIHRoaXMuc29ydCh7c2lsZW50OiB0cnVlfSk7XHJcblxyXG4gICAgICAvLyBVbmxlc3Mgc2lsZW5jZWQsIGl0J3MgdGltZSB0byBmaXJlIGFsbCBhcHByb3ByaWF0ZSBhZGQvc29ydCBldmVudHMuXHJcbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcclxuICAgICAgICBmb3IgKGkgPSAwLCBsID0gdG9BZGQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAobW9kZWwgPSB0b0FkZFtpXSkudHJpZ2dlcignYWRkJywgbW9kZWwsIHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc29ydCB8fCAob3JkZXIgJiYgb3JkZXIubGVuZ3RoKSkgdGhpcy50cmlnZ2VyKCdzb3J0JywgdGhpcywgb3B0aW9ucyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJldHVybiB0aGUgYWRkZWQgKG9yIG1lcmdlZCkgbW9kZWwgKG9yIG1vZGVscykuXHJcbiAgICAgIHJldHVybiBzaW5ndWxhciA/IG1vZGVsc1swXSA6IG1vZGVscztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gV2hlbiB5b3UgaGF2ZSBtb3JlIGl0ZW1zIHRoYW4geW91IHdhbnQgdG8gYWRkIG9yIHJlbW92ZSBpbmRpdmlkdWFsbHksXHJcbiAgICAvLyB5b3UgY2FuIHJlc2V0IHRoZSBlbnRpcmUgc2V0IHdpdGggYSBuZXcgbGlzdCBvZiBtb2RlbHMsIHdpdGhvdXQgZmlyaW5nXHJcbiAgICAvLyBhbnkgZ3JhbnVsYXIgYGFkZGAgb3IgYHJlbW92ZWAgZXZlbnRzLiBGaXJlcyBgcmVzZXRgIHdoZW4gZmluaXNoZWQuXHJcbiAgICAvLyBVc2VmdWwgZm9yIGJ1bGsgb3BlcmF0aW9ucyBhbmQgb3B0aW1pemF0aW9ucy5cclxuICAgIHJlc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcclxuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcclxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLm1vZGVscy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UodGhpcy5tb2RlbHNbaV0sIG9wdGlvbnMpO1xyXG4gICAgICB9XHJcbiAgICAgIG9wdGlvbnMucHJldmlvdXNNb2RlbHMgPSB0aGlzLm1vZGVscztcclxuICAgICAgdGhpcy5fcmVzZXQoKTtcclxuICAgICAgbW9kZWxzID0gdGhpcy5hZGQobW9kZWxzLCBfLmV4dGVuZCh7c2lsZW50OiB0cnVlfSwgb3B0aW9ucykpO1xyXG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB0aGlzLnRyaWdnZXIoJ3Jlc2V0JywgdGhpcywgb3B0aW9ucyk7XHJcbiAgICAgIHJldHVybiBtb2RlbHM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEFkZCBhIG1vZGVsIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXHJcbiAgICBwdXNoOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xyXG4gICAgICByZXR1cm4gdGhpcy5hZGQobW9kZWwsIF8uZXh0ZW5kKHthdDogdGhpcy5sZW5ndGh9LCBvcHRpb25zKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cclxuICAgIHBvcDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICB2YXIgbW9kZWwgPSB0aGlzLmF0KHRoaXMubGVuZ3RoIC0gMSk7XHJcbiAgICAgIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcclxuICAgICAgcmV0dXJuIG1vZGVsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBBZGQgYSBtb2RlbCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb2xsZWN0aW9uLlxyXG4gICAgdW5zaGlmdDogZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYWRkKG1vZGVsLCBfLmV4dGVuZCh7YXQ6IDB9LCBvcHRpb25zKSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFJlbW92ZSBhIG1vZGVsIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgY29sbGVjdGlvbi5cclxuICAgIHNoaWZ0OiBmdW5jdGlvbihvcHRpb25zKSB7XHJcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQoMCk7XHJcbiAgICAgIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcclxuICAgICAgcmV0dXJuIG1vZGVsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTbGljZSBvdXQgYSBzdWItYXJyYXkgb2YgbW9kZWxzIGZyb20gdGhlIGNvbGxlY3Rpb24uXHJcbiAgICBzbGljZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBzbGljZS5hcHBseSh0aGlzLm1vZGVscywgYXJndW1lbnRzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gR2V0IGEgbW9kZWwgZnJvbSB0aGUgc2V0IGJ5IGlkLlxyXG4gICAgZ2V0OiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xyXG4gICAgICByZXR1cm4gdGhpcy5fYnlJZFtvYmpdIHx8IHRoaXMuX2J5SWRbb2JqLmlkXSB8fCB0aGlzLl9ieUlkW29iai5jaWRdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHZXQgdGhlIG1vZGVsIGF0IHRoZSBnaXZlbiBpbmRleC5cclxuICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5tb2RlbHNbaW5kZXhdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBSZXR1cm4gbW9kZWxzIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXMgb2ZcclxuICAgIC8vIGBmaWx0ZXJgLlxyXG4gICAgd2hlcmU6IGZ1bmN0aW9uKGF0dHJzLCBmaXJzdCkge1xyXG4gICAgICBpZiAoXy5pc0VtcHR5KGF0dHJzKSkgcmV0dXJuIGZpcnN0ID8gdm9pZCAwIDogW107XHJcbiAgICAgIHJldHVybiB0aGlzW2ZpcnN0ID8gJ2ZpbmQnIDogJ2ZpbHRlciddKGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGF0dHJzKSB7XHJcbiAgICAgICAgICBpZiAoYXR0cnNba2V5XSAhPT0gbW9kZWwuZ2V0KGtleSkpIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBSZXR1cm4gdGhlIGZpcnN0IG1vZGVsIHdpdGggbWF0Y2hpbmcgYXR0cmlidXRlcy4gVXNlZnVsIGZvciBzaW1wbGUgY2FzZXNcclxuICAgIC8vIG9mIGBmaW5kYC5cclxuICAgIGZpbmRXaGVyZTogZnVuY3Rpb24oYXR0cnMpIHtcclxuICAgICAgcmV0dXJuIHRoaXMud2hlcmUoYXR0cnMsIHRydWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBGb3JjZSB0aGUgY29sbGVjdGlvbiB0byByZS1zb3J0IGl0c2VsZi4gWW91IGRvbid0IG5lZWQgdG8gY2FsbCB0aGlzIHVuZGVyXHJcbiAgICAvLyBub3JtYWwgY2lyY3Vtc3RhbmNlcywgYXMgdGhlIHNldCB3aWxsIG1haW50YWluIHNvcnQgb3JkZXIgYXMgZWFjaCBpdGVtXHJcbiAgICAvLyBpcyBhZGRlZC5cclxuICAgIHNvcnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgaWYgKCF0aGlzLmNvbXBhcmF0b3IpIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNvcnQgYSBzZXQgd2l0aG91dCBhIGNvbXBhcmF0b3InKTtcclxuICAgICAgb3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KTtcclxuXHJcbiAgICAgIC8vIFJ1biBzb3J0IGJhc2VkIG9uIHR5cGUgb2YgYGNvbXBhcmF0b3JgLlxyXG4gICAgICBpZiAoXy5pc1N0cmluZyh0aGlzLmNvbXBhcmF0b3IpIHx8IHRoaXMuY29tcGFyYXRvci5sZW5ndGggPT09IDEpIHtcclxuICAgICAgICB0aGlzLm1vZGVscyA9IHRoaXMuc29ydEJ5KHRoaXMuY29tcGFyYXRvciwgdGhpcyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5tb2RlbHMuc29ydChfLmJpbmQodGhpcy5jb21wYXJhdG9yLCB0aGlzKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHRoaXMudHJpZ2dlcignc29ydCcsIHRoaXMsIG9wdGlvbnMpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gUGx1Y2sgYW4gYXR0cmlidXRlIGZyb20gZWFjaCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbi5cclxuICAgIHBsdWNrOiBmdW5jdGlvbihhdHRyKSB7XHJcbiAgICAgIHJldHVybiBfLmludm9rZSh0aGlzLm1vZGVscywgJ2dldCcsIGF0dHIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBGZXRjaCB0aGUgZGVmYXVsdCBzZXQgb2YgbW9kZWxzIGZvciB0aGlzIGNvbGxlY3Rpb24sIHJlc2V0dGluZyB0aGVcclxuICAgIC8vIGNvbGxlY3Rpb24gd2hlbiB0aGV5IGFycml2ZS4gSWYgYHJlc2V0OiB0cnVlYCBpcyBwYXNzZWQsIHRoZSByZXNwb25zZVxyXG4gICAgLy8gZGF0YSB3aWxsIGJlIHBhc3NlZCB0aHJvdWdoIHRoZSBgcmVzZXRgIG1ldGhvZCBpbnN0ZWFkIG9mIGBzZXRgLlxyXG4gICAgZmV0Y2g6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XHJcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB2b2lkIDApIG9wdGlvbnMucGFyc2UgPSB0cnVlO1xyXG4gICAgICB2YXIgc3VjY2VzcyA9IG9wdGlvbnMuc3VjY2VzcztcclxuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzO1xyXG4gICAgICBvcHRpb25zLnN1Y2Nlc3MgPSBmdW5jdGlvbihyZXNwKSB7XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMucmVzZXQgPyAncmVzZXQnIDogJ3NldCc7XHJcbiAgICAgICAgY29sbGVjdGlvblttZXRob2RdKHJlc3AsIG9wdGlvbnMpO1xyXG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKGNvbGxlY3Rpb24sIHJlc3AsIG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbGxlY3Rpb24udHJpZ2dlcignc3luYycsIGNvbGxlY3Rpb24sIHJlc3AsIG9wdGlvbnMpO1xyXG4gICAgICB9O1xyXG4gICAgICB3cmFwRXJyb3IodGhpcywgb3B0aW9ucyk7XHJcbiAgICAgIHJldHVybiB0aGlzLnN5bmMoJ3JlYWQnLCB0aGlzLCBvcHRpb25zKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIGEgbW9kZWwgaW4gdGhpcyBjb2xsZWN0aW9uLiBBZGQgdGhlIG1vZGVsIHRvIHRoZVxyXG4gICAgLy8gY29sbGVjdGlvbiBpbW1lZGlhdGVseSwgdW5sZXNzIGB3YWl0OiB0cnVlYCBpcyBwYXNzZWQsIGluIHdoaWNoIGNhc2Ugd2VcclxuICAgIC8vIHdhaXQgZm9yIHRoZSBzZXJ2ZXIgdG8gYWdyZWUuXHJcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XHJcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gXy5jbG9uZShvcHRpb25zKSA6IHt9O1xyXG4gICAgICBpZiAoIShtb2RlbCA9IHRoaXMuX3ByZXBhcmVNb2RlbChtb2RlbCwgb3B0aW9ucykpKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICghb3B0aW9ucy53YWl0KSB0aGlzLmFkZChtb2RlbCwgb3B0aW9ucyk7XHJcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcztcclxuICAgICAgdmFyIHN1Y2Nlc3MgPSBvcHRpb25zLnN1Y2Nlc3M7XHJcbiAgICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKG1vZGVsLCByZXNwKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMud2FpdCkgY29sbGVjdGlvbi5hZGQobW9kZWwsIG9wdGlvbnMpO1xyXG4gICAgICAgIGlmIChzdWNjZXNzKSBzdWNjZXNzKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcclxuICAgICAgfTtcclxuICAgICAgbW9kZWwuc2F2ZShudWxsLCBvcHRpb25zKTtcclxuICAgICAgcmV0dXJuIG1vZGVsO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyAqKnBhcnNlKiogY29udmVydHMgYSByZXNwb25zZSBpbnRvIGEgbGlzdCBvZiBtb2RlbHMgdG8gYmUgYWRkZWQgdG8gdGhlXHJcbiAgICAvLyBjb2xsZWN0aW9uLiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgaXQgdGhyb3VnaC5cclxuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBvcHRpb25zKSB7XHJcbiAgICAgIHJldHVybiByZXNwO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBDcmVhdGUgYSBuZXcgY29sbGVjdGlvbiB3aXRoIGFuIGlkZW50aWNhbCBsaXN0IG9mIG1vZGVscyBhcyB0aGlzIG9uZS5cclxuICAgIGNsb25lOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMubW9kZWxzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gUHJpdmF0ZSBtZXRob2QgdG8gcmVzZXQgYWxsIGludGVybmFsIHN0YXRlLiBDYWxsZWQgd2hlbiB0aGUgY29sbGVjdGlvblxyXG4gICAgLy8gaXMgZmlyc3QgaW5pdGlhbGl6ZWQgb3IgcmVzZXQuXHJcbiAgICBfcmVzZXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgICAgIHRoaXMubW9kZWxzID0gW107XHJcbiAgICAgIHRoaXMuX2J5SWQgID0ge307XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFByZXBhcmUgYSBoYXNoIG9mIGF0dHJpYnV0ZXMgKG9yIG90aGVyIG1vZGVsKSB0byBiZSBhZGRlZCB0byB0aGlzXHJcbiAgICAvLyBjb2xsZWN0aW9uLlxyXG4gICAgX3ByZXBhcmVNb2RlbDogZnVuY3Rpb24oYXR0cnMsIG9wdGlvbnMpIHtcclxuICAgICAgaWYgKGF0dHJzIGluc3RhbmNlb2YgTW9kZWwpIHJldHVybiBhdHRycztcclxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XHJcbiAgICAgIG9wdGlvbnMuY29sbGVjdGlvbiA9IHRoaXM7XHJcbiAgICAgIHZhciBtb2RlbCA9IG5ldyB0aGlzLm1vZGVsKGF0dHJzLCBvcHRpb25zKTtcclxuICAgICAgaWYgKCFtb2RlbC52YWxpZGF0aW9uRXJyb3IpIHJldHVybiBtb2RlbDtcclxuICAgICAgdGhpcy50cmlnZ2VyKCdpbnZhbGlkJywgdGhpcywgbW9kZWwudmFsaWRhdGlvbkVycm9yLCBvcHRpb25zKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGEgbW9kZWwncyB0aWVzIHRvIGEgY29sbGVjdGlvbi5cclxuICAgIF9hZGRSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XHJcbiAgICAgIHRoaXMuX2J5SWRbbW9kZWwuY2lkXSA9IG1vZGVsO1xyXG4gICAgICBpZiAobW9kZWwuaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFttb2RlbC5pZF0gPSBtb2RlbDtcclxuICAgICAgaWYgKCFtb2RlbC5jb2xsZWN0aW9uKSBtb2RlbC5jb2xsZWN0aW9uID0gdGhpcztcclxuICAgICAgbW9kZWwub24oJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEludGVybmFsIG1ldGhvZCB0byBzZXZlciBhIG1vZGVsJ3MgdGllcyB0byBhIGNvbGxlY3Rpb24uXHJcbiAgICBfcmVtb3ZlUmVmZXJlbmNlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xyXG4gICAgICBpZiAodGhpcyA9PT0gbW9kZWwuY29sbGVjdGlvbikgZGVsZXRlIG1vZGVsLmNvbGxlY3Rpb247XHJcbiAgICAgIG1vZGVsLm9mZignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gSW50ZXJuYWwgbWV0aG9kIGNhbGxlZCBldmVyeSB0aW1lIGEgbW9kZWwgaW4gdGhlIHNldCBmaXJlcyBhbiBldmVudC5cclxuICAgIC8vIFNldHMgbmVlZCB0byB1cGRhdGUgdGhlaXIgaW5kZXhlcyB3aGVuIG1vZGVscyBjaGFuZ2UgaWRzLiBBbGwgb3RoZXJcclxuICAgIC8vIGV2ZW50cyBzaW1wbHkgcHJveHkgdGhyb3VnaC4gXCJhZGRcIiBhbmQgXCJyZW1vdmVcIiBldmVudHMgdGhhdCBvcmlnaW5hdGVcclxuICAgIC8vIGluIG90aGVyIGNvbGxlY3Rpb25zIGFyZSBpZ25vcmVkLlxyXG4gICAgX29uTW9kZWxFdmVudDogZnVuY3Rpb24oZXZlbnQsIG1vZGVsLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XHJcbiAgICAgIGlmICgoZXZlbnQgPT09ICdhZGQnIHx8IGV2ZW50ID09PSAncmVtb3ZlJykgJiYgY29sbGVjdGlvbiAhPT0gdGhpcykgcmV0dXJuO1xyXG4gICAgICBpZiAoZXZlbnQgPT09ICdkZXN0cm95JykgdGhpcy5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xyXG4gICAgICBpZiAobW9kZWwgJiYgZXZlbnQgPT09ICdjaGFuZ2U6JyArIG1vZGVsLmlkQXR0cmlidXRlKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwucHJldmlvdXMobW9kZWwuaWRBdHRyaWJ1dGUpXTtcclxuICAgICAgICBpZiAobW9kZWwuaWQgIT0gbnVsbCkgdGhpcy5fYnlJZFttb2RlbC5pZF0gPSBtb2RlbDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIC8vIFVuZGVyc2NvcmUgbWV0aG9kcyB0aGF0IHdlIHdhbnQgdG8gaW1wbGVtZW50IG9uIHRoZSBDb2xsZWN0aW9uLlxyXG4gIC8vIDkwJSBvZiB0aGUgY29yZSB1c2VmdWxuZXNzIG9mIEJhY2tib25lIENvbGxlY3Rpb25zIGlzIGFjdHVhbGx5IGltcGxlbWVudGVkXHJcbiAgLy8gcmlnaHQgaGVyZTpcclxuICB2YXIgbWV0aG9kcyA9IFsnZm9yRWFjaCcsICdlYWNoJywgJ21hcCcsICdjb2xsZWN0JywgJ3JlZHVjZScsICdmb2xkbCcsXHJcbiAgICAnaW5qZWN0JywgJ3JlZHVjZVJpZ2h0JywgJ2ZvbGRyJywgJ2ZpbmQnLCAnZGV0ZWN0JywgJ2ZpbHRlcicsICdzZWxlY3QnLFxyXG4gICAgJ3JlamVjdCcsICdldmVyeScsICdhbGwnLCAnc29tZScsICdhbnknLCAnaW5jbHVkZScsICdjb250YWlucycsICdpbnZva2UnLFxyXG4gICAgJ21heCcsICdtaW4nLCAndG9BcnJheScsICdzaXplJywgJ2ZpcnN0JywgJ2hlYWQnLCAndGFrZScsICdpbml0aWFsJywgJ3Jlc3QnLFxyXG4gICAgJ3RhaWwnLCAnZHJvcCcsICdsYXN0JywgJ3dpdGhvdXQnLCAnZGlmZmVyZW5jZScsICdpbmRleE9mJywgJ3NodWZmbGUnLFxyXG4gICAgJ2xhc3RJbmRleE9mJywgJ2lzRW1wdHknLCAnY2hhaW4nLCAnc2FtcGxlJ107XHJcblxyXG4gIC8vIE1peCBpbiBlYWNoIFVuZGVyc2NvcmUgbWV0aG9kIGFzIGEgcHJveHkgdG8gYENvbGxlY3Rpb24jbW9kZWxzYC5cclxuICBfLmVhY2gobWV0aG9kcywgZnVuY3Rpb24obWV0aG9kKSB7XHJcbiAgICBDb2xsZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG4gICAgICBhcmdzLnVuc2hpZnQodGhpcy5tb2RlbHMpO1xyXG4gICAgICByZXR1cm4gX1ttZXRob2RdLmFwcGx5KF8sIGFyZ3MpO1xyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgdGFrZSBhIHByb3BlcnR5IG5hbWUgYXMgYW4gYXJndW1lbnQuXHJcbiAgdmFyIGF0dHJpYnV0ZU1ldGhvZHMgPSBbJ2dyb3VwQnknLCAnY291bnRCeScsICdzb3J0QnknLCAnaW5kZXhCeSddO1xyXG5cclxuICAvLyBVc2UgYXR0cmlidXRlcyBpbnN0ZWFkIG9mIHByb3BlcnRpZXMuXHJcbiAgXy5lYWNoKGF0dHJpYnV0ZU1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xyXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICAgIHZhciBpdGVyYXRvciA9IF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZGVsLmdldCh2YWx1ZSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBfW21ldGhvZF0odGhpcy5tb2RlbHMsIGl0ZXJhdG9yLCBjb250ZXh0KTtcclxuICAgIH07XHJcbiAgfSk7XHJcblxyXG4gIC8vIEJhY2tib25lLlZpZXdcclxuICAvLyAtLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIEJhY2tib25lIFZpZXdzIGFyZSBhbG1vc3QgbW9yZSBjb252ZW50aW9uIHRoYW4gdGhleSBhcmUgYWN0dWFsIGNvZGUuIEEgVmlld1xyXG4gIC8vIGlzIHNpbXBseSBhIEphdmFTY3JpcHQgb2JqZWN0IHRoYXQgcmVwcmVzZW50cyBhIGxvZ2ljYWwgY2h1bmsgb2YgVUkgaW4gdGhlXHJcbiAgLy8gRE9NLiBUaGlzIG1pZ2h0IGJlIGEgc2luZ2xlIGl0ZW0sIGFuIGVudGlyZSBsaXN0LCBhIHNpZGViYXIgb3IgcGFuZWwsIG9yXHJcbiAgLy8gZXZlbiB0aGUgc3Vycm91bmRpbmcgZnJhbWUgd2hpY2ggd3JhcHMgeW91ciB3aG9sZSBhcHAuIERlZmluaW5nIGEgY2h1bmsgb2ZcclxuICAvLyBVSSBhcyBhICoqVmlldyoqIGFsbG93cyB5b3UgdG8gZGVmaW5lIHlvdXIgRE9NIGV2ZW50cyBkZWNsYXJhdGl2ZWx5LCB3aXRob3V0XHJcbiAgLy8gaGF2aW5nIHRvIHdvcnJ5IGFib3V0IHJlbmRlciBvcmRlciAuLi4gYW5kIG1ha2VzIGl0IGVhc3kgZm9yIHRoZSB2aWV3IHRvXHJcbiAgLy8gcmVhY3QgdG8gc3BlY2lmaWMgY2hhbmdlcyBpbiB0aGUgc3RhdGUgb2YgeW91ciBtb2RlbHMuXHJcblxyXG4gIC8vIENyZWF0aW5nIGEgQmFja2JvbmUuVmlldyBjcmVhdGVzIGl0cyBpbml0aWFsIGVsZW1lbnQgb3V0c2lkZSBvZiB0aGUgRE9NLFxyXG4gIC8vIGlmIGFuIGV4aXN0aW5nIGVsZW1lbnQgaXMgbm90IHByb3ZpZGVkLi4uXHJcbiAgdmFyIFZpZXcgPSBCYWNrYm9uZS5WaWV3ID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCd2aWV3Jyk7XHJcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xyXG4gICAgXy5leHRlbmQodGhpcywgXy5waWNrKG9wdGlvbnMsIHZpZXdPcHRpb25zKSk7XHJcbiAgICB0aGlzLl9lbnN1cmVFbGVtZW50KCk7XHJcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcclxuICB9O1xyXG5cclxuICAvLyBDYWNoZWQgcmVnZXggdG8gc3BsaXQga2V5cyBmb3IgYGRlbGVnYXRlYC5cclxuICB2YXIgZGVsZWdhdGVFdmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xyXG5cclxuICAvLyBMaXN0IG9mIHZpZXcgb3B0aW9ucyB0byBiZSBtZXJnZWQgYXMgcHJvcGVydGllcy5cclxuICB2YXIgdmlld09wdGlvbnMgPSBbJ21vZGVsJywgJ2NvbGxlY3Rpb24nLCAnZWwnLCAnaWQnLCAnYXR0cmlidXRlcycsICdjbGFzc05hbWUnLCAndGFnTmFtZScsICdldmVudHMnXTtcclxuXHJcbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLlZpZXcqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxyXG4gIF8uZXh0ZW5kKFZpZXcucHJvdG90eXBlLCBFdmVudHMsIHtcclxuXHJcbiAgICAvLyBUaGUgZGVmYXVsdCBgdGFnTmFtZWAgb2YgYSBWaWV3J3MgZWxlbWVudCBpcyBgXCJkaXZcImAuXHJcbiAgICB0YWdOYW1lOiAnZGl2JyxcclxuXHJcbiAgICAvLyBqUXVlcnkgZGVsZWdhdGUgZm9yIGVsZW1lbnQgbG9va3VwLCBzY29wZWQgdG8gRE9NIGVsZW1lbnRzIHdpdGhpbiB0aGVcclxuICAgIC8vIGN1cnJlbnQgdmlldy4gVGhpcyBzaG91bGQgYmUgcHJlZmVycmVkIHRvIGdsb2JhbCBsb29rdXBzIHdoZXJlIHBvc3NpYmxlLlxyXG4gICAgJDogZnVuY3Rpb24oc2VsZWN0b3IpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuJGVsLmZpbmQoc2VsZWN0b3IpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cclxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxyXG5cclxuICAgIC8vICoqcmVuZGVyKiogaXMgdGhlIGNvcmUgZnVuY3Rpb24gdGhhdCB5b3VyIHZpZXcgc2hvdWxkIG92ZXJyaWRlLCBpbiBvcmRlclxyXG4gICAgLy8gdG8gcG9wdWxhdGUgaXRzIGVsZW1lbnQgKGB0aGlzLmVsYCksIHdpdGggdGhlIGFwcHJvcHJpYXRlIEhUTUwuIFRoZVxyXG4gICAgLy8gY29udmVudGlvbiBpcyBmb3IgKipyZW5kZXIqKiB0byBhbHdheXMgcmV0dXJuIGB0aGlzYC5cclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBSZW1vdmUgdGhpcyB2aWV3IGJ5IHRha2luZyB0aGUgZWxlbWVudCBvdXQgb2YgdGhlIERPTSwgYW5kIHJlbW92aW5nIGFueVxyXG4gICAgLy8gYXBwbGljYWJsZSBCYWNrYm9uZS5FdmVudHMgbGlzdGVuZXJzLlxyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy4kZWwucmVtb3ZlKCk7XHJcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZygpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2hhbmdlIHRoZSB2aWV3J3MgZWxlbWVudCAoYHRoaXMuZWxgIHByb3BlcnR5KSwgaW5jbHVkaW5nIGV2ZW50XHJcbiAgICAvLyByZS1kZWxlZ2F0aW9uLlxyXG4gICAgc2V0RWxlbWVudDogZnVuY3Rpb24oZWxlbWVudCwgZGVsZWdhdGUpIHtcclxuICAgICAgaWYgKHRoaXMuJGVsKSB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKTtcclxuICAgICAgdGhpcy4kZWwgPSBlbGVtZW50IGluc3RhbmNlb2YgQmFja2JvbmUuJCA/IGVsZW1lbnQgOiBCYWNrYm9uZS4kKGVsZW1lbnQpO1xyXG4gICAgICB0aGlzLmVsID0gdGhpcy4kZWxbMF07XHJcbiAgICAgIGlmIChkZWxlZ2F0ZSAhPT0gZmFsc2UpIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFNldCBjYWxsYmFja3MsIHdoZXJlIGB0aGlzLmV2ZW50c2AgaXMgYSBoYXNoIG9mXHJcbiAgICAvL1xyXG4gICAgLy8gKntcImV2ZW50IHNlbGVjdG9yXCI6IFwiY2FsbGJhY2tcIn0qXHJcbiAgICAvL1xyXG4gICAgLy8gICAgIHtcclxuICAgIC8vICAgICAgICdtb3VzZWRvd24gLnRpdGxlJzogICdlZGl0JyxcclxuICAgIC8vICAgICAgICdjbGljayAuYnV0dG9uJzogICAgICdzYXZlJyxcclxuICAgIC8vICAgICAgICdjbGljayAub3Blbic6ICAgICAgIGZ1bmN0aW9uKGUpIHsgLi4uIH1cclxuICAgIC8vICAgICB9XHJcbiAgICAvL1xyXG4gICAgLy8gcGFpcnMuIENhbGxiYWNrcyB3aWxsIGJlIGJvdW5kIHRvIHRoZSB2aWV3LCB3aXRoIGB0aGlzYCBzZXQgcHJvcGVybHkuXHJcbiAgICAvLyBVc2VzIGV2ZW50IGRlbGVnYXRpb24gZm9yIGVmZmljaWVuY3kuXHJcbiAgICAvLyBPbWl0dGluZyB0aGUgc2VsZWN0b3IgYmluZHMgdGhlIGV2ZW50IHRvIGB0aGlzLmVsYC5cclxuICAgIC8vIFRoaXMgb25seSB3b3JrcyBmb3IgZGVsZWdhdGUtYWJsZSBldmVudHM6IG5vdCBgZm9jdXNgLCBgYmx1cmAsIGFuZFxyXG4gICAgLy8gbm90IGBjaGFuZ2VgLCBgc3VibWl0YCwgYW5kIGByZXNldGAgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXHJcbiAgICBkZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24oZXZlbnRzKSB7XHJcbiAgICAgIGlmICghKGV2ZW50cyB8fCAoZXZlbnRzID0gXy5yZXN1bHQodGhpcywgJ2V2ZW50cycpKSkpIHJldHVybiB0aGlzO1xyXG4gICAgICB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKTtcclxuICAgICAgZm9yICh2YXIga2V5IGluIGV2ZW50cykge1xyXG4gICAgICAgIHZhciBtZXRob2QgPSBldmVudHNba2V5XTtcclxuICAgICAgICBpZiAoIV8uaXNGdW5jdGlvbihtZXRob2QpKSBtZXRob2QgPSB0aGlzW2V2ZW50c1trZXldXTtcclxuICAgICAgICBpZiAoIW1ldGhvZCkgY29udGludWU7XHJcblxyXG4gICAgICAgIHZhciBtYXRjaCA9IGtleS5tYXRjaChkZWxlZ2F0ZUV2ZW50U3BsaXR0ZXIpO1xyXG4gICAgICAgIHZhciBldmVudE5hbWUgPSBtYXRjaFsxXSwgc2VsZWN0b3IgPSBtYXRjaFsyXTtcclxuICAgICAgICBtZXRob2QgPSBfLmJpbmQobWV0aG9kLCB0aGlzKTtcclxuICAgICAgICBldmVudE5hbWUgKz0gJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZDtcclxuICAgICAgICBpZiAoc2VsZWN0b3IgPT09ICcnKSB7XHJcbiAgICAgICAgICB0aGlzLiRlbC5vbihldmVudE5hbWUsIG1ldGhvZCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHRoaXMuJGVsLm9uKGV2ZW50TmFtZSwgc2VsZWN0b3IsIG1ldGhvZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBDbGVhcnMgYWxsIGNhbGxiYWNrcyBwcmV2aW91c2x5IGJvdW5kIHRvIHRoZSB2aWV3IHdpdGggYGRlbGVnYXRlRXZlbnRzYC5cclxuICAgIC8vIFlvdSB1c3VhbGx5IGRvbid0IG5lZWQgdG8gdXNlIHRoaXMsIGJ1dCBtYXkgd2lzaCB0byBpZiB5b3UgaGF2ZSBtdWx0aXBsZVxyXG4gICAgLy8gQmFja2JvbmUgdmlld3MgYXR0YWNoZWQgdG8gdGhlIHNhbWUgRE9NIGVsZW1lbnQuXHJcbiAgICB1bmRlbGVnYXRlRXZlbnRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy4kZWwub2ZmKCcuZGVsZWdhdGVFdmVudHMnICsgdGhpcy5jaWQpO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIFZpZXcgaGFzIGEgRE9NIGVsZW1lbnQgdG8gcmVuZGVyIGludG8uXHJcbiAgICAvLyBJZiBgdGhpcy5lbGAgaXMgYSBzdHJpbmcsIHBhc3MgaXQgdGhyb3VnaCBgJCgpYCwgdGFrZSB0aGUgZmlyc3RcclxuICAgIC8vIG1hdGNoaW5nIGVsZW1lbnQsIGFuZCByZS1hc3NpZ24gaXQgdG8gYGVsYC4gT3RoZXJ3aXNlLCBjcmVhdGVcclxuICAgIC8vIGFuIGVsZW1lbnQgZnJvbSB0aGUgYGlkYCwgYGNsYXNzTmFtZWAgYW5kIGB0YWdOYW1lYCBwcm9wZXJ0aWVzLlxyXG4gICAgX2Vuc3VyZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoIXRoaXMuZWwpIHtcclxuICAgICAgICB2YXIgYXR0cnMgPSBfLmV4dGVuZCh7fSwgXy5yZXN1bHQodGhpcywgJ2F0dHJpYnV0ZXMnKSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaWQpIGF0dHJzLmlkID0gXy5yZXN1bHQodGhpcywgJ2lkJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NOYW1lKSBhdHRyc1snY2xhc3MnXSA9IF8ucmVzdWx0KHRoaXMsICdjbGFzc05hbWUnKTtcclxuICAgICAgICB2YXIgJGVsID0gQmFja2JvbmUuJCgnPCcgKyBfLnJlc3VsdCh0aGlzLCAndGFnTmFtZScpICsgJz4nKS5hdHRyKGF0dHJzKTtcclxuICAgICAgICB0aGlzLnNldEVsZW1lbnQoJGVsLCBmYWxzZSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50KF8ucmVzdWx0KHRoaXMsICdlbCcpLCBmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIC8vIEJhY2tib25lLnN5bmNcclxuICAvLyAtLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIE92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gY2hhbmdlIHRoZSBtYW5uZXIgaW4gd2hpY2ggQmFja2JvbmUgcGVyc2lzdHNcclxuICAvLyBtb2RlbHMgdG8gdGhlIHNlcnZlci4gWW91IHdpbGwgYmUgcGFzc2VkIHRoZSB0eXBlIG9mIHJlcXVlc3QsIGFuZCB0aGVcclxuICAvLyBtb2RlbCBpbiBxdWVzdGlvbi4gQnkgZGVmYXVsdCwgbWFrZXMgYSBSRVNUZnVsIEFqYXggcmVxdWVzdFxyXG4gIC8vIHRvIHRoZSBtb2RlbCdzIGB1cmwoKWAuIFNvbWUgcG9zc2libGUgY3VzdG9taXphdGlvbnMgY291bGQgYmU6XHJcbiAgLy9cclxuICAvLyAqIFVzZSBgc2V0VGltZW91dGAgdG8gYmF0Y2ggcmFwaWQtZmlyZSB1cGRhdGVzIGludG8gYSBzaW5nbGUgcmVxdWVzdC5cclxuICAvLyAqIFNlbmQgdXAgdGhlIG1vZGVscyBhcyBYTUwgaW5zdGVhZCBvZiBKU09OLlxyXG4gIC8vICogUGVyc2lzdCBtb2RlbHMgdmlhIFdlYlNvY2tldHMgaW5zdGVhZCBvZiBBamF4LlxyXG4gIC8vXHJcbiAgLy8gVHVybiBvbiBgQmFja2JvbmUuZW11bGF0ZUhUVFBgIGluIG9yZGVyIHRvIHNlbmQgYFBVVGAgYW5kIGBERUxFVEVgIHJlcXVlc3RzXHJcbiAgLy8gYXMgYFBPU1RgLCB3aXRoIGEgYF9tZXRob2RgIHBhcmFtZXRlciBjb250YWluaW5nIHRoZSB0cnVlIEhUVFAgbWV0aG9kLFxyXG4gIC8vIGFzIHdlbGwgYXMgYWxsIHJlcXVlc3RzIHdpdGggdGhlIGJvZHkgYXMgYGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZGBcclxuICAvLyBpbnN0ZWFkIG9mIGBhcHBsaWNhdGlvbi9qc29uYCB3aXRoIHRoZSBtb2RlbCBpbiBhIHBhcmFtIG5hbWVkIGBtb2RlbGAuXHJcbiAgLy8gVXNlZnVsIHdoZW4gaW50ZXJmYWNpbmcgd2l0aCBzZXJ2ZXItc2lkZSBsYW5ndWFnZXMgbGlrZSAqKlBIUCoqIHRoYXQgbWFrZVxyXG4gIC8vIGl0IGRpZmZpY3VsdCB0byByZWFkIHRoZSBib2R5IG9mIGBQVVRgIHJlcXVlc3RzLlxyXG4gIEJhY2tib25lLnN5bmMgPSBmdW5jdGlvbihtZXRob2QsIG1vZGVsLCBvcHRpb25zKSB7XHJcbiAgICB2YXIgdHlwZSA9IG1ldGhvZE1hcFttZXRob2RdO1xyXG5cclxuICAgIC8vIERlZmF1bHQgb3B0aW9ucywgdW5sZXNzIHNwZWNpZmllZC5cclxuICAgIF8uZGVmYXVsdHMob3B0aW9ucyB8fCAob3B0aW9ucyA9IHt9KSwge1xyXG4gICAgICBlbXVsYXRlSFRUUDogQmFja2JvbmUuZW11bGF0ZUhUVFAsXHJcbiAgICAgIGVtdWxhdGVKU09OOiBCYWNrYm9uZS5lbXVsYXRlSlNPTlxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRGVmYXVsdCBKU09OLXJlcXVlc3Qgb3B0aW9ucy5cclxuICAgIHZhciBwYXJhbXMgPSB7dHlwZTogdHlwZSwgZGF0YVR5cGU6ICdqc29uJ307XHJcblxyXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgaGF2ZSBhIFVSTC5cclxuICAgIGlmICghb3B0aW9ucy51cmwpIHtcclxuICAgICAgcGFyYW1zLnVybCA9IF8ucmVzdWx0KG1vZGVsLCAndXJsJykgfHwgdXJsRXJyb3IoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFbnN1cmUgdGhhdCB3ZSBoYXZlIHRoZSBhcHByb3ByaWF0ZSByZXF1ZXN0IGRhdGEuXHJcbiAgICBpZiAob3B0aW9ucy5kYXRhID09IG51bGwgJiYgbW9kZWwgJiYgKG1ldGhvZCA9PT0gJ2NyZWF0ZScgfHwgbWV0aG9kID09PSAndXBkYXRlJyB8fCBtZXRob2QgPT09ICdwYXRjaCcpKSB7XHJcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi9qc29uJztcclxuICAgICAgcGFyYW1zLmRhdGEgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmF0dHJzIHx8IG1vZGVsLnRvSlNPTihvcHRpb25zKSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRm9yIG9sZGVyIHNlcnZlcnMsIGVtdWxhdGUgSlNPTiBieSBlbmNvZGluZyB0aGUgcmVxdWVzdCBpbnRvIGFuIEhUTUwtZm9ybS5cclxuICAgIGlmIChvcHRpb25zLmVtdWxhdGVKU09OKSB7XHJcbiAgICAgIHBhcmFtcy5jb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xyXG4gICAgICBwYXJhbXMuZGF0YSA9IHBhcmFtcy5kYXRhID8ge21vZGVsOiBwYXJhbXMuZGF0YX0gOiB7fTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGb3Igb2xkZXIgc2VydmVycywgZW11bGF0ZSBIVFRQIGJ5IG1pbWlja2luZyB0aGUgSFRUUCBtZXRob2Qgd2l0aCBgX21ldGhvZGBcclxuICAgIC8vIEFuZCBhbiBgWC1IVFRQLU1ldGhvZC1PdmVycmlkZWAgaGVhZGVyLlxyXG4gICAgaWYgKG9wdGlvbnMuZW11bGF0ZUhUVFAgJiYgKHR5cGUgPT09ICdQVVQnIHx8IHR5cGUgPT09ICdERUxFVEUnIHx8IHR5cGUgPT09ICdQQVRDSCcpKSB7XHJcbiAgICAgIHBhcmFtcy50eXBlID0gJ1BPU1QnO1xyXG4gICAgICBpZiAob3B0aW9ucy5lbXVsYXRlSlNPTikgcGFyYW1zLmRhdGEuX21ldGhvZCA9IHR5cGU7XHJcbiAgICAgIHZhciBiZWZvcmVTZW5kID0gb3B0aW9ucy5iZWZvcmVTZW5kO1xyXG4gICAgICBvcHRpb25zLmJlZm9yZVNlbmQgPSBmdW5jdGlvbih4aHIpIHtcclxuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignWC1IVFRQLU1ldGhvZC1PdmVycmlkZScsIHR5cGUpO1xyXG4gICAgICAgIGlmIChiZWZvcmVTZW5kKSByZXR1cm4gYmVmb3JlU2VuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERvbid0IHByb2Nlc3MgZGF0YSBvbiBhIG5vbi1HRVQgcmVxdWVzdC5cclxuICAgIGlmIChwYXJhbXMudHlwZSAhPT0gJ0dFVCcgJiYgIW9wdGlvbnMuZW11bGF0ZUpTT04pIHtcclxuICAgICAgcGFyYW1zLnByb2Nlc3NEYXRhID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgd2UncmUgc2VuZGluZyBhIGBQQVRDSGAgcmVxdWVzdCwgYW5kIHdlJ3JlIGluIGFuIG9sZCBJbnRlcm5ldCBFeHBsb3JlclxyXG4gICAgLy8gdGhhdCBzdGlsbCBoYXMgQWN0aXZlWCBlbmFibGVkIGJ5IGRlZmF1bHQsIG92ZXJyaWRlIGpRdWVyeSB0byB1c2UgdGhhdFxyXG4gICAgLy8gZm9yIFhIUiBpbnN0ZWFkLiBSZW1vdmUgdGhpcyBsaW5lIHdoZW4galF1ZXJ5IHN1cHBvcnRzIGBQQVRDSGAgb24gSUU4LlxyXG4gICAgaWYgKHBhcmFtcy50eXBlID09PSAnUEFUQ0gnICYmIG5vWGhyUGF0Y2gpIHtcclxuICAgICAgcGFyYW1zLnhociA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpO1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2UgdGhlIHJlcXVlc3QsIGFsbG93aW5nIHRoZSB1c2VyIHRvIG92ZXJyaWRlIGFueSBBamF4IG9wdGlvbnMuXHJcbiAgICB2YXIgeGhyID0gb3B0aW9ucy54aHIgPSBCYWNrYm9uZS5hamF4KF8uZXh0ZW5kKHBhcmFtcywgb3B0aW9ucykpO1xyXG4gICAgbW9kZWwudHJpZ2dlcigncmVxdWVzdCcsIG1vZGVsLCB4aHIsIG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIHhocjtcclxuICB9O1xyXG5cclxuICB2YXIgbm9YaHJQYXRjaCA9XHJcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5BY3RpdmVYT2JqZWN0ICYmXHJcbiAgICAgICEod2luZG93LlhNTEh0dHBSZXF1ZXN0ICYmIChuZXcgWE1MSHR0cFJlcXVlc3QpLmRpc3BhdGNoRXZlbnQpO1xyXG5cclxuICAvLyBNYXAgZnJvbSBDUlVEIHRvIEhUVFAgZm9yIG91ciBkZWZhdWx0IGBCYWNrYm9uZS5zeW5jYCBpbXBsZW1lbnRhdGlvbi5cclxuICB2YXIgbWV0aG9kTWFwID0ge1xyXG4gICAgJ2NyZWF0ZSc6ICdQT1NUJyxcclxuICAgICd1cGRhdGUnOiAnUFVUJyxcclxuICAgICdwYXRjaCc6ICAnUEFUQ0gnLFxyXG4gICAgJ2RlbGV0ZSc6ICdERUxFVEUnLFxyXG4gICAgJ3JlYWQnOiAgICdHRVQnXHJcbiAgfTtcclxuXHJcbiAgLy8gU2V0IHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIGBCYWNrYm9uZS5hamF4YCB0byBwcm94eSB0aHJvdWdoIHRvIGAkYC5cclxuICAvLyBPdmVycmlkZSB0aGlzIGlmIHlvdSdkIGxpa2UgdG8gdXNlIGEgZGlmZmVyZW50IGxpYnJhcnkuXHJcbiAgQmFja2JvbmUuYWpheCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIEJhY2tib25lLiQuYWpheC5hcHBseShCYWNrYm9uZS4kLCBhcmd1bWVudHMpO1xyXG4gIH07XHJcblxyXG4gIC8vIEJhY2tib25lLlJvdXRlclxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBSb3V0ZXJzIG1hcCBmYXV4LVVSTHMgdG8gYWN0aW9ucywgYW5kIGZpcmUgZXZlbnRzIHdoZW4gcm91dGVzIGFyZVxyXG4gIC8vIG1hdGNoZWQuIENyZWF0aW5nIGEgbmV3IG9uZSBzZXRzIGl0cyBgcm91dGVzYCBoYXNoLCBpZiBub3Qgc2V0IHN0YXRpY2FsbHkuXHJcbiAgdmFyIFJvdXRlciA9IEJhY2tib25lLlJvdXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XHJcbiAgICBpZiAob3B0aW9ucy5yb3V0ZXMpIHRoaXMucm91dGVzID0gb3B0aW9ucy5yb3V0ZXM7XHJcbiAgICB0aGlzLl9iaW5kUm91dGVzKCk7XHJcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9O1xyXG5cclxuICAvLyBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3IgbWF0Y2hpbmcgbmFtZWQgcGFyYW0gcGFydHMgYW5kIHNwbGF0dGVkXHJcbiAgLy8gcGFydHMgb2Ygcm91dGUgc3RyaW5ncy5cclxuICB2YXIgb3B0aW9uYWxQYXJhbSA9IC9cXCgoLio/KVxcKS9nO1xyXG4gIHZhciBuYW1lZFBhcmFtICAgID0gLyhcXChcXD8pPzpcXHcrL2c7XHJcbiAgdmFyIHNwbGF0UGFyYW0gICAgPSAvXFwqXFx3Ky9nO1xyXG4gIHZhciBlc2NhcGVSZWdFeHAgID0gL1tcXC17fVxcW1xcXSs/LixcXFxcXFxeJHwjXFxzXS9nO1xyXG5cclxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQmFja2JvbmUuUm91dGVyKiogcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cclxuICBfLmV4dGVuZChSb3V0ZXIucHJvdG90eXBlLCBFdmVudHMsIHtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGlzIGFuIGVtcHR5IGZ1bmN0aW9uIGJ5IGRlZmF1bHQuIE92ZXJyaWRlIGl0IHdpdGggeW91ciBvd25cclxuICAgIC8vIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxyXG5cclxuICAgIC8vIE1hbnVhbGx5IGJpbmQgYSBzaW5nbGUgbmFtZWQgcm91dGUgdG8gYSBjYWxsYmFjay4gRm9yIGV4YW1wbGU6XHJcbiAgICAvL1xyXG4gICAgLy8gICAgIHRoaXMucm91dGUoJ3NlYXJjaC86cXVlcnkvcDpudW0nLCAnc2VhcmNoJywgZnVuY3Rpb24ocXVlcnksIG51bSkge1xyXG4gICAgLy8gICAgICAgLi4uXHJcbiAgICAvLyAgICAgfSk7XHJcbiAgICAvL1xyXG4gICAgcm91dGU6IGZ1bmN0aW9uKHJvdXRlLCBuYW1lLCBjYWxsYmFjaykge1xyXG4gICAgICBpZiAoIV8uaXNSZWdFeHAocm91dGUpKSByb3V0ZSA9IHRoaXMuX3JvdXRlVG9SZWdFeHAocm91dGUpO1xyXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG5hbWUpKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBuYW1lO1xyXG4gICAgICAgIG5hbWUgPSAnJztcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWNhbGxiYWNrKSBjYWxsYmFjayA9IHRoaXNbbmFtZV07XHJcbiAgICAgIHZhciByb3V0ZXIgPSB0aGlzO1xyXG4gICAgICBCYWNrYm9uZS5oaXN0b3J5LnJvdXRlKHJvdXRlLCBmdW5jdGlvbihmcmFnbWVudCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gcm91dGVyLl9leHRyYWN0UGFyYW1ldGVycyhyb3V0ZSwgZnJhZ21lbnQpO1xyXG4gICAgICAgIHJvdXRlci5leGVjdXRlKGNhbGxiYWNrLCBhcmdzKTtcclxuICAgICAgICByb3V0ZXIudHJpZ2dlci5hcHBseShyb3V0ZXIsIFsncm91dGU6JyArIG5hbWVdLmNvbmNhdChhcmdzKSk7XHJcbiAgICAgICAgcm91dGVyLnRyaWdnZXIoJ3JvdXRlJywgbmFtZSwgYXJncyk7XHJcbiAgICAgICAgQmFja2JvbmUuaGlzdG9yeS50cmlnZ2VyKCdyb3V0ZScsIHJvdXRlciwgbmFtZSwgYXJncyk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRXhlY3V0ZSBhIHJvdXRlIGhhbmRsZXIgd2l0aCB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy4gIFRoaXMgaXMgYW5cclxuICAgIC8vIGV4Y2VsbGVudCBwbGFjZSB0byBkbyBwcmUtcm91dGUgc2V0dXAgb3IgcG9zdC1yb3V0ZSBjbGVhbnVwLlxyXG4gICAgZXhlY3V0ZTogZnVuY3Rpb24oY2FsbGJhY2ssIGFyZ3MpIHtcclxuICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gU2ltcGxlIHByb3h5IHRvIGBCYWNrYm9uZS5oaXN0b3J5YCB0byBzYXZlIGEgZnJhZ21lbnQgaW50byB0aGUgaGlzdG9yeS5cclxuICAgIG5hdmlnYXRlOiBmdW5jdGlvbihmcmFnbWVudCwgb3B0aW9ucykge1xyXG4gICAgICBCYWNrYm9uZS5oaXN0b3J5Lm5hdmlnYXRlKGZyYWdtZW50LCBvcHRpb25zKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEJpbmQgYWxsIGRlZmluZWQgcm91dGVzIHRvIGBCYWNrYm9uZS5oaXN0b3J5YC4gV2UgaGF2ZSB0byByZXZlcnNlIHRoZVxyXG4gICAgLy8gb3JkZXIgb2YgdGhlIHJvdXRlcyBoZXJlIHRvIHN1cHBvcnQgYmVoYXZpb3Igd2hlcmUgdGhlIG1vc3QgZ2VuZXJhbFxyXG4gICAgLy8gcm91dGVzIGNhbiBiZSBkZWZpbmVkIGF0IHRoZSBib3R0b20gb2YgdGhlIHJvdXRlIG1hcC5cclxuICAgIF9iaW5kUm91dGVzOiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCF0aGlzLnJvdXRlcykgcmV0dXJuO1xyXG4gICAgICB0aGlzLnJvdXRlcyA9IF8ucmVzdWx0KHRoaXMsICdyb3V0ZXMnKTtcclxuICAgICAgdmFyIHJvdXRlLCByb3V0ZXMgPSBfLmtleXModGhpcy5yb3V0ZXMpO1xyXG4gICAgICB3aGlsZSAoKHJvdXRlID0gcm91dGVzLnBvcCgpKSAhPSBudWxsKSB7XHJcbiAgICAgICAgdGhpcy5yb3V0ZShyb3V0ZSwgdGhpcy5yb3V0ZXNbcm91dGVdKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBDb252ZXJ0IGEgcm91dGUgc3RyaW5nIGludG8gYSByZWd1bGFyIGV4cHJlc3Npb24sIHN1aXRhYmxlIGZvciBtYXRjaGluZ1xyXG4gICAgLy8gYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbiBoYXNoLlxyXG4gICAgX3JvdXRlVG9SZWdFeHA6IGZ1bmN0aW9uKHJvdXRlKSB7XHJcbiAgICAgIHJvdXRlID0gcm91dGUucmVwbGFjZShlc2NhcGVSZWdFeHAsICdcXFxcJCYnKVxyXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2Uob3B0aW9uYWxQYXJhbSwgJyg/OiQxKT8nKVxyXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2UobmFtZWRQYXJhbSwgZnVuY3Rpb24obWF0Y2gsIG9wdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25hbCA/IG1hdGNoIDogJyhbXi8/XSspJztcclxuICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAucmVwbGFjZShzcGxhdFBhcmFtLCAnKFteP10qPyknKTtcclxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoJ14nICsgcm91dGUgKyAnKD86XFxcXD8oW1xcXFxzXFxcXFNdKikpPyQnKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gR2l2ZW4gYSByb3V0ZSwgYW5kIGEgVVJMIGZyYWdtZW50IHRoYXQgaXQgbWF0Y2hlcywgcmV0dXJuIHRoZSBhcnJheSBvZlxyXG4gICAgLy8gZXh0cmFjdGVkIGRlY29kZWQgcGFyYW1ldGVycy4gRW1wdHkgb3IgdW5tYXRjaGVkIHBhcmFtZXRlcnMgd2lsbCBiZVxyXG4gICAgLy8gdHJlYXRlZCBhcyBgbnVsbGAgdG8gbm9ybWFsaXplIGNyb3NzLWJyb3dzZXIgYmVoYXZpb3IuXHJcbiAgICBfZXh0cmFjdFBhcmFtZXRlcnM6IGZ1bmN0aW9uKHJvdXRlLCBmcmFnbWVudCkge1xyXG4gICAgICB2YXIgcGFyYW1zID0gcm91dGUuZXhlYyhmcmFnbWVudCkuc2xpY2UoMSk7XHJcbiAgICAgIHJldHVybiBfLm1hcChwYXJhbXMsIGZ1bmN0aW9uKHBhcmFtLCBpKSB7XHJcbiAgICAgICAgLy8gRG9uJ3QgZGVjb2RlIHRoZSBzZWFyY2ggcGFyYW1zLlxyXG4gICAgICAgIGlmIChpID09PSBwYXJhbXMubGVuZ3RoIC0gMSkgcmV0dXJuIHBhcmFtIHx8IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtID8gZGVjb2RlVVJJQ29tcG9uZW50KHBhcmFtKSA6IG51bGw7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICB9KTtcclxuXHJcbiAgLy8gQmFja2JvbmUuSGlzdG9yeVxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gSGFuZGxlcyBjcm9zcy1icm93c2VyIGhpc3RvcnkgbWFuYWdlbWVudCwgYmFzZWQgb24gZWl0aGVyXHJcbiAgLy8gW3B1c2hTdGF0ZV0oaHR0cDovL2RpdmVpbnRvaHRtbDUuaW5mby9oaXN0b3J5Lmh0bWwpIGFuZCByZWFsIFVSTHMsIG9yXHJcbiAgLy8gW29uaGFzaGNoYW5nZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vd2luZG93Lm9uaGFzaGNoYW5nZSlcclxuICAvLyBhbmQgVVJMIGZyYWdtZW50cy4gSWYgdGhlIGJyb3dzZXIgc3VwcG9ydHMgbmVpdGhlciAob2xkIElFLCBuYXRjaCksXHJcbiAgLy8gZmFsbHMgYmFjayB0byBwb2xsaW5nLlxyXG4gIHZhciBIaXN0b3J5ID0gQmFja2JvbmUuSGlzdG9yeSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xyXG4gICAgXy5iaW5kQWxsKHRoaXMsICdjaGVja1VybCcpO1xyXG5cclxuICAgIC8vIEVuc3VyZSB0aGF0IGBIaXN0b3J5YCBjYW4gYmUgdXNlZCBvdXRzaWRlIG9mIHRoZSBicm93c2VyLlxyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIHRoaXMubG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XHJcbiAgICAgIHRoaXMuaGlzdG9yeSA9IHdpbmRvdy5oaXN0b3J5O1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIGEgbGVhZGluZyBoYXNoL3NsYXNoIGFuZCB0cmFpbGluZyBzcGFjZS5cclxuICB2YXIgcm91dGVTdHJpcHBlciA9IC9eWyNcXC9dfFxccyskL2c7XHJcblxyXG4gIC8vIENhY2hlZCByZWdleCBmb3Igc3RyaXBwaW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMuXHJcbiAgdmFyIHJvb3RTdHJpcHBlciA9IC9eXFwvK3xcXC8rJC9nO1xyXG5cclxuICAvLyBDYWNoZWQgcmVnZXggZm9yIGRldGVjdGluZyBNU0lFLlxyXG4gIHZhciBpc0V4cGxvcmVyID0gL21zaWUgW1xcdy5dKy87XHJcblxyXG4gIC8vIENhY2hlZCByZWdleCBmb3IgcmVtb3ZpbmcgYSB0cmFpbGluZyBzbGFzaC5cclxuICB2YXIgdHJhaWxpbmdTbGFzaCA9IC9cXC8kLztcclxuXHJcbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBzdHJpcHBpbmcgdXJscyBvZiBoYXNoLlxyXG4gIHZhciBwYXRoU3RyaXBwZXIgPSAvIy4qJC87XHJcblxyXG4gIC8vIEhhcyB0aGUgaGlzdG9yeSBoYW5kbGluZyBhbHJlYWR5IGJlZW4gc3RhcnRlZD9cclxuICBIaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcclxuXHJcbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkJhY2tib25lLkhpc3RvcnkqKiBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzLlxyXG4gIF8uZXh0ZW5kKEhpc3RvcnkucHJvdG90eXBlLCBFdmVudHMsIHtcclxuXHJcbiAgICAvLyBUaGUgZGVmYXVsdCBpbnRlcnZhbCB0byBwb2xsIGZvciBoYXNoIGNoYW5nZXMsIGlmIG5lY2Vzc2FyeSwgaXNcclxuICAgIC8vIHR3ZW50eSB0aW1lcyBhIHNlY29uZC5cclxuICAgIGludGVydmFsOiA1MCxcclxuXHJcbiAgICAvLyBBcmUgd2UgYXQgdGhlIGFwcCByb290P1xyXG4gICAgYXRSb290OiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvW15cXC9dJC8sICckJi8nKSA9PT0gdGhpcy5yb290O1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHZXRzIHRoZSB0cnVlIGhhc2ggdmFsdWUuIENhbm5vdCB1c2UgbG9jYXRpb24uaGFzaCBkaXJlY3RseSBkdWUgdG8gYnVnXHJcbiAgICAvLyBpbiBGaXJlZm94IHdoZXJlIGxvY2F0aW9uLmhhc2ggd2lsbCBhbHdheXMgYmUgZGVjb2RlZC5cclxuICAgIGdldEhhc2g6IGZ1bmN0aW9uKHdpbmRvdykge1xyXG4gICAgICB2YXIgbWF0Y2ggPSAod2luZG93IHx8IHRoaXMpLmxvY2F0aW9uLmhyZWYubWF0Y2goLyMoLiopJC8pO1xyXG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBHZXQgdGhlIGNyb3NzLWJyb3dzZXIgbm9ybWFsaXplZCBVUkwgZnJhZ21lbnQsIGVpdGhlciBmcm9tIHRoZSBVUkwsXHJcbiAgICAvLyB0aGUgaGFzaCwgb3IgdGhlIG92ZXJyaWRlLlxyXG4gICAgZ2V0RnJhZ21lbnQ6IGZ1bmN0aW9uKGZyYWdtZW50LCBmb3JjZVB1c2hTdGF0ZSkge1xyXG4gICAgICBpZiAoZnJhZ21lbnQgPT0gbnVsbCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUgfHwgIXRoaXMuX3dhbnRzSGFzaENoYW5nZSB8fCBmb3JjZVB1c2hTdGF0ZSkge1xyXG4gICAgICAgICAgZnJhZ21lbnQgPSBkZWNvZGVVUkkodGhpcy5sb2NhdGlvbi5wYXRobmFtZSArIHRoaXMubG9jYXRpb24uc2VhcmNoKTtcclxuICAgICAgICAgIHZhciByb290ID0gdGhpcy5yb290LnJlcGxhY2UodHJhaWxpbmdTbGFzaCwgJycpO1xyXG4gICAgICAgICAgaWYgKCFmcmFnbWVudC5pbmRleE9mKHJvb3QpKSBmcmFnbWVudCA9IGZyYWdtZW50LnNsaWNlKHJvb3QubGVuZ3RoKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEhhc2goKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBTdGFydCB0aGUgaGFzaCBjaGFuZ2UgaGFuZGxpbmcsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgVVJMIG1hdGNoZXNcclxuICAgIC8vIGFuIGV4aXN0aW5nIHJvdXRlLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXHJcbiAgICBzdGFydDogZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgICBpZiAoSGlzdG9yeS5zdGFydGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrYm9uZS5oaXN0b3J5IGhhcyBhbHJlYWR5IGJlZW4gc3RhcnRlZFwiKTtcclxuICAgICAgSGlzdG9yeS5zdGFydGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgIC8vIEZpZ3VyZSBvdXQgdGhlIGluaXRpYWwgY29uZmlndXJhdGlvbi4gRG8gd2UgbmVlZCBhbiBpZnJhbWU/XHJcbiAgICAgIC8vIElzIHB1c2hTdGF0ZSBkZXNpcmVkIC4uLiBpcyBpdCBhdmFpbGFibGU/XHJcbiAgICAgIHRoaXMub3B0aW9ucyAgICAgICAgICA9IF8uZXh0ZW5kKHtyb290OiAnLyd9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgICB0aGlzLnJvb3QgICAgICAgICAgICAgPSB0aGlzLm9wdGlvbnMucm9vdDtcclxuICAgICAgdGhpcy5fd2FudHNIYXNoQ2hhbmdlID0gdGhpcy5vcHRpb25zLmhhc2hDaGFuZ2UgIT09IGZhbHNlO1xyXG4gICAgICB0aGlzLl93YW50c1B1c2hTdGF0ZSAgPSAhIXRoaXMub3B0aW9ucy5wdXNoU3RhdGU7XHJcbiAgICAgIHRoaXMuX2hhc1B1c2hTdGF0ZSAgICA9ICEhKHRoaXMub3B0aW9ucy5wdXNoU3RhdGUgJiYgdGhpcy5oaXN0b3J5ICYmIHRoaXMuaGlzdG9yeS5wdXNoU3RhdGUpO1xyXG4gICAgICB2YXIgZnJhZ21lbnQgICAgICAgICAgPSB0aGlzLmdldEZyYWdtZW50KCk7XHJcbiAgICAgIHZhciBkb2NNb2RlICAgICAgICAgICA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcclxuICAgICAgdmFyIG9sZElFICAgICAgICAgICAgID0gKGlzRXhwbG9yZXIuZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpICYmICghZG9jTW9kZSB8fCBkb2NNb2RlIDw9IDcpKTtcclxuXHJcbiAgICAgIC8vIE5vcm1hbGl6ZSByb290IHRvIGFsd2F5cyBpbmNsdWRlIGEgbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2guXHJcbiAgICAgIHRoaXMucm9vdCA9ICgnLycgKyB0aGlzLnJvb3QgKyAnLycpLnJlcGxhY2Uocm9vdFN0cmlwcGVyLCAnLycpO1xyXG5cclxuICAgICAgaWYgKG9sZElFICYmIHRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xyXG4gICAgICAgIHZhciBmcmFtZSA9IEJhY2tib25lLiQoJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgdGFiaW5kZXg9XCItMVwiPicpO1xyXG4gICAgICAgIHRoaXMuaWZyYW1lID0gZnJhbWUuaGlkZSgpLmFwcGVuZFRvKCdib2R5JylbMF0uY29udGVudFdpbmRvdztcclxuICAgICAgICB0aGlzLm5hdmlnYXRlKGZyYWdtZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGVwZW5kaW5nIG9uIHdoZXRoZXIgd2UncmUgdXNpbmcgcHVzaFN0YXRlIG9yIGhhc2hlcywgYW5kIHdoZXRoZXJcclxuICAgICAgLy8gJ29uaGFzaGNoYW5nZScgaXMgc3VwcG9ydGVkLCBkZXRlcm1pbmUgaG93IHdlIGNoZWNrIHRoZSBVUkwgc3RhdGUuXHJcbiAgICAgIGlmICh0aGlzLl9oYXNQdXNoU3RhdGUpIHtcclxuICAgICAgICBCYWNrYm9uZS4kKHdpbmRvdykub24oJ3BvcHN0YXRlJywgdGhpcy5jaGVja1VybCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmICgnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3cpICYmICFvbGRJRSkge1xyXG4gICAgICAgIEJhY2tib25lLiQod2luZG93KS5vbignaGFzaGNoYW5nZScsIHRoaXMuY2hlY2tVcmwpO1xyXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSkge1xyXG4gICAgICAgIHRoaXMuX2NoZWNrVXJsSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLmNoZWNrVXJsLCB0aGlzLmludGVydmFsKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGlmIHdlIG5lZWQgdG8gY2hhbmdlIHRoZSBiYXNlIHVybCwgZm9yIGEgcHVzaFN0YXRlIGxpbmtcclxuICAgICAgLy8gb3BlbmVkIGJ5IGEgbm9uLXB1c2hTdGF0ZSBicm93c2VyLlxyXG4gICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQ7XHJcbiAgICAgIHZhciBsb2MgPSB0aGlzLmxvY2F0aW9uO1xyXG5cclxuICAgICAgLy8gVHJhbnNpdGlvbiBmcm9tIGhhc2hDaGFuZ2UgdG8gcHVzaFN0YXRlIG9yIHZpY2UgdmVyc2EgaWYgYm90aCBhcmVcclxuICAgICAgLy8gcmVxdWVzdGVkLlxyXG4gICAgICBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmIHRoaXMuX3dhbnRzUHVzaFN0YXRlKSB7XHJcblxyXG4gICAgICAgIC8vIElmIHdlJ3ZlIHN0YXJ0ZWQgb2ZmIHdpdGggYSByb3V0ZSBmcm9tIGEgYHB1c2hTdGF0ZWAtZW5hYmxlZFxyXG4gICAgICAgIC8vIGJyb3dzZXIsIGJ1dCB3ZSdyZSBjdXJyZW50bHkgaW4gYSBicm93c2VyIHRoYXQgZG9lc24ndCBzdXBwb3J0IGl0Li4uXHJcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNQdXNoU3RhdGUgJiYgIXRoaXMuYXRSb290KCkpIHtcclxuICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KG51bGwsIHRydWUpO1xyXG4gICAgICAgICAgdGhpcy5sb2NhdGlvbi5yZXBsYWNlKHRoaXMucm9vdCArICcjJyArIHRoaXMuZnJhZ21lbnQpO1xyXG4gICAgICAgICAgLy8gUmV0dXJuIGltbWVkaWF0ZWx5IGFzIGJyb3dzZXIgd2lsbCBkbyByZWRpcmVjdCB0byBuZXcgdXJsXHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHJcbiAgICAgICAgLy8gT3IgaWYgd2UndmUgc3RhcnRlZCBvdXQgd2l0aCBhIGhhc2gtYmFzZWQgcm91dGUsIGJ1dCB3ZSdyZSBjdXJyZW50bHlcclxuICAgICAgICAvLyBpbiBhIGJyb3dzZXIgd2hlcmUgaXQgY291bGQgYmUgYHB1c2hTdGF0ZWAtYmFzZWQgaW5zdGVhZC4uLlxyXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5faGFzUHVzaFN0YXRlICYmIHRoaXMuYXRSb290KCkgJiYgbG9jLmhhc2gpIHtcclxuICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSB0aGlzLmdldEhhc2goKS5yZXBsYWNlKHJvdXRlU3RyaXBwZXIsICcnKTtcclxuICAgICAgICAgIHRoaXMuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIGRvY3VtZW50LnRpdGxlLCB0aGlzLnJvb3QgKyB0aGlzLmZyYWdtZW50KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaWxlbnQpIHJldHVybiB0aGlzLmxvYWRVcmwoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRGlzYWJsZSBCYWNrYm9uZS5oaXN0b3J5LCBwZXJoYXBzIHRlbXBvcmFyaWx5LiBOb3QgdXNlZnVsIGluIGEgcmVhbCBhcHAsXHJcbiAgICAvLyBidXQgcG9zc2libHkgdXNlZnVsIGZvciB1bml0IHRlc3RpbmcgUm91dGVycy5cclxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBCYWNrYm9uZS4kKHdpbmRvdykub2ZmKCdwb3BzdGF0ZScsIHRoaXMuY2hlY2tVcmwpLm9mZignaGFzaGNoYW5nZScsIHRoaXMuY2hlY2tVcmwpO1xyXG4gICAgICBpZiAodGhpcy5fY2hlY2tVcmxJbnRlcnZhbCkgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja1VybEludGVydmFsKTtcclxuICAgICAgSGlzdG9yeS5zdGFydGVkID0gZmFsc2U7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEFkZCBhIHJvdXRlIHRvIGJlIHRlc3RlZCB3aGVuIHRoZSBmcmFnbWVudCBjaGFuZ2VzLiBSb3V0ZXMgYWRkZWQgbGF0ZXJcclxuICAgIC8vIG1heSBvdmVycmlkZSBwcmV2aW91cyByb3V0ZXMuXHJcbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIGNhbGxiYWNrKSB7XHJcbiAgICAgIHRoaXMuaGFuZGxlcnMudW5zaGlmdCh7cm91dGU6IHJvdXRlLCBjYWxsYmFjazogY2FsbGJhY2t9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gQ2hlY2tzIHRoZSBjdXJyZW50IFVSTCB0byBzZWUgaWYgaXQgaGFzIGNoYW5nZWQsIGFuZCBpZiBpdCBoYXMsXHJcbiAgICAvLyBjYWxscyBgbG9hZFVybGAsIG5vcm1hbGl6aW5nIGFjcm9zcyB0aGUgaGlkZGVuIGlmcmFtZS5cclxuICAgIGNoZWNrVXJsOiBmdW5jdGlvbihlKSB7XHJcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5nZXRGcmFnbWVudCgpO1xyXG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcy5mcmFnbWVudCAmJiB0aGlzLmlmcmFtZSkge1xyXG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldEZyYWdtZW50KHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZSkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50KSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIGlmICh0aGlzLmlmcmFtZSkgdGhpcy5uYXZpZ2F0ZShjdXJyZW50KTtcclxuICAgICAgdGhpcy5sb2FkVXJsKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEF0dGVtcHQgdG8gbG9hZCB0aGUgY3VycmVudCBVUkwgZnJhZ21lbnQuIElmIGEgcm91dGUgc3VjY2VlZHMgd2l0aCBhXHJcbiAgICAvLyBtYXRjaCwgcmV0dXJucyBgdHJ1ZWAuIElmIG5vIGRlZmluZWQgcm91dGVzIG1hdGNoZXMgdGhlIGZyYWdtZW50LFxyXG4gICAgLy8gcmV0dXJucyBgZmFsc2VgLlxyXG4gICAgbG9hZFVybDogZnVuY3Rpb24oZnJhZ21lbnQpIHtcclxuICAgICAgZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50ID0gdGhpcy5nZXRGcmFnbWVudChmcmFnbWVudCk7XHJcbiAgICAgIHJldHVybiBfLmFueSh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbihoYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKGhhbmRsZXIucm91dGUudGVzdChmcmFnbWVudCkpIHtcclxuICAgICAgICAgIGhhbmRsZXIuY2FsbGJhY2soZnJhZ21lbnQpO1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gU2F2ZSBhIGZyYWdtZW50IGludG8gdGhlIGhhc2ggaGlzdG9yeSwgb3IgcmVwbGFjZSB0aGUgVVJMIHN0YXRlIGlmIHRoZVxyXG4gICAgLy8gJ3JlcGxhY2UnIG9wdGlvbiBpcyBwYXNzZWQuIFlvdSBhcmUgcmVzcG9uc2libGUgZm9yIHByb3Blcmx5IFVSTC1lbmNvZGluZ1xyXG4gICAgLy8gdGhlIGZyYWdtZW50IGluIGFkdmFuY2UuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIG9wdGlvbnMgb2JqZWN0IGNhbiBjb250YWluIGB0cmlnZ2VyOiB0cnVlYCBpZiB5b3Ugd2lzaCB0byBoYXZlIHRoZVxyXG4gICAgLy8gcm91dGUgY2FsbGJhY2sgYmUgZmlyZWQgKG5vdCB1c3VhbGx5IGRlc2lyYWJsZSksIG9yIGByZXBsYWNlOiB0cnVlYCwgaWZcclxuICAgIC8vIHlvdSB3aXNoIHRvIG1vZGlmeSB0aGUgY3VycmVudCBVUkwgd2l0aG91dCBhZGRpbmcgYW4gZW50cnkgdG8gdGhlIGhpc3RvcnkuXHJcbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcclxuICAgICAgaWYgKCFIaXN0b3J5LnN0YXJ0ZWQpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKCFvcHRpb25zIHx8IG9wdGlvbnMgPT09IHRydWUpIG9wdGlvbnMgPSB7dHJpZ2dlcjogISFvcHRpb25zfTtcclxuXHJcbiAgICAgIHZhciB1cmwgPSB0aGlzLnJvb3QgKyAoZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KGZyYWdtZW50IHx8ICcnKSk7XHJcblxyXG4gICAgICAvLyBTdHJpcCB0aGUgaGFzaCBmb3IgbWF0Y2hpbmcuXHJcbiAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQucmVwbGFjZShwYXRoU3RyaXBwZXIsICcnKTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmZyYWdtZW50ID09PSBmcmFnbWVudCkgcmV0dXJuO1xyXG4gICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQ7XHJcblxyXG4gICAgICAvLyBEb24ndCBpbmNsdWRlIGEgdHJhaWxpbmcgc2xhc2ggb24gdGhlIHJvb3QuXHJcbiAgICAgIGlmIChmcmFnbWVudCA9PT0gJycgJiYgdXJsICE9PSAnLycpIHVybCA9IHVybC5zbGljZSgwLCAtMSk7XHJcblxyXG4gICAgICAvLyBJZiBwdXNoU3RhdGUgaXMgYXZhaWxhYmxlLCB3ZSB1c2UgaXQgdG8gc2V0IHRoZSBmcmFnbWVudCBhcyBhIHJlYWwgVVJMLlxyXG4gICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5oaXN0b3J5W29wdGlvbnMucmVwbGFjZSA/ICdyZXBsYWNlU3RhdGUnIDogJ3B1c2hTdGF0ZSddKHt9LCBkb2N1bWVudC50aXRsZSwgdXJsKTtcclxuXHJcbiAgICAgIC8vIElmIGhhc2ggY2hhbmdlcyBoYXZlbid0IGJlZW4gZXhwbGljaXRseSBkaXNhYmxlZCwgdXBkYXRlIHRoZSBoYXNoXHJcbiAgICAgIC8vIGZyYWdtZW50IHRvIHN0b3JlIGhpc3RvcnkuXHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlSGFzaCh0aGlzLmxvY2F0aW9uLCBmcmFnbWVudCwgb3B0aW9ucy5yZXBsYWNlKTtcclxuICAgICAgICBpZiAodGhpcy5pZnJhbWUgJiYgKGZyYWdtZW50ICE9PSB0aGlzLmdldEZyYWdtZW50KHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZSkpKSkge1xyXG4gICAgICAgICAgLy8gT3BlbmluZyBhbmQgY2xvc2luZyB0aGUgaWZyYW1lIHRyaWNrcyBJRTcgYW5kIGVhcmxpZXIgdG8gcHVzaCBhXHJcbiAgICAgICAgICAvLyBoaXN0b3J5IGVudHJ5IG9uIGhhc2gtdGFnIGNoYW5nZS4gIFdoZW4gcmVwbGFjZSBpcyB0cnVlLCB3ZSBkb24ndFxyXG4gICAgICAgICAgLy8gd2FudCB0aGlzLlxyXG4gICAgICAgICAgaWYoIW9wdGlvbnMucmVwbGFjZSkgdGhpcy5pZnJhbWUuZG9jdW1lbnQub3BlbigpLmNsb3NlKCk7XHJcbiAgICAgICAgICB0aGlzLl91cGRhdGVIYXNoKHRoaXMuaWZyYW1lLmxvY2F0aW9uLCBmcmFnbWVudCwgb3B0aW9ucy5yZXBsYWNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAvLyBJZiB5b3UndmUgdG9sZCB1cyB0aGF0IHlvdSBleHBsaWNpdGx5IGRvbid0IHdhbnQgZmFsbGJhY2sgaGFzaGNoYW5nZS1cclxuICAgICAgLy8gYmFzZWQgaGlzdG9yeSwgdGhlbiBgbmF2aWdhdGVgIGJlY29tZXMgYSBwYWdlIHJlZnJlc2guXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24uYXNzaWduKHVybCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKG9wdGlvbnMudHJpZ2dlcikgcmV0dXJuIHRoaXMubG9hZFVybChmcmFnbWVudCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgaGFzaCBsb2NhdGlvbiwgZWl0aGVyIHJlcGxhY2luZyB0aGUgY3VycmVudCBlbnRyeSwgb3IgYWRkaW5nXHJcbiAgICAvLyBhIG5ldyBvbmUgdG8gdGhlIGJyb3dzZXIgaGlzdG9yeS5cclxuICAgIF91cGRhdGVIYXNoOiBmdW5jdGlvbihsb2NhdGlvbiwgZnJhZ21lbnQsIHJlcGxhY2UpIHtcclxuICAgICAgaWYgKHJlcGxhY2UpIHtcclxuICAgICAgICB2YXIgaHJlZiA9IGxvY2F0aW9uLmhyZWYucmVwbGFjZSgvKGphdmFzY3JpcHQ6fCMpLiokLywgJycpO1xyXG4gICAgICAgIGxvY2F0aW9uLnJlcGxhY2UoaHJlZiArICcjJyArIGZyYWdtZW50KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBTb21lIGJyb3dzZXJzIHJlcXVpcmUgdGhhdCBgaGFzaGAgY29udGFpbnMgYSBsZWFkaW5nICMuXHJcbiAgICAgICAgbG9jYXRpb24uaGFzaCA9ICcjJyArIGZyYWdtZW50O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICAvLyBDcmVhdGUgdGhlIGRlZmF1bHQgQmFja2JvbmUuaGlzdG9yeS5cclxuICBCYWNrYm9uZS5oaXN0b3J5ID0gbmV3IEhpc3Rvcnk7XHJcblxyXG4gIC8vIEhlbHBlcnNcclxuICAvLyAtLS0tLS0tXHJcblxyXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBjb3JyZWN0bHkgc2V0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4sIGZvciBzdWJjbGFzc2VzLlxyXG4gIC8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXHJcbiAgLy8gY2xhc3MgcHJvcGVydGllcyB0byBiZSBleHRlbmRlZC5cclxuICB2YXIgZXh0ZW5kID0gZnVuY3Rpb24ocHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcclxuICAgIHZhciBwYXJlbnQgPSB0aGlzO1xyXG4gICAgdmFyIGNoaWxkO1xyXG5cclxuICAgIC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcclxuICAgIC8vICh0aGUgXCJjb25zdHJ1Y3RvclwiIHByb3BlcnR5IGluIHlvdXIgYGV4dGVuZGAgZGVmaW5pdGlvbiksIG9yIGRlZmF1bHRlZFxyXG4gICAgLy8gYnkgdXMgdG8gc2ltcGx5IGNhbGwgdGhlIHBhcmVudCdzIGNvbnN0cnVjdG9yLlxyXG4gICAgaWYgKHByb3RvUHJvcHMgJiYgXy5oYXMocHJvdG9Qcm9wcywgJ2NvbnN0cnVjdG9yJykpIHtcclxuICAgICAgY2hpbGQgPSBwcm90b1Byb3BzLmNvbnN0cnVjdG9yO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXHJcbiAgICBfLmV4dGVuZChjaGlsZCwgcGFyZW50LCBzdGF0aWNQcm9wcyk7XHJcblxyXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcclxuICAgIC8vIGBwYXJlbnRgJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcbiAgICB2YXIgU3Vycm9nYXRlID0gZnVuY3Rpb24oKXsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9O1xyXG4gICAgU3Vycm9nYXRlLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XHJcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgU3Vycm9nYXRlO1xyXG5cclxuICAgIC8vIEFkZCBwcm90b3R5cGUgcHJvcGVydGllcyAoaW5zdGFuY2UgcHJvcGVydGllcykgdG8gdGhlIHN1YmNsYXNzLFxyXG4gICAgLy8gaWYgc3VwcGxpZWQuXHJcbiAgICBpZiAocHJvdG9Qcm9wcykgXy5leHRlbmQoY2hpbGQucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcclxuXHJcbiAgICAvLyBTZXQgYSBjb252ZW5pZW5jZSBwcm9wZXJ0eSBpbiBjYXNlIHRoZSBwYXJlbnQncyBwcm90b3R5cGUgaXMgbmVlZGVkXHJcbiAgICAvLyBsYXRlci5cclxuICAgIGNoaWxkLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XHJcblxyXG4gICAgcmV0dXJuIGNoaWxkO1xyXG4gIH07XHJcblxyXG4gIC8vIFNldCB1cCBpbmhlcml0YW5jZSBmb3IgdGhlIG1vZGVsLCBjb2xsZWN0aW9uLCByb3V0ZXIsIHZpZXcgYW5kIGhpc3RvcnkuXHJcbiAgTW9kZWwuZXh0ZW5kID0gQ29sbGVjdGlvbi5leHRlbmQgPSBSb3V0ZXIuZXh0ZW5kID0gVmlldy5leHRlbmQgPSBIaXN0b3J5LmV4dGVuZCA9IGV4dGVuZDtcclxuXHJcbiAgLy8gVGhyb3cgYW4gZXJyb3Igd2hlbiBhIFVSTCBpcyBuZWVkZWQsIGFuZCBub25lIGlzIHN1cHBsaWVkLlxyXG4gIHZhciB1cmxFcnJvciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIFwidXJsXCIgcHJvcGVydHkgb3IgZnVuY3Rpb24gbXVzdCBiZSBzcGVjaWZpZWQnKTtcclxuICB9O1xyXG5cclxuICAvLyBXcmFwIGFuIG9wdGlvbmFsIGVycm9yIGNhbGxiYWNrIHdpdGggYSBmYWxsYmFjayBlcnJvciBldmVudC5cclxuICB2YXIgd3JhcEVycm9yID0gZnVuY3Rpb24obW9kZWwsIG9wdGlvbnMpIHtcclxuICAgIHZhciBlcnJvciA9IG9wdGlvbnMuZXJyb3I7XHJcbiAgICBvcHRpb25zLmVycm9yID0gZnVuY3Rpb24ocmVzcCkge1xyXG4gICAgICBpZiAoZXJyb3IpIGVycm9yKG1vZGVsLCByZXNwLCBvcHRpb25zKTtcclxuICAgICAgbW9kZWwudHJpZ2dlcignZXJyb3InLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIHJldHVybiBCYWNrYm9uZTtcclxuXHJcbn0pKTtcclxuIiwiLypcclxuICBiYWNrZ3JpZC1maWx0ZXJcclxuICBodHRwOi8vZ2l0aHViLmNvbS93eXVlbmhvL2JhY2tncmlkXHJcblxyXG4gIENvcHlyaWdodCAoYykgMjAxMyBKaW1teSBZdWVuIEhvIFdvbmcgYW5kIGNvbnRyaWJ1dG9yc1xyXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgQGxpY2Vuc2UuXHJcbiovXHJcbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG5cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXHJcbiAgICBkZWZpbmUoW1widW5kZXJzY29yZVwiLCBcImJhY2tib25lXCIsIFwiYmFja2dyaWRcIl0sIGZhY3RvcnkpO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIikge1xyXG4gICAgLy8gQ29tbW9uSlNcclxuICAgIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBsdW5yO1xyXG4gICAgICB0cnkgeyBsdW5yID0gcmVxdWlyZShcImx1bnJcIik7IH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwidW5kZXJzY29yZVwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCJiYWNrYm9uZVwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoXCJiYWNrZ3JpZFwiKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGx1bnIpO1xyXG4gICAgfSgpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gQnJvd3NlclxyXG4gICAgZmFjdG9yeShyb290Ll8sIHJvb3QuQmFja2JvbmUsIHJvb3QuQmFja2dyaWQsIHJvb3QubHVucik7XHJcbiAgfVxyXG5cclxufSh0aGlzLCBmdW5jdGlvbiAoXywgQmFja2JvbmUsIEJhY2tncmlkLCBsdW5yKSB7XHJcblxyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAvKipcclxuICAgICBTZXJ2ZXJTaWRlRmlsdGVyIGlzIGEgc2VhcmNoIGZvcm0gd2lkZ2V0IHRoYXQgc3VibWl0cyBhIHF1ZXJ5IHRvIHRoZSBzZXJ2ZXJcclxuICAgICBmb3IgZmlsdGVyaW5nIHRoZSBjdXJyZW50IGNvbGxlY3Rpb24uXHJcblxyXG4gICAgIEBjbGFzcyBCYWNrZ3JpZC5FeHRlbnNpb24uU2VydmVyU2lkZUZpbHRlclxyXG4gICovXHJcbiAgdmFyIFNlcnZlclNpZGVGaWx0ZXIgPSBCYWNrZ3JpZC5FeHRlbnNpb24uU2VydmVyU2lkZUZpbHRlciA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuXHJcbiAgICAvKiogQHByb3BlcnR5ICovXHJcbiAgICB0YWdOYW1lOiBcImZvcm1cIixcclxuXHJcbiAgICAvKiogQHByb3BlcnR5ICovXHJcbiAgICBjbGFzc05hbWU6IFwiYmFja2dyaWQtZmlsdGVyIGZvcm0tc2VhcmNoXCIsXHJcblxyXG4gICAgLyoqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oT2JqZWN0LCA/T2JqZWN0PSk6IHN0cmluZ30gdGVtcGxhdGUgKi9cclxuICAgIHRlbXBsYXRlOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICByZXR1cm4gJzxzcGFuIGNsYXNzPVwic2VhcmNoXCI+Jm5ic3A7PC9zcGFuPjxpbnB1dCB0eXBlPVwic2VhcmNoXCIgJyArIChkYXRhLnBsYWNlaG9sZGVyID8gJ3BsYWNlaG9sZGVyPVwiJyArIGRhdGEucGxhY2Vob2xkZXIgKyAnXCInIDogJycpICsgJyBuYW1lPVwiJyArIGRhdGEubmFtZSArICdcIiAnICsgKGRhdGEudmFsdWUgPyAndmFsdWU9XCInICsgZGF0YS52YWx1ZSArICdcIicgOiAnJykgKyAnLz48YSBjbGFzcz1cImNsZWFyXCIgZGF0YS1iYWNrZ3JpZC1hY3Rpb249XCJjbGVhclwiIGhyZWY9XCIjXCI+JnRpbWVzOzwvYT4nO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiogQHByb3BlcnR5ICovXHJcbiAgICBldmVudHM6IHtcclxuICAgICAgXCJrZXl1cCBpbnB1dFt0eXBlPXNlYXJjaF1cIjogXCJzaG93Q2xlYXJCdXR0b25NYXliZVwiLFxyXG4gICAgICBcImNsaWNrIGFbZGF0YS1iYWNrZ3JpZC1hY3Rpb249Y2xlYXJdXCI6IFwiY2xlYXJcIixcclxuICAgICAgXCJzdWJtaXRcIjogXCJzZWFyY2hcIlxyXG4gICAgfSxcclxuXHJcbiAgICAvKiogQHByb3BlcnR5IHtzdHJpbmd9IFtuYW1lPSdxJ10gUXVlcnkga2V5ICovXHJcbiAgICBuYW1lOiBcInFcIixcclxuXHJcbiAgICAvKiogQHByb3BlcnR5IHtzdHJpbmd9IFt2YWx1ZV0gVGhlIHNlYXJjaCBib3ggdmFsdWUuICAqL1xyXG4gICAgdmFsdWU6IG51bGwsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBAcHJvcGVydHkge3N0cmluZ30gW3BsYWNlaG9sZGVyXSBUaGUgSFRNTDUgcGxhY2Vob2xkZXIgdG8gYXBwZWFyIGJlbmVhdGhcclxuICAgICAgIHRoZSBzZWFyY2ggYm94LlxyXG4gICAgKi9cclxuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAgIEBwYXJhbSB7QmFja2JvbmUuQ29sbGVjdGlvbn0gb3B0aW9ucy5jb2xsZWN0aW9uXHJcbiAgICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV1cclxuICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy52YWx1ZV1cclxuICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wbGFjZWhvbGRlcl1cclxuICAgICAgIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KTogc3RyaW5nfSBbb3B0aW9ucy50ZW1wbGF0ZV1cclxuICAgICovXHJcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICBTZXJ2ZXJTaWRlRmlsdGVyLl9fc3VwZXJfXy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCB0aGlzLm5hbWU7XHJcbiAgICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlIHx8IHRoaXMudmFsdWU7XHJcbiAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBvcHRpb25zLnBsYWNlaG9sZGVyIHx8IHRoaXMucGxhY2Vob2xkZXI7XHJcbiAgICAgIHRoaXMudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlIHx8IHRoaXMudGVtcGxhdGU7XHJcblxyXG4gICAgICAvLyBQZXJzaXN0IHRoZSBxdWVyeSBvbiBwYWdpbmF0aW9uXHJcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uLCBzZWxmID0gdGhpcztcclxuICAgICAgaWYgKEJhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbiAmJlxyXG4gICAgICAgICAgY29sbGVjdGlvbiBpbnN0YW5jZW9mIEJhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbiAmJlxyXG4gICAgICAgICAgY29sbGVjdGlvbi5tb2RlID09IFwic2VydmVyXCIpIHtcclxuICAgICAgICBjb2xsZWN0aW9uLnF1ZXJ5UGFyYW1zW3RoaXMubmFtZV0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gc2VsZi5zZWFyY2hCb3goKS52YWwoKSB8fCBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBFdmVudCBoYW5kbGVyLiBDbGVhciB0aGUgc2VhcmNoIGJveCBhbmQgcmVzZXQgdGhlIGludGVybmFsIHNlYXJjaCB2YWx1ZS5cclxuICAgICAqL1xyXG4gICAgY2xlYXJTZWFyY2hCb3g6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLnZhbHVlID0gbnVsbDtcclxuICAgICAgdGhpcy5zZWFyY2hCb3goKS52YWwobnVsbCk7XHJcbiAgICAgIHRoaXMuc2hvd0NsZWFyQnV0dG9uTWF5YmUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBFdmVudCBoYW5kbGVyLiBTaG93IHRoZSBjbGVhciBidXR0b24gd2hlbiB0aGUgc2VhcmNoIGJveCBoYXMgdGV4dCwgaGlkZVxyXG4gICAgICAgaXQgb3RoZXJ3aXNlLlxyXG4gICAgICovXHJcbiAgICBzaG93Q2xlYXJCdXR0b25NYXliZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgJGNsZWFyQnV0dG9uID0gdGhpcy5jbGVhckJ1dHRvbigpO1xyXG4gICAgICB2YXIgc2VhcmNoVGVybXMgPSB0aGlzLnNlYXJjaEJveCgpLnZhbCgpO1xyXG4gICAgICBpZiAoc2VhcmNoVGVybXMpICRjbGVhckJ1dHRvbi5zaG93KCk7XHJcbiAgICAgIGVsc2UgJGNsZWFyQnV0dG9uLmhpZGUoKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBSZXR1cm5zIHRoZSBzZWFyY2ggaW5wdXQgYm94LlxyXG4gICAgICovXHJcbiAgICBzZWFyY2hCb3g6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuJGVsLmZpbmQoXCJpbnB1dFt0eXBlPXNlYXJjaF1cIik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgUmV0dXJucyB0aGUgY2xlYXIgYnV0dG9uLlxyXG4gICAgICovXHJcbiAgICBjbGVhckJ1dHRvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy4kZWwuZmluZChcImFbZGF0YS1iYWNrZ3JpZC1hY3Rpb249Y2xlYXJdXCIpO1xyXG4gICAgfSxcclxuXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBSZXR1cm5zIHRoZSBjdXJyZW50IHNlYXJjaCBxdWVyeS5cclxuICAgICAqL1xyXG4gICAgcXVlcnk6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLnZhbHVlID0gdGhpcy5zZWFyY2hCb3goKS52YWwoKTtcclxuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgVXBvbiBzZWFyY2ggZm9ybSBzdWJtaXNzaW9uLCB0aGlzIGV2ZW50IGhhbmRsZXIgY29uc3RydWN0cyBhIHF1ZXJ5XHJcbiAgICAgICBwYXJhbWV0ZXIgb2JqZWN0IGFuZCBwYXNzIGl0IHRvIENvbGxlY3Rpb24jZmV0Y2ggZm9yIHNlcnZlci1zaWRlXHJcbiAgICAgICBmaWx0ZXJpbmcuXHJcblxyXG4gICAgICAgSWYgdGhlIGNvbGxlY3Rpb24gaXMgYSBQYWdlYWJsZUNvbGxlY3Rpb24sIHNlYXJjaGluZyB3aWxsIGdvIGJhY2sgdG8gdGhlXHJcbiAgICAgICBmaXJzdCBwYWdlLlxyXG4gICAgKi9cclxuICAgIHNlYXJjaDogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgIHZhciBkYXRhID0ge307XHJcbiAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkoKTtcclxuICAgICAgaWYgKHF1ZXJ5KSBkYXRhW3RoaXMubmFtZV0gPSBxdWVyeTtcclxuXHJcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uO1xyXG5cclxuICAgICAgLy8gZ28gYmFjayB0byB0aGUgZmlyc3QgcGFnZSBvbiBzZWFyY2hcclxuICAgICAgaWYgKEJhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbiAmJlxyXG4gICAgICAgICAgY29sbGVjdGlvbiBpbnN0YW5jZW9mIEJhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbikge1xyXG4gICAgICAgIGNvbGxlY3Rpb24uZ2V0Rmlyc3RQYWdlKHtkYXRhOiBkYXRhLCByZXNldDogdHJ1ZSwgZmV0Y2g6IHRydWV9KTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIGNvbGxlY3Rpb24uZmV0Y2goe2RhdGE6IGRhdGEsIHJlc2V0OiB0cnVlfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgRXZlbnQgaGFuZGxlciBmb3IgdGhlIGNsZWFyIGJ1dHRvbi4gQ2xlYXJzIHRoZSBzZWFyY2ggYm94IGFuZCByZWZldGNoIHRoZVxyXG4gICAgICAgY29sbGVjdGlvbi5cclxuXHJcbiAgICAgICBJZiB0aGUgY29sbGVjdGlvbiBpcyBhIFBhZ2VhYmxlQ29sbGVjdGlvbiwgY2xlYXJpbmcgd2lsbCBnbyBiYWNrIHRvIHRoZVxyXG4gICAgICAgZmlyc3QgcGFnZS5cclxuICAgICovXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgaWYgKGUpIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgdGhpcy5jbGVhclNlYXJjaEJveCgpO1xyXG5cclxuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb247XHJcblxyXG4gICAgICAvLyBnbyBiYWNrIHRvIHRoZSBmaXJzdCBwYWdlIG9uIGNsZWFyXHJcbiAgICAgIGlmIChCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb24gJiZcclxuICAgICAgICAgIGNvbGxlY3Rpb24gaW5zdGFuY2VvZiBCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb24pIHtcclxuICAgICAgICBjb2xsZWN0aW9uLmdldEZpcnN0UGFnZSh7cmVzZXQ6IHRydWUsIGZldGNoOiB0cnVlfSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBjb2xsZWN0aW9uLmZldGNoKHtyZXNldDogdHJ1ZX0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAgIFJlbmRlcnMgYSBzZWFyY2ggZm9ybSB3aXRoIGEgdGV4dCBib3gsIG9wdGlvbmFsbHkgd2l0aCBhIHBsYWNlaG9sZGVyIGFuZFxyXG4gICAgICAgYSBwcmVzZXQgdmFsdWUgaWYgc3VwcGxpZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxyXG4gICAgKi9cclxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLiRlbC5lbXB0eSgpLmFwcGVuZCh0aGlzLnRlbXBsYXRlKHtcclxuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXHJcbiAgICAgICAgcGxhY2Vob2xkZXI6IHRoaXMucGxhY2Vob2xkZXIsXHJcbiAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVcclxuICAgICAgfSkpO1xyXG4gICAgICB0aGlzLnNob3dDbGVhckJ1dHRvbk1heWJlKCk7XHJcbiAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gIH0pO1xyXG5cclxuICAvKipcclxuICAgICBDbGllbnRTaWRlRmlsdGVyIGlzIGEgc2VhcmNoIGZvcm0gd2lkZ2V0IHRoYXQgc2VhcmNoZXMgYSBjb2xsZWN0aW9uIGZvclxyXG4gICAgIG1vZGVsIG1hdGNoZXMgYWdhaW5zdCBhIHF1ZXJ5IG9uIHRoZSBjbGllbnQgc2lkZS4gVGhlIGV4YWN0IG1hdGNoaW5nXHJcbiAgICAgYWxnb3JpdGhtIGNhbiBiZSBvdmVycmlkZW4gYnkgc3ViY2xhc3Nlcy5cclxuXHJcbiAgICAgQGNsYXNzIEJhY2tncmlkLkV4dGVuc2lvbi5DbGllbnRTaWRlRmlsdGVyXHJcbiAgICAgQGV4dGVuZHMgQmFja2dyaWQuRXh0ZW5zaW9uLlNlcnZlclNpZGVGaWx0ZXJcclxuICAqL1xyXG4gIHZhciBDbGllbnRTaWRlRmlsdGVyID0gQmFja2dyaWQuRXh0ZW5zaW9uLkNsaWVudFNpZGVGaWx0ZXIgPSBTZXJ2ZXJTaWRlRmlsdGVyLmV4dGVuZCh7XHJcblxyXG4gICAgLyoqIEBwcm9wZXJ0eSAqL1xyXG4gICAgZXZlbnRzOiBfLmV4dGVuZCh7fSwgU2VydmVyU2lkZUZpbHRlci5wcm90b3R5cGUuZXZlbnRzLCB7XHJcbiAgICAgIFwiY2xpY2sgYVtkYXRhLWJhY2tncmlkLWFjdGlvbj1jbGVhcl1cIjogZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICB9LFxyXG4gICAgICBcImtleWRvd24gaW5wdXRbdHlwZT1zZWFyY2hdXCI6IFwic2VhcmNoXCIsXHJcbiAgICAgIFwic3VibWl0XCI6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIHRoaXMuc2VhcmNoKCk7XHJcbiAgICAgIH1cclxuICAgIH0pLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgQHByb3BlcnR5IHs/QXJyYXkuPHN0cmluZz59IFtmaWVsZHNdIEEgbGlzdCBvZiBtb2RlbCBmaWVsZCBuYW1lcyB0b1xyXG4gICAgICAgc2VhcmNoIGZvciBtYXRjaGVzLiBJZiBudWxsLCBhbGwgb2YgdGhlIGZpZWxkcyB3aWxsIGJlIHNlYXJjaGVkLlxyXG4gICAgKi9cclxuICAgIGZpZWxkczogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAgIEBwcm9wZXJ0eSBbd2FpdD0xNDldIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB3YWl0IHNpbmNlIHRoZSBsYXN0XHJcbiAgICAgICBjaGFuZ2UgdG8gdGhlIHNlYXJjaCBib3gncyB2YWx1ZSBiZWZvcmUgc2VhcmNoaW5nLiBUaGlzIHZhbHVlIGNhbiBiZVxyXG4gICAgICAgYWRqdXN0ZWQgZGVwZW5kaW5nIG9uIGhvdyBvZnRlbiB0aGUgc2VhcmNoIGJveCBpcyB1c2VkIGFuZCBob3cgbGFyZ2UgdGhlXHJcbiAgICAgICBzZWFyY2ggaW5kZXggaXMuXHJcbiAgICAqL1xyXG4gICAgd2FpdDogMTQ5LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgRGVib3VuY2VzIHRoZSAjc2VhcmNoIGFuZCAjY2xlYXIgbWV0aG9kcyBhbmQgbWFrZXMgYSBjb3B5IG9mIHRoZSBnaXZlblxyXG4gICAgICAgY29sbGVjdGlvbiBmb3Igc2VhcmNoaW5nLlxyXG5cclxuICAgICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgICBAcGFyYW0ge0JhY2tib25lLkNvbGxlY3Rpb259IG9wdGlvbnMuY29sbGVjdGlvblxyXG4gICAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBsYWNlaG9sZGVyXVxyXG4gICAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZpZWxkc11cclxuICAgICAgIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy53YWl0PTE0OV1cclxuICAgICovXHJcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICBDbGllbnRTaWRlRmlsdGVyLl9fc3VwZXJfXy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblxyXG4gICAgICB0aGlzLmZpZWxkcyA9IG9wdGlvbnMuZmllbGRzIHx8IHRoaXMuZmllbGRzO1xyXG4gICAgICB0aGlzLndhaXQgPSBvcHRpb25zLndhaXQgfHwgdGhpcy53YWl0O1xyXG5cclxuICAgICAgdGhpcy5fZGVib3VuY2VNZXRob2RzKFtcInNlYXJjaFwiLCBcImNsZWFyXCJdKTtcclxuXHJcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uLmZ1bGxDb2xsZWN0aW9uIHx8IHRoaXMuY29sbGVjdGlvbjtcclxuICAgICAgdmFyIHNoYWRvd0NvbGxlY3Rpb24gPSB0aGlzLnNoYWRvd0NvbGxlY3Rpb24gPSBjb2xsZWN0aW9uLmNsb25lKCk7XHJcblxyXG4gICAgICB0aGlzLmxpc3RlblRvKGNvbGxlY3Rpb24sIFwiYWRkXCIsIGZ1bmN0aW9uIChtb2RlbCwgY29sbGVjdGlvbiwgb3B0aW9ucykge1xyXG4gICAgICAgIHNoYWRvd0NvbGxlY3Rpb24uYWRkKG1vZGVsLCBvcHRpb25zKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMubGlzdGVuVG8oY29sbGVjdGlvbiwgXCJyZW1vdmVcIiwgZnVuY3Rpb24gKG1vZGVsLCBjb2xsZWN0aW9uLCBvcHRpb25zKSB7XHJcbiAgICAgICAgc2hhZG93Q29sbGVjdGlvbi5yZW1vdmUobW9kZWwsIG9wdGlvbnMpO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5saXN0ZW5Ubyhjb2xsZWN0aW9uLCBcInNvcnRcIiwgZnVuY3Rpb24gKGNvbCkge1xyXG4gICAgICAgIGlmICghdGhpcy5zZWFyY2hCb3goKS52YWwoKSkgc2hhZG93Q29sbGVjdGlvbi5yZXNldChjb2wubW9kZWxzKTtcclxuICAgICAgfSk7XHJcbiAgICAgIHRoaXMubGlzdGVuVG8oY29sbGVjdGlvbiwgXCJyZXNldFwiLCBmdW5jdGlvbiAoY29sLCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IF8uZXh0ZW5kKHtyZWluZGV4OiB0cnVlfSwgb3B0aW9ucyB8fCB7fSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucmVpbmRleCAmJiBvcHRpb25zLmZyb20gPT0gbnVsbCAmJiBvcHRpb25zLnRvID09IG51bGwpIHtcclxuICAgICAgICAgIHNoYWRvd0NvbGxlY3Rpb24ucmVzZXQoY29sLm1vZGVscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX2RlYm91bmNlTWV0aG9kczogZnVuY3Rpb24gKG1ldGhvZE5hbWVzKSB7XHJcbiAgICAgIGlmIChfLmlzU3RyaW5nKG1ldGhvZE5hbWVzKSkgbWV0aG9kTmFtZXMgPSBbbWV0aG9kTmFtZXNdO1xyXG5cclxuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XHJcblxyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG1ldGhvZE5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIHZhciBtZXRob2ROYW1lID0gbWV0aG9kTmFtZXNbaV07XHJcbiAgICAgICAgdmFyIG1ldGhvZCA9IHRoaXNbbWV0aG9kTmFtZV07XHJcbiAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IF8uZGVib3VuY2UobWV0aG9kLCB0aGlzLndhaXQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgQ29uc3RydWN0cyBhIEphdmFzY3JpcHQgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgI21ha2VNYXRjaGVyLlxyXG5cclxuICAgICAgIFRoaXMgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB0YWtlcyBhIHF1ZXJ5IHN0cmluZyBhbmQgcmV0dXJucyBhIEphdmFzY3JpcHRcclxuICAgICAgIFJlZ0V4cCBvYmplY3QgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgd29yZHMgY29udGFpbmVkIGluIHRoZSBxdWVyeSBzdHJpbmdcclxuICAgICAgIGNhc2UtaW5zZW5zaXRpdmVseS4gT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGEgZGlmZmVyZW50IHJlZ3VsYXJcclxuICAgICAgIGV4cHJlc3Npb24gbWF0Y2hlciBpZiB0aGlzIGJlaGF2aW9yIGlzIG5vdCBkZXNpcmVkLlxyXG5cclxuICAgICAgIEBwYXJhbSB7c3RyaW5nfSBxdWVyeSBUaGUgc2VhcmNoIHF1ZXJ5IGluIHRoZSBzZWFyY2ggYm94LlxyXG4gICAgICAgQHJldHVybiB7UmVnRXhwfSBBIFJlZ0V4cCBvYmplY3QgdG8gbWF0Y2ggYWdhaW5zdCBtb2RlbCAjZmllbGRzLlxyXG4gICAgICovXHJcbiAgICBtYWtlUmVnRXhwOiBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocXVlcnkudHJpbSgpLnNwbGl0KC9cXHMrLykuam9pbihcInxcIiksIFwiaVwiKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBUaGlzIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gdGFrZXMgYSBxdWVyeSBzdHJpbmcgYW5kIHJldHVybnMgYSBtYXRjaGVyXHJcbiAgICAgICBmdW5jdGlvbiB0aGF0IGxvb2tzIGZvciBtYXRjaGVzIGluIHRoZSBtb2RlbCdzICNmaWVsZHMgb3IgYWxsIG9mIGl0c1xyXG4gICAgICAgZmllbGRzIGlmICNmaWVsZHMgaXMgbnVsbCwgZm9yIGFueSBvZiB0aGUgd29yZHMgaW4gdGhlIHF1ZXJ5XHJcbiAgICAgICBjYXNlLWluc2Vuc2l0aXZlbHkgdXNpbmcgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBvYmplY3QgcmV0dXJuZWQgZnJvbVxyXG4gICAgICAgI21ha2VSZWdFeHAuXHJcblxyXG4gICAgICAgTW9zdCBvZiB0aW1lLCB5b3UnZCB3YW50IHRvIG92ZXJyaWRlIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gdXNlZCBmb3JcclxuICAgICAgIG1hdGNoaW5nLiBJZiBzbywgcGxlYXNlIHJlZmVyIHRvIHRoZSAjbWFrZVJlZ0V4cCBkb2N1bWVudGF0aW9uLFxyXG4gICAgICAgb3RoZXJ3aXNlLCB5b3UgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVybiBhIGN1c3RvbSBtYXRjaGluZ1xyXG4gICAgICAgZnVuY3Rpb24uXHJcblxyXG4gICAgICAgU3ViY2xhc3NlcyBvdmVycmlkaW5nIHRoaXMgbWV0aG9kIG11c3QgdGFrZSBjYXJlIHRvIGNvbmZvcm0gdG8gdGhlXHJcbiAgICAgICBzaWduYXR1cmUgb2YgdGhlIG1hdGNoZXIgZnVuY3Rpb24uIFRoZSBtYXRjaGVyIGZ1bmN0aW9uIGlzIGEgZnVuY3Rpb25cclxuICAgICAgIHRoYXQgdGFrZXMgYSBtb2RlbCBhcyBwYXJhbXRlciBhbmQgcmV0dXJucyB0cnVlIGlmIHRoZSBtb2RlbCBtYXRjaGVzIGFcclxuICAgICAgIHNlYXJjaCwgb3IgZmFsc2Ugb3RoZXJ3aXNlLlxyXG5cclxuICAgICAgIEluIGFkZGl0aW9uLCB3aGVuIHRoZSBtYXRjaGVyIGZ1bmN0aW9uIGlzIGNhbGxlZCwgaXRzIGNvbnRleHQgd2lsbCBiZVxyXG4gICAgICAgYm91bmQgdG8gdGhpcyBDbGllbnRTaWRlRmlsdGVyIG9iamVjdCBzbyBpdCBoYXMgYWNjZXNzIHRvIHRoZSBmaWx0ZXInc1xyXG4gICAgICAgYXR0cmlidXRlcyBhbmQgbWV0aG9kcy5cclxuXHJcbiAgICAgICBAcGFyYW0ge3N0cmluZ30gcXVlcnkgVGhlIHNlYXJjaCBxdWVyeSBpbiB0aGUgc2VhcmNoIGJveC5cclxuICAgICAgIEByZXR1cm4ge2Z1bmN0aW9uKEJhY2tib25lLk1vZGVsKTpib29sZWFufSBBIG1hdGNoaW5nIGZ1bmN0aW9uLlxyXG4gICAgKi9cclxuICAgIG1ha2VNYXRjaGVyOiBmdW5jdGlvbiAocXVlcnkpIHtcclxuICAgICAgdmFyIHJlZ2V4cCA9IHRoaXMubWFrZVJlZ0V4cChxdWVyeSk7XHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgICB2YXIga2V5cyA9IHRoaXMuZmllbGRzIHx8IG1vZGVsLmtleXMoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAocmVnZXhwLnRlc3QobW9kZWwuZ2V0KGtleXNbaV0pICsgXCJcIikpIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH07XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgVGFrZXMgdGhlIHF1ZXJ5IGZyb20gdGhlIHNlYXJjaCBib3gsIGNvbnN0cnVjdHMgYSBtYXRjaGVyIHdpdGggaXQgYW5kXHJcbiAgICAgICBsb29wcyB0aHJvdWdoIGNvbGxlY3Rpb24gbG9va2luZyBmb3IgbWF0Y2hlcy4gUmVzZXQgdGhlIGdpdmVuIGNvbGxlY3Rpb25cclxuICAgICAgIHdoZW4gYWxsIHRoZSBtYXRjaGVzIGhhdmUgYmVlbiBmb3VuZC5cclxuXHJcbiAgICAgICBJZiB0aGUgY29sbGVjdGlvbiBpcyBhIFBhZ2VhYmxlQ29sbGVjdGlvbiwgc2VhcmNoaW5nIHdpbGwgZ28gYmFjayB0byB0aGVcclxuICAgICAgIGZpcnN0IHBhZ2UuXHJcbiAgICAqL1xyXG4gICAgc2VhcmNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBtYXRjaGVyID0gXy5iaW5kKHRoaXMubWFrZU1hdGNoZXIodGhpcy5xdWVyeSgpKSwgdGhpcyk7XHJcbiAgICAgIHZhciBjb2wgPSB0aGlzLmNvbGxlY3Rpb247XHJcbiAgICAgIGlmIChjb2wucGFnZWFibGVDb2xsZWN0aW9uKSBjb2wucGFnZWFibGVDb2xsZWN0aW9uLmdldEZpcnN0UGFnZSh7c2lsZW50OiB0cnVlfSk7XHJcbiAgICAgIGNvbC5yZXNldCh0aGlzLnNoYWRvd0NvbGxlY3Rpb24uZmlsdGVyKG1hdGNoZXIpLCB7cmVpbmRleDogZmFsc2V9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBDbGVhcnMgdGhlIHNlYXJjaCBib3ggYW5kIHJlc2V0IHRoZSBjb2xsZWN0aW9uIHRvIGl0cyBvcmlnaW5hbC5cclxuXHJcbiAgICAgICBJZiB0aGUgY29sbGVjdGlvbiBpcyBhIFBhZ2VhYmxlQ29sbGVjdGlvbiwgY2xlYXJpbmcgd2lsbCBnbyBiYWNrIHRvIHRoZVxyXG4gICAgICAgZmlyc3QgcGFnZS5cclxuICAgICovXHJcbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLmNsZWFyU2VhcmNoQm94KCk7XHJcbiAgICAgIHZhciBjb2wgPSB0aGlzLmNvbGxlY3Rpb247XHJcbiAgICAgIGlmIChjb2wucGFnZWFibGVDb2xsZWN0aW9uKSBjb2wucGFnZWFibGVDb2xsZWN0aW9uLmdldEZpcnN0UGFnZSh7c2lsZW50OiB0cnVlfSk7XHJcbiAgICAgIGNvbC5yZXNldCh0aGlzLnNoYWRvd0NvbGxlY3Rpb24ubW9kZWxzLCB7cmVpbmRleDogZmFsc2V9KTtcclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAgIEx1bnJGaWx0ZXIgaXMgYSBDbGllbnRTaWRlRmlsdGVyIHRoYXQgdXNlcyBbbHVucmpzXShodHRwOi8vbHVucmpzLmNvbS8pIHRvXHJcbiAgICAgaW5kZXggdGhlIHRleHQgZmllbGRzIG9mIGVhY2ggbW9kZWwgZm9yIGEgY29sbGVjdGlvbiwgYW5kIHBlcmZvcm1zXHJcbiAgICAgZnVsbC10ZXh0IHNlYXJjaGluZy5cclxuXHJcbiAgICAgQGNsYXNzIEJhY2tncmlkLkV4dGVuc2lvbi5MdW5yRmlsdGVyXHJcbiAgICAgQGV4dGVuZHMgQmFja2dyaWQuRXh0ZW5zaW9uLkNsaWVudFNpZGVGaWx0ZXJcclxuICAqL1xyXG4gIHZhciBMdW5yRmlsdGVyID0gQmFja2dyaWQuRXh0ZW5zaW9uLkx1bnJGaWx0ZXIgPSBDbGllbnRTaWRlRmlsdGVyLmV4dGVuZCh7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBAcHJvcGVydHkge3N0cmluZ30gW3JlZj1cImlkXCJd772AbHVucmpzYCBkb2N1bWVudCByZWZlcmVuY2UgYXR0cmlidXRlIG5hbWUuXHJcbiAgICAqL1xyXG4gICAgcmVmOiBcImlkXCIsXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBAcHJvcGVydHkge09iamVjdH0gZmllbGRzIEEgaGFzaCBvZiBgbHVucmpzYCBpbmRleCBmaWVsZCBuYW1lcyBhbmQgYm9vc3RcclxuICAgICAgIHZhbHVlLiBVbmxpa2UgQ2xpZW50U2lkZUZpbHRlciNmaWVsZHMsIEx1bnJGaWx0ZXIjZmllbGRzIGlzIF9yZXF1aXJlZF8gdG9cclxuICAgICAgIGluaXRpYWxpemUgdGhlIGluZGV4LlxyXG4gICAgKi9cclxuICAgIGZpZWxkczogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAgIEluZGV4ZXMgdGhlIHVuZGVybHlpbmcgY29sbGVjdGlvbiBvbiBjb25zdHJ1Y3Rpb24uIFRoZSBpbmRleCB3aWxsIHJlZnJlc2hcclxuICAgICAgIHdoZW4gdGhlIHVuZGVybHlpbmcgY29sbGVjdGlvbiBpcyByZXNldC4gSWYgYW55IG1vZGVsIGlzIGFkZGVkLCByZW1vdmVkXHJcbiAgICAgICBvciBpZiBhbnkgaW5kZXhlZCBmaWVsZHMgb2YgYW55IG1vZGVscyBoYXMgY2hhbmdlZCwgdGhlIGluZGV4IHdpbGwgYmVcclxuICAgICAgIHVwZGF0ZWQuXHJcblxyXG4gICAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICAgIEBwYXJhbSB7QmFja2JvbmUuQ29sbGVjdGlvbn0gb3B0aW9ucy5jb2xsZWN0aW9uXHJcbiAgICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGxhY2Vob2xkZXJdXHJcbiAgICAgICBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucmVmXSDvvYBsdW5yanNgIGRvY3VtZW50IHJlZmVyZW5jZSBhdHRyaWJ1dGUgbmFtZS5cclxuICAgICAgIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5maWVsZHNdIEEgaGFzaCBvZiBgbHVucmpzYCBpbmRleCBmaWVsZCBuYW1lcyBhbmRcclxuICAgICAgIGJvb3N0IHZhbHVlLlxyXG4gICAgICAgQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndhaXRdXHJcbiAgICAqL1xyXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgTHVuckZpbHRlci5fX3N1cGVyX18uaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgICAgdGhpcy5yZWYgPSBvcHRpb25zLnJlZiB8fCB0aGlzLnJlZjtcclxuXHJcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uLmZ1bGxDb2xsZWN0aW9uIHx8IHRoaXMuY29sbGVjdGlvbjtcclxuICAgICAgdGhpcy5saXN0ZW5Ubyhjb2xsZWN0aW9uLCBcImFkZFwiLCB0aGlzLmFkZFRvSW5kZXgpO1xyXG4gICAgICB0aGlzLmxpc3RlblRvKGNvbGxlY3Rpb24sIFwicmVtb3ZlXCIsIHRoaXMucmVtb3ZlRnJvbUluZGV4KTtcclxuICAgICAgdGhpcy5saXN0ZW5Ubyhjb2xsZWN0aW9uLCBcInJlc2V0XCIsIHRoaXMucmVzZXRJbmRleCk7XHJcbiAgICAgIHRoaXMubGlzdGVuVG8oY29sbGVjdGlvbiwgXCJjaGFuZ2VcIiwgdGhpcy51cGRhdGVJbmRleCk7XHJcblxyXG4gICAgICB0aGlzLnJlc2V0SW5kZXgoY29sbGVjdGlvbik7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgUmVpbmRleCB0aGUgY29sbGVjdGlvbi4gSWYgYG9wdGlvbnMucmVpbmRleGAgaXMgYGZhbHNlYCwgdGhpcyBtZXRob2QgaXMgYVxyXG4gICAgICAgbm8tb3AuXHJcblxyXG4gICAgICAgQHBhcmFtIHtCYWNrYm9uZS5Db2xsZWN0aW9ufSBjb2xsZWN0aW9uXHJcbiAgICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXHJcbiAgICAgICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnJlaW5kZXg9dHJ1ZV1cclxuICAgICovXHJcbiAgICByZXNldEluZGV4OiBmdW5jdGlvbiAoY29sbGVjdGlvbiwgb3B0aW9ucykge1xyXG4gICAgICBvcHRpb25zID0gXy5leHRlbmQoe3JlaW5kZXg6IHRydWV9LCBvcHRpb25zIHx8IHt9KTtcclxuXHJcbiAgICAgIGlmIChvcHRpb25zLnJlaW5kZXgpIHtcclxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGx1bnIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgXy5lYWNoKHNlbGYuZmllbGRzLCBmdW5jdGlvbiAoYm9vc3QsIGZpZWxkTmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZpZWxkKGZpZWxkTmFtZSwgYm9vc3QpO1xyXG4gICAgICAgICAgICB0aGlzLnJlZihzZWxmLnJlZik7XHJcbiAgICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29sbGVjdGlvbi5lYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgICAgdGhpcy5hZGRUb0luZGV4KG1vZGVsKTtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAgIEFkZHMgdGhlIGdpdmVuIG1vZGVsIHRvIHRoZSBpbmRleC5cclxuXHJcbiAgICAgICBAcGFyYW0ge0JhY2tib25lLk1vZGVsfSBtb2RlbFxyXG4gICAgKi9cclxuICAgIGFkZFRvSW5kZXg6IGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xyXG4gICAgICB2YXIgZG9jID0gbW9kZWwudG9KU09OKCk7XHJcbiAgICAgIGlmIChpbmRleC5kb2N1bWVudFN0b3JlLmhhcyhkb2NbdGhpcy5yZWZdKSkgaW5kZXgudXBkYXRlKGRvYyk7XHJcbiAgICAgIGVsc2UgaW5kZXguYWRkKGRvYyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgUmVtb3ZlcyB0aGUgZ2l2ZW4gbW9kZWwgZnJvbSB0aGUgaW5kZXguXHJcblxyXG4gICAgICAgQHBhcmFtIHtCYWNrYm9uZS5Nb2RlbH0gbW9kZWxcclxuICAgICovXHJcbiAgICByZW1vdmVGcm9tSW5kZXg6IGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xyXG4gICAgICB2YXIgZG9jID0gbW9kZWwudG9KU09OKCk7XHJcbiAgICAgIGlmIChpbmRleC5kb2N1bWVudFN0b3JlLmhhcyhkb2NbdGhpcy5yZWZdKSkgaW5kZXgucmVtb3ZlKGRvYyk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICAgVXBkYXRlcyB0aGUgaW5kZXggZm9yIHRoZSBnaXZlbiBtb2RlbC5cclxuXHJcbiAgICAgICBAcGFyYW0ge0JhY2tib25lLk1vZGVsfSBtb2RlbFxyXG4gICAgKi9cclxuICAgIHVwZGF0ZUluZGV4OiBmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgdmFyIGNoYW5nZWQgPSBtb2RlbC5jaGFuZ2VkQXR0cmlidXRlcygpO1xyXG4gICAgICBpZiAoY2hhbmdlZCAmJiAhXy5pc0VtcHR5KF8uaW50ZXJzZWN0aW9uKF8ua2V5cyh0aGlzLmZpZWxkcyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5rZXlzKGNoYW5nZWQpKSkpIHtcclxuICAgICAgICB0aGlzLmluZGV4LnVwZGF0ZShtb2RlbC50b0pTT04oKSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgICBUYWtlcyB0aGUgcXVlcnkgZnJvbSB0aGUgc2VhcmNoIGJveCBhbmQgcGVyZm9ybXMgYSBmdWxsLXRleHQgc2VhcmNoIG9uXHJcbiAgICAgICB0aGUgY2xpZW50LXNpZGUuIFRoZSBzZWFyY2ggcmVzdWx0IGlzIHJldHVybmVkIGJ5IHJlc2V0dGluZyB0aGVcclxuICAgICAgIHVuZGVybHlpbmcgY29sbGVjdGlvbiB0byB0aGUgbW9kZWxzIGFmdGVyIGludGVycm9nYXRpbmcgdGhlIGluZGV4IGZvciB0aGVcclxuICAgICAgIHF1ZXJ5IGFuc3dlci5cclxuXHJcbiAgICAgICBJZiB0aGUgY29sbGVjdGlvbiBpcyBhIFBhZ2VhYmxlQ29sbGVjdGlvbiwgc2VhcmNoaW5nIHdpbGwgZ28gYmFjayB0byB0aGVcclxuICAgICAgIGZpcnN0IHBhZ2UuXHJcbiAgICAqL1xyXG4gICAgc2VhcmNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBjb2wgPSB0aGlzLmNvbGxlY3Rpb247XHJcbiAgICAgIGlmICghdGhpcy5xdWVyeSgpKSB7XHJcbiAgICAgICAgY29sLnJlc2V0KHRoaXMuc2hhZG93Q29sbGVjdGlvbi5tb2RlbHMsIHtyZWluZGV4OiBmYWxzZX0pO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHNlYXJjaFJlc3VsdHMgPSB0aGlzLmluZGV4LnNlYXJjaCh0aGlzLnF1ZXJ5KCkpO1xyXG4gICAgICB2YXIgbW9kZWxzID0gW107XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VhcmNoUmVzdWx0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBzZWFyY2hSZXN1bHRzW2ldO1xyXG4gICAgICAgIG1vZGVscy5wdXNoKHRoaXMuc2hhZG93Q29sbGVjdGlvbi5nZXQocmVzdWx0LnJlZikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY29sLnBhZ2VhYmxlQ29sbGVjdGlvbikgY29sLnBhZ2VhYmxlQ29sbGVjdGlvbi5nZXRGaXJzdFBhZ2Uoe3NpbGVudDogdHJ1ZX0pO1xyXG4gICAgICBjb2wucmVzZXQobW9kZWxzLCB7cmVpbmRleDogZmFsc2V9KTtcclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG59KSk7XHJcbiIsIi8qKlxyXG4gKiBsdW5yIC0gaHR0cDovL2x1bnJqcy5jb20gLSBBIGJpdCBsaWtlIFNvbHIsIGJ1dCBtdWNoIHNtYWxsZXIgYW5kIG5vdCBhcyBicmlnaHQgLSAwLjQuNVxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTQgT2xpdmVyIE5pZ2h0aW5nYWxlXHJcbiAqIE1JVCBMaWNlbnNlZFxyXG4gKiBAbGljZW5zZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgaW5zdGFudGlhdGluZyBhIG5ldyBsdW5yIGluZGV4IGFuZCBjb25maWd1cmluZyBpdFxyXG4gKiB3aXRoIHRoZSBkZWZhdWx0IHBpcGVsaW5lIGZ1bmN0aW9ucyBhbmQgdGhlIHBhc3NlZCBjb25maWcgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIFdoZW4gdXNpbmcgdGhpcyBjb252ZW5pZW5jZSBmdW5jdGlvbiBhIG5ldyBpbmRleCB3aWxsIGJlIGNyZWF0ZWQgd2l0aCB0aGVcclxuICogZm9sbG93aW5nIGZ1bmN0aW9ucyBhbHJlYWR5IGluIHRoZSBwaXBlbGluZTpcclxuICpcclxuICogbHVuci5TdG9wV29yZEZpbHRlciAtIGZpbHRlcnMgb3V0IGFueSBzdG9wIHdvcmRzIGJlZm9yZSB0aGV5IGVudGVyIHRoZVxyXG4gKiBpbmRleFxyXG4gKlxyXG4gKiBsdW5yLnN0ZW1tZXIgLSBzdGVtcyB0aGUgdG9rZW5zIGJlZm9yZSBlbnRlcmluZyB0aGUgaW5kZXguXHJcbiAqXHJcbiAqIEV4YW1wbGU6XHJcbiAqXHJcbiAqICAgICB2YXIgaWR4ID0gbHVucihmdW5jdGlvbiAoKSB7XHJcbiAqICAgICAgIHRoaXMuZmllbGQoJ3RpdGxlJywgMTApXHJcbiAqICAgICAgIHRoaXMuZmllbGQoJ3RhZ3MnLCAxMDApXHJcbiAqICAgICAgIHRoaXMuZmllbGQoJ2JvZHknKVxyXG4gKiAgICAgICBcclxuICogICAgICAgdGhpcy5yZWYoJ2NpZCcpXHJcbiAqICAgICAgIFxyXG4gKiAgICAgICB0aGlzLnBpcGVsaW5lLmFkZChmdW5jdGlvbiAoKSB7XHJcbiAqICAgICAgICAgLy8gc29tZSBjdXN0b20gcGlwZWxpbmUgZnVuY3Rpb25cclxuICogICAgICAgfSlcclxuICogICAgICAgXHJcbiAqICAgICB9KVxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25maWcgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIG5ldyBpbnN0YW5jZVxyXG4gKiBvZiB0aGUgbHVuci5JbmRleCBhcyBib3RoIGl0cyBjb250ZXh0IGFuZCBmaXJzdCBwYXJhbWV0ZXIuIEl0IGNhbiBiZSB1c2VkIHRvXHJcbiAqIGN1c3RvbWl6ZSB0aGUgaW5zdGFuY2Ugb2YgbmV3IGx1bnIuSW5kZXguXHJcbiAqIEBuYW1lc3BhY2VcclxuICogQG1vZHVsZVxyXG4gKiBAcmV0dXJucyB7bHVuci5JbmRleH1cclxuICpcclxuICovXHJcbnZhciBsdW5yID0gZnVuY3Rpb24gKGNvbmZpZykge1xyXG4gIHZhciBpZHggPSBuZXcgbHVuci5JbmRleFxyXG5cclxuICBpZHgucGlwZWxpbmUuYWRkKGx1bnIuc3RvcFdvcmRGaWx0ZXIsIGx1bnIuc3RlbW1lcilcclxuXHJcbiAgaWYgKGNvbmZpZykgY29uZmlnLmNhbGwoaWR4LCBpZHgpXHJcblxyXG4gIHJldHVybiBpZHhcclxufVxyXG5cclxubHVuci52ZXJzaW9uID0gXCIwLjQuNVwiXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IGx1bnJcclxufVxyXG47XHJcbi8qIVxyXG4gKiBsdW5yLnV0aWxzXHJcbiAqIENvcHlyaWdodCAoQykgMjAxNCBPbGl2ZXIgTmlnaHRpbmdhbGVcclxuICovXHJcblxyXG4vKipcclxuICogQSBuYW1lc3BhY2UgY29udGFpbmluZyB1dGlscyBmb3IgdGhlIHJlc3Qgb2YgdGhlIGx1bnIgbGlicmFyeVxyXG4gKi9cclxubHVuci51dGlscyA9IHt9XHJcblxyXG4vKipcclxuICogUHJpbnQgYSB3YXJuaW5nIG1lc3NhZ2UgdG8gdGhlIGNvbnNvbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGJlIHByaW50ZWQuXHJcbiAqIEBtZW1iZXJPZiBVdGlsc1xyXG4gKi9cclxubHVuci51dGlscy53YXJuID0gKGZ1bmN0aW9uIChnbG9iYWwpIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcclxuICAgIGlmIChnbG9iYWwuY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcclxuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpXHJcbiAgICB9XHJcbiAgfVxyXG59KSh0aGlzKVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSB6ZXJvIGZpbGxlZCBhcnJheSBvZiB0aGUgbGVuZ3RoIHNwZWNpZmllZC5cclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIHplcm9zIHJlcXVpcmVkLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEBtZW1iZXJPZiBVdGlsc1xyXG4gKi9cclxubHVuci51dGlscy56ZXJvRmlsbEFycmF5ID0gKGZ1bmN0aW9uICgpIHtcclxuICB2YXIgemVyb3MgPSBbMF1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uIChsZW5ndGgpIHtcclxuICAgIHdoaWxlICh6ZXJvcy5sZW5ndGggPCBsZW5ndGgpIHtcclxuICAgICAgemVyb3MgPSB6ZXJvcy5jb25jYXQoemVyb3MpXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHplcm9zLnNsaWNlKDAsIGxlbmd0aClcclxuICB9XHJcbn0pKClcclxuO1xyXG4vKiFcclxuICogbHVuci5FdmVudEVtaXR0ZXJcclxuICogQ29weXJpZ2h0IChDKSAyMDE0IE9saXZlciBOaWdodGluZ2FsZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBsdW5yLkV2ZW50RW1pdHRlciBpcyBhbiBldmVudCBlbWl0dGVyIGZvciBsdW5yLiBJdCBtYW5hZ2VzIGFkZGluZyBhbmQgcmVtb3ZpbmcgZXZlbnQgaGFuZGxlcnMgYW5kIHRyaWdnZXJpbmcgZXZlbnRzIGFuZCB0aGVpciBoYW5kbGVycy5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5sdW5yLkV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLmV2ZW50cyA9IHt9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCaW5kcyBhIGhhbmRsZXIgZnVuY3Rpb24gdG8gYSBzcGVjaWZpYyBldmVudChzKS5cclxuICpcclxuICogQ2FuIGJpbmQgYSBzaW5nbGUgZnVuY3Rpb24gdG8gbWFueSBkaWZmZXJlbnQgZXZlbnRzIGluIG9uZSBjYWxsLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2V2ZW50TmFtZV0gVGhlIG5hbWUocykgb2YgZXZlbnRzIHRvIGJpbmQgdGhpcyBmdW5jdGlvbiB0by5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGFuIGV2ZW50IGlzIGZpcmVkLlxyXG4gKiBAbWVtYmVyT2YgRXZlbnRFbWl0dGVyXHJcbiAqL1xyXG5sdW5yLkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxyXG4gICAgICBmbiA9IGFyZ3MucG9wKCksXHJcbiAgICAgIG5hbWVzID0gYXJnc1xyXG5cclxuICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IgKFwibGFzdCBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb25cIilcclxuXHJcbiAgbmFtZXMuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgaWYgKCF0aGlzLmhhc0hhbmRsZXIobmFtZSkpIHRoaXMuZXZlbnRzW25hbWVdID0gW11cclxuICAgIHRoaXMuZXZlbnRzW25hbWVdLnB1c2goZm4pXHJcbiAgfSwgdGhpcylcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYSBoYW5kbGVyIGZ1bmN0aW9uIGZyb20gYSBzcGVjaWZpYyBldmVudC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlIHRoaXMgZnVuY3Rpb24gZnJvbS5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gYW4gZXZlbnQuXHJcbiAqIEBtZW1iZXJPZiBFdmVudEVtaXR0ZXJcclxuICovXHJcbmx1bnIuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xyXG4gIGlmICghdGhpcy5oYXNIYW5kbGVyKG5hbWUpKSByZXR1cm5cclxuXHJcbiAgdmFyIGZuSW5kZXggPSB0aGlzLmV2ZW50c1tuYW1lXS5pbmRleE9mKGZuKVxyXG4gIHRoaXMuZXZlbnRzW25hbWVdLnNwbGljZShmbkluZGV4LCAxKVxyXG5cclxuICBpZiAoIXRoaXMuZXZlbnRzW25hbWVdLmxlbmd0aCkgZGVsZXRlIHRoaXMuZXZlbnRzW25hbWVdXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxscyBhbGwgZnVuY3Rpb25zIGJvdW5kIHRvIHRoZSBnaXZlbiBldmVudC5cclxuICpcclxuICogQWRkaXRpb25hbCBkYXRhIGNhbiBiZSBwYXNzZWQgdG8gdGhlIGV2ZW50IGhhbmRsZXIgYXMgYXJndW1lbnRzIHRvIGBlbWl0YFxyXG4gKiBhZnRlciB0aGUgZXZlbnQgbmFtZS5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdC5cclxuICogQG1lbWJlck9mIEV2ZW50RW1pdHRlclxyXG4gKi9cclxubHVuci5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIGlmICghdGhpcy5oYXNIYW5kbGVyKG5hbWUpKSByZXR1cm5cclxuXHJcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcblxyXG4gIHRoaXMuZXZlbnRzW25hbWVdLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XHJcbiAgICBmbi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpXHJcbiAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIGEgaGFuZGxlciBoYXMgZXZlciBiZWVuIHN0b3JlZCBhZ2FpbnN0IGFuIGV2ZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBjaGVjay5cclxuICogQHByaXZhdGVcclxuICogQG1lbWJlck9mIEV2ZW50RW1pdHRlclxyXG4gKi9cclxubHVuci5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmhhc0hhbmRsZXIgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gIHJldHVybiBuYW1lIGluIHRoaXMuZXZlbnRzXHJcbn1cclxuXHJcbjtcclxuLyohXHJcbiAqIGx1bnIudG9rZW5pemVyXHJcbiAqIENvcHlyaWdodCAoQykgMjAxNCBPbGl2ZXIgTmlnaHRpbmdhbGVcclxuICovXHJcblxyXG4vKipcclxuICogQSBmdW5jdGlvbiBmb3Igc3BsaXR0aW5nIGEgc3RyaW5nIGludG8gdG9rZW5zIHJlYWR5IHRvIGJlIGluc2VydGVkIGludG9cclxuICogdGhlIHNlYXJjaCBpbmRleC5cclxuICpcclxuICogQG1vZHVsZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gb2JqIFRoZSBzdHJpbmcgdG8gY29udmVydCBpbnRvIHRva2Vuc1xyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xyXG5sdW5yLnRva2VuaXplciA9IGZ1bmN0aW9uIChvYmopIHtcclxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGggfHwgb2JqID09IG51bGwgfHwgb2JqID09IHVuZGVmaW5lZCkgcmV0dXJuIFtdXHJcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkgcmV0dXJuIG9iai5tYXAoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQudG9Mb3dlckNhc2UoKSB9KVxyXG5cclxuICB2YXIgc3RyID0gb2JqLnRvU3RyaW5nKCkucmVwbGFjZSgvXlxccysvLCAnJylcclxuXHJcbiAgZm9yICh2YXIgaSA9IHN0ci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgaWYgKC9cXFMvLnRlc3Qoc3RyLmNoYXJBdChpKSkpIHtcclxuICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpICsgMSlcclxuICAgICAgYnJlYWtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzdHJcclxuICAgIC5zcGxpdCgvXFxzKy8pXHJcbiAgICAubWFwKGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgICByZXR1cm4gdG9rZW4ucmVwbGFjZSgvXlxcVysvLCAnJykucmVwbGFjZSgvXFxXKyQvLCAnJykudG9Mb3dlckNhc2UoKVxyXG4gICAgfSlcclxufVxyXG47XHJcbi8qIVxyXG4gKiBsdW5yLlBpcGVsaW5lXHJcbiAqIENvcHlyaWdodCAoQykgMjAxNCBPbGl2ZXIgTmlnaHRpbmdhbGVcclxuICovXHJcblxyXG4vKipcclxuICogbHVuci5QaXBlbGluZXMgbWFpbnRhaW4gYW4gb3JkZXJlZCBsaXN0IG9mIGZ1bmN0aW9ucyB0byBiZSBhcHBsaWVkIHRvIGFsbFxyXG4gKiB0b2tlbnMgaW4gZG9jdW1lbnRzIGVudGVyaW5nIHRoZSBzZWFyY2ggaW5kZXggYW5kIHF1ZXJpZXMgYmVpbmcgcmFuIGFnYWluc3RcclxuICogdGhlIGluZGV4LlxyXG4gKlxyXG4gKiBBbiBpbnN0YW5jZSBvZiBsdW5yLkluZGV4IGNyZWF0ZWQgd2l0aCB0aGUgbHVuciBzaG9ydGN1dCB3aWxsIGNvbnRhaW4gYVxyXG4gKiBwaXBlbGluZSB3aXRoIGEgc3RvcCB3b3JkIGZpbHRlciBhbmQgYW4gRW5nbGlzaCBsYW5ndWFnZSBzdGVtbWVyLiBFeHRyYVxyXG4gKiBmdW5jdGlvbnMgY2FuIGJlIGFkZGVkIGJlZm9yZSBvciBhZnRlciBlaXRoZXIgb2YgdGhlc2UgZnVuY3Rpb25zIG9yIHRoZXNlXHJcbiAqIGRlZmF1bHQgZnVuY3Rpb25zIGNhbiBiZSByZW1vdmVkLlxyXG4gKlxyXG4gKiBXaGVuIHJ1biB0aGUgcGlwZWxpbmUgd2lsbCBjYWxsIGVhY2ggZnVuY3Rpb24gaW4gdHVybiwgcGFzc2luZyBhIHRva2VuLCB0aGVcclxuICogaW5kZXggb2YgdGhhdCB0b2tlbiBpbiB0aGUgb3JpZ2luYWwgbGlzdCBvZiBhbGwgdG9rZW5zIGFuZCBmaW5hbGx5IGEgbGlzdCBvZlxyXG4gKiBhbGwgdGhlIG9yaWdpbmFsIHRva2Vucy5cclxuICpcclxuICogVGhlIG91dHB1dCBvZiBmdW5jdGlvbnMgaW4gdGhlIHBpcGVsaW5lIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBuZXh0IGZ1bmN0aW9uXHJcbiAqIGluIHRoZSBwaXBlbGluZS4gVG8gZXhjbHVkZSBhIHRva2VuIGZyb20gZW50ZXJpbmcgdGhlIGluZGV4IHRoZSBmdW5jdGlvblxyXG4gKiBzaG91bGQgcmV0dXJuIHVuZGVmaW5lZCwgdGhlIHJlc3Qgb2YgdGhlIHBpcGVsaW5lIHdpbGwgbm90IGJlIGNhbGxlZCB3aXRoXHJcbiAqIHRoaXMgdG9rZW4uXHJcbiAqXHJcbiAqIEZvciBzZXJpYWxpc2F0aW9uIG9mIHBpcGVsaW5lcyB0byB3b3JrLCBhbGwgZnVuY3Rpb25zIHVzZWQgaW4gYW4gaW5zdGFuY2Ugb2ZcclxuICogYSBwaXBlbGluZSBzaG91bGQgYmUgcmVnaXN0ZXJlZCB3aXRoIGx1bnIuUGlwZWxpbmUuIFJlZ2lzdGVyZWQgZnVuY3Rpb25zIGNhblxyXG4gKiB0aGVuIGJlIGxvYWRlZC4gSWYgdHJ5aW5nIHRvIGxvYWQgYSBzZXJpYWxpc2VkIHBpcGVsaW5lIHRoYXQgdXNlcyBmdW5jdGlvbnNcclxuICogdGhhdCBhcmUgbm90IHJlZ2lzdGVyZWQgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcbiAqXHJcbiAqIElmIG5vdCBwbGFubmluZyBvbiBzZXJpYWxpc2luZyB0aGUgcGlwZWxpbmUgdGhlbiByZWdpc3RlcmluZyBwaXBlbGluZSBmdW5jdGlvbnNcclxuICogaXMgbm90IG5lY2Vzc2FyeS5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5sdW5yLlBpcGVsaW5lID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuX3N0YWNrID0gW11cclxufVxyXG5cclxubHVuci5QaXBlbGluZS5yZWdpc3RlcmVkRnVuY3Rpb25zID0ge31cclxuXHJcbi8qKlxyXG4gKiBSZWdpc3RlciBhIGZ1bmN0aW9uIHdpdGggdGhlIHBpcGVsaW5lLlxyXG4gKlxyXG4gKiBGdW5jdGlvbnMgdGhhdCBhcmUgdXNlZCBpbiB0aGUgcGlwZWxpbmUgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgaWYgdGhlIHBpcGVsaW5lXHJcbiAqIG5lZWRzIHRvIGJlIHNlcmlhbGlzZWQsIG9yIGEgc2VyaWFsaXNlZCBwaXBlbGluZSBuZWVkcyB0byBiZSBsb2FkZWQuXHJcbiAqXHJcbiAqIFJlZ2lzdGVyaW5nIGEgZnVuY3Rpb24gZG9lcyBub3QgYWRkIGl0IHRvIGEgcGlwZWxpbmUsIGZ1bmN0aW9ucyBtdXN0IHN0aWxsIGJlXHJcbiAqIGFkZGVkIHRvIGluc3RhbmNlcyBvZiB0aGUgcGlwZWxpbmUgZm9yIHRoZW0gdG8gYmUgdXNlZCB3aGVuIHJ1bm5pbmcgYSBwaXBlbGluZS5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIGZvci5cclxuICogQHBhcmFtIHtTdHJpbmd9IGxhYmVsIFRoZSBsYWJlbCB0byByZWdpc3RlciB0aGlzIGZ1bmN0aW9uIHdpdGhcclxuICogQG1lbWJlck9mIFBpcGVsaW5lXHJcbiAqL1xyXG5sdW5yLlBpcGVsaW5lLnJlZ2lzdGVyRnVuY3Rpb24gPSBmdW5jdGlvbiAoZm4sIGxhYmVsKSB7XHJcbiAgaWYgKGxhYmVsIGluIHRoaXMucmVnaXN0ZXJlZEZ1bmN0aW9ucykge1xyXG4gICAgbHVuci51dGlscy53YXJuKCdPdmVyd3JpdGluZyBleGlzdGluZyByZWdpc3RlcmVkIGZ1bmN0aW9uOiAnICsgbGFiZWwpXHJcbiAgfVxyXG5cclxuICBmbi5sYWJlbCA9IGxhYmVsXHJcbiAgbHVuci5QaXBlbGluZS5yZWdpc3RlcmVkRnVuY3Rpb25zW2ZuLmxhYmVsXSA9IGZuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBXYXJucyBpZiB0aGUgZnVuY3Rpb24gaXMgbm90IHJlZ2lzdGVyZWQgYXMgYSBQaXBlbGluZSBmdW5jdGlvbi5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIGZvci5cclxuICogQHByaXZhdGVcclxuICogQG1lbWJlck9mIFBpcGVsaW5lXHJcbiAqL1xyXG5sdW5yLlBpcGVsaW5lLndhcm5JZkZ1bmN0aW9uTm90UmVnaXN0ZXJlZCA9IGZ1bmN0aW9uIChmbikge1xyXG4gIHZhciBpc1JlZ2lzdGVyZWQgPSBmbi5sYWJlbCAmJiAoZm4ubGFiZWwgaW4gdGhpcy5yZWdpc3RlcmVkRnVuY3Rpb25zKVxyXG5cclxuICBpZiAoIWlzUmVnaXN0ZXJlZCkge1xyXG4gICAgbHVuci51dGlscy53YXJuKCdGdW5jdGlvbiBpcyBub3QgcmVnaXN0ZXJlZCB3aXRoIHBpcGVsaW5lLiBUaGlzIG1heSBjYXVzZSBwcm9ibGVtcyB3aGVuIHNlcmlhbGlzaW5nIHRoZSBpbmRleC5cXG4nLCBmbilcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkcyBhIHByZXZpb3VzbHkgc2VyaWFsaXNlZCBwaXBlbGluZS5cclxuICpcclxuICogQWxsIGZ1bmN0aW9ucyB0byBiZSBsb2FkZWQgbXVzdCBhbHJlYWR5IGJlIHJlZ2lzdGVyZWQgd2l0aCBsdW5yLlBpcGVsaW5lLlxyXG4gKiBJZiBhbnkgZnVuY3Rpb24gZnJvbSB0aGUgc2VyaWFsaXNlZCBkYXRhIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHRoZW4gYW5cclxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpYWxpc2VkIFRoZSBzZXJpYWxpc2VkIHBpcGVsaW5lIHRvIGxvYWQuXHJcbiAqIEByZXR1cm5zIHtsdW5yLlBpcGVsaW5lfVxyXG4gKiBAbWVtYmVyT2YgUGlwZWxpbmVcclxuICovXHJcbmx1bnIuUGlwZWxpbmUubG9hZCA9IGZ1bmN0aW9uIChzZXJpYWxpc2VkKSB7XHJcbiAgdmFyIHBpcGVsaW5lID0gbmV3IGx1bnIuUGlwZWxpbmVcclxuXHJcbiAgc2VyaWFsaXNlZC5mb3JFYWNoKGZ1bmN0aW9uIChmbk5hbWUpIHtcclxuICAgIHZhciBmbiA9IGx1bnIuUGlwZWxpbmUucmVnaXN0ZXJlZEZ1bmN0aW9uc1tmbk5hbWVdXHJcblxyXG4gICAgaWYgKGZuKSB7XHJcbiAgICAgIHBpcGVsaW5lLmFkZChmbilcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvciAoJ0Nhbm5vdCBsb2FkIHVuLXJlZ2lzdGVyZWQgZnVuY3Rpb246ICcgKyBmbk5hbWUpXHJcbiAgICB9XHJcbiAgfSlcclxuXHJcbiAgcmV0dXJuIHBpcGVsaW5lXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIG5ldyBmdW5jdGlvbnMgdG8gdGhlIGVuZCBvZiB0aGUgcGlwZWxpbmUuXHJcbiAqXHJcbiAqIExvZ3MgYSB3YXJuaW5nIGlmIHRoZSBmdW5jdGlvbiBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb25zIEFueSBudW1iZXIgb2YgZnVuY3Rpb25zIHRvIGFkZCB0byB0aGUgcGlwZWxpbmUuXHJcbiAqIEBtZW1iZXJPZiBQaXBlbGluZVxyXG4gKi9cclxubHVuci5QaXBlbGluZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBmbnMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXHJcblxyXG4gIGZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xyXG4gICAgbHVuci5QaXBlbGluZS53YXJuSWZGdW5jdGlvbk5vdFJlZ2lzdGVyZWQoZm4pXHJcbiAgICB0aGlzLl9zdGFjay5wdXNoKGZuKVxyXG4gIH0sIHRoaXMpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgc2luZ2xlIGZ1bmN0aW9uIGFmdGVyIGEgZnVuY3Rpb24gdGhhdCBhbHJlYWR5IGV4aXN0cyBpbiB0aGVcclxuICogcGlwZWxpbmUuXHJcbiAqXHJcbiAqIExvZ3MgYSB3YXJuaW5nIGlmIHRoZSBmdW5jdGlvbiBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhpc3RpbmdGbiBBIGZ1bmN0aW9uIHRoYXQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIHBpcGVsaW5lLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBuZXdGbiBUaGUgbmV3IGZ1bmN0aW9uIHRvIGFkZCB0byB0aGUgcGlwZWxpbmUuXHJcbiAqIEBtZW1iZXJPZiBQaXBlbGluZVxyXG4gKi9cclxubHVuci5QaXBlbGluZS5wcm90b3R5cGUuYWZ0ZXIgPSBmdW5jdGlvbiAoZXhpc3RpbmdGbiwgbmV3Rm4pIHtcclxuICBsdW5yLlBpcGVsaW5lLndhcm5JZkZ1bmN0aW9uTm90UmVnaXN0ZXJlZChuZXdGbilcclxuXHJcbiAgdmFyIHBvcyA9IHRoaXMuX3N0YWNrLmluZGV4T2YoZXhpc3RpbmdGbikgKyAxXHJcbiAgdGhpcy5fc3RhY2suc3BsaWNlKHBvcywgMCwgbmV3Rm4pXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgc2luZ2xlIGZ1bmN0aW9uIGJlZm9yZSBhIGZ1bmN0aW9uIHRoYXQgYWxyZWFkeSBleGlzdHMgaW4gdGhlXHJcbiAqIHBpcGVsaW5lLlxyXG4gKlxyXG4gKiBMb2dzIGEgd2FybmluZyBpZiB0aGUgZnVuY3Rpb24gaGFzIG5vdCBiZWVuIHJlZ2lzdGVyZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4aXN0aW5nRm4gQSBmdW5jdGlvbiB0aGF0IGFscmVhZHkgZXhpc3RzIGluIHRoZSBwaXBlbGluZS5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gbmV3Rm4gVGhlIG5ldyBmdW5jdGlvbiB0byBhZGQgdG8gdGhlIHBpcGVsaW5lLlxyXG4gKiBAbWVtYmVyT2YgUGlwZWxpbmVcclxuICovXHJcbmx1bnIuUGlwZWxpbmUucHJvdG90eXBlLmJlZm9yZSA9IGZ1bmN0aW9uIChleGlzdGluZ0ZuLCBuZXdGbikge1xyXG4gIGx1bnIuUGlwZWxpbmUud2FybklmRnVuY3Rpb25Ob3RSZWdpc3RlcmVkKG5ld0ZuKVxyXG5cclxuICB2YXIgcG9zID0gdGhpcy5fc3RhY2suaW5kZXhPZihleGlzdGluZ0ZuKVxyXG4gIHRoaXMuX3N0YWNrLnNwbGljZShwb3MsIDAsIG5ld0ZuKVxyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyBhIGZ1bmN0aW9uIGZyb20gdGhlIHBpcGVsaW5lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gcmVtb3ZlIGZyb20gdGhlIHBpcGVsaW5lLlxyXG4gKiBAbWVtYmVyT2YgUGlwZWxpbmVcclxuICovXHJcbmx1bnIuUGlwZWxpbmUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChmbikge1xyXG4gIHZhciBwb3MgPSB0aGlzLl9zdGFjay5pbmRleE9mKGZuKVxyXG4gIHRoaXMuX3N0YWNrLnNwbGljZShwb3MsIDEpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSdW5zIHRoZSBjdXJyZW50IGxpc3Qgb2YgZnVuY3Rpb25zIHRoYXQgbWFrZSB1cCB0aGUgcGlwZWxpbmUgYWdhaW5zdCB0aGVcclxuICogcGFzc2VkIHRva2Vucy5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gdG9rZW5zIFRoZSB0b2tlbnMgdG8gcnVuIHRocm91Z2ggdGhlIHBpcGVsaW5lLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEBtZW1iZXJPZiBQaXBlbGluZVxyXG4gKi9cclxubHVuci5QaXBlbGluZS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKHRva2Vucykge1xyXG4gIHZhciBvdXQgPSBbXSxcclxuICAgICAgdG9rZW5MZW5ndGggPSB0b2tlbnMubGVuZ3RoLFxyXG4gICAgICBzdGFja0xlbmd0aCA9IHRoaXMuX3N0YWNrLmxlbmd0aFxyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2VuTGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxyXG5cclxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3RhY2tMZW5ndGg7IGorKykge1xyXG4gICAgICB0b2tlbiA9IHRoaXMuX3N0YWNrW2pdKHRva2VuLCBpLCB0b2tlbnMpXHJcbiAgICAgIGlmICh0b2tlbiA9PT0gdm9pZCAwKSBicmVha1xyXG4gICAgfTtcclxuXHJcbiAgICBpZiAodG9rZW4gIT09IHZvaWQgMCkgb3V0LnB1c2godG9rZW4pXHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIG91dFxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwaXBlbGluZSByZWFkeSBmb3Igc2VyaWFsaXNhdGlvbi5cclxuICpcclxuICogTG9ncyBhIHdhcm5pbmcgaWYgdGhlIGZ1bmN0aW9uIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEBtZW1iZXJPZiBQaXBlbGluZVxyXG4gKi9cclxubHVuci5QaXBlbGluZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLl9zdGFjay5tYXAoZnVuY3Rpb24gKGZuKSB7XHJcbiAgICBsdW5yLlBpcGVsaW5lLndhcm5JZkZ1bmN0aW9uTm90UmVnaXN0ZXJlZChmbilcclxuXHJcbiAgICByZXR1cm4gZm4ubGFiZWxcclxuICB9KVxyXG59XHJcbjtcclxuLyohXHJcbiAqIGx1bnIuVmVjdG9yXHJcbiAqIENvcHlyaWdodCAoQykgMjAxNCBPbGl2ZXIgTmlnaHRpbmdhbGVcclxuICovXHJcblxyXG4vKipcclxuICogbHVuci5WZWN0b3JzIHdyYXAgYXJyYXlzIGFuZCBhZGQgdmVjdG9yIHJlbGF0ZWQgb3BlcmF0aW9ucyBmb3IgdGhlIGFycmF5XHJcbiAqIGVsZW1lbnRzLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICogQHBhcmFtIHtBcnJheX0gZWxlbWVudHMgRWxlbWVudHMgdGhhdCBtYWtlIHVwIHRoZSB2ZWN0b3IuXHJcbiAqL1xyXG5sdW5yLlZlY3RvciA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xyXG4gIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50c1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgbWFnbml0dWRlIG9mIHRoaXMgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gKiBAbWVtYmVyT2YgVmVjdG9yXHJcbiAqL1xyXG5sdW5yLlZlY3Rvci5wcm90b3R5cGUubWFnbml0dWRlID0gZnVuY3Rpb24gKCkge1xyXG4gIGlmICh0aGlzLl9tYWduaXR1ZGUpIHJldHVybiB0aGlzLl9tYWduaXR1ZGVcclxuXHJcbiAgdmFyIHN1bU9mU3F1YXJlcyA9IDAsXHJcbiAgICAgIGVsZW1zID0gdGhpcy5lbGVtZW50cyxcclxuICAgICAgbGVuID0gZWxlbXMubGVuZ3RoLFxyXG4gICAgICBlbFxyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICBlbCA9IGVsZW1zW2ldXHJcbiAgICBzdW1PZlNxdWFyZXMgKz0gZWwgKiBlbFxyXG4gIH07XHJcblxyXG4gIHJldHVybiB0aGlzLl9tYWduaXR1ZGUgPSBNYXRoLnNxcnQoc3VtT2ZTcXVhcmVzKVxyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdGhpcyB2ZWN0b3IgYW5kIGFub3RoZXIgdmVjdG9yLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2x1bnIuVmVjdG9yfSBvdGhlclZlY3RvciBUaGUgdmVjdG9yIHRvIGNvbXB1dGUgdGhlIGRvdCBwcm9kdWN0IHdpdGguXHJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XHJcbiAqIEBtZW1iZXJPZiBWZWN0b3JcclxuICovXHJcbmx1bnIuVmVjdG9yLnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbiAob3RoZXJWZWN0b3IpIHtcclxuICB2YXIgZWxlbTEgPSB0aGlzLmVsZW1lbnRzLFxyXG4gICAgICBlbGVtMiA9IG90aGVyVmVjdG9yLmVsZW1lbnRzLFxyXG4gICAgICBsZW5ndGggPSBlbGVtMS5sZW5ndGgsXHJcbiAgICAgIGRvdFByb2R1Y3QgPSAwXHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgIGRvdFByb2R1Y3QgKz0gZWxlbTFbaV0gKiBlbGVtMltpXVxyXG4gIH07XHJcblxyXG4gIHJldHVybiBkb3RQcm9kdWN0XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBjb3NpbmUgc2ltaWxhcml0eSBiZXR3ZWVuIHRoaXMgdmVjdG9yIGFuZCBhbm90aGVyXHJcbiAqIHZlY3Rvci5cclxuICpcclxuICogQHBhcmFtIHtsdW5yLlZlY3Rvcn0gb3RoZXJWZWN0b3IgVGhlIG90aGVyIHZlY3RvciB0byBjYWxjdWxhdGUgdGhlXHJcbiAqIHNpbWlsYXJpdHkgd2l0aC5cclxuICogQHJldHVybnMge051bWJlcn1cclxuICogQG1lbWJlck9mIFZlY3RvclxyXG4gKi9cclxubHVuci5WZWN0b3IucHJvdG90eXBlLnNpbWlsYXJpdHkgPSBmdW5jdGlvbiAob3RoZXJWZWN0b3IpIHtcclxuICByZXR1cm4gdGhpcy5kb3Qob3RoZXJWZWN0b3IpIC8gKHRoaXMubWFnbml0dWRlKCkgKiBvdGhlclZlY3Rvci5tYWduaXR1ZGUoKSlcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIHRoaXMgdmVjdG9yIGJhY2sgaW50byBhbiBhcnJheS5cclxuICpcclxuICogQHJldHVybnMge0FycmF5fVxyXG4gKiBAbWVtYmVyT2YgVmVjdG9yXHJcbiAqL1xyXG5sdW5yLlZlY3Rvci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy5lbGVtZW50c1xyXG59XHJcbjtcclxuLyohXHJcbiAqIGx1bnIuU29ydGVkU2V0XHJcbiAqIENvcHlyaWdodCAoQykgMjAxNCBPbGl2ZXIgTmlnaHRpbmdhbGVcclxuICovXHJcblxyXG4vKipcclxuICogbHVuci5Tb3J0ZWRTZXRzIGFyZSB1c2VkIHRvIG1haW50YWluIGFuIGFycmF5IG9mIHVuaXEgdmFsdWVzIGluIGEgc29ydGVkXHJcbiAqIG9yZGVyLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmx1bnIuU29ydGVkU2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMubGVuZ3RoID0gMFxyXG4gIHRoaXMuZWxlbWVudHMgPSBbXVxyXG59XHJcblxyXG4vKipcclxuICogTG9hZHMgYSBwcmV2aW91c2x5IHNlcmlhbGlzZWQgc29ydGVkIHNldC5cclxuICpcclxuICogQHBhcmFtIHtBcnJheX0gc2VyaWFsaXNlZERhdGEgVGhlIHNlcmlhbGlzZWQgc2V0IHRvIGxvYWQuXHJcbiAqIEByZXR1cm5zIHtsdW5yLlNvcnRlZFNldH1cclxuICogQG1lbWJlck9mIFNvcnRlZFNldFxyXG4gKi9cclxubHVuci5Tb3J0ZWRTZXQubG9hZCA9IGZ1bmN0aW9uIChzZXJpYWxpc2VkRGF0YSkge1xyXG4gIHZhciBzZXQgPSBuZXcgdGhpc1xyXG5cclxuICBzZXQuZWxlbWVudHMgPSBzZXJpYWxpc2VkRGF0YVxyXG4gIHNldC5sZW5ndGggPSBzZXJpYWxpc2VkRGF0YS5sZW5ndGhcclxuXHJcbiAgcmV0dXJuIHNldFxyXG59XHJcblxyXG4vKipcclxuICogSW5zZXJ0cyBuZXcgaXRlbXMgaW50byB0aGUgc2V0IGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uIHRvIG1haW50YWluIHRoZVxyXG4gKiBvcmRlci5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IFRoZSBvYmplY3RzIHRvIGFkZCB0byB0aGlzIHNldC5cclxuICogQG1lbWJlck9mIFNvcnRlZFNldFxyXG4gKi9cclxubHVuci5Tb3J0ZWRTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICgpIHtcclxuICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgIGlmICh+dGhpcy5pbmRleE9mKGVsZW1lbnQpKSByZXR1cm5cclxuICAgIHRoaXMuZWxlbWVudHMuc3BsaWNlKHRoaXMubG9jYXRpb25Gb3IoZWxlbWVudCksIDAsIGVsZW1lbnQpXHJcbiAgfSwgdGhpcylcclxuXHJcbiAgdGhpcy5sZW5ndGggPSB0aGlzLmVsZW1lbnRzLmxlbmd0aFxyXG59XHJcblxyXG4vKipcclxuICogQ29udmVydHMgdGhpcyBzb3J0ZWQgc2V0IGludG8gYW4gYXJyYXkuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQG1lbWJlck9mIFNvcnRlZFNldFxyXG4gKi9cclxubHVuci5Tb3J0ZWRTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHRoaXMuZWxlbWVudHMuc2xpY2UoKVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBhcnJheSB3aXRoIHRoZSByZXN1bHRzIG9mIGNhbGxpbmcgYSBwcm92aWRlZCBmdW5jdGlvbiBvbiBldmVyeVxyXG4gKiBlbGVtZW50IGluIHRoaXMgc29ydGVkIHNldC5cclxuICpcclxuICogRGVsZWdhdGVzIHRvIEFycmF5LnByb3RvdHlwZS5tYXAgYW5kIGhhcyB0aGUgc2FtZSBzaWduYXR1cmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBlYWNoIGVsZW1lbnQgb2YgdGhlXHJcbiAqIHNldC5cclxuICogQHBhcmFtIHtPYmplY3R9IGN0eCBBbiBvcHRpb25hbCBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCBhcyB0aGUgY29udGV4dFxyXG4gKiBmb3IgdGhlIGZ1bmN0aW9uIGZuLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEBtZW1iZXJPZiBTb3J0ZWRTZXRcclxuICovXHJcbmx1bnIuU29ydGVkU2V0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIGN0eCkge1xyXG4gIHJldHVybiB0aGlzLmVsZW1lbnRzLm1hcChmbiwgY3R4KVxyXG59XHJcblxyXG4vKipcclxuICogRXhlY3V0ZXMgYSBwcm92aWRlZCBmdW5jdGlvbiBvbmNlIHBlciBzb3J0ZWQgc2V0IGVsZW1lbnQuXHJcbiAqXHJcbiAqIERlbGVnYXRlcyB0byBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCBhbmQgaGFzIHRoZSBzYW1lIHNpZ25hdHVyZS5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIG9uIGVhY2ggZWxlbWVudCBvZiB0aGVcclxuICogc2V0LlxyXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4IEFuIG9wdGlvbmFsIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGFzIHRoZSBjb250ZXh0XHJcbiAqIEBtZW1iZXJPZiBTb3J0ZWRTZXRcclxuICogZm9yIHRoZSBmdW5jdGlvbiBmbi5cclxuICovXHJcbmx1bnIuU29ydGVkU2V0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCBjdHgpIHtcclxuICByZXR1cm4gdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZuLCBjdHgpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBhIGdpdmVuIGVsZW1lbnQgY2FuIGJlIGZvdW5kIGluIHRoZVxyXG4gKiBzb3J0ZWQgc2V0LCBvciAtMSBpZiBpdCBpcyBub3QgcHJlc2VudC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGVsZW0gVGhlIG9iamVjdCB0byBsb2NhdGUgaW4gdGhlIHNvcnRlZCBzZXQuXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBBbiBvcHRpb25hbCBpbmRleCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmcgZnJvbVxyXG4gKiB3aXRoaW4gdGhlIHNldC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBBbiBvcHRpb25hbCBpbmRleCBhdCB3aGljaCB0byBzdG9wIHNlYXJjaCBmcm9tIHdpdGhpblxyXG4gKiB0aGUgc2V0LlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gKiBAbWVtYmVyT2YgU29ydGVkU2V0XHJcbiAqL1xyXG5sdW5yLlNvcnRlZFNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIChlbGVtLCBzdGFydCwgZW5kKSB7XHJcbiAgdmFyIHN0YXJ0ID0gc3RhcnQgfHwgMCxcclxuICAgICAgZW5kID0gZW5kIHx8IHRoaXMuZWxlbWVudHMubGVuZ3RoLFxyXG4gICAgICBzZWN0aW9uTGVuZ3RoID0gZW5kIC0gc3RhcnQsXHJcbiAgICAgIHBpdm90ID0gc3RhcnQgKyBNYXRoLmZsb29yKHNlY3Rpb25MZW5ndGggLyAyKSxcclxuICAgICAgcGl2b3RFbGVtID0gdGhpcy5lbGVtZW50c1twaXZvdF1cclxuXHJcbiAgaWYgKHNlY3Rpb25MZW5ndGggPD0gMSkge1xyXG4gICAgaWYgKHBpdm90RWxlbSA9PT0gZWxlbSkge1xyXG4gICAgICByZXR1cm4gcGl2b3RcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiAtMVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHBpdm90RWxlbSA8IGVsZW0pIHJldHVybiB0aGlzLmluZGV4T2YoZWxlbSwgcGl2b3QsIGVuZClcclxuICBpZiAocGl2b3RFbGVtID4gZWxlbSkgcmV0dXJuIHRoaXMuaW5kZXhPZihlbGVtLCBzdGFydCwgcGl2b3QpXHJcbiAgaWYgKHBpdm90RWxlbSA9PT0gZWxlbSkgcmV0dXJuIHBpdm90XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwb3NpdGlvbiB3aXRoaW4gdGhlIHNvcnRlZCBzZXQgdGhhdCBhbiBlbGVtZW50IHNob3VsZCBiZVxyXG4gKiBpbnNlcnRlZCBhdCB0byBtYWludGFpbiB0aGUgY3VycmVudCBvcmRlciBvZiB0aGUgc2V0LlxyXG4gKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGUgZWxlbWVudCB0byBzZWFyY2ggZm9yIGRvZXMgbm90IGFscmVhZHkgZXhpc3RcclxuICogaW4gdGhlIHNvcnRlZCBzZXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtIFRoZSBlbGVtIHRvIGZpbmQgdGhlIHBvc2l0aW9uIGZvciBpbiB0aGUgc2V0XHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBBbiBvcHRpb25hbCBpbmRleCBhdCB3aGljaCB0byBzdGFydCBzZWFyY2hpbmcgZnJvbVxyXG4gKiB3aXRoaW4gdGhlIHNldC5cclxuICogQHBhcmFtIHtOdW1iZXJ9IGVuZCBBbiBvcHRpb25hbCBpbmRleCBhdCB3aGljaCB0byBzdG9wIHNlYXJjaCBmcm9tIHdpdGhpblxyXG4gKiB0aGUgc2V0LlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxyXG4gKiBAbWVtYmVyT2YgU29ydGVkU2V0XHJcbiAqL1xyXG5sdW5yLlNvcnRlZFNldC5wcm90b3R5cGUubG9jYXRpb25Gb3IgPSBmdW5jdGlvbiAoZWxlbSwgc3RhcnQsIGVuZCkge1xyXG4gIHZhciBzdGFydCA9IHN0YXJ0IHx8IDAsXHJcbiAgICAgIGVuZCA9IGVuZCB8fCB0aGlzLmVsZW1lbnRzLmxlbmd0aCxcclxuICAgICAgc2VjdGlvbkxlbmd0aCA9IGVuZCAtIHN0YXJ0LFxyXG4gICAgICBwaXZvdCA9IHN0YXJ0ICsgTWF0aC5mbG9vcihzZWN0aW9uTGVuZ3RoIC8gMiksXHJcbiAgICAgIHBpdm90RWxlbSA9IHRoaXMuZWxlbWVudHNbcGl2b3RdXHJcblxyXG4gIGlmIChzZWN0aW9uTGVuZ3RoIDw9IDEpIHtcclxuICAgIGlmIChwaXZvdEVsZW0gPiBlbGVtKSByZXR1cm4gcGl2b3RcclxuICAgIGlmIChwaXZvdEVsZW0gPCBlbGVtKSByZXR1cm4gcGl2b3QgKyAxXHJcbiAgfVxyXG5cclxuICBpZiAocGl2b3RFbGVtIDwgZWxlbSkgcmV0dXJuIHRoaXMubG9jYXRpb25Gb3IoZWxlbSwgcGl2b3QsIGVuZClcclxuICBpZiAocGl2b3RFbGVtID4gZWxlbSkgcmV0dXJuIHRoaXMubG9jYXRpb25Gb3IoZWxlbSwgc3RhcnQsIHBpdm90KVxyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBsdW5yLlNvcnRlZFNldCB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50cyBpbiB0aGUgaW50ZXJzZWN0aW9uXHJcbiAqIG9mIHRoaXMgc2V0IGFuZCB0aGUgcGFzc2VkIHNldC5cclxuICpcclxuICogQHBhcmFtIHtsdW5yLlNvcnRlZFNldH0gb3RoZXJTZXQgVGhlIHNldCB0byBpbnRlcnNlY3Qgd2l0aCB0aGlzIHNldC5cclxuICogQHJldHVybnMge2x1bnIuU29ydGVkU2V0fVxyXG4gKiBAbWVtYmVyT2YgU29ydGVkU2V0XHJcbiAqL1xyXG5sdW5yLlNvcnRlZFNldC5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24gKG90aGVyU2V0KSB7XHJcbiAgdmFyIGludGVyc2VjdFNldCA9IG5ldyBsdW5yLlNvcnRlZFNldCxcclxuICAgICAgaSA9IDAsIGogPSAwLFxyXG4gICAgICBhX2xlbiA9IHRoaXMubGVuZ3RoLCBiX2xlbiA9IG90aGVyU2V0Lmxlbmd0aCxcclxuICAgICAgYSA9IHRoaXMuZWxlbWVudHMsIGIgPSBvdGhlclNldC5lbGVtZW50c1xyXG5cclxuICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgaWYgKGkgPiBhX2xlbiAtIDEgfHwgaiA+IGJfbGVuIC0gMSkgYnJlYWtcclxuXHJcbiAgICBpZiAoYVtpXSA9PT0gYltqXSkge1xyXG4gICAgICBpbnRlcnNlY3RTZXQuYWRkKGFbaV0pXHJcbiAgICAgIGkrKywgaisrXHJcbiAgICAgIGNvbnRpbnVlXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFbaV0gPCBiW2pdKSB7XHJcbiAgICAgIGkrK1xyXG4gICAgICBjb250aW51ZVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChhW2ldID4gYltqXSkge1xyXG4gICAgICBqKytcclxuICAgICAgY29udGludWVcclxuICAgIH1cclxuICB9O1xyXG5cclxuICByZXR1cm4gaW50ZXJzZWN0U2V0XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYWtlcyBhIGNvcHkgb2YgdGhpcyBzZXRcclxuICpcclxuICogQHJldHVybnMge2x1bnIuU29ydGVkU2V0fVxyXG4gKiBAbWVtYmVyT2YgU29ydGVkU2V0XHJcbiAqL1xyXG5sdW5yLlNvcnRlZFNldC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGNsb25lID0gbmV3IGx1bnIuU29ydGVkU2V0XHJcblxyXG4gIGNsb25lLmVsZW1lbnRzID0gdGhpcy50b0FycmF5KClcclxuICBjbG9uZS5sZW5ndGggPSBjbG9uZS5lbGVtZW50cy5sZW5ndGhcclxuXHJcbiAgcmV0dXJuIGNsb25lXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgbmV3IGx1bnIuU29ydGVkU2V0IHRoYXQgY29udGFpbnMgdGhlIGVsZW1lbnRzIGluIHRoZSB1bmlvblxyXG4gKiBvZiB0aGlzIHNldCBhbmQgdGhlIHBhc3NlZCBzZXQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bHVuci5Tb3J0ZWRTZXR9IG90aGVyU2V0IFRoZSBzZXQgdG8gdW5pb24gd2l0aCB0aGlzIHNldC5cclxuICogQHJldHVybnMge2x1bnIuU29ydGVkU2V0fVxyXG4gKiBAbWVtYmVyT2YgU29ydGVkU2V0XHJcbiAqL1xyXG5sdW5yLlNvcnRlZFNldC5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbiAob3RoZXJTZXQpIHtcclxuICB2YXIgbG9uZ1NldCwgc2hvcnRTZXQsIHVuaW9uU2V0XHJcblxyXG4gIGlmICh0aGlzLmxlbmd0aCA+PSBvdGhlclNldC5sZW5ndGgpIHtcclxuICAgIGxvbmdTZXQgPSB0aGlzLCBzaG9ydFNldCA9IG90aGVyU2V0XHJcbiAgfSBlbHNlIHtcclxuICAgIGxvbmdTZXQgPSBvdGhlclNldCwgc2hvcnRTZXQgPSB0aGlzXHJcbiAgfVxyXG5cclxuICB1bmlvblNldCA9IGxvbmdTZXQuY2xvbmUoKVxyXG5cclxuICB1bmlvblNldC5hZGQuYXBwbHkodW5pb25TZXQsIHNob3J0U2V0LnRvQXJyYXkoKSlcclxuXHJcbiAgcmV0dXJuIHVuaW9uU2V0XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNvcnRlZCBzZXQgcmVhZHkgZm9yIHNlcmlhbGlzYXRpb24uXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtBcnJheX1cclxuICogQG1lbWJlck9mIFNvcnRlZFNldFxyXG4gKi9cclxubHVuci5Tb3J0ZWRTZXQucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gdGhpcy50b0FycmF5KClcclxufVxyXG47XHJcbi8qIVxyXG4gKiBsdW5yLkluZGV4XHJcbiAqIENvcHlyaWdodCAoQykgMjAxNCBPbGl2ZXIgTmlnaHRpbmdhbGVcclxuICovXHJcblxyXG4vKipcclxuICogbHVuci5JbmRleCBpcyBvYmplY3QgdGhhdCBtYW5hZ2VzIGEgc2VhcmNoIGluZGV4LiAgSXQgY29udGFpbnMgdGhlIGluZGV4ZXNcclxuICogYW5kIHN0b3JlcyBhbGwgdGhlIHRva2VucyBhbmQgZG9jdW1lbnQgbG9va3Vwcy4gIEl0IGFsc28gcHJvdmlkZXMgdGhlIG1haW5cclxuICogdXNlciBmYWNpbmcgQVBJIGZvciB0aGUgbGlicmFyeS5cclxuICpcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5sdW5yLkluZGV4ID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuX2ZpZWxkcyA9IFtdXHJcbiAgdGhpcy5fcmVmID0gJ2lkJ1xyXG4gIHRoaXMucGlwZWxpbmUgPSBuZXcgbHVuci5QaXBlbGluZVxyXG4gIHRoaXMuZG9jdW1lbnRTdG9yZSA9IG5ldyBsdW5yLlN0b3JlXHJcbiAgdGhpcy50b2tlblN0b3JlID0gbmV3IGx1bnIuVG9rZW5TdG9yZVxyXG4gIHRoaXMuY29ycHVzVG9rZW5zID0gbmV3IGx1bnIuU29ydGVkU2V0XHJcbiAgdGhpcy5ldmVudEVtaXR0ZXIgPSAgbmV3IGx1bnIuRXZlbnRFbWl0dGVyXHJcblxyXG4gIHRoaXMuX2lkZkNhY2hlID0ge31cclxuXHJcbiAgdGhpcy5vbignYWRkJywgJ3JlbW92ZScsICd1cGRhdGUnLCAoZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5faWRmQ2FjaGUgPSB7fVxyXG4gIH0pLmJpbmQodGhpcykpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBCaW5kIGEgaGFuZGxlciB0byBldmVudHMgYmVpbmcgZW1pdHRlZCBieSB0aGUgaW5kZXguXHJcbiAqXHJcbiAqIFRoZSBoYW5kbGVyIGNhbiBiZSBib3VuZCB0byBtYW55IGV2ZW50cyBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2V2ZW50TmFtZV0gVGhlIG5hbWUocykgb2YgZXZlbnRzIHRvIGJpbmQgdGhlIGZ1bmN0aW9uIHRvLlxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBzZXJpYWxpc2VkIHNldCB0byBsb2FkLlxyXG4gKiBAbWVtYmVyT2YgSW5kZXhcclxuICovXHJcbmx1bnIuSW5kZXgucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxyXG4gIHJldHVybiB0aGlzLmV2ZW50RW1pdHRlci5hZGRMaXN0ZW5lci5hcHBseSh0aGlzLmV2ZW50RW1pdHRlciwgYXJncylcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgYSBoYW5kbGVyIGZyb20gYW4gZXZlbnQgYmVpbmcgZW1pdHRlZCBieSB0aGUgaW5kZXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgZXZlbnRzIHRvIHJlbW92ZSB0aGUgZnVuY3Rpb24gZnJvbS5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgc2VyaWFsaXNlZCBzZXQgdG8gbG9hZC5cclxuICogQG1lbWJlck9mIEluZGV4XHJcbiAqL1xyXG5sdW5yLkluZGV4LnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAobmFtZSwgZm4pIHtcclxuICByZXR1cm4gdGhpcy5ldmVudEVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgZm4pXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkcyBhIHByZXZpb3VzbHkgc2VyaWFsaXNlZCBpbmRleC5cclxuICpcclxuICogSXNzdWVzIGEgd2FybmluZyBpZiB0aGUgaW5kZXggYmVpbmcgaW1wb3J0ZWQgd2FzIHNlcmlhbGlzZWRcclxuICogYnkgYSBkaWZmZXJlbnQgdmVyc2lvbiBvZiBsdW5yLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gc2VyaWFsaXNlZERhdGEgVGhlIHNlcmlhbGlzZWQgc2V0IHRvIGxvYWQuXHJcbiAqIEByZXR1cm5zIHtsdW5yLkluZGV4fVxyXG4gKiBAbWVtYmVyT2YgSW5kZXhcclxuICovXHJcbmx1bnIuSW5kZXgubG9hZCA9IGZ1bmN0aW9uIChzZXJpYWxpc2VkRGF0YSkge1xyXG4gIGlmIChzZXJpYWxpc2VkRGF0YS52ZXJzaW9uICE9PSBsdW5yLnZlcnNpb24pIHtcclxuICAgIGx1bnIudXRpbHMud2FybigndmVyc2lvbiBtaXNtYXRjaDogY3VycmVudCAnICsgbHVuci52ZXJzaW9uICsgJyBpbXBvcnRpbmcgJyArIHNlcmlhbGlzZWREYXRhLnZlcnNpb24pXHJcbiAgfVxyXG5cclxuICB2YXIgaWR4ID0gbmV3IHRoaXNcclxuXHJcbiAgaWR4Ll9maWVsZHMgPSBzZXJpYWxpc2VkRGF0YS5maWVsZHNcclxuICBpZHguX3JlZiA9IHNlcmlhbGlzZWREYXRhLnJlZlxyXG5cclxuICBpZHguZG9jdW1lbnRTdG9yZSA9IGx1bnIuU3RvcmUubG9hZChzZXJpYWxpc2VkRGF0YS5kb2N1bWVudFN0b3JlKVxyXG4gIGlkeC50b2tlblN0b3JlID0gbHVuci5Ub2tlblN0b3JlLmxvYWQoc2VyaWFsaXNlZERhdGEudG9rZW5TdG9yZSlcclxuICBpZHguY29ycHVzVG9rZW5zID0gbHVuci5Tb3J0ZWRTZXQubG9hZChzZXJpYWxpc2VkRGF0YS5jb3JwdXNUb2tlbnMpXHJcbiAgaWR4LnBpcGVsaW5lID0gbHVuci5QaXBlbGluZS5sb2FkKHNlcmlhbGlzZWREYXRhLnBpcGVsaW5lKVxyXG5cclxuICByZXR1cm4gaWR4XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIGEgZmllbGQgdG8gdGhlIGxpc3Qgb2YgZmllbGRzIHRoYXQgd2lsbCBiZSBzZWFyY2hhYmxlIHdpdGhpbiBkb2N1bWVudHNcclxuICogaW4gdGhlIGluZGV4LlxyXG4gKlxyXG4gKiBBbiBvcHRpb25hbCBib29zdCBwYXJhbSBjYW4gYmUgcGFzc2VkIHRvIGFmZmVjdCBob3cgbXVjaCB0b2tlbnMgaW4gdGhpcyBmaWVsZFxyXG4gKiByYW5rIGluIHNlYXJjaCByZXN1bHRzLCBieSBkZWZhdWx0IHRoZSBib29zdCB2YWx1ZSBpcyAxLlxyXG4gKlxyXG4gKiBGaWVsZHMgc2hvdWxkIGJlIGFkZGVkIGJlZm9yZSBhbnkgZG9jdW1lbnRzIGFyZSBhZGRlZCB0byB0aGUgaW5kZXgsIGZpZWxkc1xyXG4gKiB0aGF0IGFyZSBhZGRlZCBhZnRlciBkb2N1bWVudHMgYXJlIGFkZGVkIHRvIHRoZSBpbmRleCB3aWxsIG9ubHkgYXBwbHkgdG8gbmV3XHJcbiAqIGRvY3VtZW50cyBhZGRlZCB0byB0aGUgaW5kZXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGZpZWxkIHdpdGhpbiB0aGUgZG9jdW1lbnQgdGhhdFxyXG4gKiBzaG91bGQgYmUgaW5kZXhlZFxyXG4gKiBAcGFyYW0ge051bWJlcn0gYm9vc3QgQW4gb3B0aW9uYWwgYm9vc3QgdGhhdCBjYW4gYmUgYXBwbGllZCB0byB0ZXJtcyBpbiB0aGlzXHJcbiAqIGZpZWxkLlxyXG4gKiBAcmV0dXJucyB7bHVuci5JbmRleH1cclxuICogQG1lbWJlck9mIEluZGV4XHJcbiAqL1xyXG5sdW5yLkluZGV4LnByb3RvdHlwZS5maWVsZCA9IGZ1bmN0aW9uIChmaWVsZE5hbWUsIG9wdHMpIHtcclxuICB2YXIgb3B0cyA9IG9wdHMgfHwge30sXHJcbiAgICAgIGZpZWxkID0geyBuYW1lOiBmaWVsZE5hbWUsIGJvb3N0OiBvcHRzLmJvb3N0IHx8IDEgfVxyXG5cclxuICB0aGlzLl9maWVsZHMucHVzaChmaWVsZClcclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgcHJvcGVydHkgdXNlZCB0byB1bmlxdWVseSBpZGVudGlmeSBkb2N1bWVudHMgYWRkZWQgdG8gdGhlIGluZGV4LFxyXG4gKiBieSBkZWZhdWx0IHRoaXMgcHJvcGVydHkgaXMgJ2lkJy5cclxuICpcclxuICogVGhpcyBzaG91bGQgb25seSBiZSBjaGFuZ2VkIGJlZm9yZSBhZGRpbmcgZG9jdW1lbnRzIHRvIHRoZSBpbmRleCwgY2hhbmdpbmdcclxuICogdGhlIHJlZiBwcm9wZXJ0eSB3aXRob3V0IHJlc2V0dGluZyB0aGUgaW5kZXggY2FuIGxlYWQgdG8gdW5leHBlY3RlZCByZXN1bHRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVmTmFtZSBUaGUgcHJvcGVydHkgdG8gdXNlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoZVxyXG4gKiBkb2N1bWVudHMgaW4gdGhlIGluZGV4LlxyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGVtaXRFdmVudCBXaGV0aGVyIHRvIGVtaXQgYWRkIGV2ZW50cywgZGVmYXVsdHMgdG8gdHJ1ZVxyXG4gKiBAcmV0dXJucyB7bHVuci5JbmRleH1cclxuICogQG1lbWJlck9mIEluZGV4XHJcbiAqL1xyXG5sdW5yLkluZGV4LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbiAocmVmTmFtZSkge1xyXG4gIHRoaXMuX3JlZiA9IHJlZk5hbWVcclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vKipcclxuICogQWRkIGEgZG9jdW1lbnQgdG8gdGhlIGluZGV4LlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSB3YXkgbmV3IGRvY3VtZW50cyBlbnRlciB0aGUgaW5kZXgsIHRoaXMgZnVuY3Rpb24gd2lsbCBydW4gdGhlXHJcbiAqIGZpZWxkcyBmcm9tIHRoZSBkb2N1bWVudCB0aHJvdWdoIHRoZSBpbmRleCdzIHBpcGVsaW5lIGFuZCB0aGVuIGFkZCBpdCB0b1xyXG4gKiB0aGUgaW5kZXgsIGl0IHdpbGwgdGhlbiBzaG93IHVwIGluIHNlYXJjaCByZXN1bHRzLlxyXG4gKlxyXG4gKiBBbiAnYWRkJyBldmVudCBpcyBlbWl0dGVkIHdpdGggdGhlIGRvY3VtZW50IHRoYXQgaGFzIGJlZW4gYWRkZWQgYW5kIHRoZSBpbmRleFxyXG4gKiB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gYWRkZWQgdG8uIFRoaXMgZXZlbnQgY2FuIGJlIHNpbGVuY2VkIGJ5IHBhc3NpbmcgZmFsc2VcclxuICogYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBhZGQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgVGhlIGRvY3VtZW50IHRvIGFkZCB0byB0aGUgaW5kZXguXHJcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZW1pdEV2ZW50IFdoZXRoZXIgb3Igbm90IHRvIGVtaXQgZXZlbnRzLCBkZWZhdWx0IHRydWUuXHJcbiAqIEBtZW1iZXJPZiBJbmRleFxyXG4gKi9cclxubHVuci5JbmRleC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGRvYywgZW1pdEV2ZW50KSB7XHJcbiAgdmFyIGRvY1Rva2VucyA9IHt9LFxyXG4gICAgICBhbGxEb2N1bWVudFRva2VucyA9IG5ldyBsdW5yLlNvcnRlZFNldCxcclxuICAgICAgZG9jUmVmID0gZG9jW3RoaXMuX3JlZl0sXHJcbiAgICAgIGVtaXRFdmVudCA9IGVtaXRFdmVudCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGVtaXRFdmVudFxyXG5cclxuICB0aGlzLl9maWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcclxuICAgIHZhciBmaWVsZFRva2VucyA9IHRoaXMucGlwZWxpbmUucnVuKGx1bnIudG9rZW5pemVyKGRvY1tmaWVsZC5uYW1lXSkpXHJcblxyXG4gICAgZG9jVG9rZW5zW2ZpZWxkLm5hbWVdID0gZmllbGRUb2tlbnNcclxuICAgIGx1bnIuU29ydGVkU2V0LnByb3RvdHlwZS5hZGQuYXBwbHkoYWxsRG9jdW1lbnRUb2tlbnMsIGZpZWxkVG9rZW5zKVxyXG4gIH0sIHRoaXMpXHJcblxyXG4gIHRoaXMuZG9jdW1lbnRTdG9yZS5zZXQoZG9jUmVmLCBhbGxEb2N1bWVudFRva2VucylcclxuICBsdW5yLlNvcnRlZFNldC5wcm90b3R5cGUuYWRkLmFwcGx5KHRoaXMuY29ycHVzVG9rZW5zLCBhbGxEb2N1bWVudFRva2Vucy50b0FycmF5KCkpXHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsRG9jdW1lbnRUb2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgIHZhciB0b2tlbiA9IGFsbERvY3VtZW50VG9rZW5zLmVsZW1lbnRzW2ldXHJcbiAgICB2YXIgdGYgPSB0aGlzLl9maWVsZHMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBmaWVsZCkge1xyXG4gICAgICB2YXIgZmllbGRMZW5ndGggPSBkb2NUb2tlbnNbZmllbGQubmFtZV0ubGVuZ3RoXHJcblxyXG4gICAgICBpZiAoIWZpZWxkTGVuZ3RoKSByZXR1cm4gbWVtb1xyXG5cclxuICAgICAgdmFyIHRva2VuQ291bnQgPSBkb2NUb2tlbnNbZmllbGQubmFtZV0uZmlsdGVyKGZ1bmN0aW9uICh0KSB7IHJldHVybiB0ID09PSB0b2tlbiB9KS5sZW5ndGhcclxuXHJcbiAgICAgIHJldHVybiBtZW1vICsgKHRva2VuQ291bnQgLyBmaWVsZExlbmd0aCAqIGZpZWxkLmJvb3N0KVxyXG4gICAgfSwgMClcclxuXHJcbiAgICB0aGlzLnRva2VuU3RvcmUuYWRkKHRva2VuLCB7IHJlZjogZG9jUmVmLCB0ZjogdGYgfSlcclxuICB9O1xyXG5cclxuICBpZiAoZW1pdEV2ZW50KSB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCdhZGQnLCBkb2MsIHRoaXMpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGEgZG9jdW1lbnQgZnJvbSB0aGUgaW5kZXguXHJcbiAqXHJcbiAqIFRvIG1ha2Ugc3VyZSBkb2N1bWVudHMgbm8gbG9uZ2VyIHNob3cgdXAgaW4gc2VhcmNoIHJlc3VsdHMgdGhleSBjYW4gYmVcclxuICogcmVtb3ZlZCBmcm9tIHRoZSBpbmRleCB1c2luZyB0aGlzIG1ldGhvZC5cclxuICpcclxuICogVGhlIGRvY3VtZW50IHBhc3NlZCBvbmx5IG5lZWRzIHRvIGhhdmUgdGhlIHNhbWUgcmVmIHByb3BlcnR5IHZhbHVlIGFzIHRoZVxyXG4gKiBkb2N1bWVudCB0aGF0IHdhcyBhZGRlZCB0byB0aGUgaW5kZXgsIHRoZXkgY291bGQgYmUgY29tcGxldGVseSBkaWZmZXJlbnRcclxuICogb2JqZWN0cy5cclxuICpcclxuICogQSAncmVtb3ZlJyBldmVudCBpcyBlbWl0dGVkIHdpdGggdGhlIGRvY3VtZW50IHRoYXQgaGFzIGJlZW4gcmVtb3ZlZCBhbmQgdGhlIGluZGV4XHJcbiAqIHRoZSBkb2N1bWVudCBoYXMgYmVlbiByZW1vdmVkIGZyb20uIFRoaXMgZXZlbnQgY2FuIGJlIHNpbGVuY2VkIGJ5IHBhc3NpbmcgZmFsc2VcclxuICogYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byByZW1vdmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgVGhlIGRvY3VtZW50IHRvIHJlbW92ZSBmcm9tIHRoZSBpbmRleC5cclxuICogQHBhcmFtIHtCb29sZWFufSBlbWl0RXZlbnQgV2hldGhlciB0byBlbWl0IHJlbW92ZSBldmVudHMsIGRlZmF1bHRzIHRvIHRydWVcclxuICogQG1lbWJlck9mIEluZGV4XHJcbiAqL1xyXG5sdW5yLkluZGV4LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZG9jLCBlbWl0RXZlbnQpIHtcclxuICB2YXIgZG9jUmVmID0gZG9jW3RoaXMuX3JlZl0sXHJcbiAgICAgIGVtaXRFdmVudCA9IGVtaXRFdmVudCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGVtaXRFdmVudFxyXG5cclxuICBpZiAoIXRoaXMuZG9jdW1lbnRTdG9yZS5oYXMoZG9jUmVmKSkgcmV0dXJuXHJcblxyXG4gIHZhciBkb2NUb2tlbnMgPSB0aGlzLmRvY3VtZW50U3RvcmUuZ2V0KGRvY1JlZilcclxuXHJcbiAgdGhpcy5kb2N1bWVudFN0b3JlLnJlbW92ZShkb2NSZWYpXHJcblxyXG4gIGRvY1Rva2Vucy5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xyXG4gICAgdGhpcy50b2tlblN0b3JlLnJlbW92ZSh0b2tlbiwgZG9jUmVmKVxyXG4gIH0sIHRoaXMpXHJcblxyXG4gIGlmIChlbWl0RXZlbnQpIHRoaXMuZXZlbnRFbWl0dGVyLmVtaXQoJ3JlbW92ZScsIGRvYywgdGhpcylcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgYSBkb2N1bWVudCBpbiB0aGUgaW5kZXguXHJcbiAqXHJcbiAqIFdoZW4gYSBkb2N1bWVudCBjb250YWluZWQgd2l0aGluIHRoZSBpbmRleCBnZXRzIHVwZGF0ZWQsIGZpZWxkcyBjaGFuZ2VkLFxyXG4gKiBhZGRlZCBvciByZW1vdmVkLCB0byBtYWtlIHN1cmUgaXQgY29ycmVjdGx5IG1hdGNoZWQgYWdhaW5zdCBzZWFyY2ggcXVlcmllcyxcclxuICogaXQgc2hvdWxkIGJlIHVwZGF0ZWQgaW4gdGhlIGluZGV4LlxyXG4gKlxyXG4gKiBUaGlzIG1ldGhvZCBpcyBqdXN0IGEgd3JhcHBlciBhcm91bmQgYHJlbW92ZWAgYW5kIGBhZGRgXHJcbiAqXHJcbiAqIEFuICd1cGRhdGUnIGV2ZW50IGlzIGVtaXR0ZWQgd2l0aCB0aGUgZG9jdW1lbnQgdGhhdCBoYXMgYmVlbiB1cGRhdGVkIGFuZCB0aGUgaW5kZXguXHJcbiAqIFRoaXMgZXZlbnQgY2FuIGJlIHNpbGVuY2VkIGJ5IHBhc3NpbmcgZmFsc2UgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byB1cGRhdGUuIE9ubHlcclxuICogYW4gdXBkYXRlIGV2ZW50IHdpbGwgYmUgZmlyZWQsIHRoZSAnYWRkJyBhbmQgJ3JlbW92ZScgZXZlbnRzIG9mIHRoZSB1bmRlcmx5aW5nIGNhbGxzXHJcbiAqIGFyZSBzaWxlbmNlZC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBUaGUgZG9jdW1lbnQgdG8gdXBkYXRlIGluIHRoZSBpbmRleC5cclxuICogQHBhcmFtIHtCb29sZWFufSBlbWl0RXZlbnQgV2hldGhlciB0byBlbWl0IHVwZGF0ZSBldmVudHMsIGRlZmF1bHRzIHRvIHRydWVcclxuICogQHNlZSBJbmRleC5wcm90b3R5cGUucmVtb3ZlXHJcbiAqIEBzZWUgSW5kZXgucHJvdG90eXBlLmFkZFxyXG4gKiBAbWVtYmVyT2YgSW5kZXhcclxuICovXHJcbmx1bnIuSW5kZXgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkb2MsIGVtaXRFdmVudCkge1xyXG4gIHZhciBlbWl0RXZlbnQgPSBlbWl0RXZlbnQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBlbWl0RXZlbnRcclxuXHJcbiAgdGhpcy5yZW1vdmUoZG9jLCBmYWxzZSlcclxuICB0aGlzLmFkZChkb2MsIGZhbHNlKVxyXG5cclxuICBpZiAoZW1pdEV2ZW50KSB0aGlzLmV2ZW50RW1pdHRlci5lbWl0KCd1cGRhdGUnLCBkb2MsIHRoaXMpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIGRvY3VtZW50IGZyZXF1ZW5jeSBmb3IgYSB0b2tlbiB3aXRoaW4gdGhlIGluZGV4LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gVGhlIHRva2VuIHRvIGNhbGN1bGF0ZSB0aGUgaWRmIG9mLlxyXG4gKiBAc2VlIEluZGV4LnByb3RvdHlwZS5pZGZcclxuICogQHByaXZhdGVcclxuICogQG1lbWJlck9mIEluZGV4XHJcbiAqL1xyXG5sdW5yLkluZGV4LnByb3RvdHlwZS5pZGYgPSBmdW5jdGlvbiAodGVybSkge1xyXG4gIHZhciBjYWNoZUtleSA9IFwiQFwiICsgdGVybVxyXG4gIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5faWRmQ2FjaGUsIGNhY2hlS2V5KSkgcmV0dXJuIHRoaXMuX2lkZkNhY2hlW2NhY2hlS2V5XVxyXG5cclxuICB2YXIgZG9jdW1lbnRGcmVxdWVuY3kgPSB0aGlzLnRva2VuU3RvcmUuY291bnQodGVybSksXHJcbiAgICAgIGlkZiA9IDFcclxuXHJcbiAgaWYgKGRvY3VtZW50RnJlcXVlbmN5ID4gMCkge1xyXG4gICAgaWRmID0gMSArIE1hdGgubG9nKHRoaXMudG9rZW5TdG9yZS5sZW5ndGggLyBkb2N1bWVudEZyZXF1ZW5jeSlcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzLl9pZGZDYWNoZVtjYWNoZUtleV0gPSBpZGZcclxufVxyXG5cclxuLyoqXHJcbiAqIFNlYXJjaGVzIHRoZSBpbmRleCB1c2luZyB0aGUgcGFzc2VkIHF1ZXJ5LlxyXG4gKlxyXG4gKiBRdWVyaWVzIHNob3VsZCBiZSBhIHN0cmluZywgbXVsdGlwbGUgd29yZHMgYXJlIGFsbG93ZWQgYW5kIHdpbGwgbGVhZCB0byBhblxyXG4gKiBBTkQgYmFzZWQgcXVlcnksIGUuZy4gYGlkeC5zZWFyY2goJ2ZvbyBiYXInKWAgd2lsbCBydW4gYSBzZWFyY2ggZm9yXHJcbiAqIGRvY3VtZW50cyBjb250YWluaW5nIGJvdGggJ2ZvbycgYW5kICdiYXInLlxyXG4gKlxyXG4gKiBBbGwgcXVlcnkgdG9rZW5zIGFyZSBwYXNzZWQgdGhyb3VnaCB0aGUgc2FtZSBwaXBlbGluZSB0aGF0IGRvY3VtZW50IHRva2Vuc1xyXG4gKiBhcmUgcGFzc2VkIHRocm91Z2gsIHNvIGFueSBsYW5ndWFnZSBwcm9jZXNzaW5nIGludm9sdmVkIHdpbGwgYmUgcnVuIG9uIGV2ZXJ5XHJcbiAqIHF1ZXJ5IHRlcm0uXHJcbiAqXHJcbiAqIEVhY2ggcXVlcnkgdGVybSBpcyBleHBhbmRlZCwgc28gdGhhdCB0aGUgdGVybSAnaGUnIG1pZ2h0IGJlIGV4cGFuZGVkIHRvXHJcbiAqICdoZWxsbycgYW5kICdoZWxwJyBpZiB0aG9zZSB0ZXJtcyB3ZXJlIGFscmVhZHkgaW5jbHVkZWQgaW4gdGhlIGluZGV4LlxyXG4gKlxyXG4gKiBNYXRjaGluZyBkb2N1bWVudHMgYXJlIHJldHVybmVkIGFzIGFuIGFycmF5IG9mIG9iamVjdHMsIGVhY2ggb2JqZWN0IGNvbnRhaW5zXHJcbiAqIHRoZSBtYXRjaGluZyBkb2N1bWVudCByZWYsIGFzIHNldCBmb3IgdGhpcyBpbmRleCwgYW5kIHRoZSBzaW1pbGFyaXR5IHNjb3JlXHJcbiAqIGZvciB0aGlzIGRvY3VtZW50IGFnYWluc3QgdGhlIHF1ZXJ5LlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gcXVlcnkgVGhlIHF1ZXJ5IHRvIHNlYXJjaCB0aGUgaW5kZXggd2l0aC5cclxuICogQHJldHVybnMge09iamVjdH1cclxuICogQHNlZSBJbmRleC5wcm90b3R5cGUuaWRmXHJcbiAqIEBzZWUgSW5kZXgucHJvdG90eXBlLmRvY3VtZW50VmVjdG9yXHJcbiAqIEBtZW1iZXJPZiBJbmRleFxyXG4gKi9cclxubHVuci5JbmRleC5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XHJcbiAgdmFyIHF1ZXJ5VG9rZW5zID0gdGhpcy5waXBlbGluZS5ydW4obHVuci50b2tlbml6ZXIocXVlcnkpKSxcclxuICAgICAgcXVlcnlBcnIgPSBsdW5yLnV0aWxzLnplcm9GaWxsQXJyYXkodGhpcy5jb3JwdXNUb2tlbnMubGVuZ3RoKSxcclxuICAgICAgZG9jdW1lbnRTZXRzID0gW10sXHJcbiAgICAgIGZpZWxkQm9vc3RzID0gdGhpcy5fZmllbGRzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgZikgeyByZXR1cm4gbWVtbyArIGYuYm9vc3QgfSwgMClcclxuXHJcbiAgdmFyIGhhc1NvbWVUb2tlbiA9IHF1ZXJ5VG9rZW5zLnNvbWUoZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b2tlblN0b3JlLmhhcyh0b2tlbilcclxuICB9LCB0aGlzKVxyXG5cclxuICBpZiAoIWhhc1NvbWVUb2tlbikgcmV0dXJuIFtdXHJcblxyXG4gIHF1ZXJ5VG9rZW5zXHJcbiAgICAuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4sIGksIHRva2Vucykge1xyXG4gICAgICB2YXIgdGYgPSAxIC8gdG9rZW5zLmxlbmd0aCAqIHRoaXMuX2ZpZWxkcy5sZW5ndGggKiBmaWVsZEJvb3N0cyxcclxuICAgICAgICAgIHNlbGYgPSB0aGlzXHJcblxyXG4gICAgICB2YXIgc2V0ID0gdGhpcy50b2tlblN0b3JlLmV4cGFuZCh0b2tlbikucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBrZXkpIHtcclxuICAgICAgICB2YXIgcG9zID0gc2VsZi5jb3JwdXNUb2tlbnMuaW5kZXhPZihrZXkpLFxyXG4gICAgICAgICAgICBpZGYgPSBzZWxmLmlkZihrZXkpLFxyXG4gICAgICAgICAgICBzaW1pbGFyaXR5Qm9vc3QgPSAxLFxyXG4gICAgICAgICAgICBzZXQgPSBuZXcgbHVuci5Tb3J0ZWRTZXRcclxuXHJcbiAgICAgICAgLy8gaWYgdGhlIGV4cGFuZGVkIGtleSBpcyBub3QgYW4gZXhhY3QgbWF0Y2ggdG8gdGhlIHRva2VuIHRoZW5cclxuICAgICAgICAvLyBwZW5hbGlzZSB0aGUgc2NvcmUgZm9yIHRoaXMga2V5IGJ5IGhvdyBkaWZmZXJlbnQgdGhlIGtleSBpc1xyXG4gICAgICAgIC8vIHRvIHRoZSB0b2tlbi5cclxuICAgICAgICBpZiAoa2V5ICE9PSB0b2tlbikge1xyXG4gICAgICAgICAgdmFyIGRpZmYgPSBNYXRoLm1heCgzLCBrZXkubGVuZ3RoIC0gdG9rZW4ubGVuZ3RoKVxyXG4gICAgICAgICAgc2ltaWxhcml0eUJvb3N0ID0gMSAvIE1hdGgubG9nKGRpZmYpXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHF1ZXJ5IHRmLWlkZiBzY29yZSBmb3IgdGhpcyB0b2tlblxyXG4gICAgICAgIC8vIGFwcGx5aW5nIGFuIHNpbWlsYXJpdHlCb29zdCB0byBlbnN1cmUgZXhhY3QgbWF0Y2hlc1xyXG4gICAgICAgIC8vIHRoZXNlIHJhbmsgaGlnaGVyIHRoYW4gZXhwYW5kZWQgdGVybXNcclxuICAgICAgICBpZiAocG9zID4gLTEpIHF1ZXJ5QXJyW3Bvc10gPSB0ZiAqIGlkZiAqIHNpbWlsYXJpdHlCb29zdFxyXG5cclxuICAgICAgICAvLyBhZGQgYWxsIHRoZSBkb2N1bWVudHMgdGhhdCBoYXZlIHRoaXMga2V5IGludG8gYSBzZXRcclxuICAgICAgICBPYmplY3Qua2V5cyhzZWxmLnRva2VuU3RvcmUuZ2V0KGtleSkpLmZvckVhY2goZnVuY3Rpb24gKHJlZikgeyBzZXQuYWRkKHJlZikgfSlcclxuXHJcbiAgICAgICAgcmV0dXJuIG1lbW8udW5pb24oc2V0KVxyXG4gICAgICB9LCBuZXcgbHVuci5Tb3J0ZWRTZXQpXHJcblxyXG4gICAgICBkb2N1bWVudFNldHMucHVzaChzZXQpXHJcbiAgICB9LCB0aGlzKVxyXG5cclxuICB2YXIgZG9jdW1lbnRTZXQgPSBkb2N1bWVudFNldHMucmVkdWNlKGZ1bmN0aW9uIChtZW1vLCBzZXQpIHtcclxuICAgIHJldHVybiBtZW1vLmludGVyc2VjdChzZXQpXHJcbiAgfSlcclxuXHJcbiAgdmFyIHF1ZXJ5VmVjdG9yID0gbmV3IGx1bnIuVmVjdG9yIChxdWVyeUFycilcclxuXHJcbiAgcmV0dXJuIGRvY3VtZW50U2V0XHJcbiAgICAubWFwKGZ1bmN0aW9uIChyZWYpIHtcclxuICAgICAgcmV0dXJuIHsgcmVmOiByZWYsIHNjb3JlOiBxdWVyeVZlY3Rvci5zaW1pbGFyaXR5KHRoaXMuZG9jdW1lbnRWZWN0b3IocmVmKSkgfVxyXG4gICAgfSwgdGhpcylcclxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XHJcbiAgICAgIHJldHVybiBiLnNjb3JlIC0gYS5zY29yZVxyXG4gICAgfSlcclxufVxyXG5cclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIHZlY3RvciBjb250YWluaW5nIGFsbCB0aGUgdG9rZW5zIGluIHRoZSBkb2N1bWVudCBtYXRjaGluZyB0aGVcclxuICogcGFzc2VkIGRvY3VtZW50UmVmLlxyXG4gKlxyXG4gKiBUaGUgdmVjdG9yIGNvbnRhaW5zIHRoZSB0Zi1pZGYgc2NvcmUgZm9yIGVhY2ggdG9rZW4gY29udGFpbmVkIGluIHRoZVxyXG4gKiBkb2N1bWVudCB3aXRoIHRoZSBwYXNzZWQgZG9jdW1lbnRSZWYuICBUaGUgdmVjdG9yIHdpbGwgY29udGFpbiBhbiBlbGVtZW50XHJcbiAqIGZvciBldmVyeSB0b2tlbiBpbiB0aGUgaW5kZXhlcyBjb3JwdXMsIGlmIHRoZSBkb2N1bWVudCBkb2VzIG5vdCBjb250YWluIHRoYXRcclxuICogdG9rZW4gdGhlIGVsZW1lbnQgd2lsbCBiZSAwLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jdW1lbnRSZWYgVGhlIHJlZiB0byBmaW5kIHRoZSBkb2N1bWVudCB3aXRoLlxyXG4gKiBAcmV0dXJucyB7bHVuci5WZWN0b3J9XHJcbiAqIEBwcml2YXRlXHJcbiAqIEBtZW1iZXJPZiBJbmRleFxyXG4gKi9cclxubHVuci5JbmRleC5wcm90b3R5cGUuZG9jdW1lbnRWZWN0b3IgPSBmdW5jdGlvbiAoZG9jdW1lbnRSZWYpIHtcclxuICB2YXIgZG9jdW1lbnRUb2tlbnMgPSB0aGlzLmRvY3VtZW50U3RvcmUuZ2V0KGRvY3VtZW50UmVmKSxcclxuICAgICAgZG9jdW1lbnRUb2tlbnNMZW5ndGggPSBkb2N1bWVudFRva2Vucy5sZW5ndGgsXHJcbiAgICAgIGRvY3VtZW50QXJyID0gbHVuci51dGlscy56ZXJvRmlsbEFycmF5KHRoaXMuY29ycHVzVG9rZW5zLmxlbmd0aClcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb2N1bWVudFRva2Vuc0xlbmd0aDsgaSsrKSB7XHJcbiAgICB2YXIgdG9rZW4gPSBkb2N1bWVudFRva2Vucy5lbGVtZW50c1tpXSxcclxuICAgICAgICB0ZiA9IHRoaXMudG9rZW5TdG9yZS5nZXQodG9rZW4pW2RvY3VtZW50UmVmXS50ZixcclxuICAgICAgICBpZGYgPSB0aGlzLmlkZih0b2tlbilcclxuXHJcbiAgICBkb2N1bWVudEFyclt0aGlzLmNvcnB1c1Rva2Vucy5pbmRleE9mKHRva2VuKV0gPSB0ZiAqIGlkZlxyXG4gIH07XHJcblxyXG4gIHJldHVybiBuZXcgbHVuci5WZWN0b3IgKGRvY3VtZW50QXJyKVxyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbmRleCByZWFkeSBmb3Igc2VyaWFsaXNhdGlvbi5cclxuICpcclxuICogQHJldHVybnMge09iamVjdH1cclxuICogQG1lbWJlck9mIEluZGV4XHJcbiAqL1xyXG5sdW5yLkluZGV4LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHZlcnNpb246IGx1bnIudmVyc2lvbixcclxuICAgIGZpZWxkczogdGhpcy5fZmllbGRzLFxyXG4gICAgcmVmOiB0aGlzLl9yZWYsXHJcbiAgICBkb2N1bWVudFN0b3JlOiB0aGlzLmRvY3VtZW50U3RvcmUudG9KU09OKCksXHJcbiAgICB0b2tlblN0b3JlOiB0aGlzLnRva2VuU3RvcmUudG9KU09OKCksXHJcbiAgICBjb3JwdXNUb2tlbnM6IHRoaXMuY29ycHVzVG9rZW5zLnRvSlNPTigpLFxyXG4gICAgcGlwZWxpbmU6IHRoaXMucGlwZWxpbmUudG9KU09OKClcclxuICB9XHJcbn1cclxuO1xyXG4vKiFcclxuICogbHVuci5TdG9yZVxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTQgT2xpdmVyIE5pZ2h0aW5nYWxlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIGx1bnIuU3RvcmUgaXMgYSBzaW1wbGUga2V5LXZhbHVlIHN0b3JlIHVzZWQgZm9yIHN0b3Jpbmcgc2V0cyBvZiB0b2tlbnMgZm9yXHJcbiAqIGRvY3VtZW50cyBzdG9yZWQgaW4gaW5kZXguXHJcbiAqXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKiBAbW9kdWxlXHJcbiAqL1xyXG5sdW5yLlN0b3JlID0gZnVuY3Rpb24gKCkge1xyXG4gIHRoaXMuc3RvcmUgPSB7fVxyXG4gIHRoaXMubGVuZ3RoID0gMFxyXG59XHJcblxyXG4vKipcclxuICogTG9hZHMgYSBwcmV2aW91c2x5IHNlcmlhbGlzZWQgc3RvcmVcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHNlcmlhbGlzZWREYXRhIFRoZSBzZXJpYWxpc2VkIHN0b3JlIHRvIGxvYWQuXHJcbiAqIEByZXR1cm5zIHtsdW5yLlN0b3JlfVxyXG4gKiBAbWVtYmVyT2YgU3RvcmVcclxuICovXHJcbmx1bnIuU3RvcmUubG9hZCA9IGZ1bmN0aW9uIChzZXJpYWxpc2VkRGF0YSkge1xyXG4gIHZhciBzdG9yZSA9IG5ldyB0aGlzXHJcblxyXG4gIHN0b3JlLmxlbmd0aCA9IHNlcmlhbGlzZWREYXRhLmxlbmd0aFxyXG4gIHN0b3JlLnN0b3JlID0gT2JqZWN0LmtleXMoc2VyaWFsaXNlZERhdGEuc3RvcmUpLnJlZHVjZShmdW5jdGlvbiAobWVtbywga2V5KSB7XHJcbiAgICBtZW1vW2tleV0gPSBsdW5yLlNvcnRlZFNldC5sb2FkKHNlcmlhbGlzZWREYXRhLnN0b3JlW2tleV0pXHJcbiAgICByZXR1cm4gbWVtb1xyXG4gIH0sIHt9KVxyXG5cclxuICByZXR1cm4gc3RvcmVcclxufVxyXG5cclxuLyoqXHJcbiAqIFN0b3JlcyB0aGUgZ2l2ZW4gdG9rZW5zIGluIHRoZSBzdG9yZSBhZ2FpbnN0IHRoZSBnaXZlbiBpZC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IGlkIFRoZSBrZXkgdXNlZCB0byBzdG9yZSB0aGUgdG9rZW5zIGFnYWluc3QuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0b2tlbnMgVGhlIHRva2VucyB0byBzdG9yZSBhZ2FpbnN0IHRoZSBrZXkuXHJcbiAqIEBtZW1iZXJPZiBTdG9yZVxyXG4gKi9cclxubHVuci5TdG9yZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGlkLCB0b2tlbnMpIHtcclxuICB0aGlzLnN0b3JlW2lkXSA9IHRva2Vuc1xyXG4gIHRoaXMubGVuZ3RoID0gT2JqZWN0LmtleXModGhpcy5zdG9yZSkubGVuZ3RoXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZXMgdGhlIHRva2VucyBmcm9tIHRoZSBzdG9yZSBmb3IgYSBnaXZlbiBrZXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpZCBUaGUga2V5IHRvIGxvb2t1cCBhbmQgcmV0cmlldmUgZnJvbSB0aGUgc3RvcmUuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqIEBtZW1iZXJPZiBTdG9yZVxyXG4gKi9cclxubHVuci5TdG9yZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgcmV0dXJuIHRoaXMuc3RvcmVbaWRdXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgc3RvcmUgY29udGFpbnMgYSBrZXkuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpZCBUaGUgaWQgdG8gbG9vayB1cCBpbiB0aGUgc3RvcmUuXHJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxyXG4gKiBAbWVtYmVyT2YgU3RvcmVcclxuICovXHJcbmx1bnIuU3RvcmUucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChpZCkge1xyXG4gIHJldHVybiBpZCBpbiB0aGlzLnN0b3JlXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIHRoZSB2YWx1ZSBmb3IgYSBrZXkgaW4gdGhlIHN0b3JlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gaWQgVGhlIGlkIHRvIHJlbW92ZSBmcm9tIHRoZSBzdG9yZS5cclxuICogQG1lbWJlck9mIFN0b3JlXHJcbiAqL1xyXG5sdW5yLlN0b3JlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoaWQpIHtcclxuICBpZiAoIXRoaXMuaGFzKGlkKSkgcmV0dXJuXHJcblxyXG4gIGRlbGV0ZSB0aGlzLnN0b3JlW2lkXVxyXG4gIHRoaXMubGVuZ3RoLS1cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgc3RvcmUgcmVhZHkgZm9yIHNlcmlhbGlzYXRpb24uXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqIEBtZW1iZXJPZiBTdG9yZVxyXG4gKi9cclxubHVuci5TdG9yZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICBzdG9yZTogdGhpcy5zdG9yZSxcclxuICAgIGxlbmd0aDogdGhpcy5sZW5ndGhcclxuICB9XHJcbn1cclxuXHJcbjtcclxuLyohXHJcbiAqIGx1bnIuc3RlbW1lclxyXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTQgT2xpdmVyIE5pZ2h0aW5nYWxlXHJcbiAqIEluY2x1ZGVzIGNvZGUgZnJvbSAtIGh0dHA6Ly90YXJ0YXJ1cy5vcmcvfm1hcnRpbi9Qb3J0ZXJTdGVtbWVyL2pzLnR4dFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBsdW5yLnN0ZW1tZXIgaXMgYW4gZW5nbGlzaCBsYW5ndWFnZSBzdGVtbWVyLCB0aGlzIGlzIGEgSmF2YVNjcmlwdFxyXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUG9ydGVyU3RlbW1lciB0YWtlbiBmcm9tIGh0dHA6Ly90YXJ0YXVycy5vcmcvfm1hcnRpblxyXG4gKlxyXG4gKiBAbW9kdWxlXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBzdGVtXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqIEBzZWUgbHVuci5QaXBlbGluZVxyXG4gKi9cclxubHVuci5zdGVtbWVyID0gKGZ1bmN0aW9uKCl7XHJcbiAgdmFyIHN0ZXAybGlzdCA9IHtcclxuICAgICAgXCJhdGlvbmFsXCIgOiBcImF0ZVwiLFxyXG4gICAgICBcInRpb25hbFwiIDogXCJ0aW9uXCIsXHJcbiAgICAgIFwiZW5jaVwiIDogXCJlbmNlXCIsXHJcbiAgICAgIFwiYW5jaVwiIDogXCJhbmNlXCIsXHJcbiAgICAgIFwiaXplclwiIDogXCJpemVcIixcclxuICAgICAgXCJibGlcIiA6IFwiYmxlXCIsXHJcbiAgICAgIFwiYWxsaVwiIDogXCJhbFwiLFxyXG4gICAgICBcImVudGxpXCIgOiBcImVudFwiLFxyXG4gICAgICBcImVsaVwiIDogXCJlXCIsXHJcbiAgICAgIFwib3VzbGlcIiA6IFwib3VzXCIsXHJcbiAgICAgIFwiaXphdGlvblwiIDogXCJpemVcIixcclxuICAgICAgXCJhdGlvblwiIDogXCJhdGVcIixcclxuICAgICAgXCJhdG9yXCIgOiBcImF0ZVwiLFxyXG4gICAgICBcImFsaXNtXCIgOiBcImFsXCIsXHJcbiAgICAgIFwiaXZlbmVzc1wiIDogXCJpdmVcIixcclxuICAgICAgXCJmdWxuZXNzXCIgOiBcImZ1bFwiLFxyXG4gICAgICBcIm91c25lc3NcIiA6IFwib3VzXCIsXHJcbiAgICAgIFwiYWxpdGlcIiA6IFwiYWxcIixcclxuICAgICAgXCJpdml0aVwiIDogXCJpdmVcIixcclxuICAgICAgXCJiaWxpdGlcIiA6IFwiYmxlXCIsXHJcbiAgICAgIFwibG9naVwiIDogXCJsb2dcIlxyXG4gICAgfSxcclxuXHJcbiAgICBzdGVwM2xpc3QgPSB7XHJcbiAgICAgIFwiaWNhdGVcIiA6IFwiaWNcIixcclxuICAgICAgXCJhdGl2ZVwiIDogXCJcIixcclxuICAgICAgXCJhbGl6ZVwiIDogXCJhbFwiLFxyXG4gICAgICBcImljaXRpXCIgOiBcImljXCIsXHJcbiAgICAgIFwiaWNhbFwiIDogXCJpY1wiLFxyXG4gICAgICBcImZ1bFwiIDogXCJcIixcclxuICAgICAgXCJuZXNzXCIgOiBcIlwiXHJcbiAgICB9LFxyXG5cclxuICAgIGMgPSBcIlteYWVpb3VdXCIsICAgICAgICAgIC8vIGNvbnNvbmFudFxyXG4gICAgdiA9IFwiW2FlaW91eV1cIiwgICAgICAgICAgLy8gdm93ZWxcclxuICAgIEMgPSBjICsgXCJbXmFlaW91eV0qXCIsICAgIC8vIGNvbnNvbmFudCBzZXF1ZW5jZVxyXG4gICAgViA9IHYgKyBcIlthZWlvdV0qXCIsICAgICAgLy8gdm93ZWwgc2VxdWVuY2VcclxuXHJcbiAgICBtZ3IwID0gXCJeKFwiICsgQyArIFwiKT9cIiArIFYgKyBDLCAgICAgICAgICAgICAgIC8vIFtDXVZDLi4uIGlzIG0+MFxyXG4gICAgbWVxMSA9IFwiXihcIiArIEMgKyBcIik/XCIgKyBWICsgQyArIFwiKFwiICsgViArIFwiKT8kXCIsICAvLyBbQ11WQ1tWXSBpcyBtPTFcclxuICAgIG1ncjEgPSBcIl4oXCIgKyBDICsgXCIpP1wiICsgViArIEMgKyBWICsgQywgICAgICAgLy8gW0NdVkNWQy4uLiBpcyBtPjFcclxuICAgIHNfdiA9IFwiXihcIiArIEMgKyBcIik/XCIgKyB2OyAgICAgICAgICAgICAgICAgICAvLyB2b3dlbCBpbiBzdGVtXHJcblxyXG4gIHJldHVybiBmdW5jdGlvbiAodykge1xyXG4gICAgdmFyICAgc3RlbSxcclxuICAgICAgc3VmZml4LFxyXG4gICAgICBmaXJzdGNoLFxyXG4gICAgICByZSxcclxuICAgICAgcmUyLFxyXG4gICAgICByZTMsXHJcbiAgICAgIHJlNDtcclxuXHJcbiAgICBpZiAody5sZW5ndGggPCAzKSB7IHJldHVybiB3OyB9XHJcblxyXG4gICAgZmlyc3RjaCA9IHcuc3Vic3RyKDAsMSk7XHJcbiAgICBpZiAoZmlyc3RjaCA9PSBcInlcIikge1xyXG4gICAgICB3ID0gZmlyc3RjaC50b1VwcGVyQ2FzZSgpICsgdy5zdWJzdHIoMSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RlcCAxYVxyXG4gICAgcmUgPSAvXiguKz8pKHNzfGkpZXMkLztcclxuICAgIHJlMiA9IC9eKC4rPykoW15zXSlzJC87XHJcblxyXG4gICAgaWYgKHJlLnRlc3QodykpIHsgdyA9IHcucmVwbGFjZShyZSxcIiQxJDJcIik7IH1cclxuICAgIGVsc2UgaWYgKHJlMi50ZXN0KHcpKSB7IHcgPSB3LnJlcGxhY2UocmUyLFwiJDEkMlwiKTsgfVxyXG5cclxuICAgIC8vIFN0ZXAgMWJcclxuICAgIHJlID0gL14oLis/KWVlZCQvO1xyXG4gICAgcmUyID0gL14oLis/KShlZHxpbmcpJC87XHJcbiAgICBpZiAocmUudGVzdCh3KSkge1xyXG4gICAgICB2YXIgZnAgPSByZS5leGVjKHcpO1xyXG4gICAgICByZSA9IG5ldyBSZWdFeHAobWdyMCk7XHJcbiAgICAgIGlmIChyZS50ZXN0KGZwWzFdKSkge1xyXG4gICAgICAgIHJlID0gLy4kLztcclxuICAgICAgICB3ID0gdy5yZXBsYWNlKHJlLFwiXCIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHJlMi50ZXN0KHcpKSB7XHJcbiAgICAgIHZhciBmcCA9IHJlMi5leGVjKHcpO1xyXG4gICAgICBzdGVtID0gZnBbMV07XHJcbiAgICAgIHJlMiA9IG5ldyBSZWdFeHAoc192KTtcclxuICAgICAgaWYgKHJlMi50ZXN0KHN0ZW0pKSB7XHJcbiAgICAgICAgdyA9IHN0ZW07XHJcbiAgICAgICAgcmUyID0gLyhhdHxibHxpeikkLztcclxuICAgICAgICByZTMgPSBuZXcgUmVnRXhwKFwiKFteYWVpb3V5bHN6XSlcXFxcMSRcIik7XHJcbiAgICAgICAgcmU0ID0gbmV3IFJlZ0V4cChcIl5cIiArIEMgKyB2ICsgXCJbXmFlaW91d3h5XSRcIik7XHJcbiAgICAgICAgaWYgKHJlMi50ZXN0KHcpKSB7ICB3ID0gdyArIFwiZVwiOyB9XHJcbiAgICAgICAgZWxzZSBpZiAocmUzLnRlc3QodykpIHsgcmUgPSAvLiQvOyB3ID0gdy5yZXBsYWNlKHJlLFwiXCIpOyB9XHJcbiAgICAgICAgZWxzZSBpZiAocmU0LnRlc3QodykpIHsgdyA9IHcgKyBcImVcIjsgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RlcCAxY1xyXG4gICAgcmUgPSAvXiguKz8peSQvO1xyXG4gICAgaWYgKHJlLnRlc3QodykpIHtcclxuICAgICAgdmFyIGZwID0gcmUuZXhlYyh3KTtcclxuICAgICAgc3RlbSA9IGZwWzFdO1xyXG4gICAgICByZSA9IG5ldyBSZWdFeHAoc192KTtcclxuICAgICAgaWYgKHJlLnRlc3Qoc3RlbSkpIHsgdyA9IHN0ZW0gKyBcImlcIjsgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0ZXAgMlxyXG4gICAgcmUgPSAvXiguKz8pKGF0aW9uYWx8dGlvbmFsfGVuY2l8YW5jaXxpemVyfGJsaXxhbGxpfGVudGxpfGVsaXxvdXNsaXxpemF0aW9ufGF0aW9ufGF0b3J8YWxpc218aXZlbmVzc3xmdWxuZXNzfG91c25lc3N8YWxpdGl8aXZpdGl8YmlsaXRpfGxvZ2kpJC87XHJcbiAgICBpZiAocmUudGVzdCh3KSkge1xyXG4gICAgICB2YXIgZnAgPSByZS5leGVjKHcpO1xyXG4gICAgICBzdGVtID0gZnBbMV07XHJcbiAgICAgIHN1ZmZpeCA9IGZwWzJdO1xyXG4gICAgICByZSA9IG5ldyBSZWdFeHAobWdyMCk7XHJcbiAgICAgIGlmIChyZS50ZXN0KHN0ZW0pKSB7XHJcbiAgICAgICAgdyA9IHN0ZW0gKyBzdGVwMmxpc3Rbc3VmZml4XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0ZXAgM1xyXG4gICAgcmUgPSAvXiguKz8pKGljYXRlfGF0aXZlfGFsaXplfGljaXRpfGljYWx8ZnVsfG5lc3MpJC87XHJcbiAgICBpZiAocmUudGVzdCh3KSkge1xyXG4gICAgICB2YXIgZnAgPSByZS5leGVjKHcpO1xyXG4gICAgICBzdGVtID0gZnBbMV07XHJcbiAgICAgIHN1ZmZpeCA9IGZwWzJdO1xyXG4gICAgICByZSA9IG5ldyBSZWdFeHAobWdyMCk7XHJcbiAgICAgIGlmIChyZS50ZXN0KHN0ZW0pKSB7XHJcbiAgICAgICAgdyA9IHN0ZW0gKyBzdGVwM2xpc3Rbc3VmZml4XTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0ZXAgNFxyXG4gICAgcmUgPSAvXiguKz8pKGFsfGFuY2V8ZW5jZXxlcnxpY3xhYmxlfGlibGV8YW50fGVtZW50fG1lbnR8ZW50fG91fGlzbXxhdGV8aXRpfG91c3xpdmV8aXplKSQvO1xyXG4gICAgcmUyID0gL14oLis/KShzfHQpKGlvbikkLztcclxuICAgIGlmIChyZS50ZXN0KHcpKSB7XHJcbiAgICAgIHZhciBmcCA9IHJlLmV4ZWModyk7XHJcbiAgICAgIHN0ZW0gPSBmcFsxXTtcclxuICAgICAgcmUgPSBuZXcgUmVnRXhwKG1ncjEpO1xyXG4gICAgICBpZiAocmUudGVzdChzdGVtKSkge1xyXG4gICAgICAgIHcgPSBzdGVtO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2UgaWYgKHJlMi50ZXN0KHcpKSB7XHJcbiAgICAgIHZhciBmcCA9IHJlMi5leGVjKHcpO1xyXG4gICAgICBzdGVtID0gZnBbMV0gKyBmcFsyXTtcclxuICAgICAgcmUyID0gbmV3IFJlZ0V4cChtZ3IxKTtcclxuICAgICAgaWYgKHJlMi50ZXN0KHN0ZW0pKSB7XHJcbiAgICAgICAgdyA9IHN0ZW07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGVwIDVcclxuICAgIHJlID0gL14oLis/KWUkLztcclxuICAgIGlmIChyZS50ZXN0KHcpKSB7XHJcbiAgICAgIHZhciBmcCA9IHJlLmV4ZWModyk7XHJcbiAgICAgIHN0ZW0gPSBmcFsxXTtcclxuICAgICAgcmUgPSBuZXcgUmVnRXhwKG1ncjEpO1xyXG4gICAgICByZTIgPSBuZXcgUmVnRXhwKG1lcTEpO1xyXG4gICAgICByZTMgPSBuZXcgUmVnRXhwKFwiXlwiICsgQyArIHYgKyBcIlteYWVpb3V3eHldJFwiKTtcclxuICAgICAgaWYgKHJlLnRlc3Qoc3RlbSkgfHwgKHJlMi50ZXN0KHN0ZW0pICYmICEocmUzLnRlc3Qoc3RlbSkpKSkge1xyXG4gICAgICAgIHcgPSBzdGVtO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmUgPSAvbGwkLztcclxuICAgIHJlMiA9IG5ldyBSZWdFeHAobWdyMSk7XHJcbiAgICBpZiAocmUudGVzdCh3KSAmJiByZTIudGVzdCh3KSkge1xyXG4gICAgICByZSA9IC8uJC87XHJcbiAgICAgIHcgPSB3LnJlcGxhY2UocmUsXCJcIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gYW5kIHR1cm4gaW5pdGlhbCBZIGJhY2sgdG8geVxyXG5cclxuICAgIGlmIChmaXJzdGNoID09IFwieVwiKSB7XHJcbiAgICAgIHcgPSBmaXJzdGNoLnRvTG93ZXJDYXNlKCkgKyB3LnN1YnN0cigxKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdztcclxuICB9XHJcbn0pKCk7XHJcblxyXG5sdW5yLlBpcGVsaW5lLnJlZ2lzdGVyRnVuY3Rpb24obHVuci5zdGVtbWVyLCAnc3RlbW1lcicpXHJcbjtcclxuLyohXHJcbiAqIGx1bnIuc3RvcFdvcmRGaWx0ZXJcclxuICogQ29weXJpZ2h0IChDKSAyMDE0IE9saXZlciBOaWdodGluZ2FsZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBsdW5yLnN0b3BXb3JkRmlsdGVyIGlzIGFuIEVuZ2xpc2ggbGFuZ3VhZ2Ugc3RvcCB3b3JkIGxpc3QgZmlsdGVyLCBhbnkgd29yZHNcclxuICogY29udGFpbmVkIGluIHRoZSBsaXN0IHdpbGwgbm90IGJlIHBhc3NlZCB0aHJvdWdoIHRoZSBmaWx0ZXIuXHJcbiAqXHJcbiAqIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiB0aGUgUGlwZWxpbmUuIElmIHRoZSB0b2tlbiBkb2VzIG5vdCBwYXNzIHRoZVxyXG4gKiBmaWx0ZXIgdGhlbiB1bmRlZmluZWQgd2lsbCBiZSByZXR1cm5lZC5cclxuICpcclxuICogQG1vZHVsZVxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gVGhlIHRva2VuIHRvIHBhc3MgdGhyb3VnaCB0aGUgZmlsdGVyXHJcbiAqIEByZXR1cm5zIHtTdHJpbmd9XHJcbiAqIEBzZWUgbHVuci5QaXBlbGluZVxyXG4gKi9cclxubHVuci5zdG9wV29yZEZpbHRlciA9IGZ1bmN0aW9uICh0b2tlbikge1xyXG4gIGlmIChsdW5yLnN0b3BXb3JkRmlsdGVyLnN0b3BXb3Jkcy5pbmRleE9mKHRva2VuKSA9PT0gLTEpIHJldHVybiB0b2tlblxyXG59XHJcblxyXG5sdW5yLnN0b3BXb3JkRmlsdGVyLnN0b3BXb3JkcyA9IG5ldyBsdW5yLlNvcnRlZFNldFxyXG5sdW5yLnN0b3BXb3JkRmlsdGVyLnN0b3BXb3Jkcy5sZW5ndGggPSAxMTlcclxubHVuci5zdG9wV29yZEZpbHRlci5zdG9wV29yZHMuZWxlbWVudHMgPSBbXHJcbiAgXCJcIixcclxuICBcImFcIixcclxuICBcImFibGVcIixcclxuICBcImFib3V0XCIsXHJcbiAgXCJhY3Jvc3NcIixcclxuICBcImFmdGVyXCIsXHJcbiAgXCJhbGxcIixcclxuICBcImFsbW9zdFwiLFxyXG4gIFwiYWxzb1wiLFxyXG4gIFwiYW1cIixcclxuICBcImFtb25nXCIsXHJcbiAgXCJhblwiLFxyXG4gIFwiYW5kXCIsXHJcbiAgXCJhbnlcIixcclxuICBcImFyZVwiLFxyXG4gIFwiYXNcIixcclxuICBcImF0XCIsXHJcbiAgXCJiZVwiLFxyXG4gIFwiYmVjYXVzZVwiLFxyXG4gIFwiYmVlblwiLFxyXG4gIFwiYnV0XCIsXHJcbiAgXCJieVwiLFxyXG4gIFwiY2FuXCIsXHJcbiAgXCJjYW5ub3RcIixcclxuICBcImNvdWxkXCIsXHJcbiAgXCJkZWFyXCIsXHJcbiAgXCJkaWRcIixcclxuICBcImRvXCIsXHJcbiAgXCJkb2VzXCIsXHJcbiAgXCJlaXRoZXJcIixcclxuICBcImVsc2VcIixcclxuICBcImV2ZXJcIixcclxuICBcImV2ZXJ5XCIsXHJcbiAgXCJmb3JcIixcclxuICBcImZyb21cIixcclxuICBcImdldFwiLFxyXG4gIFwiZ290XCIsXHJcbiAgXCJoYWRcIixcclxuICBcImhhc1wiLFxyXG4gIFwiaGF2ZVwiLFxyXG4gIFwiaGVcIixcclxuICBcImhlclwiLFxyXG4gIFwiaGVyc1wiLFxyXG4gIFwiaGltXCIsXHJcbiAgXCJoaXNcIixcclxuICBcImhvd1wiLFxyXG4gIFwiaG93ZXZlclwiLFxyXG4gIFwiaVwiLFxyXG4gIFwiaWZcIixcclxuICBcImluXCIsXHJcbiAgXCJpbnRvXCIsXHJcbiAgXCJpc1wiLFxyXG4gIFwiaXRcIixcclxuICBcIml0c1wiLFxyXG4gIFwianVzdFwiLFxyXG4gIFwibGVhc3RcIixcclxuICBcImxldFwiLFxyXG4gIFwibGlrZVwiLFxyXG4gIFwibGlrZWx5XCIsXHJcbiAgXCJtYXlcIixcclxuICBcIm1lXCIsXHJcbiAgXCJtaWdodFwiLFxyXG4gIFwibW9zdFwiLFxyXG4gIFwibXVzdFwiLFxyXG4gIFwibXlcIixcclxuICBcIm5laXRoZXJcIixcclxuICBcIm5vXCIsXHJcbiAgXCJub3JcIixcclxuICBcIm5vdFwiLFxyXG4gIFwib2ZcIixcclxuICBcIm9mZlwiLFxyXG4gIFwib2Z0ZW5cIixcclxuICBcIm9uXCIsXHJcbiAgXCJvbmx5XCIsXHJcbiAgXCJvclwiLFxyXG4gIFwib3RoZXJcIixcclxuICBcIm91clwiLFxyXG4gIFwib3duXCIsXHJcbiAgXCJyYXRoZXJcIixcclxuICBcInNhaWRcIixcclxuICBcInNheVwiLFxyXG4gIFwic2F5c1wiLFxyXG4gIFwic2hlXCIsXHJcbiAgXCJzaG91bGRcIixcclxuICBcInNpbmNlXCIsXHJcbiAgXCJzb1wiLFxyXG4gIFwic29tZVwiLFxyXG4gIFwidGhhblwiLFxyXG4gIFwidGhhdFwiLFxyXG4gIFwidGhlXCIsXHJcbiAgXCJ0aGVpclwiLFxyXG4gIFwidGhlbVwiLFxyXG4gIFwidGhlblwiLFxyXG4gIFwidGhlcmVcIixcclxuICBcInRoZXNlXCIsXHJcbiAgXCJ0aGV5XCIsXHJcbiAgXCJ0aGlzXCIsXHJcbiAgXCJ0aXNcIixcclxuICBcInRvXCIsXHJcbiAgXCJ0b29cIixcclxuICBcInR3YXNcIixcclxuICBcInVzXCIsXHJcbiAgXCJ3YW50c1wiLFxyXG4gIFwid2FzXCIsXHJcbiAgXCJ3ZVwiLFxyXG4gIFwid2VyZVwiLFxyXG4gIFwid2hhdFwiLFxyXG4gIFwid2hlblwiLFxyXG4gIFwid2hlcmVcIixcclxuICBcIndoaWNoXCIsXHJcbiAgXCJ3aGlsZVwiLFxyXG4gIFwid2hvXCIsXHJcbiAgXCJ3aG9tXCIsXHJcbiAgXCJ3aHlcIixcclxuICBcIndpbGxcIixcclxuICBcIndpdGhcIixcclxuICBcIndvdWxkXCIsXHJcbiAgXCJ5ZXRcIixcclxuICBcInlvdVwiLFxyXG4gIFwieW91clwiXHJcbl1cclxuXHJcbmx1bnIuUGlwZWxpbmUucmVnaXN0ZXJGdW5jdGlvbihsdW5yLnN0b3BXb3JkRmlsdGVyLCAnc3RvcFdvcmRGaWx0ZXInKVxyXG47XHJcbi8qIVxyXG4gKiBsdW5yLnN0ZW1tZXJcclxuICogQ29weXJpZ2h0IChDKSAyMDE0IE9saXZlciBOaWdodGluZ2FsZVxyXG4gKiBJbmNsdWRlcyBjb2RlIGZyb20gLSBodHRwOi8vdGFydGFydXMub3JnL35tYXJ0aW4vUG9ydGVyU3RlbW1lci9qcy50eHRcclxuICovXHJcblxyXG4vKipcclxuICogbHVuci5Ub2tlblN0b3JlIGlzIHVzZWQgZm9yIGVmZmljaWVudCBzdG9yaW5nIGFuZCBsb29rdXAgb2YgdGhlIHJldmVyc2VcclxuICogaW5kZXggb2YgdG9rZW4gdG8gZG9jdW1lbnQgcmVmLlxyXG4gKlxyXG4gKiBAY29uc3RydWN0b3JcclxuICovXHJcbmx1bnIuVG9rZW5TdG9yZSA9IGZ1bmN0aW9uICgpIHtcclxuICB0aGlzLnJvb3QgPSB7IGRvY3M6IHt9IH1cclxuICB0aGlzLmxlbmd0aCA9IDBcclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRzIGEgcHJldmlvdXNseSBzZXJpYWxpc2VkIHRva2VuIHN0b3JlXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXJpYWxpc2VkRGF0YSBUaGUgc2VyaWFsaXNlZCB0b2tlbiBzdG9yZSB0byBsb2FkLlxyXG4gKiBAcmV0dXJucyB7bHVuci5Ub2tlblN0b3JlfVxyXG4gKiBAbWVtYmVyT2YgVG9rZW5TdG9yZVxyXG4gKi9cclxubHVuci5Ub2tlblN0b3JlLmxvYWQgPSBmdW5jdGlvbiAoc2VyaWFsaXNlZERhdGEpIHtcclxuICB2YXIgc3RvcmUgPSBuZXcgdGhpc1xyXG5cclxuICBzdG9yZS5yb290ID0gc2VyaWFsaXNlZERhdGEucm9vdFxyXG4gIHN0b3JlLmxlbmd0aCA9IHNlcmlhbGlzZWREYXRhLmxlbmd0aFxyXG5cclxuICByZXR1cm4gc3RvcmVcclxufVxyXG5cclxuLyoqXHJcbiAqIEFkZHMgYSBuZXcgdG9rZW4gZG9jIHBhaXIgdG8gdGhlIHN0b3JlLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0IHRoaXMgZnVuY3Rpb24gc3RhcnRzIGF0IHRoZSByb290IG9mIHRoZSBjdXJyZW50IHN0b3JlLCBob3dldmVyXHJcbiAqIGl0IGNhbiBzdGFydCBhdCBhbnkgbm9kZSBvZiBhbnkgdG9rZW4gc3RvcmUgaWYgcmVxdWlyZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiBUaGUgdG9rZW4gdG8gc3RvcmUgdGhlIGRvYyB1bmRlclxyXG4gKiBAcGFyYW0ge09iamVjdH0gZG9jIFRoZSBkb2MgdG8gc3RvcmUgYWdhaW5zdCB0aGUgdG9rZW5cclxuICogQHBhcmFtIHtPYmplY3R9IHJvb3QgQW4gb3B0aW9uYWwgbm9kZSBhdCB3aGljaCB0byBzdGFydCBsb29raW5nIGZvciB0aGVcclxuICogY29ycmVjdCBwbGFjZSB0byBlbnRlciB0aGUgZG9jLCBieSBkZWZhdWx0IHRoZSByb290IG9mIHRoaXMgbHVuci5Ub2tlblN0b3JlXHJcbiAqIGlzIHVzZWQuXHJcbiAqIEBtZW1iZXJPZiBUb2tlblN0b3JlXHJcbiAqL1xyXG5sdW5yLlRva2VuU3RvcmUucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uICh0b2tlbiwgZG9jLCByb290KSB7XHJcbiAgdmFyIHJvb3QgPSByb290IHx8IHRoaXMucm9vdCxcclxuICAgICAga2V5ID0gdG9rZW5bMF0sXHJcbiAgICAgIHJlc3QgPSB0b2tlbi5zbGljZSgxKVxyXG5cclxuICBpZiAoIShrZXkgaW4gcm9vdCkpIHJvb3Rba2V5XSA9IHtkb2NzOiB7fX1cclxuXHJcbiAgaWYgKHJlc3QubGVuZ3RoID09PSAwKSB7XHJcbiAgICByb290W2tleV0uZG9jc1tkb2MucmVmXSA9IGRvY1xyXG4gICAgdGhpcy5sZW5ndGggKz0gMVxyXG4gICAgcmV0dXJuXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiB0aGlzLmFkZChyZXN0LCBkb2MsIHJvb3Rba2V5XSlcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciB0aGlzIGtleSBpcyBjb250YWluZWQgd2l0aGluIHRoaXMgbHVuci5Ub2tlblN0b3JlLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0IHRoaXMgZnVuY3Rpb24gc3RhcnRzIGF0IHRoZSByb290IG9mIHRoZSBjdXJyZW50IHN0b3JlLCBob3dldmVyXHJcbiAqIGl0IGNhbiBzdGFydCBhdCBhbnkgbm9kZSBvZiBhbnkgdG9rZW4gc3RvcmUgaWYgcmVxdWlyZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiBUaGUgdG9rZW4gdG8gY2hlY2sgZm9yXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSByb290IEFuIG9wdGlvbmFsIG5vZGUgYXQgd2hpY2ggdG8gc3RhcnRcclxuICogQG1lbWJlck9mIFRva2VuU3RvcmVcclxuICovXHJcbmx1bnIuVG9rZW5TdG9yZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHRva2VuKSB7XHJcbiAgaWYgKCF0b2tlbikgcmV0dXJuIGZhbHNlXHJcblxyXG4gIHZhciBub2RlID0gdGhpcy5yb290XHJcblxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmICghbm9kZVt0b2tlbltpXV0pIHJldHVybiBmYWxzZVxyXG5cclxuICAgIG5vZGUgPSBub2RlW3Rva2VuW2ldXVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRydWVcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHJpZXZlIGEgbm9kZSBmcm9tIHRoZSB0b2tlbiBzdG9yZSBmb3IgYSBnaXZlbiB0b2tlbi5cclxuICpcclxuICogQnkgZGVmYXVsdCB0aGlzIGZ1bmN0aW9uIHN0YXJ0cyBhdCB0aGUgcm9vdCBvZiB0aGUgY3VycmVudCBzdG9yZSwgaG93ZXZlclxyXG4gKiBpdCBjYW4gc3RhcnQgYXQgYW55IG5vZGUgb2YgYW55IHRva2VuIHN0b3JlIGlmIHJlcXVpcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW4gVGhlIHRva2VuIHRvIGdldCB0aGUgbm9kZSBmb3IuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSByb290IEFuIG9wdGlvbmFsIG5vZGUgYXQgd2hpY2ggdG8gc3RhcnQuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqIEBzZWUgVG9rZW5TdG9yZS5wcm90b3R5cGUuZ2V0XHJcbiAqIEBtZW1iZXJPZiBUb2tlblN0b3JlXHJcbiAqL1xyXG5sdW5yLlRva2VuU3RvcmUucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcclxuICBpZiAoIXRva2VuKSByZXR1cm4ge31cclxuXHJcbiAgdmFyIG5vZGUgPSB0aGlzLnJvb3RcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgaWYgKCFub2RlW3Rva2VuW2ldXSkgcmV0dXJuIHt9XHJcblxyXG4gICAgbm9kZSA9IG5vZGVbdG9rZW5baV1dXHJcbiAgfVxyXG5cclxuICByZXR1cm4gbm9kZVxyXG59XHJcblxyXG4vKipcclxuICogUmV0cmlldmUgdGhlIGRvY3VtZW50cyBmb3IgYSBub2RlIGZvciB0aGUgZ2l2ZW4gdG9rZW4uXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQgdGhpcyBmdW5jdGlvbiBzdGFydHMgYXQgdGhlIHJvb3Qgb2YgdGhlIGN1cnJlbnQgc3RvcmUsIGhvd2V2ZXJcclxuICogaXQgY2FuIHN0YXJ0IGF0IGFueSBub2RlIG9mIGFueSB0b2tlbiBzdG9yZSBpZiByZXF1aXJlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIFRoZSB0b2tlbiB0byBnZXQgdGhlIGRvY3VtZW50cyBmb3IuXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSByb290IEFuIG9wdGlvbmFsIG5vZGUgYXQgd2hpY2ggdG8gc3RhcnQuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqIEBtZW1iZXJPZiBUb2tlblN0b3JlXHJcbiAqL1xyXG5sdW5yLlRva2VuU3RvcmUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICh0b2tlbiwgcm9vdCkge1xyXG4gIHJldHVybiB0aGlzLmdldE5vZGUodG9rZW4sIHJvb3QpLmRvY3MgfHwge31cclxufVxyXG5cclxubHVuci5Ub2tlblN0b3JlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICh0b2tlbiwgcm9vdCkge1xyXG4gIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldCh0b2tlbiwgcm9vdCkpLmxlbmd0aFxyXG59XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBkb2N1bWVudCBpZGVudGlmaWVkIGJ5IHJlZiBmcm9tIHRoZSB0b2tlbiBpbiB0aGUgc3RvcmUuXHJcbiAqXHJcbiAqIEJ5IGRlZmF1bHQgdGhpcyBmdW5jdGlvbiBzdGFydHMgYXQgdGhlIHJvb3Qgb2YgdGhlIGN1cnJlbnQgc3RvcmUsIGhvd2V2ZXJcclxuICogaXQgY2FuIHN0YXJ0IGF0IGFueSBub2RlIG9mIGFueSB0b2tlbiBzdG9yZSBpZiByZXF1aXJlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHRva2VuIFRoZSB0b2tlbiB0byBnZXQgdGhlIGRvY3VtZW50cyBmb3IuXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWYgVGhlIHJlZiBvZiB0aGUgZG9jdW1lbnQgdG8gcmVtb3ZlIGZyb20gdGhpcyB0b2tlbi5cclxuICogQHBhcmFtIHtPYmplY3R9IHJvb3QgQW4gb3B0aW9uYWwgbm9kZSBhdCB3aGljaCB0byBzdGFydC5cclxuICogQHJldHVybnMge09iamVjdH1cclxuICogQG1lbWJlck9mIFRva2VuU3RvcmVcclxuICovXHJcbmx1bnIuVG9rZW5TdG9yZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHRva2VuLCByZWYpIHtcclxuICBpZiAoIXRva2VuKSByZXR1cm5cclxuICB2YXIgbm9kZSA9IHRoaXMucm9vdFxyXG5cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoISh0b2tlbltpXSBpbiBub2RlKSkgcmV0dXJuXHJcbiAgICBub2RlID0gbm9kZVt0b2tlbltpXV1cclxuICB9XHJcblxyXG4gIGRlbGV0ZSBub2RlLmRvY3NbcmVmXVxyXG59XHJcblxyXG4vKipcclxuICogRmluZCBhbGwgdGhlIHBvc3NpYmxlIHN1ZmZpeGVzIG9mIHRoZSBwYXNzZWQgdG9rZW4gdXNpbmcgdG9rZW5zXHJcbiAqIGN1cnJlbnRseSBpbiB0aGUgc3RvcmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiBUaGUgdG9rZW4gdG8gZXhwYW5kLlxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqIEBtZW1iZXJPZiBUb2tlblN0b3JlXHJcbiAqL1xyXG5sdW5yLlRva2VuU3RvcmUucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uICh0b2tlbiwgbWVtbykge1xyXG4gIHZhciByb290ID0gdGhpcy5nZXROb2RlKHRva2VuKSxcclxuICAgICAgZG9jcyA9IHJvb3QuZG9jcyB8fCB7fSxcclxuICAgICAgbWVtbyA9IG1lbW8gfHwgW11cclxuXHJcbiAgaWYgKE9iamVjdC5rZXlzKGRvY3MpLmxlbmd0aCkgbWVtby5wdXNoKHRva2VuKVxyXG5cclxuICBPYmplY3Qua2V5cyhyb290KVxyXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICBpZiAoa2V5ID09PSAnZG9jcycpIHJldHVyblxyXG5cclxuICAgICAgbWVtby5jb25jYXQodGhpcy5leHBhbmQodG9rZW4gKyBrZXksIG1lbW8pKVxyXG4gICAgfSwgdGhpcylcclxuXHJcbiAgcmV0dXJuIG1lbW9cclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgdG9rZW4gc3RvcmUgcmVhZHkgZm9yIHNlcmlhbGlzYXRpb24uXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9XHJcbiAqIEBtZW1iZXJPZiBUb2tlblN0b3JlXHJcbiAqL1xyXG5sdW5yLlRva2VuU3RvcmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4ge1xyXG4gICAgcm9vdDogdGhpcy5yb290LFxyXG4gICAgbGVuZ3RoOiB0aGlzLmxlbmd0aFxyXG4gIH1cclxufVxyXG5cclxuO1xyXG4iLCIvKiFcclxuICBiYWNrZ3JpZFxyXG4gIGh0dHA6Ly9naXRodWIuY29tL3d5dWVuaG8vYmFja2dyaWRcclxuXHJcbiAgQ29weXJpZ2h0IChjKSAyMDE0IEppbW15IFl1ZW4gSG8gV29uZyBhbmQgY29udHJpYnV0b3JzIDx3eXVlbmhvQGdtYWlsLmNvbT5cclxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiovXHJcblxyXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuXHJcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XHJcbiAgICAvLyBBTUQgKCsgZ2xvYmFsIGZvciBleHRlbnNpb25zKVxyXG4gICAgZGVmaW5lKFtcInVuZGVyc2NvcmVcIiwgXCJiYWNrYm9uZVwiXSwgZnVuY3Rpb24gKF8sIEJhY2tib25lKSB7XHJcbiAgICAgIHJldHVybiAocm9vdC5CYWNrZ3JpZCA9IGZhY3RvcnkoXywgQmFja2JvbmUpKTtcclxuICAgIH0pO1xyXG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcclxuICAgIC8vIENvbW1vbkpTXHJcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZShcInVuZGVyc2NvcmVcIiksIHJlcXVpcmUoXCJiYWNrYm9uZVwiKSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIEJyb3dzZXJcclxuICAgIHJvb3QuQmFja2dyaWQgPSBmYWN0b3J5KHJvb3QuXywgcm9vdC5CYWNrYm9uZSk7XHJcbiAgfX0odGhpcywgZnVuY3Rpb24gKF8sIEJhY2tib25lKSB7XHJcblxyXG4gIFwidXNlIHN0cmljdFwiO1xyXG5cclxuLypcclxuICBiYWNrZ3JpZFxyXG4gIGh0dHA6Ly9naXRodWIuY29tL3d5dWVuaG8vYmFja2dyaWRcclxuXHJcbiAgQ29weXJpZ2h0IChjKSAyMDEzIEppbW15IFl1ZW4gSG8gV29uZyBhbmQgY29udHJpYnV0b3JzXHJcbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4qL1xyXG5cclxuLy8gQ29weXJpZ2h0IDIwMDksIDIwMTAgS3Jpc3RvcGhlciBNaWNoYWVsIEtvd2FsXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvZXM1LXNoaW1cclxuLy8gRVM1IDE1LjUuNC4yMFxyXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS41LjQuMjBcclxudmFyIHdzID0gXCJcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1wiICtcclxuICBcIlxcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBcXHUyMDI4XCIgK1xyXG4gIFwiXFx1MjAyOVxcdUZFRkZcIjtcclxuaWYgKCFTdHJpbmcucHJvdG90eXBlLnRyaW0gfHwgd3MudHJpbSgpKSB7XHJcbiAgLy8gaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Zhc3Rlci10cmltLWphdmFzY3JpcHRcclxuICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS93aGl0ZXNwYWNlLWRldmlhdGlvbnMvXHJcbiAgd3MgPSBcIltcIiArIHdzICsgXCJdXCI7XHJcbiAgdmFyIHRyaW1CZWdpblJlZ2V4cCA9IG5ldyBSZWdFeHAoXCJeXCIgKyB3cyArIHdzICsgXCIqXCIpLFxyXG4gIHRyaW1FbmRSZWdleHAgPSBuZXcgUmVnRXhwKHdzICsgd3MgKyBcIiokXCIpO1xyXG4gIFN0cmluZy5wcm90b3R5cGUudHJpbSA9IGZ1bmN0aW9uIHRyaW0oKSB7XHJcbiAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkIHx8IHRoaXMgPT09IG51bGwpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyB0aGlzICsgXCIgdG8gb2JqZWN0XCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZyh0aGlzKVxyXG4gICAgICAucmVwbGFjZSh0cmltQmVnaW5SZWdleHAsIFwiXCIpXHJcbiAgICAgIC5yZXBsYWNlKHRyaW1FbmRSZWdleHAsIFwiXCIpO1xyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGxwYWQoc3RyLCBsZW5ndGgsIHBhZHN0cikge1xyXG4gIHZhciBwYWRkaW5nTGVuID0gbGVuZ3RoIC0gKHN0ciArICcnKS5sZW5ndGg7XHJcbiAgcGFkZGluZ0xlbiA9ICBwYWRkaW5nTGVuIDwgMCA/IDAgOiBwYWRkaW5nTGVuO1xyXG4gIHZhciBwYWRkaW5nID0gJyc7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRkaW5nTGVuOyBpKyspIHtcclxuICAgIHBhZGRpbmcgPSBwYWRkaW5nICsgcGFkc3RyO1xyXG4gIH1cclxuICByZXR1cm4gcGFkZGluZyArIHN0cjtcclxufVxyXG5cclxudmFyICQgPSBCYWNrYm9uZS4kO1xyXG5cclxudmFyIEJhY2tncmlkID0ge1xyXG5cclxuICBFeHRlbnNpb246IHt9LFxyXG5cclxuICByZXNvbHZlTmFtZVRvQ2xhc3M6IGZ1bmN0aW9uIChuYW1lLCBzdWZmaXgpIHtcclxuICAgIGlmIChfLmlzU3RyaW5nKG5hbWUpKSB7XHJcbiAgICAgIHZhciBrZXkgPSBfLm1hcChuYW1lLnNwbGl0KCctJyksIGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgcmV0dXJuIGUuc2xpY2UoMCwgMSkudG9VcHBlckNhc2UoKSArIGUuc2xpY2UoMSk7XHJcbiAgICAgIH0pLmpvaW4oJycpICsgc3VmZml4O1xyXG4gICAgICB2YXIga2xhc3MgPSBCYWNrZ3JpZFtrZXldIHx8IEJhY2tncmlkLkV4dGVuc2lvbltrZXldO1xyXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChrbGFzcykpIHtcclxuICAgICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJDbGFzcyAnXCIgKyBrZXkgKyBcIicgbm90IGZvdW5kXCIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBrbGFzcztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmFtZTtcclxuICB9LFxyXG5cclxuICBjYWxsQnlOZWVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XHJcbiAgICBpZiAoIV8uaXNGdW5jdGlvbih2YWx1ZSkpIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50c1sxXTtcclxuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgcmV0dXJuIHZhbHVlLmFwcGx5KGNvbnRleHQsICEhKGFyZ3MgKyAnJykgPyBhcmdzIDogW10pO1xyXG4gIH1cclxuXHJcbn07XHJcbl8uZXh0ZW5kKEJhY2tncmlkLCBCYWNrYm9uZS5FdmVudHMpO1xyXG5cclxuLyoqXHJcbiAgIENvbW1hbmQgdHJhbnNsYXRlcyBhIERPTSBFdmVudCBpbnRvIGNvbW1hbmRzIHRoYXQgQmFja2dyaWRcclxuICAgcmVjb2duaXplcy4gSW50ZXJlc3RlZCBwYXJ0aWVzIGNhbiBsaXN0ZW4gb24gc2VsZWN0ZWQgQmFja2dyaWQgZXZlbnRzIHRoYXRcclxuICAgY29tZSB3aXRoIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgYW5kIGFjdCBvbiB0aGUgY29tbWFuZHMuXHJcblxyXG4gICBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGdsb2JhbGx5IHJlYmluZCB0aGUga2V5Ym9hcmQgc2hvcnRjdXRzIGJ5IHJlcGxhY2luZ1xyXG4gICB0aGUgbWV0aG9kcyBpbiB0aGlzIGNsYXNzJyBwcm90b3R5cGUuXHJcblxyXG4gICBAY2xhc3MgQmFja2dyaWQuQ29tbWFuZFxyXG4gICBAY29uc3RydWN0b3JcclxuICovXHJcbnZhciBDb21tYW5kID0gQmFja2dyaWQuQ29tbWFuZCA9IGZ1bmN0aW9uIChldnQpIHtcclxuICBfLmV4dGVuZCh0aGlzLCB7XHJcbiAgICBhbHRLZXk6ICEhZXZ0LmFsdEtleSxcclxuICAgIFwiY2hhclwiOiBldnRbXCJjaGFyXCJdLFxyXG4gICAgY2hhckNvZGU6IGV2dC5jaGFyQ29kZSxcclxuICAgIGN0cmxLZXk6ICEhZXZ0LmN0cmxLZXksXHJcbiAgICBrZXk6IGV2dC5rZXksXHJcbiAgICBrZXlDb2RlOiBldnQua2V5Q29kZSxcclxuICAgIGxvY2FsZTogZXZ0LmxvY2FsZSxcclxuICAgIGxvY2F0aW9uOiBldnQubG9jYXRpb24sXHJcbiAgICBtZXRhS2V5OiAhIWV2dC5tZXRhS2V5LFxyXG4gICAgcmVwZWF0OiAhIWV2dC5yZXBlYXQsXHJcbiAgICBzaGlmdEtleTogISFldnQuc2hpZnRLZXksXHJcbiAgICB3aGljaDogZXZ0LndoaWNoXHJcbiAgfSk7XHJcbn07XHJcbl8uZXh0ZW5kKENvbW1hbmQucHJvdG90eXBlLCB7XHJcbiAgLyoqXHJcbiAgICAgVXAgQXJyb3dcclxuXHJcbiAgICAgQG1lbWJlciBCYWNrZ3JpZC5Db21tYW5kXHJcbiAgICovXHJcbiAgbW92ZVVwOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmtleUNvZGUgPT0gMzg7IH0sXHJcbiAgLyoqXHJcbiAgICAgRG93biBBcnJvd1xyXG5cclxuICAgICBAbWVtYmVyIEJhY2tncmlkLkNvbW1hbmRcclxuICAgKi9cclxuICBtb3ZlRG93bjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5rZXlDb2RlID09PSA0MDsgfSxcclxuICAvKipcclxuICAgICBTaGlmdCBUYWJcclxuXHJcbiAgICAgQG1lbWJlciBCYWNrZ3JpZC5Db21tYW5kXHJcbiAgICovXHJcbiAgbW92ZUxlZnQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuc2hpZnRLZXkgJiYgdGhpcy5rZXlDb2RlID09PSA5OyB9LFxyXG4gIC8qKlxyXG4gICAgIFRhYlxyXG5cclxuICAgICBAbWVtYmVyIEJhY2tncmlkLkNvbW1hbmRcclxuICAgKi9cclxuICBtb3ZlUmlnaHQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICF0aGlzLnNoaWZ0S2V5ICYmIHRoaXMua2V5Q29kZSA9PT0gOTsgfSxcclxuICAvKipcclxuICAgICBFbnRlclxyXG5cclxuICAgICBAbWVtYmVyIEJhY2tncmlkLkNvbW1hbmRcclxuICAgKi9cclxuICBzYXZlOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmtleUNvZGUgPT09IDEzOyB9LFxyXG4gIC8qKlxyXG4gICAgIEVzY1xyXG5cclxuICAgICBAbWVtYmVyIEJhY2tncmlkLkNvbW1hbmRcclxuICAgKi9cclxuICBjYW5jZWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMua2V5Q29kZSA9PT0gMjc7IH0sXHJcbiAgLyoqXHJcbiAgICAgTm9uZSBvZiB0aGUgYWJvdmUuXHJcblxyXG4gICAgIEBtZW1iZXIgQmFja2dyaWQuQ29tbWFuZFxyXG4gICAqL1xyXG4gIHBhc3NUaHJ1OiBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gISh0aGlzLm1vdmVVcCgpIHx8IHRoaXMubW92ZURvd24oKSB8fCB0aGlzLm1vdmVMZWZ0KCkgfHxcclxuICAgICAgICAgICAgIHRoaXMubW92ZVJpZ2h0KCkgfHwgdGhpcy5zYXZlKCkgfHwgdGhpcy5jYW5jZWwoKSk7XHJcbiAgfVxyXG59KTtcclxuXHJcbi8qXHJcbiAgYmFja2dyaWRcclxuICBodHRwOi8vZ2l0aHViLmNvbS93eXVlbmhvL2JhY2tncmlkXHJcblxyXG4gIENvcHlyaWdodCAoYykgMjAxMyBKaW1teSBZdWVuIEhvIFdvbmcgYW5kIGNvbnRyaWJ1dG9yc1xyXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuKi9cclxuXHJcbi8qKlxyXG4gICBKdXN0IGEgY29udmVuaWVudCBjbGFzcyBmb3IgaW50ZXJlc3RlZCBwYXJ0aWVzIHRvIHN1YmNsYXNzLlxyXG5cclxuICAgVGhlIGRlZmF1bHQgQ2VsbCBjbGFzc2VzIGRvbid0IHJlcXVpcmUgdGhlIGZvcm1hdHRlciB0byBiZSBhIHN1YmNsYXNzIG9mXHJcbiAgIEZvcm1hdHRlciBhcyBsb25nIGFzIHRoZSBmcm9tUmF3KHJhd0RhdGEpIGFuZCB0b1Jhdyhmb3JtYXR0ZWREYXRhKSBtZXRob2RzXHJcbiAgIGFyZSBkZWZpbmVkLlxyXG5cclxuICAgQGFic3RyYWN0XHJcbiAgIEBjbGFzcyBCYWNrZ3JpZC5DZWxsRm9ybWF0dGVyXHJcbiAgIEBjb25zdHJ1Y3RvclxyXG4qL1xyXG52YXIgQ2VsbEZvcm1hdHRlciA9IEJhY2tncmlkLkNlbGxGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcclxuXy5leHRlbmQoQ2VsbEZvcm1hdHRlci5wcm90b3R5cGUsIHtcclxuXHJcbiAgLyoqXHJcbiAgICAgVGFrZXMgYSByYXcgdmFsdWUgZnJvbSBhIG1vZGVsIGFuZCByZXR1cm5zIGFuIG9wdGlvbmFsbHkgZm9ybWF0dGVkIHN0cmluZ1xyXG4gICAgIGZvciBkaXNwbGF5LiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzaW1wbHkgcmV0dXJucyB0aGUgc3VwcGxpZWQgdmFsdWVcclxuICAgICBhcyBpcyB3aXRob3V0IGFueSB0eXBlIGNvbnZlcnNpb24uXHJcblxyXG4gICAgIEBtZW1iZXIgQmFja2dyaWQuQ2VsbEZvcm1hdHRlclxyXG4gICAgIEBwYXJhbSB7Kn0gcmF3RGF0YVxyXG4gICAgIEBwYXJhbSB7QmFja2JvbmUuTW9kZWx9IG1vZGVsIFVzZWQgZm9yIG1vcmUgY29tcGxpY2F0ZWQgZm9ybWF0dGluZ1xyXG4gICAgIEByZXR1cm4geyp9XHJcbiAgKi9cclxuICBmcm9tUmF3OiBmdW5jdGlvbiAocmF3RGF0YSwgbW9kZWwpIHtcclxuICAgIHJldHVybiByYXdEYXRhO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIFRha2VzIGEgZm9ybWF0dGVkIHN0cmluZywgdXN1YWxseSBmcm9tIHVzZXIgaW5wdXQsIGFuZCByZXR1cm5zIGFcclxuICAgICBhcHByb3ByaWF0ZWx5IHR5cGVkIHZhbHVlIGZvciBwZXJzaXN0ZW5jZSBpbiB0aGUgbW9kZWwuXHJcblxyXG4gICAgIElmIHRoZSB1c2VyIGlucHV0IGlzIGludmFsaWQgb3IgdW5hYmxlIHRvIGJlIGNvbnZlcnRlZCB0byBhIHJhdyB2YWx1ZVxyXG4gICAgIHN1aXRhYmxlIGZvciBwZXJzaXN0ZW5jZSBpbiB0aGUgbW9kZWwsIHRvUmF3IG11c3QgcmV0dXJuIGB1bmRlZmluZWRgLlxyXG5cclxuICAgICBAbWVtYmVyIEJhY2tncmlkLkNlbGxGb3JtYXR0ZXJcclxuICAgICBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkRGF0YVxyXG4gICAgIEBwYXJhbSB7QmFja2JvbmUuTW9kZWx9IG1vZGVsIFVzZWQgZm9yIG1vcmUgY29tcGxpY2F0ZWQgZm9ybWF0dGluZ1xyXG4gICAgIEByZXR1cm4geyp8dW5kZWZpbmVkfVxyXG4gICovXHJcbiAgdG9SYXc6IGZ1bmN0aW9uIChmb3JtYXR0ZWREYXRhLCBtb2RlbCkge1xyXG4gICAgcmV0dXJuIGZvcm1hdHRlZERhdGE7XHJcbiAgfVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICAgQSBmbG9hdGluZyBwb2ludCBudW1iZXIgZm9ybWF0dGVyLiBEb2Vzbid0IHVuZGVyc3RhbmQgc2NpZW50aWZpYyBub3RhdGlvbiBhdFxyXG4gICB0aGUgbW9tZW50LlxyXG5cclxuICAgQGNsYXNzIEJhY2tncmlkLk51bWJlckZvcm1hdHRlclxyXG4gICBAZXh0ZW5kcyBCYWNrZ3JpZC5DZWxsRm9ybWF0dGVyXHJcbiAgIEBjb25zdHJ1Y3RvclxyXG4gICBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBkZWNpbWFscyA8IDAgb3IgPiAyMC5cclxuKi9cclxudmFyIE51bWJlckZvcm1hdHRlciA9IEJhY2tncmlkLk51bWJlckZvcm1hdHRlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgXy5leHRlbmQodGhpcywgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XHJcblxyXG4gIGlmICh0aGlzLmRlY2ltYWxzIDwgMCB8fCB0aGlzLmRlY2ltYWxzID4gMjApIHtcclxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiZGVjaW1hbHMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDIwXCIpO1xyXG4gIH1cclxufTtcclxuTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZSA9IG5ldyBDZWxsRm9ybWF0dGVyKCk7XHJcbl8uZXh0ZW5kKE51bWJlckZvcm1hdHRlci5wcm90b3R5cGUsIHtcclxuXHJcbiAgLyoqXHJcbiAgICAgQG1lbWJlciBCYWNrZ3JpZC5OdW1iZXJGb3JtYXR0ZXJcclxuICAgICBAY2ZnIHtPYmplY3R9IG9wdGlvbnNcclxuXHJcbiAgICAgQGNmZyB7bnVtYmVyfSBbb3B0aW9ucy5kZWNpbWFscz0yXSBOdW1iZXIgb2YgZGVjaW1hbHMgdG8gZGlzcGxheS4gTXVzdCBiZSBhbiBpbnRlZ2VyLlxyXG5cclxuICAgICBAY2ZnIHtzdHJpbmd9IFtvcHRpb25zLmRlY2ltYWxTZXBhcmF0b3I9Jy4nXSBUaGUgc2VwYXJhdG9yIHRvIHVzZSB3aGVuXHJcbiAgICAgZGlzcGxheWluZyBkZWNpbWFscy5cclxuXHJcbiAgICAgQGNmZyB7c3RyaW5nfSBbb3B0aW9ucy5vcmRlclNlcGFyYXRvcj0nLCddIFRoZSBzZXBhcmF0b3IgdG8gdXNlIHRvXHJcbiAgICAgc2VwYXJhdG9yIHRob3VzYW5kcy4gTWF5IGJlIGFuIGVtcHR5IHN0cmluZy5cclxuICAgKi9cclxuICBkZWZhdWx0czoge1xyXG4gICAgZGVjaW1hbHM6IDIsXHJcbiAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICBvcmRlclNlcGFyYXRvcjogJywnXHJcbiAgfSxcclxuXHJcbiAgSFVNQU5JWkVEX05VTV9SRTogLyhcXGQpKD89KD86XFxkezN9KSskKS9nLFxyXG5cclxuICAvKipcclxuICAgICBUYWtlcyBhIGZsb2F0aW5nIHBvaW50IG51bWJlciBhbmQgY29udmVydCBpdCB0byBhIGZvcm1hdHRlZCBzdHJpbmcgd2hlcmVcclxuICAgICBldmVyeSB0aG91c2FuZCBpcyBzZXBhcmF0ZWQgYnkgYG9yZGVyU2VwYXJhdG9yYCwgd2l0aCBhIGBkZWNpbWFsYCBudW1iZXIgb2ZcclxuICAgICBkZWNpbWFscyBzZXBhcmF0ZWQgYnkgYGRlY2ltYWxTZXBhcmF0b3JgLiBUaGUgbnVtYmVyIHJldHVybmVkIGlzIHJvdW5kZWRcclxuICAgICB0aGUgdXN1YWwgd2F5LlxyXG5cclxuICAgICBAbWVtYmVyIEJhY2tncmlkLk51bWJlckZvcm1hdHRlclxyXG4gICAgIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJcclxuICAgICBAcGFyYW0ge0JhY2tib25lLk1vZGVsfSBtb2RlbCBVc2VkIGZvciBtb3JlIGNvbXBsaWNhdGVkIGZvcm1hdHRpbmdcclxuICAgICBAcmV0dXJuIHtzdHJpbmd9XHJcbiAgKi9cclxuICBmcm9tUmF3OiBmdW5jdGlvbiAobnVtYmVyLCBtb2RlbCkge1xyXG4gICAgaWYgKF8uaXNOdWxsKG51bWJlcikgfHwgXy5pc1VuZGVmaW5lZChudW1iZXIpKSByZXR1cm4gJyc7XHJcblxyXG4gICAgbnVtYmVyID0gbnVtYmVyLnRvRml4ZWQofn50aGlzLmRlY2ltYWxzKTtcclxuXHJcbiAgICB2YXIgcGFydHMgPSBudW1iZXIuc3BsaXQoJy4nKTtcclxuICAgIHZhciBpbnRlZ2VyUGFydCA9IHBhcnRzWzBdO1xyXG4gICAgdmFyIGRlY2ltYWxQYXJ0ID0gcGFydHNbMV0gPyAodGhpcy5kZWNpbWFsU2VwYXJhdG9yIHx8ICcuJykgKyBwYXJ0c1sxXSA6ICcnO1xyXG5cclxuICAgIHJldHVybiBpbnRlZ2VyUGFydC5yZXBsYWNlKHRoaXMuSFVNQU5JWkVEX05VTV9SRSwgJyQxJyArIHRoaXMub3JkZXJTZXBhcmF0b3IpICsgZGVjaW1hbFBhcnQ7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgVGFrZXMgYSBzdHJpbmcsIHBvc3NpYmx5IGZvcm1hdHRlZCB3aXRoIGBvcmRlclNlcGFyYXRvcmAgYW5kL29yXHJcbiAgICAgYGRlY2ltYWxTZXBhcmF0b3JgLCBhbmQgY29udmVydCBpdCBiYWNrIHRvIGEgbnVtYmVyLlxyXG5cclxuICAgICBAbWVtYmVyIEJhY2tncmlkLk51bWJlckZvcm1hdHRlclxyXG4gICAgIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXR0ZWREYXRhXHJcbiAgICAgQHBhcmFtIHtCYWNrYm9uZS5Nb2RlbH0gbW9kZWwgVXNlZCBmb3IgbW9yZSBjb21wbGljYXRlZCBmb3JtYXR0aW5nXHJcbiAgICAgQHJldHVybiB7bnVtYmVyfHVuZGVmaW5lZH0gVW5kZWZpbmVkIGlmIHRoZSBzdHJpbmcgY2Fubm90IGJlIGNvbnZlcnRlZCB0b1xyXG4gICAgIGEgbnVtYmVyLlxyXG4gICovXHJcbiAgdG9SYXc6IGZ1bmN0aW9uIChmb3JtYXR0ZWREYXRhLCBtb2RlbCkge1xyXG4gICAgZm9ybWF0dGVkRGF0YSA9IGZvcm1hdHRlZERhdGEudHJpbSgpO1xyXG5cclxuICAgIGlmIChmb3JtYXR0ZWREYXRhID09PSAnJykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgdmFyIHJhd0RhdGEgPSAnJztcclxuXHJcbiAgICB2YXIgdGhvdXNhbmRzID0gZm9ybWF0dGVkRGF0YS5zcGxpdCh0aGlzLm9yZGVyU2VwYXJhdG9yKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhvdXNhbmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHJhd0RhdGEgKz0gdGhvdXNhbmRzW2ldO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBkZWNpbWFsUGFydHMgPSByYXdEYXRhLnNwbGl0KHRoaXMuZGVjaW1hbFNlcGFyYXRvcik7XHJcbiAgICByYXdEYXRhID0gJyc7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlY2ltYWxQYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICByYXdEYXRhID0gcmF3RGF0YSArIGRlY2ltYWxQYXJ0c1tpXSArICcuJztcclxuICAgIH1cclxuXHJcbiAgICBpZiAocmF3RGF0YVtyYXdEYXRhLmxlbmd0aCAtIDFdID09PSAnLicpIHtcclxuICAgICAgcmF3RGF0YSA9IHJhd0RhdGEuc2xpY2UoMCwgcmF3RGF0YS5sZW5ndGggLSAxKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgcmVzdWx0ID0gKHJhd0RhdGEgKiAxKS50b0ZpeGVkKH5+dGhpcy5kZWNpbWFscykgKiAxO1xyXG4gICAgaWYgKF8uaXNOdW1iZXIocmVzdWx0KSAmJiAhXy5pc05hTihyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAgIEEgbnVtYmVyIGZvcm1hdHRlciB0aGF0IGNvbnZlcnRzIGEgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLCBvcHRpb25hbGx5XHJcbiAgIG11bHRpcGxpZWQgYnkgYSBtdWx0aXBsaWVyLCB0byBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGFuZCB2aWNlIHZlcnNhLlxyXG5cclxuICAgQGNsYXNzIEJhY2tncmlkLlBlcmNlbnRGb3JtYXR0ZXJcclxuICAgQGV4dGVuZHMgQmFja2dyaWQuTnVtYmVyRm9ybWF0dGVyXHJcbiAgIEBjb25zdHJ1Y3RvclxyXG4gICBAdGhyb3dzIHtSYW5nZUVycm9yfSBJZiBkZWNpbWFscyA8IDAgb3IgPiAyMC5cclxuICovXHJcbnZhciBQZXJjZW50Rm9ybWF0dGVyID0gQmFja2dyaWQuUGVyY2VudEZvcm1hdHRlciA9IGZ1bmN0aW9uICgpIHtcclxuICBCYWNrZ3JpZC5OdW1iZXJGb3JtYXR0ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcblBlcmNlbnRGb3JtYXR0ZXIucHJvdG90eXBlID0gbmV3IEJhY2tncmlkLk51bWJlckZvcm1hdHRlcigpLFxyXG5cclxuXy5leHRlbmQoUGVyY2VudEZvcm1hdHRlci5wcm90b3R5cGUsIHtcclxuXHJcbiAgLyoqXHJcbiAgICAgQG1lbWJlciBCYWNrZ3JpZC5QZXJjZW50Rm9ybWF0dGVyXHJcbiAgICAgQGNmZyB7T2JqZWN0fSBvcHRpb25zXHJcblxyXG4gICAgIEBjZmcge251bWJlcn0gW29wdGlvbnMubXVsdGlwbGllcj0xXSBUaGUgbnVtYmVyIHVzZWQgdG8gbXVsdGlwbHkgdGhlIG1vZGVsXHJcbiAgICAgdmFsdWUgZm9yIGRpc3BsYXkuXHJcblxyXG4gICAgIEBjZmcge3N0cmluZ30gW29wdGlvbnMuc3ltYm9sPSclJ10gVGhlIHN5bWJvbCB0byBhcHBlbmQgdG8gdGhlIHBlcmNlbnRhZ2VcclxuICAgICBzdHJpbmcuXHJcbiAgICovXHJcbiAgZGVmYXVsdHM6IF8uZXh0ZW5kKHt9LCBOdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlLmRlZmF1bHRzLCB7XHJcbiAgICBtdWx0aXBsaWVyOiAxLFxyXG4gICAgc3ltYm9sOiBcIiVcIlxyXG4gIH0pLFxyXG5cclxuICAvKipcclxuICAgICBUYWtlcyBhIGZsb2F0aW5nIHBvaW50IG51bWJlciwgd2hlcmUgdGhlIG51bWJlciBpcyBmaXJzdCBtdWx0aXBsaWVkIGJ5XHJcbiAgICAgYG11bHRpcGxpZXJgLCB0aGVuIGNvbnZlcnRlZCB0byBhIGZvcm1hdHRlZCBzdHJpbmcgbGlrZVxyXG4gICAgIE51bWJlckZvcm1hdHRlciNmcm9tUmF3LCB0aGVuIGZpbmFsbHkgYXBwZW5kIGBzeW1ib2xgIHRvIHRoZSBlbmQuXHJcblxyXG4gICAgIEBtZW1iZXIgQmFja2dyaWQuUGVyY2VudEZvcm1hdHRlclxyXG4gICAgIEBwYXJhbSB7bnVtYmVyfSByYXdWYWx1ZVxyXG4gICAgIEBwYXJhbSB7QmFja2JvbmUuTW9kZWx9IG1vZGVsIFVzZWQgZm9yIG1vcmUgY29tcGxpY2F0ZWQgZm9ybWF0dGluZ1xyXG4gICAgIEByZXR1cm4ge3N0cmluZ31cclxuICAqL1xyXG4gIGZyb21SYXc6IGZ1bmN0aW9uIChudW1iZXIsIG1vZGVsKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgIGFyZ3MudW5zaGlmdChudW1iZXIgKiB0aGlzLm11bHRpcGxpZXIpO1xyXG4gICAgcmV0dXJuIChOdW1iZXJGb3JtYXR0ZXIucHJvdG90eXBlLmZyb21SYXcuYXBwbHkodGhpcywgYXJncykgfHwgXCIwXCIpICsgdGhpcy5zeW1ib2w7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgVGFrZXMgYSBzdHJpbmcsIHBvc3NpYmx5IGFwcGVuZGVkIHdpdGggYHN5bWJvbGAgYW5kL29yIGBkZWNpbWFsU2VwYXJhdG9yYCxcclxuICAgICBhbmQgY29udmVydCBpdCBiYWNrIHRvIGEgbnVtYmVyIGZvciB0aGUgbW9kZWwgbGlrZSBOdW1iZXJGb3JtYXR0ZXIjdG9SYXcsXHJcbiAgICAgYW5kIHRoZW4gZGl2aWRpbmcgaXQgYnkgYG11bHRpcGxpZXJgLlxyXG5cclxuICAgICBAbWVtYmVyIEJhY2tncmlkLlBlcmNlbnRGb3JtYXR0ZXJcclxuICAgICBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkRGF0YVxyXG4gICAgIEBwYXJhbSB7QmFja2JvbmUuTW9kZWx9IG1vZGVsIFVzZWQgZm9yIG1vcmUgY29tcGxpY2F0ZWQgZm9ybWF0dGluZ1xyXG4gICAgIEByZXR1cm4ge251bWJlcnx1bmRlZmluZWR9IFVuZGVmaW5lZCBpZiB0aGUgc3RyaW5nIGNhbm5vdCBiZSBjb252ZXJ0ZWQgdG9cclxuICAgICBhIG51bWJlci5cclxuICAqL1xyXG4gIHRvUmF3OiBmdW5jdGlvbiAoZm9ybWF0dGVkVmFsdWUsIG1vZGVsKSB7XHJcbiAgICB2YXIgdG9rZW5zID0gZm9ybWF0dGVkVmFsdWUuc3BsaXQodGhpcy5zeW1ib2wpO1xyXG4gICAgaWYgKHRva2VucyAmJiB0b2tlbnNbMF0gJiYgdG9rZW5zWzFdID09PSBcIlwiIHx8IHRva2Vuc1sxXSA9PSBudWxsKSB7XHJcbiAgICAgIHZhciByYXdWYWx1ZSA9IE51bWJlckZvcm1hdHRlci5wcm90b3R5cGUudG9SYXcuY2FsbCh0aGlzLCB0b2tlbnNbMF0pO1xyXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChyYXdWYWx1ZSkpIHJldHVybiByYXdWYWx1ZTtcclxuICAgICAgcmV0dXJuIHJhd1ZhbHVlIC8gdGhpcy5tdWx0aXBsaWVyO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAgIEZvcm1hdHRlciB0byBjb252ZXJ0cyBiZXR3ZWVuIHZhcmlvdXMgZGF0ZXRpbWUgZm9ybWF0cy5cclxuXHJcbiAgIFRoaXMgY2xhc3Mgb25seSB1bmRlcnN0YW5kcyBJU08tODYwMSBmb3JtYXR0ZWQgZGF0ZXRpbWUgc3RyaW5ncyBhbmQgVU5JWFxyXG4gICBvZmZzZXQgKG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgVU5JWCBFcG9jaCkuIFNlZVxyXG4gICBCYWNrZ3JpZC5FeHRlbnNpb24uTW9tZW50Rm9ybWF0dGVyIGlmIHlvdSBuZWVkIGEgbXVjaCBtb3JlIGZsZXhpYmxlIGRhdGV0aW1lXHJcbiAgIGZvcm1hdHRlci5cclxuXHJcbiAgIEBjbGFzcyBCYWNrZ3JpZC5EYXRldGltZUZvcm1hdHRlclxyXG4gICBAZXh0ZW5kcyBCYWNrZ3JpZC5DZWxsRm9ybWF0dGVyXHJcbiAgIEBjb25zdHJ1Y3RvclxyXG4gICBAdGhyb3dzIHtFcnJvcn0gSWYgYm90aCBgaW5jbHVkZURhdGVgIGFuZCBgaW5jbHVkZVRpbWVgIGFyZSBmYWxzZS5cclxuKi9cclxudmFyIERhdGV0aW1lRm9ybWF0dGVyID0gQmFja2dyaWQuRGF0ZXRpbWVGb3JtYXR0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gIF8uZXh0ZW5kKHRoaXMsIHRoaXMuZGVmYXVsdHMsIG9wdGlvbnMgfHwge30pO1xyXG5cclxuICBpZiAoIXRoaXMuaW5jbHVkZURhdGUgJiYgIXRoaXMuaW5jbHVkZVRpbWUpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcIkVpdGhlciBpbmNsdWRlRGF0ZSBvciBpbmNsdWRlVGltZSBtdXN0IGJlIHRydWVcIik7XHJcbiAgfVxyXG59O1xyXG5EYXRldGltZUZvcm1hdHRlci5wcm90b3R5cGUgPSBuZXcgQ2VsbEZvcm1hdHRlcigpO1xyXG5fLmV4dGVuZChEYXRldGltZUZvcm1hdHRlci5wcm90b3R5cGUsIHtcclxuXHJcbiAgLyoqXHJcbiAgICAgQG1lbWJlciBCYWNrZ3JpZC5EYXRldGltZUZvcm1hdHRlclxyXG5cclxuICAgICBAY2ZnIHtPYmplY3R9IG9wdGlvbnNcclxuXHJcbiAgICAgQGNmZyB7Ym9vbGVhbn0gW29wdGlvbnMuaW5jbHVkZURhdGU9dHJ1ZV0gV2hldGhlciB0aGUgdmFsdWVzIGluY2x1ZGUgdGhlXHJcbiAgICAgZGF0ZSBwYXJ0LlxyXG5cclxuICAgICBAY2ZnIHtib29sZWFufSBbb3B0aW9ucy5pbmNsdWRlVGltZT10cnVlXSBXaGV0aGVyIHRoZSB2YWx1ZXMgaW5jbHVkZSB0aGVcclxuICAgICB0aW1lIHBhcnQuXHJcblxyXG4gICAgIEBjZmcge2Jvb2xlYW59IFtvcHRpb25zLmluY2x1ZGVNaWxsaT1mYWxzZV0gSWYgYGluY2x1ZGVUaW1lYCBpcyB0cnVlLFxyXG4gICAgIHdoZXRoZXIgdG8gaW5jbHVkZSB0aGUgbWlsbGlzZWNvbmQgcGFydCwgaWYgaXQgZXhpc3RzLlxyXG4gICAqL1xyXG4gIGRlZmF1bHRzOiB7XHJcbiAgICBpbmNsdWRlRGF0ZTogdHJ1ZSxcclxuICAgIGluY2x1ZGVUaW1lOiB0cnVlLFxyXG4gICAgaW5jbHVkZU1pbGxpOiBmYWxzZVxyXG4gIH0sXHJcblxyXG4gIERBVEVfUkU6IC9eKFsrXFwtXT9cXGR7NH0pLShcXGR7Mn0pLShcXGR7Mn0pJC8sXHJcbiAgVElNRV9SRTogL14oXFxkezJ9KTooXFxkezJ9KTooXFxkezJ9KShcXC4oXFxkezN9KSk/JC8sXHJcbiAgSVNPX1NQTElUVEVSX1JFOiAvVHxafCArLyxcclxuXHJcbiAgX2NvbnZlcnQ6IGZ1bmN0aW9uIChkYXRhLCB2YWxpZGF0ZSkge1xyXG4gICAgaWYgKChkYXRhICsgJycpLnRyaW0oKSA9PT0gJycpIHJldHVybiBudWxsO1xyXG5cclxuICAgIHZhciBkYXRlLCB0aW1lID0gbnVsbDtcclxuICAgIGlmIChfLmlzTnVtYmVyKGRhdGEpKSB7XHJcbiAgICAgIHZhciBqc0RhdGUgPSBuZXcgRGF0ZShkYXRhKTtcclxuICAgICAgZGF0ZSA9IGxwYWQoanNEYXRlLmdldFVUQ0Z1bGxZZWFyKCksIDQsIDApICsgJy0nICsgbHBhZChqc0RhdGUuZ2V0VVRDTW9udGgoKSArIDEsIDIsIDApICsgJy0nICsgbHBhZChqc0RhdGUuZ2V0VVRDRGF0ZSgpLCAyLCAwKTtcclxuICAgICAgdGltZSA9IGxwYWQoanNEYXRlLmdldFVUQ0hvdXJzKCksIDIsIDApICsgJzonICsgbHBhZChqc0RhdGUuZ2V0VVRDTWludXRlcygpLCAyLCAwKSArICc6JyArIGxwYWQoanNEYXRlLmdldFVUQ1NlY29uZHMoKSwgMiwgMCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgZGF0YSA9IGRhdGEudHJpbSgpO1xyXG4gICAgICB2YXIgcGFydHMgPSBkYXRhLnNwbGl0KHRoaXMuSVNPX1NQTElUVEVSX1JFKSB8fCBbXTtcclxuICAgICAgZGF0ZSA9IHRoaXMuREFURV9SRS50ZXN0KHBhcnRzWzBdKSA/IHBhcnRzWzBdIDogJyc7XHJcbiAgICAgIHRpbWUgPSBkYXRlICYmIHBhcnRzWzFdID8gcGFydHNbMV0gOiB0aGlzLlRJTUVfUkUudGVzdChwYXJ0c1swXSkgPyBwYXJ0c1swXSA6ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBZWVlZTU1ERCA9IHRoaXMuREFURV9SRS5leGVjKGRhdGUpIHx8IFtdO1xyXG4gICAgdmFyIEhIbW1zc1NTUyA9IHRoaXMuVElNRV9SRS5leGVjKHRpbWUpIHx8IFtdO1xyXG5cclxuICAgIGlmICh2YWxpZGF0ZSkge1xyXG4gICAgICBpZiAodGhpcy5pbmNsdWRlRGF0ZSAmJiBfLmlzVW5kZWZpbmVkKFlZWVlNTUREWzBdKSkgcmV0dXJuO1xyXG4gICAgICBpZiAodGhpcy5pbmNsdWRlVGltZSAmJiBfLmlzVW5kZWZpbmVkKEhIbW1zc1NTU1swXSkpIHJldHVybjtcclxuICAgICAgaWYgKCF0aGlzLmluY2x1ZGVEYXRlICYmIGRhdGUpIHJldHVybjtcclxuICAgICAgaWYgKCF0aGlzLmluY2x1ZGVUaW1lICYmIHRpbWUpIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB2YXIganNEYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoWVlZWU1NRERbMV0gKiAxIHx8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWVlZWU1NRERbMl0gKiAxIC0gMSB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFlZWVlNTUREWzNdICogMSB8fCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhIbW1zc1NTU1sxXSAqIDEgfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBISG1tc3NTU1NbMl0gKiAxIHx8IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSEhtbXNzU1NTWzNdICogMSB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEhIbW1zc1NTU1s1XSAqIDEgfHwgbnVsbCkpO1xyXG5cclxuICAgIHZhciByZXN1bHQgPSAnJztcclxuXHJcbiAgICBpZiAodGhpcy5pbmNsdWRlRGF0ZSkge1xyXG4gICAgICByZXN1bHQgPSBscGFkKGpzRGF0ZS5nZXRVVENGdWxsWWVhcigpLCA0LCAwKSArICctJyArIGxwYWQoanNEYXRlLmdldFVUQ01vbnRoKCkgKyAxLCAyLCAwKSArICctJyArIGxwYWQoanNEYXRlLmdldFVUQ0RhdGUoKSwgMiwgMCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaW5jbHVkZVRpbWUpIHtcclxuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgKHRoaXMuaW5jbHVkZURhdGUgPyAnVCcgOiAnJykgKyBscGFkKGpzRGF0ZS5nZXRVVENIb3VycygpLCAyLCAwKSArICc6JyArIGxwYWQoanNEYXRlLmdldFVUQ01pbnV0ZXMoKSwgMiwgMCkgKyAnOicgKyBscGFkKGpzRGF0ZS5nZXRVVENTZWNvbmRzKCksIDIsIDApO1xyXG5cclxuICAgICAgaWYgKHRoaXMuaW5jbHVkZU1pbGxpKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgJy4nICsgbHBhZChqc0RhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCksIDMsIDApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuaW5jbHVkZURhdGUgJiYgdGhpcy5pbmNsdWRlVGltZSkge1xyXG4gICAgICByZXN1bHQgKz0gXCJaXCI7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBDb252ZXJ0cyBhbiBJU08tODYwMSBmb3JtYXR0ZWQgZGF0ZXRpbWUgc3RyaW5nIHRvIGEgZGF0ZXRpbWUgc3RyaW5nLCBkYXRlXHJcbiAgICAgc3RyaW5nIG9yIGEgdGltZSBzdHJpbmcuIFRoZSB0aW1lem9uZSBpcyBpZ25vcmVkIGlmIHN1cHBsaWVkLlxyXG5cclxuICAgICBAbWVtYmVyIEJhY2tncmlkLkRhdGV0aW1lRm9ybWF0dGVyXHJcbiAgICAgQHBhcmFtIHtzdHJpbmd9IHJhd0RhdGFcclxuICAgICBAcGFyYW0ge0JhY2tib25lLk1vZGVsfSBtb2RlbCBVc2VkIGZvciBtb3JlIGNvbXBsaWNhdGVkIGZvcm1hdHRpbmdcclxuICAgICBAcmV0dXJuIHtzdHJpbmd8bnVsbHx1bmRlZmluZWR9IElTTy04NjAxIHN0cmluZyBpbiBVVEMuIE51bGwgYW5kIHVuZGVmaW5lZFxyXG4gICAgIHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgaXMuXHJcbiAgKi9cclxuICBmcm9tUmF3OiBmdW5jdGlvbiAocmF3RGF0YSwgbW9kZWwpIHtcclxuICAgIGlmIChfLmlzTnVsbChyYXdEYXRhKSB8fCBfLmlzVW5kZWZpbmVkKHJhd0RhdGEpKSByZXR1cm4gJyc7XHJcbiAgICByZXR1cm4gdGhpcy5fY29udmVydChyYXdEYXRhKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBDb252ZXJ0cyBhbiBJU08tODYwMSBmb3JtYXR0ZWQgZGF0ZXRpbWUgc3RyaW5nIHRvIGEgZGF0ZXRpbWUgc3RyaW5nLCBkYXRlXHJcbiAgICAgc3RyaW5nIG9yIGEgdGltZSBzdHJpbmcuIFRoZSB0aW1lem9uZSBpcyBpZ25vcmVkIGlmIHN1cHBsaWVkLiBUaGlzIG1ldGhvZFxyXG4gICAgIHBhcnNlcyB0aGUgaW5wdXQgdmFsdWVzIGV4YWN0bHkgdGhlIHNhbWUgd2F5IGFzXHJcbiAgICAgQmFja2dyaWQuRXh0ZW5zaW9uLk1vbWVudEZvcm1hdHRlciNmcm9tUmF3KCksIGluIGFkZGl0aW9uIHRvIGRvaW5nIHNvbWVcclxuICAgICBzYW5pdHkgY2hlY2tzLlxyXG5cclxuICAgICBAbWVtYmVyIEJhY2tncmlkLkRhdGV0aW1lRm9ybWF0dGVyXHJcbiAgICAgQHBhcmFtIHtzdHJpbmd9IGZvcm1hdHRlZERhdGFcclxuICAgICBAcGFyYW0ge0JhY2tib25lLk1vZGVsfSBtb2RlbCBVc2VkIGZvciBtb3JlIGNvbXBsaWNhdGVkIGZvcm1hdHRpbmdcclxuICAgICBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfSBJU08tODYwMSBzdHJpbmcgaW4gVVRDLiBVbmRlZmluZWQgaWYgYSBkYXRlIGlzXHJcbiAgICAgZm91bmQgd2hlbiBgaW5jbHVkZURhdGVgIGlzIGZhbHNlLCBvciBhIHRpbWUgaXMgZm91bmQgd2hlbiBgaW5jbHVkZVRpbWVgIGlzXHJcbiAgICAgZmFsc2UsIG9yIGlmIGBpbmNsdWRlRGF0ZWAgaXMgdHJ1ZSBhbmQgYSBkYXRlIGlzIG5vdCBmb3VuZCwgb3IgaWZcclxuICAgICBgaW5jbHVkZVRpbWVgIGlzIHRydWUgYW5kIGEgdGltZSBpcyBub3QgZm91bmQuXHJcbiAgKi9cclxuICB0b1JhdzogZnVuY3Rpb24gKGZvcm1hdHRlZERhdGEsIG1vZGVsKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fY29udmVydChmb3JtYXR0ZWREYXRhLCB0cnVlKTtcclxuICB9XHJcblxyXG59KTtcclxuXHJcbi8qKlxyXG4gICBGb3JtYXR0ZXIgdG8gY29udmVydCBhbnkgdmFsdWUgdG8gc3RyaW5nLlxyXG5cclxuICAgQGNsYXNzIEJhY2tncmlkLlN0cmluZ0Zvcm1hdHRlclxyXG4gICBAZXh0ZW5kcyBCYWNrZ3JpZC5DZWxsRm9ybWF0dGVyXHJcbiAgIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIFN0cmluZ0Zvcm1hdHRlciA9IEJhY2tncmlkLlN0cmluZ0Zvcm1hdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xyXG5TdHJpbmdGb3JtYXR0ZXIucHJvdG90eXBlID0gbmV3IENlbGxGb3JtYXR0ZXIoKTtcclxuXy5leHRlbmQoU3RyaW5nRm9ybWF0dGVyLnByb3RvdHlwZSwge1xyXG4gIC8qKlxyXG4gICAgIENvbnZlcnRzIGFueSB2YWx1ZSB0byBhIHN0cmluZyB1c2luZyBFY21hc2NyaXB0J3MgaW1wbGljaXQgdHlwZVxyXG4gICAgIGNvbnZlcnNpb24uIElmIHRoZSBnaXZlbiB2YWx1ZSBpcyBgbnVsbGAgb3IgYHVuZGVmaW5lZGAsIGFuIGVtcHR5IHN0cmluZyBpc1xyXG4gICAgIHJldHVybmVkIGluc3RlYWQuXHJcblxyXG4gICAgIEBtZW1iZXIgQmFja2dyaWQuU3RyaW5nRm9ybWF0dGVyXHJcbiAgICAgQHBhcmFtIHsqfSByYXdWYWx1ZVxyXG4gICAgIEBwYXJhbSB7QmFja2JvbmUuTW9kZWx9IG1vZGVsIFVzZWQgZm9yIG1vcmUgY29tcGxpY2F0ZWQgZm9ybWF0dGluZ1xyXG4gICAgIEByZXR1cm4ge3N0cmluZ31cclxuICAgKi9cclxuICBmcm9tUmF3OiBmdW5jdGlvbiAocmF3VmFsdWUsIG1vZGVsKSB7XHJcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChyYXdWYWx1ZSkgfHwgXy5pc051bGwocmF3VmFsdWUpKSByZXR1cm4gJyc7XHJcbiAgICByZXR1cm4gcmF3VmFsdWUgKyAnJztcclxuICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAgIFNpbXBsZSBlbWFpbCB2YWxpZGF0aW9uIGZvcm1hdHRlci5cclxuXHJcbiAgIEBjbGFzcyBCYWNrZ3JpZC5FbWFpbEZvcm1hdHRlclxyXG4gICBAZXh0ZW5kcyBCYWNrZ3JpZC5DZWxsRm9ybWF0dGVyXHJcbiAgIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxudmFyIEVtYWlsRm9ybWF0dGVyID0gQmFja2dyaWQuRW1haWxGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoKSB7fTtcclxuRW1haWxGb3JtYXR0ZXIucHJvdG90eXBlID0gbmV3IENlbGxGb3JtYXR0ZXIoKTtcclxuXy5leHRlbmQoRW1haWxGb3JtYXR0ZXIucHJvdG90eXBlLCB7XHJcbiAgLyoqXHJcbiAgICAgUmV0dXJuIHRoZSBpbnB1dCBpZiBpdCBpcyBhIHN0cmluZyB0aGF0IGNvbnRhaW5zIGFuICdAJyBjaGFyYWN0ZXIgYW5kIGlmXHJcbiAgICAgdGhlIHN0cmluZ3MgYmVmb3JlIGFuZCBhZnRlciAnQCcgYXJlIG5vbi1lbXB0eS4gSWYgdGhlIGlucHV0IGRvZXMgbm90XHJcbiAgICAgdmFsaWRhdGUsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxyXG5cclxuICAgICBAbWVtYmVyIEJhY2tncmlkLkVtYWlsRm9ybWF0dGVyXHJcbiAgICAgQHBhcmFtIHsqfSBmb3JtYXR0ZWREYXRhXHJcbiAgICAgQHBhcmFtIHtCYWNrYm9uZS5Nb2RlbH0gbW9kZWwgVXNlZCBmb3IgbW9yZSBjb21wbGljYXRlZCBmb3JtYXR0aW5nXHJcbiAgICAgQHJldHVybiB7c3RyaW5nfHVuZGVmaW5lZH1cclxuICAgKi9cclxuICB0b1JhdzogZnVuY3Rpb24gKGZvcm1hdHRlZERhdGEsIG1vZGVsKSB7XHJcbiAgICB2YXIgcGFydHMgPSBmb3JtYXR0ZWREYXRhLnRyaW0oKS5zcGxpdChcIkBcIik7XHJcbiAgICBpZiAocGFydHMubGVuZ3RoID09PSAyICYmIF8uYWxsKHBhcnRzKSkge1xyXG4gICAgICByZXR1cm4gZm9ybWF0dGVkRGF0YTtcclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAgIEZvcm1hdHRlciBmb3IgU2VsZWN0Q2VsbC5cclxuXHJcbiAgIElmIHRoZSB0eXBlIG9mIGEgbW9kZWwgdmFsdWUgaXMgbm90IGEgc3RyaW5nLCBpdCBpcyBleHBlY3RlZCB0aGF0IGEgc3ViY2xhc3NcclxuICAgb2YgdGhpcyBmb3JtYXR0ZXIgaXMgcHJvdmlkZWQgdG8gdGhlIFNlbGVjdENlbGwsIHdpdGggI3RvUmF3IG92ZXJyaWRkZW4gdG9cclxuICAgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlIHJldHVybmVkIGZyb20gdGhlIERPTSBiYWNrIHRvIHdoYXRldmVyIHZhbHVlIGlzXHJcbiAgIGV4cGVjdGVkIGluIHRoZSBtb2RlbC5cclxuXHJcbiAgIEBjbGFzcyBCYWNrZ3JpZC5TZWxlY3RGb3JtYXR0ZXJcclxuICAgQGV4dGVuZHMgQmFja2dyaWQuQ2VsbEZvcm1hdHRlclxyXG4gICBAY29uc3RydWN0b3JcclxuKi9cclxudmFyIFNlbGVjdEZvcm1hdHRlciA9IEJhY2tncmlkLlNlbGVjdEZvcm1hdHRlciA9IGZ1bmN0aW9uICgpIHt9O1xyXG5TZWxlY3RGb3JtYXR0ZXIucHJvdG90eXBlID0gbmV3IENlbGxGb3JtYXR0ZXIoKTtcclxuXy5leHRlbmQoU2VsZWN0Rm9ybWF0dGVyLnByb3RvdHlwZSwge1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICAgTm9ybWFsaXplcyByYXcgc2NhbGFyIG9yIGFycmF5IHZhbHVlcyB0byBhbiBhcnJheS5cclxuXHJcbiAgICAgQG1lbWJlciBCYWNrZ3JpZC5TZWxlY3RGb3JtYXR0ZXJcclxuICAgICBAcGFyYW0geyp9IHJhd1ZhbHVlXHJcbiAgICAgQHBhcmFtIHtCYWNrYm9uZS5Nb2RlbH0gbW9kZWwgVXNlZCBmb3IgbW9yZSBjb21wbGljYXRlZCBmb3JtYXR0aW5nXHJcbiAgICAgQHJldHVybiB7QXJyYXkuPCo+fVxyXG4gICovXHJcbiAgZnJvbVJhdzogZnVuY3Rpb24gKHJhd1ZhbHVlLCBtb2RlbCkge1xyXG4gICAgcmV0dXJuIF8uaXNBcnJheShyYXdWYWx1ZSkgPyByYXdWYWx1ZSA6IHJhd1ZhbHVlICE9IG51bGwgPyBbcmF3VmFsdWVdIDogW107XHJcbiAgfVxyXG59KTtcclxuXHJcbnZhciAkID0gcmVxdWlyZSgnanF1ZXJ5Jyk7XHJcbi8qXHJcbiAgYmFja2dyaWRcclxuICBodHRwOi8vZ2l0aHViLmNvbS93eXVlbmhvL2JhY2tncmlkXHJcblxyXG4gIENvcHlyaWdodCAoYykgMjAxMyBKaW1teSBZdWVuIEhvIFdvbmcgYW5kIGNvbnRyaWJ1dG9yc1xyXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuKi9cclxuXHJcbi8qKlxyXG4gICBHZW5lcmljIGNlbGwgZWRpdG9yIGJhc2UgY2xhc3MuIE9ubHkgZGVmaW5lcyBhbiBpbml0aWFsaXplciBmb3IgYSBudW1iZXIgb2ZcclxuICAgcmVxdWlyZWQgcGFyYW1ldGVycy5cclxuXHJcbiAgIEBhYnN0cmFjdFxyXG4gICBAY2xhc3MgQmFja2dyaWQuQ2VsbEVkaXRvclxyXG4gICBAZXh0ZW5kcyBCYWNrYm9uZS5WaWV3XHJcbiovXHJcbnZhciBDZWxsRWRpdG9yID0gQmFja2dyaWQuQ2VsbEVkaXRvciA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuXHJcbiAgLyoqXHJcbiAgICAgSW5pdGlhbGl6ZXIuXHJcblxyXG4gICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgQHBhcmFtIHtCYWNrZ3JpZC5DZWxsRm9ybWF0dGVyfSBvcHRpb25zLmZvcm1hdHRlclxyXG4gICAgIEBwYXJhbSB7QmFja2dyaWQuQ29sdW1ufSBvcHRpb25zLmNvbHVtblxyXG4gICAgIEBwYXJhbSB7QmFja2JvbmUuTW9kZWx9IG9wdGlvbnMubW9kZWxcclxuXHJcbiAgICAgQHRocm93cyB7VHlwZUVycm9yfSBJZiBgZm9ybWF0dGVyYCBpcyBub3QgYSBmb3JtYXR0ZXIgaW5zdGFuY2UsIG9yIHdoZW5cclxuICAgICBgbW9kZWxgIG9yIGBjb2x1bW5gIGFyZSB1bmRlZmluZWQuXHJcbiAgKi9cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdGhpcy5mb3JtYXR0ZXIgPSBvcHRpb25zLmZvcm1hdHRlcjtcclxuICAgIHRoaXMuY29sdW1uID0gb3B0aW9ucy5jb2x1bW47XHJcbiAgICBpZiAoISh0aGlzLmNvbHVtbiBpbnN0YW5jZW9mIENvbHVtbikpIHtcclxuICAgICAgdGhpcy5jb2x1bW4gPSBuZXcgQ29sdW1uKHRoaXMuY29sdW1uKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmxpc3RlblRvKHRoaXMubW9kZWwsIFwiYmFja2dyaWQ6ZWRpdGluZ1wiLCB0aGlzLnBvc3RSZW5kZXIpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIFBvc3QtcmVuZGVyaW5nIHNldHVwIGFuZCBpbml0aWFsaXphdGlvbi4gRm9jdXNlcyB0aGUgY2VsbCBlZGl0b3IncyBgZWxgIGluXHJcbiAgICAgdGhpcyBkZWZhdWx0IGltcGxlbWVudGF0aW9uLiAqKlNob3VsZCoqIGJlIGNhbGxlZCBieSBDZWxsIGNsYXNzZXMgYWZ0ZXJcclxuICAgICBjYWxsaW5nIEJhY2tncmlkLkNlbGxFZGl0b3IjcmVuZGVyLlxyXG4gICovXHJcbiAgcG9zdFJlbmRlcjogZnVuY3Rpb24gKG1vZGVsLCBjb2x1bW4pIHtcclxuICAgIGlmIChjb2x1bW4gPT0gbnVsbCB8fCBjb2x1bW4uZ2V0KFwibmFtZVwiKSA9PSB0aGlzLmNvbHVtbi5nZXQoXCJuYW1lXCIpKSB7XHJcbiAgICAgIHRoaXMuJGVsLmZvY3VzKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG59KTtcclxuXHJcbi8qKlxyXG4gICBJbnB1dENlbGxFZGl0b3IgdGhlIGNlbGwgZWRpdG9yIHR5cGUgdXNlZCBieSBtb3N0IGNvcmUgY2VsbCB0eXBlcy4gVGhpcyBjZWxsXHJcbiAgIGVkaXRvciByZW5kZXJzIGEgdGV4dCBpbnB1dCBib3ggYXMgaXRzIGVkaXRvci4gVGhlIGlucHV0IHdpbGwgcmVuZGVyIGFcclxuICAgcGxhY2Vob2xkZXIgaWYgdGhlIHZhbHVlIGlzIGVtcHR5IG9uIHN1cHBvcnRlZCBicm93c2Vycy5cclxuXHJcbiAgIEBjbGFzcyBCYWNrZ3JpZC5JbnB1dENlbGxFZGl0b3JcclxuICAgQGV4dGVuZHMgQmFja2dyaWQuQ2VsbEVkaXRvclxyXG4qL1xyXG52YXIgSW5wdXRDZWxsRWRpdG9yID0gQmFja2dyaWQuSW5wdXRDZWxsRWRpdG9yID0gQ2VsbEVkaXRvci5leHRlbmQoe1xyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgdGFnTmFtZTogXCJpbnB1dFwiLFxyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgYXR0cmlidXRlczoge1xyXG4gICAgdHlwZTogXCJ0ZXh0XCJcclxuICB9LFxyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgZXZlbnRzOiB7XHJcbiAgICBcImJsdXJcIjogXCJzYXZlT3JDYW5jZWxcIixcclxuICAgIFwia2V5ZG93blwiOiBcInNhdmVPckNhbmNlbFwiXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgSW5pdGlhbGl6ZXIuIFJlbW92ZXMgdGhpcyBgZWxgIGZyb20gdGhlIERPTSB3aGVuIGEgYGRvbmVgIGV2ZW50IGlzXHJcbiAgICAgdHJpZ2dlcmVkLlxyXG5cclxuICAgICBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgIEBwYXJhbSB7QmFja2dyaWQuQ2VsbEZvcm1hdHRlcn0gb3B0aW9ucy5mb3JtYXR0ZXJcclxuICAgICBAcGFyYW0ge0JhY2tncmlkLkNvbHVtbn0gb3B0aW9ucy5jb2x1bW5cclxuICAgICBAcGFyYW0ge0JhY2tib25lLk1vZGVsfSBvcHRpb25zLm1vZGVsXHJcbiAgICAgQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBsYWNlaG9sZGVyXVxyXG4gICovXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIElucHV0Q2VsbEVkaXRvci5fX3N1cGVyX18uaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIGlmIChvcHRpb25zLnBsYWNlaG9sZGVyKSB7XHJcbiAgICAgIHRoaXMuJGVsLmF0dHIoXCJwbGFjZWhvbGRlclwiLCBvcHRpb25zLnBsYWNlaG9sZGVyKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBSZW5kZXJzIGEgdGV4dCBpbnB1dCB3aXRoIHRoZSBjZWxsIHZhbHVlIGZvcm1hdHRlZCBmb3IgZGlzcGxheSwgaWYgaXRcclxuICAgICBleGlzdHMuXHJcbiAgKi9cclxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XHJcbiAgICB0aGlzLiRlbC52YWwodGhpcy5mb3JtYXR0ZXIuZnJvbVJhdyhtb2RlbC5nZXQodGhpcy5jb2x1bW4uZ2V0KFwibmFtZVwiKSksIG1vZGVsKSk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBJZiB0aGUga2V5IHByZXNzZWQgaXMgYGVudGVyYCwgYHRhYmAsIGB1cGAsIG9yIGBkb3duYCwgY29udmVydHMgdGhlIHZhbHVlXHJcbiAgICAgaW4gdGhlIGVkaXRvciB0byBhIHJhdyB2YWx1ZSBmb3Igc2F2aW5nIGludG8gdGhlIG1vZGVsIHVzaW5nIHRoZSBmb3JtYXR0ZXIuXHJcblxyXG4gICAgIElmIHRoZSBrZXkgcHJlc3NlZCBpcyBgZXNjYCB0aGUgY2hhbmdlcyBhcmUgdW5kb25lLlxyXG5cclxuICAgICBJZiB0aGUgZWRpdG9yIGdvZXMgb3V0IG9mIGZvY3VzIChgYmx1cmApIGJ1dCB0aGUgdmFsdWUgaXMgaW52YWxpZCwgdGhlXHJcbiAgICAgZXZlbnQgaXMgaW50ZXJjZXB0ZWQgYW5kIGNhbmNlbGxlZCBzbyB0aGUgY2VsbCByZW1haW5zIGluIGZvY3VzIHBlbmRpbmcgZm9yXHJcbiAgICAgZnVydGhlciBhY3Rpb24uIFRoZSBjaGFuZ2VzIGFyZSBzYXZlZCBvdGhlcndpc2UuXHJcblxyXG4gICAgIFRyaWdnZXJzIGEgQmFja2JvbmUgYGJhY2tncmlkOmVkaXRlZGAgZXZlbnQgZnJvbSB0aGUgbW9kZWwgd2hlbiBzdWNjZXNzZnVsLFxyXG4gICAgIGFuZCBgYmFja2dyaWQ6ZXJyb3JgIGlmIHRoZSB2YWx1ZSBjYW5ub3QgYmUgY29udmVydGVkLiBDbGFzc2VzIGxpc3RlbmluZyB0b1xyXG4gICAgIHRoZSBgZXJyb3JgIGV2ZW50LCB1c3VhbGx5IHRoZSBDZWxsIGNsYXNzZXMsIHNob3VsZCByZXNwb25kIGFwcHJvcHJpYXRlbHksXHJcbiAgICAgdXN1YWxseSBieSByZW5kZXJpbmcgc29tZSBraW5kIG9mIGVycm9yIGZlZWRiYWNrLlxyXG5cclxuICAgICBAcGFyYW0ge0V2ZW50fSBlXHJcbiAgKi9cclxuICBzYXZlT3JDYW5jZWw6IGZ1bmN0aW9uIChlKSB7XHJcblxyXG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZm9ybWF0dGVyO1xyXG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcclxuICAgIHZhciBjb2x1bW4gPSB0aGlzLmNvbHVtbjtcclxuXHJcbiAgICB2YXIgY29tbWFuZCA9IG5ldyBDb21tYW5kKGUpO1xyXG4gICAgdmFyIGJsdXJyZWQgPSBlLnR5cGUgPT09IFwiYmx1clwiO1xyXG5cclxuICAgIGlmIChjb21tYW5kLm1vdmVVcCgpIHx8IGNvbW1hbmQubW92ZURvd24oKSB8fCBjb21tYW5kLm1vdmVMZWZ0KCkgfHwgY29tbWFuZC5tb3ZlUmlnaHQoKSB8fFxyXG4gICAgICAgIGNvbW1hbmQuc2F2ZSgpIHx8IGJsdXJyZWQpIHtcclxuXHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgIHZhciB2YWwgPSB0aGlzLiRlbC52YWwoKTtcclxuICAgICAgdmFyIG5ld1ZhbHVlID0gZm9ybWF0dGVyLnRvUmF3KHZhbCwgbW9kZWwpO1xyXG4gICAgICBpZiAoXy5pc1VuZGVmaW5lZChuZXdWYWx1ZSkpIHtcclxuICAgICAgICBtb2RlbC50cmlnZ2VyKFwiYmFja2dyaWQ6ZXJyb3JcIiwgbW9kZWwsIGNvbHVtbiwgdmFsKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBtb2RlbC5zZXQoY29sdW1uLmdldChcIm5hbWVcIiksIG5ld1ZhbHVlKTtcclxuICAgICAgICBtb2RlbC50cmlnZ2VyKFwiYmFja2dyaWQ6ZWRpdGVkXCIsIG1vZGVsLCBjb2x1bW4sIGNvbW1hbmQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBlc2NcclxuICAgIGVsc2UgaWYgKGNvbW1hbmQuY2FuY2VsKCkpIHtcclxuICAgICAgLy8gdW5kb1xyXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICBtb2RlbC50cmlnZ2VyKFwiYmFja2dyaWQ6ZWRpdGVkXCIsIG1vZGVsLCBjb2x1bW4sIGNvbW1hbmQpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHBvc3RSZW5kZXI6IGZ1bmN0aW9uIChtb2RlbCwgY29sdW1uKSB7XHJcbiAgICBpZiAoY29sdW1uID09IG51bGwgfHwgY29sdW1uLmdldChcIm5hbWVcIikgPT0gdGhpcy5jb2x1bW4uZ2V0KFwibmFtZVwiKSkge1xyXG4gICAgICAvLyBtb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGVuZCBvbiBmaXJlZm94IGlmIHRleHQgaXMgcmlnaHQgYWxpZ25lZFxyXG4gICAgICBpZiAodGhpcy4kZWwuY3NzKFwidGV4dC1hbGlnblwiKSA9PT0gXCJyaWdodFwiKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuJGVsLnZhbCgpO1xyXG4gICAgICAgIHRoaXMuJGVsLmZvY3VzKCkudmFsKG51bGwpLnZhbCh2YWwpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgdGhpcy4kZWwuZm9jdXMoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAgIFRoZSBzdXBlci1jbGFzcyBmb3IgYWxsIENlbGwgdHlwZXMuIEJ5IGRlZmF1bHQsIHRoaXMgY2xhc3MgcmVuZGVycyBhIHBsYWluXHJcbiAgIHRhYmxlIGNlbGwgd2l0aCB0aGUgbW9kZWwgdmFsdWUgY29udmVydGVkIHRvIGEgc3RyaW5nIHVzaW5nIHRoZVxyXG4gICBmb3JtYXR0ZXIuIFRoZSB0YWJsZSBjZWxsIGlzIGNsaWNrYWJsZSwgdXBvbiB3aGljaCB0aGUgY2VsbCB3aWxsIGdvIGludG9cclxuICAgZWRpdG9yIG1vZGUsIHdoaWNoIGlzIHJlbmRlcmVkIGJ5IGEgQmFja2dyaWQuSW5wdXRDZWxsRWRpdG9yIGluc3RhbmNlIGJ5XHJcbiAgIGRlZmF1bHQuIFVwb24gZW5jb3VudGVyaW5nIGFueSBmb3JtYXR0aW5nIGVycm9ycywgdGhpcyBjbGFzcyB3aWxsIGFkZCBhblxyXG4gICBgZXJyb3JgIENTUyBjbGFzcyB0byB0aGUgdGFibGUgY2VsbC5cclxuXHJcbiAgIEBhYnN0cmFjdFxyXG4gICBAY2xhc3MgQmFja2dyaWQuQ2VsbFxyXG4gICBAZXh0ZW5kcyBCYWNrYm9uZS5WaWV3XHJcbiovXHJcbnZhciBDZWxsID0gQmFja2dyaWQuQ2VsbCA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuXHJcbiAgLyoqIEBwcm9wZXJ0eSAqL1xyXG4gIHRhZ05hbWU6IFwidGRcIixcclxuXHJcbiAgLyoqXHJcbiAgICAgQHByb3BlcnR5IHtCYWNrZ3JpZC5DZWxsRm9ybWF0dGVyfE9iamVjdHxzdHJpbmd9IFtmb3JtYXR0ZXI9Q2VsbEZvcm1hdHRlcl1cclxuICAqL1xyXG4gIGZvcm1hdHRlcjogQ2VsbEZvcm1hdHRlcixcclxuXHJcbiAgLyoqXHJcbiAgICAgQHByb3BlcnR5IHtCYWNrZ3JpZC5DZWxsRWRpdG9yfSBbZWRpdG9yPUJhY2tncmlkLklucHV0Q2VsbEVkaXRvcl0gVGhlXHJcbiAgICAgZGVmYXVsdCBlZGl0b3IgZm9yIGFsbCBjZWxsIGluc3RhbmNlcyBvZiB0aGlzIGNsYXNzLiBUaGlzIHZhbHVlIG11c3QgYmUgYVxyXG4gICAgIGNsYXNzLCBpdCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgaW5zdGFudGlhdGVkIHVwb24gZW50ZXJpbmcgZWRpdCBtb2RlLlxyXG5cclxuICAgICBTZWUgQmFja2dyaWQuQ2VsbEVkaXRvclxyXG4gICovXHJcbiAgZWRpdG9yOiBJbnB1dENlbGxFZGl0b3IsXHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBldmVudHM6IHtcclxuICAgIFwiY2xpY2tcIjogXCJlbnRlckVkaXRNb2RlXCJcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBJbml0aWFsaXplci5cclxuXHJcbiAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICBAcGFyYW0ge0JhY2tib25lLk1vZGVsfSBvcHRpb25zLm1vZGVsXHJcbiAgICAgQHBhcmFtIHtCYWNrZ3JpZC5Db2x1bW59IG9wdGlvbnMuY29sdW1uXHJcblxyXG4gICAgIEB0aHJvd3Mge1JlZmVyZW5jZUVycm9yfSBJZiBmb3JtYXR0ZXIgaXMgYSBzdHJpbmcgYnV0IGEgZm9ybWF0dGVyIGNsYXNzIG9mXHJcbiAgICAgc2FpZCBuYW1lIGNhbm5vdCBiZSBmb3VuZCBpbiB0aGUgQmFja2dyaWQgbW9kdWxlLlxyXG4gICovXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuY29sdW1uID0gb3B0aW9ucy5jb2x1bW47XHJcbiAgICBpZiAoISh0aGlzLmNvbHVtbiBpbnN0YW5jZW9mIENvbHVtbikpIHtcclxuICAgICAgdGhpcy5jb2x1bW4gPSBuZXcgQ29sdW1uKHRoaXMuY29sdW1uKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29sdW1uID0gdGhpcy5jb2x1bW4sIG1vZGVsID0gdGhpcy5tb2RlbCwgJGVsID0gdGhpcy4kZWw7XHJcblxyXG4gICAgdmFyIGZvcm1hdHRlciA9IEJhY2tncmlkLnJlc29sdmVOYW1lVG9DbGFzcyhjb2x1bW4uZ2V0KFwiZm9ybWF0dGVyXCIpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVyLCBcIkZvcm1hdHRlclwiKTtcclxuXHJcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmb3JtYXR0ZXIuZnJvbVJhdykgJiYgIV8uaXNGdW5jdGlvbihmb3JtYXR0ZXIudG9SYXcpKSB7XHJcbiAgICAgIGZvcm1hdHRlciA9IG5ldyBmb3JtYXR0ZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmZvcm1hdHRlciA9IGZvcm1hdHRlcjtcclxuXHJcbiAgICB0aGlzLmVkaXRvciA9IEJhY2tncmlkLnJlc29sdmVOYW1lVG9DbGFzcyh0aGlzLmVkaXRvciwgXCJDZWxsRWRpdG9yXCIpO1xyXG5cclxuICAgIHRoaXMubGlzdGVuVG8obW9kZWwsIFwiY2hhbmdlOlwiICsgY29sdW1uLmdldChcIm5hbWVcIiksIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKCEkZWwuaGFzQ2xhc3MoXCJlZGl0b3JcIikpIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB0aGlzLmxpc3RlblRvKG1vZGVsLCBcImJhY2tncmlkOmVycm9yXCIsIHRoaXMucmVuZGVyRXJyb3IpO1xyXG5cclxuICAgIHRoaXMubGlzdGVuVG8oY29sdW1uLCBcImNoYW5nZTplZGl0YWJsZSBjaGFuZ2U6c29ydGFibGUgY2hhbmdlOnJlbmRlcmFibGVcIixcclxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gY29sdW1uLmNoYW5nZWRBdHRyaWJ1dGVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGVsLnRvZ2dsZUNsYXNzKGtleSwgY2hhbmdlZFtrZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgIGlmIChCYWNrZ3JpZC5jYWxsQnlOZWVkKGNvbHVtbi5lZGl0YWJsZSgpLCBjb2x1bW4sIG1vZGVsKSkgJGVsLmFkZENsYXNzKFwiZWRpdGFibGVcIik7XHJcbiAgICBpZiAoQmFja2dyaWQuY2FsbEJ5TmVlZChjb2x1bW4uc29ydGFibGUoKSwgY29sdW1uLCBtb2RlbCkpICRlbC5hZGRDbGFzcyhcInNvcnRhYmxlXCIpO1xyXG4gICAgaWYgKEJhY2tncmlkLmNhbGxCeU5lZWQoY29sdW1uLnJlbmRlcmFibGUoKSwgY29sdW1uLCBtb2RlbCkpICRlbC5hZGRDbGFzcyhcInJlbmRlcmFibGVcIik7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgUmVuZGVyIGEgdGV4dCBzdHJpbmcgaW4gYSB0YWJsZSBjZWxsLiBUaGUgdGV4dCBpcyBjb252ZXJ0ZWQgZnJvbSB0aGVcclxuICAgICBtb2RlbCdzIHJhdyB2YWx1ZSBmb3IgdGhpcyBjZWxsJ3MgY29sdW1uLlxyXG4gICovXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLiRlbC5lbXB0eSgpO1xyXG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcclxuICAgIHRoaXMuJGVsLnRleHQodGhpcy5mb3JtYXR0ZXIuZnJvbVJhdyhtb2RlbC5nZXQodGhpcy5jb2x1bW4uZ2V0KFwibmFtZVwiKSksIG1vZGVsKSk7XHJcbiAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBJZiB0aGlzIGNvbHVtbiBpcyBlZGl0YWJsZSwgYSBuZXcgQ2VsbEVkaXRvciBpbnN0YW5jZSBpcyBpbnN0YW50aWF0ZWQgd2l0aFxyXG4gICAgIGl0cyByZXF1aXJlZCBwYXJhbWV0ZXJzLiBBbiBgZWRpdG9yYCBDU1MgY2xhc3MgaXMgYWRkZWQgdG8gdGhlIGNlbGwgdXBvblxyXG4gICAgIGVudGVyaW5nIGVkaXQgbW9kZS5cclxuXHJcbiAgICAgVGhpcyBtZXRob2QgdHJpZ2dlcnMgYSBCYWNrYm9uZSBgYmFja2dyaWQ6ZWRpdGAgZXZlbnQgZnJvbSB0aGUgbW9kZWwgd2hlblxyXG4gICAgIHRoZSBjZWxsIGlzIGVudGVyaW5nIGVkaXQgbW9kZSBhbmQgYW4gZWRpdG9yIGluc3RhbmNlIGhhcyBiZWVuIGNvbnN0cnVjdGVkLFxyXG4gICAgIGJ1dCBiZWZvcmUgaXQgaXMgcmVuZGVyZWQgYW5kIGluc2VydGVkIGludG8gdGhlIERPTS4gVGhlIGNlbGwgYW5kIHRoZVxyXG4gICAgIGNvbnN0cnVjdGVkIGNlbGwgZWRpdG9yIGluc3RhbmNlIGFyZSBzZW50IGFzIGV2ZW50IHBhcmFtZXRlcnMgd2hlbiB0aGlzXHJcbiAgICAgZXZlbnQgaXMgdHJpZ2dlcmVkLlxyXG5cclxuICAgICBXaGVuIHRoaXMgY2VsbCBoYXMgZmluaXNoZWQgc3dpdGNoaW5nIHRvIGVkaXQgbW9kZSwgYSBCYWNrYm9uZVxyXG4gICAgIGBiYWNrZ3JpZDplZGl0aW5nYCBldmVudCBpcyB0cmlnZ2VyZWQgZnJvbSB0aGUgbW9kZWwuIFRoZSBjZWxsIGFuZCB0aGVcclxuICAgICBjb25zdHJ1Y3RlZCBjZWxsIGluc3RhbmNlIGFyZSBhbHNvIHNlbnQgYXMgcGFyYW1ldGVycyBpbiB0aGUgZXZlbnQuXHJcblxyXG4gICAgIFdoZW4gdGhlIG1vZGVsIHRyaWdnZXJzIGEgYGJhY2tncmlkOmVycm9yYCBldmVudCwgaXQgbWVhbnMgdGhlIGVkaXRvciBpc1xyXG4gICAgIHVuYWJsZSB0byBjb252ZXJ0IHRoZSBjdXJyZW50IHVzZXIgaW5wdXQgdG8gYW4gYXBwcnByaWF0ZSB2YWx1ZSBmb3IgdGhlXHJcbiAgICAgbW9kZWwncyBjb2x1bW4sIGFuZCBhbiBgZXJyb3JgIENTUyBjbGFzcyBpcyBhZGRlZCB0byB0aGUgY2VsbCBhY2NvcmRpbmdseS5cclxuICAqL1xyXG4gIGVudGVyRWRpdE1vZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XHJcbiAgICB2YXIgY29sdW1uID0gdGhpcy5jb2x1bW47XHJcblxyXG4gICAgdmFyIGVkaXRhYmxlID0gQmFja2dyaWQuY2FsbEJ5TmVlZChjb2x1bW4uZWRpdGFibGUoKSwgY29sdW1uLCBtb2RlbCk7XHJcbiAgICBpZiAoZWRpdGFibGUpIHtcclxuXHJcbiAgICAgIHRoaXMuY3VycmVudEVkaXRvciA9IG5ldyB0aGlzLmVkaXRvcih7XHJcbiAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcclxuICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcclxuICAgICAgICBmb3JtYXR0ZXI6IHRoaXMuZm9ybWF0dGVyXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbW9kZWwudHJpZ2dlcihcImJhY2tncmlkOmVkaXRcIiwgbW9kZWwsIGNvbHVtbiwgdGhpcywgdGhpcy5jdXJyZW50RWRpdG9yKTtcclxuXHJcbiAgICAgIC8vIE5lZWQgdG8gcmVkdW5kYW50bHkgdW5kZWxlZ2F0ZSBldmVudHMgZm9yIEZpcmVmb3hcclxuICAgICAgdGhpcy51bmRlbGVnYXRlRXZlbnRzKCk7XHJcbiAgICAgIHRoaXMuJGVsLmVtcHR5KCk7XHJcbiAgICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLmN1cnJlbnRFZGl0b3IuJGVsKTtcclxuICAgICAgdGhpcy5jdXJyZW50RWRpdG9yLnJlbmRlcigpO1xyXG4gICAgICB0aGlzLiRlbC5hZGRDbGFzcyhcImVkaXRvclwiKTtcclxuXHJcbiAgICAgIG1vZGVsLnRyaWdnZXIoXCJiYWNrZ3JpZDplZGl0aW5nXCIsIG1vZGVsLCBjb2x1bW4sIHRoaXMsIHRoaXMuY3VycmVudEVkaXRvcik7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgUHV0IGFuIGBlcnJvcmAgQ1NTIGNsYXNzIG9uIHRoZSB0YWJsZSBjZWxsLlxyXG4gICovXHJcbiAgcmVuZGVyRXJyb3I6IGZ1bmN0aW9uIChtb2RlbCwgY29sdW1uKSB7XHJcbiAgICBpZiAoY29sdW1uID09IG51bGwgfHwgY29sdW1uLmdldChcIm5hbWVcIikgPT0gdGhpcy5jb2x1bW4uZ2V0KFwibmFtZVwiKSkge1xyXG4gICAgICB0aGlzLiRlbC5hZGRDbGFzcyhcImVycm9yXCIpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIFJlbW92ZXMgdGhlIGVkaXRvciBhbmQgcmUtcmVuZGVyIGluIGRpc3BsYXkgbW9kZS5cclxuICAqL1xyXG4gIGV4aXRFZGl0TW9kZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy4kZWwucmVtb3ZlQ2xhc3MoXCJlcnJvclwiKTtcclxuICAgIHRoaXMuY3VycmVudEVkaXRvci5yZW1vdmUoKTtcclxuICAgIHRoaXMuc3RvcExpc3RlbmluZyh0aGlzLmN1cnJlbnRFZGl0b3IpO1xyXG4gICAgZGVsZXRlIHRoaXMuY3VycmVudEVkaXRvcjtcclxuICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKFwiZWRpdG9yXCIpO1xyXG4gICAgdGhpcy5yZW5kZXIoKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBDbGVhbiB1cCB0aGlzIGNlbGwuXHJcblxyXG4gICAgIEBjaGFpbmFibGVcclxuICAqL1xyXG4gIHJlbW92ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHRoaXMuY3VycmVudEVkaXRvcikge1xyXG4gICAgICB0aGlzLmN1cnJlbnRFZGl0b3IucmVtb3ZlLmFwcGx5KHRoaXMuY3VycmVudEVkaXRvciwgYXJndW1lbnRzKTtcclxuICAgICAgZGVsZXRlIHRoaXMuY3VycmVudEVkaXRvcjtcclxuICAgIH1cclxuICAgIHJldHVybiBDZWxsLl9fc3VwZXJfXy5yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG59KTtcclxuXHJcbi8qKlxyXG4gICBTdHJpbmdDZWxsIGRpc3BsYXlzIEhUTUwgZXNjYXBlZCBzdHJpbmdzIGFuZCBhY2NlcHRzIGFueXRoaW5nIHR5cGVkIGluLlxyXG5cclxuICAgQGNsYXNzIEJhY2tncmlkLlN0cmluZ0NlbGxcclxuICAgQGV4dGVuZHMgQmFja2dyaWQuQ2VsbFxyXG4qL1xyXG52YXIgU3RyaW5nQ2VsbCA9IEJhY2tncmlkLlN0cmluZ0NlbGwgPSBDZWxsLmV4dGVuZCh7XHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBjbGFzc05hbWU6IFwic3RyaW5nLWNlbGxcIixcclxuXHJcbiAgZm9ybWF0dGVyOiBTdHJpbmdGb3JtYXR0ZXJcclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAgIFVyaUNlbGwgcmVuZGVycyBhbiBIVE1MIGA8YT5gIGFuY2hvciBmb3IgdGhlIHZhbHVlIGFuZCBhY2NlcHRzIFVSSXMgYXMgdXNlclxyXG4gICBpbnB1dCB2YWx1ZXMuIE5vIHR5cGUgY29udmVyc2lvbiBvciBVUkwgdmFsaWRhdGlvbiBpcyBkb25lIGJ5IHRoZSBmb3JtYXR0ZXJcclxuICAgb2YgdGhpcyBjZWxsLiBVc2VycyB3aG8gbmVlZCBVUkwgdmFsaWRhdGlvbiBhcmUgZW5jb3VyYWdlIHRvIHN1YmNsYXNzIFVyaUNlbGxcclxuICAgdG8gdGFrZSBhZHZhbnRhZ2Ugb2YgdGhlIHBhcnNpbmcgY2FwYWJpbGl0aWVzIG9mIHRoZSBIVE1MQW5jaG9yRWxlbWVudFxyXG4gICBhdmFpbGFibGUgb24gSFRNTDUtY2FwYWJsZSBicm93c2VycyBvciB1c2luZyBhIHRoaXJkLXBhcnR5IGxpYnJhcnkgbGlrZVxyXG4gICBbVVJJLmpzXShodHRwczovL2dpdGh1Yi5jb20vbWVkaWFsaXplL1VSSS5qcykuXHJcblxyXG4gICBAY2xhc3MgQmFja2dyaWQuVXJpQ2VsbFxyXG4gICBAZXh0ZW5kcyBCYWNrZ3JpZC5DZWxsXHJcbiovXHJcbnZhciBVcmlDZWxsID0gQmFja2dyaWQuVXJpQ2VsbCA9IENlbGwuZXh0ZW5kKHtcclxuXHJcbiAgLyoqIEBwcm9wZXJ0eSAqL1xyXG4gIGNsYXNzTmFtZTogXCJ1cmktY2VsbFwiLFxyXG5cclxuICAvKipcclxuICAgICBAcHJvcGVydHkge3N0cmluZ30gW3RpdGxlXSBUaGUgdGl0bGUgYXR0cmlidXRlIG9mIHRoZSBnZW5lcmF0ZWQgYW5jaG9yLiBJdFxyXG4gICAgIHVzZXMgdGhlIGRpc3BsYXkgdmFsdWUgZm9ybWF0dGVkIGJ5IHRoZSBgZm9ybWF0dGVyLmZyb21SYXdgIGJ5IGRlZmF1bHQuXHJcbiAgKi9cclxuICB0aXRsZTogbnVsbCxcclxuXHJcbiAgLyoqXHJcbiAgICAgQHByb3BlcnR5IHtzdHJpbmd9IFt0YXJnZXQ9XCJfYmxhbmtcIl0gVGhlIHRhcmdldCBhdHRyaWJ1dGUgb2YgdGhlIGdlbmVyYXRlZFxyXG4gICAgIGFuY2hvci5cclxuICAqL1xyXG4gIHRhcmdldDogXCJfYmxhbmtcIixcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIFVyaUNlbGwuX19zdXBlcl9fLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgIHRoaXMudGl0bGUgPSBvcHRpb25zLnRpdGxlIHx8IHRoaXMudGl0bGU7XHJcbiAgICB0aGlzLnRhcmdldCA9IG9wdGlvbnMudGFyZ2V0IHx8IHRoaXMudGFyZ2V0O1xyXG4gIH0sXHJcblxyXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy4kZWwuZW1wdHkoKTtcclxuICAgIHZhciByYXdWYWx1ZSA9IHRoaXMubW9kZWwuZ2V0KHRoaXMuY29sdW1uLmdldChcIm5hbWVcIikpO1xyXG4gICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gdGhpcy5mb3JtYXR0ZXIuZnJvbVJhdyhyYXdWYWx1ZSwgdGhpcy5tb2RlbCk7XHJcbiAgICB0aGlzLiRlbC5hcHBlbmQoJChcIjxhPlwiLCB7XHJcbiAgICAgIHRhYkluZGV4OiAtMSxcclxuICAgICAgaHJlZjogcmF3VmFsdWUsXHJcbiAgICAgIHRpdGxlOiB0aGlzLnRpdGxlIHx8IGZvcm1hdHRlZFZhbHVlLFxyXG4gICAgICB0YXJnZXQ6IHRoaXMudGFyZ2V0XHJcbiAgICB9KS50ZXh0KGZvcm1hdHRlZFZhbHVlKSk7XHJcbiAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG59KTtcclxuXHJcbi8qKlxyXG4gICBMaWtlIEJhY2tncmlkLlVyaUNlbGwsIEVtYWlsQ2VsbCByZW5kZXJzIGFuIEhUTUwgYDxhPmAgYW5jaG9yIGZvciB0aGVcclxuICAgdmFsdWUuIFRoZSBgaHJlZmAgaW4gdGhlIGFuY2hvciBpcyBwcmVmaXhlZCB3aXRoIGBtYWlsdG86YC4gRW1haWxDZWxsIHdpbGxcclxuICAgY29tcGxhaW4gaWYgdGhlIHVzZXIgZW50ZXJzIGEgc3RyaW5nIHRoYXQgZG9lc24ndCBjb250YWluIHRoZSBgQGAgc2lnbi5cclxuXHJcbiAgIEBjbGFzcyBCYWNrZ3JpZC5FbWFpbENlbGxcclxuICAgQGV4dGVuZHMgQmFja2dyaWQuU3RyaW5nQ2VsbFxyXG4qL1xyXG52YXIgRW1haWxDZWxsID0gQmFja2dyaWQuRW1haWxDZWxsID0gU3RyaW5nQ2VsbC5leHRlbmQoe1xyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgY2xhc3NOYW1lOiBcImVtYWlsLWNlbGxcIixcclxuXHJcbiAgZm9ybWF0dGVyOiBFbWFpbEZvcm1hdHRlcixcclxuXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLiRlbC5lbXB0eSgpO1xyXG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcclxuICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IHRoaXMuZm9ybWF0dGVyLmZyb21SYXcobW9kZWwuZ2V0KHRoaXMuY29sdW1uLmdldChcIm5hbWVcIikpLCBtb2RlbCk7XHJcbiAgICB0aGlzLiRlbC5hcHBlbmQoJChcIjxhPlwiLCB7XHJcbiAgICAgIHRhYkluZGV4OiAtMSxcclxuICAgICAgaHJlZjogXCJtYWlsdG86XCIgKyBmb3JtYXR0ZWRWYWx1ZSxcclxuICAgICAgdGl0bGU6IGZvcm1hdHRlZFZhbHVlXHJcbiAgICB9KS50ZXh0KGZvcm1hdHRlZFZhbHVlKSk7XHJcbiAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG59KTtcclxuXHJcbi8qKlxyXG4gICBOdW1iZXJDZWxsIGlzIGEgZ2VuZXJpYyBjZWxsIHRoYXQgcmVuZGVycyBhbGwgbnVtYmVycy4gTnVtYmVycyBhcmUgZm9ybWF0dGVkXHJcbiAgIHVzaW5nIGEgQmFja2dyaWQuTnVtYmVyRm9ybWF0dGVyLlxyXG5cclxuICAgQGNsYXNzIEJhY2tncmlkLk51bWJlckNlbGxcclxuICAgQGV4dGVuZHMgQmFja2dyaWQuQ2VsbFxyXG4qL1xyXG52YXIgTnVtYmVyQ2VsbCA9IEJhY2tncmlkLk51bWJlckNlbGwgPSBDZWxsLmV4dGVuZCh7XHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBjbGFzc05hbWU6IFwibnVtYmVyLWNlbGxcIixcclxuXHJcbiAgLyoqXHJcbiAgICAgQHByb3BlcnR5IHtudW1iZXJ9IFtkZWNpbWFscz0yXSBNdXN0IGJlIGFuIGludGVnZXIuXHJcbiAgKi9cclxuICBkZWNpbWFsczogTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZS5kZWZhdWx0cy5kZWNpbWFscyxcclxuXHJcbiAgLyoqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZGVjaW1hbFNlcGFyYXRvcj0nLiddICovXHJcbiAgZGVjaW1hbFNlcGFyYXRvcjogTnVtYmVyRm9ybWF0dGVyLnByb3RvdHlwZS5kZWZhdWx0cy5kZWNpbWFsU2VwYXJhdG9yLFxyXG5cclxuICAvKiogQHByb3BlcnR5IHtzdHJpbmd9IFtvcmRlclNlcGFyYXRvcj0nLCddICovXHJcbiAgb3JkZXJTZXBhcmF0b3I6IE51bWJlckZvcm1hdHRlci5wcm90b3R5cGUuZGVmYXVsdHMub3JkZXJTZXBhcmF0b3IsXHJcblxyXG4gIC8qKiBAcHJvcGVydHkge0JhY2tncmlkLkNlbGxGb3JtYXR0ZXJ9IFtmb3JtYXR0ZXI9QmFja2dyaWQuTnVtYmVyRm9ybWF0dGVyXSAqL1xyXG4gIGZvcm1hdHRlcjogTnVtYmVyRm9ybWF0dGVyLFxyXG5cclxuICAvKipcclxuICAgICBJbml0aWFsaXplcyB0aGlzIGNlbGwgYW5kIHRoZSBudW1iZXIgZm9ybWF0dGVyLlxyXG5cclxuICAgICBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgIEBwYXJhbSB7QmFja2JvbmUuTW9kZWx9IG9wdGlvbnMubW9kZWxcclxuICAgICBAcGFyYW0ge0JhY2tncmlkLkNvbHVtbn0gb3B0aW9ucy5jb2x1bW5cclxuICAqL1xyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICBOdW1iZXJDZWxsLl9fc3VwZXJfXy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB2YXIgZm9ybWF0dGVyID0gdGhpcy5mb3JtYXR0ZXI7XHJcbiAgICBmb3JtYXR0ZXIuZGVjaW1hbHMgPSB0aGlzLmRlY2ltYWxzO1xyXG4gICAgZm9ybWF0dGVyLmRlY2ltYWxTZXBhcmF0b3IgPSB0aGlzLmRlY2ltYWxTZXBhcmF0b3I7XHJcbiAgICBmb3JtYXR0ZXIub3JkZXJTZXBhcmF0b3IgPSB0aGlzLm9yZGVyU2VwYXJhdG9yO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAgIEFuIEludGVnZXJDZWxsIGlzIGp1c3QgYSBCYWNrZ3JpZC5OdW1iZXJDZWxsIHdpdGggMCBkZWNpbWFscy4gSWYgYSBmbG9hdGluZ1xyXG4gICBwb2ludCBudW1iZXIgaXMgc3VwcGxpZWQsIHRoZSBudW1iZXIgaXMgc2ltcGx5IHJvdW5kZWQgdGhlIHVzdWFsIHdheSB3aGVuXHJcbiAgIGRpc3BsYXllZC5cclxuXHJcbiAgIEBjbGFzcyBCYWNrZ3JpZC5JbnRlZ2VyQ2VsbFxyXG4gICBAZXh0ZW5kcyBCYWNrZ3JpZC5OdW1iZXJDZWxsXHJcbiovXHJcbnZhciBJbnRlZ2VyQ2VsbCA9IEJhY2tncmlkLkludGVnZXJDZWxsID0gTnVtYmVyQ2VsbC5leHRlbmQoe1xyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgY2xhc3NOYW1lOiBcImludGVnZXItY2VsbFwiLFxyXG5cclxuICAvKipcclxuICAgICBAcHJvcGVydHkge251bWJlcn0gZGVjaW1hbHMgTXVzdCBiZSBhbiBpbnRlZ2VyLlxyXG4gICovXHJcbiAgZGVjaW1hbHM6IDBcclxufSk7XHJcblxyXG4vKipcclxuICAgQSBQZXJjZW50Q2VsbCBpcyBhbm90aGVyIEJhY2tncmlkLk51bWJlckNlbGwgdGhhdCB0YWtlcyBhIGZsb2F0aW5nIG51bWJlcixcclxuICAgb3B0aW9uYWxseSBtdWx0aXBsaWVkIGJ5IGEgbXVsdGlwbGllciBhbmQgZGlzcGxheSBpdCBhcyBhIHBlcmNlbnRhZ2UuXHJcblxyXG4gICBAY2xhc3MgQmFja2dyaWQuUGVyY2VudENlbGxcclxuICAgQGV4dGVuZHMgQmFja2dyaWQuTnVtYmVyQ2VsbFxyXG4gKi9cclxudmFyIFBlcmNlbnRDZWxsID0gQmFja2dyaWQuUGVyY2VudENlbGwgPSBOdW1iZXJDZWxsLmV4dGVuZCh7XHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBjbGFzc05hbWU6IFwicGVyY2VudC1jZWxsXCIsXHJcblxyXG4gIC8qKiBAcHJvcGVydHkge251bWJlcn0gW211bHRpcGxpZXI9MV0gKi9cclxuICBtdWx0aXBsaWVyOiBQZXJjZW50Rm9ybWF0dGVyLnByb3RvdHlwZS5kZWZhdWx0cy5tdWx0aXBsaWVyLFxyXG5cclxuICAvKiogQHByb3BlcnR5IHtzdHJpbmd9IFtzeW1ib2w9JyUnXSAqL1xyXG4gIHN5bWJvbDogUGVyY2VudEZvcm1hdHRlci5wcm90b3R5cGUuZGVmYXVsdHMuc3ltYm9sLFxyXG5cclxuICAvKiogQHByb3BlcnR5IHtCYWNrZ3JpZC5DZWxsRm9ybWF0dGVyfSBbZm9ybWF0dGVyPUJhY2tncmlkLlBlcmNlbnRGb3JtYXR0ZXJdICovXHJcbiAgZm9ybWF0dGVyOiBQZXJjZW50Rm9ybWF0dGVyLFxyXG5cclxuICAvKipcclxuICAgICBJbml0aWFsaXplcyB0aGlzIGNlbGwgYW5kIHRoZSBwZXJjZW50IGZvcm1hdHRlci5cclxuXHJcbiAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICBAcGFyYW0ge0JhY2tib25lLk1vZGVsfSBvcHRpb25zLm1vZGVsXHJcbiAgICAgQHBhcmFtIHtCYWNrZ3JpZC5Db2x1bW59IG9wdGlvbnMuY29sdW1uXHJcbiAgKi9cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBQZXJjZW50Q2VsbC5fX3N1cGVyX18uaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZm9ybWF0dGVyO1xyXG4gICAgZm9ybWF0dGVyLm11bHRpcGxpZXIgPSB0aGlzLm11bHRpcGxpZXI7XHJcbiAgICBmb3JtYXR0ZXIuc3ltYm9sID0gdGhpcy5zeW1ib2w7XHJcbiAgfVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICAgRGF0ZXRpbWVDZWxsIGlzIGEgYmFzaWMgY2VsbCB0aGF0IGFjY2VwdHMgZGF0ZXRpbWUgc3RyaW5nIHZhbHVlcyBpbiBSRkMtMjgyMlxyXG4gICBvciBXM0MncyBzdWJzZXQgb2YgSVNPLTg2MDEgYW5kIGRpc3BsYXlzIHRoZW0gaW4gSVNPLTg2MDEgZm9ybWF0LiBGb3IgYSBtdWNoXHJcbiAgIG1vcmUgc29waGlzdGljYXRlZCBkYXRlIHRpbWUgY2VsbCB3aXRoIGJldHRlciBkYXRldGltZSBmb3JtYXR0aW5nLCB0YWtlIGFcclxuICAgbG9vayBhdCB0aGUgQmFja2dyaWQuRXh0ZW5zaW9uLk1vbWVudENlbGwgZXh0ZW5zaW9uLlxyXG5cclxuICAgQGNsYXNzIEJhY2tncmlkLkRhdGV0aW1lQ2VsbFxyXG4gICBAZXh0ZW5kcyBCYWNrZ3JpZC5DZWxsXHJcblxyXG4gICBTZWU6XHJcblxyXG4gICAtIEJhY2tncmlkLkV4dGVuc2lvbi5Nb21lbnRDZWxsXHJcbiAgIC0gQmFja2dyaWQuRGF0ZXRpbWVGb3JtYXR0ZXJcclxuKi9cclxudmFyIERhdGV0aW1lQ2VsbCA9IEJhY2tncmlkLkRhdGV0aW1lQ2VsbCA9IENlbGwuZXh0ZW5kKHtcclxuXHJcbiAgLyoqIEBwcm9wZXJ0eSAqL1xyXG4gIGNsYXNzTmFtZTogXCJkYXRldGltZS1jZWxsXCIsXHJcblxyXG4gIC8qKlxyXG4gICAgIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2luY2x1ZGVEYXRlPXRydWVdXHJcbiAgKi9cclxuICBpbmNsdWRlRGF0ZTogRGF0ZXRpbWVGb3JtYXR0ZXIucHJvdG90eXBlLmRlZmF1bHRzLmluY2x1ZGVEYXRlLFxyXG5cclxuICAvKipcclxuICAgICBAcHJvcGVydHkge2Jvb2xlYW59IFtpbmNsdWRlVGltZT10cnVlXVxyXG4gICovXHJcbiAgaW5jbHVkZVRpbWU6IERhdGV0aW1lRm9ybWF0dGVyLnByb3RvdHlwZS5kZWZhdWx0cy5pbmNsdWRlVGltZSxcclxuXHJcbiAgLyoqXHJcbiAgICAgQHByb3BlcnR5IHtib29sZWFufSBbaW5jbHVkZU1pbGxpPWZhbHNlXVxyXG4gICovXHJcbiAgaW5jbHVkZU1pbGxpOiBEYXRldGltZUZvcm1hdHRlci5wcm90b3R5cGUuZGVmYXVsdHMuaW5jbHVkZU1pbGxpLFxyXG5cclxuICAvKiogQHByb3BlcnR5IHtCYWNrZ3JpZC5DZWxsRm9ybWF0dGVyfSBbZm9ybWF0dGVyPUJhY2tncmlkLkRhdGV0aW1lRm9ybWF0dGVyXSAqL1xyXG4gIGZvcm1hdHRlcjogRGF0ZXRpbWVGb3JtYXR0ZXIsXHJcblxyXG4gIC8qKlxyXG4gICAgIEluaXRpYWxpemVzIHRoaXMgY2VsbCBhbmQgdGhlIGRhdGV0aW1lIGZvcm1hdHRlci5cclxuXHJcbiAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICBAcGFyYW0ge0JhY2tib25lLk1vZGVsfSBvcHRpb25zLm1vZGVsXHJcbiAgICAgQHBhcmFtIHtCYWNrZ3JpZC5Db2x1bW59IG9wdGlvbnMuY29sdW1uXHJcbiAgKi9cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgRGF0ZXRpbWVDZWxsLl9fc3VwZXJfXy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB2YXIgZm9ybWF0dGVyID0gdGhpcy5mb3JtYXR0ZXI7XHJcbiAgICBmb3JtYXR0ZXIuaW5jbHVkZURhdGUgPSB0aGlzLmluY2x1ZGVEYXRlO1xyXG4gICAgZm9ybWF0dGVyLmluY2x1ZGVUaW1lID0gdGhpcy5pbmNsdWRlVGltZTtcclxuICAgIGZvcm1hdHRlci5pbmNsdWRlTWlsbGkgPSB0aGlzLmluY2x1ZGVNaWxsaTtcclxuXHJcbiAgICB2YXIgcGxhY2Vob2xkZXIgPSB0aGlzLmluY2x1ZGVEYXRlID8gXCJZWVlZLU1NLUREXCIgOiBcIlwiO1xyXG4gICAgcGxhY2Vob2xkZXIgKz0gKHRoaXMuaW5jbHVkZURhdGUgJiYgdGhpcy5pbmNsdWRlVGltZSkgPyBcIlRcIiA6IFwiXCI7XHJcbiAgICBwbGFjZWhvbGRlciArPSB0aGlzLmluY2x1ZGVUaW1lID8gXCJISDptbTpzc1wiIDogXCJcIjtcclxuICAgIHBsYWNlaG9sZGVyICs9ICh0aGlzLmluY2x1ZGVUaW1lICYmIHRoaXMuaW5jbHVkZU1pbGxpKSA/IFwiLlNTU1wiIDogXCJcIjtcclxuXHJcbiAgICB0aGlzLmVkaXRvciA9IHRoaXMuZWRpdG9yLmV4dGVuZCh7XHJcbiAgICAgIGF0dHJpYnV0ZXM6IF8uZXh0ZW5kKHt9LCB0aGlzLmVkaXRvci5wcm90b3R5cGUuYXR0cmlidXRlcywgdGhpcy5lZGl0b3IuYXR0cmlidXRlcywge1xyXG4gICAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlclxyXG4gICAgICB9KVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICAgRGF0ZUNlbGwgaXMgYSBCYWNrZ3JpZC5EYXRldGltZUNlbGwgd2l0aG91dCB0aGUgdGltZSBwYXJ0LlxyXG5cclxuICAgQGNsYXNzIEJhY2tncmlkLkRhdGVDZWxsXHJcbiAgIEBleHRlbmRzIEJhY2tncmlkLkRhdGV0aW1lQ2VsbFxyXG4qL1xyXG52YXIgRGF0ZUNlbGwgPSBCYWNrZ3JpZC5EYXRlQ2VsbCA9IERhdGV0aW1lQ2VsbC5leHRlbmQoe1xyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgY2xhc3NOYW1lOiBcImRhdGUtY2VsbFwiLFxyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgaW5jbHVkZVRpbWU6IGZhbHNlXHJcblxyXG59KTtcclxuXHJcbi8qKlxyXG4gICBUaW1lQ2VsbCBpcyBhIEJhY2tncmlkLkRhdGV0aW1lQ2VsbCB3aXRob3V0IHRoZSBkYXRlIHBhcnQuXHJcblxyXG4gICBAY2xhc3MgQmFja2dyaWQuVGltZUNlbGxcclxuICAgQGV4dGVuZHMgQmFja2dyaWQuRGF0ZXRpbWVDZWxsXHJcbiovXHJcbnZhciBUaW1lQ2VsbCA9IEJhY2tncmlkLlRpbWVDZWxsID0gRGF0ZXRpbWVDZWxsLmV4dGVuZCh7XHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBjbGFzc05hbWU6IFwidGltZS1jZWxsXCIsXHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBpbmNsdWRlRGF0ZTogZmFsc2VcclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAgIEJvb2xlYW5DZWxsRWRpdG9yIHJlbmRlcnMgYSBjaGVja2JveCBhcyBpdHMgZWRpdG9yLlxyXG5cclxuICAgQGNsYXNzIEJhY2tncmlkLkJvb2xlYW5DZWxsRWRpdG9yXHJcbiAgIEBleHRlbmRzIEJhY2tncmlkLkNlbGxFZGl0b3JcclxuKi9cclxudmFyIEJvb2xlYW5DZWxsRWRpdG9yID0gQmFja2dyaWQuQm9vbGVhbkNlbGxFZGl0b3IgPSBDZWxsRWRpdG9yLmV4dGVuZCh7XHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICB0YWdOYW1lOiBcImlucHV0XCIsXHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBhdHRyaWJ1dGVzOiB7XHJcbiAgICB0YWJJbmRleDogLTEsXHJcbiAgICB0eXBlOiBcImNoZWNrYm94XCJcclxuICB9LFxyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgZXZlbnRzOiB7XHJcbiAgICBcIm1vdXNlZG93blwiOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMubW91c2VEb3duID0gdHJ1ZTtcclxuICAgIH0sXHJcbiAgICBcImJsdXJcIjogXCJlbnRlck9yRXhpdEVkaXRNb2RlXCIsXHJcbiAgICBcIm1vdXNldXBcIjogZnVuY3Rpb24gKCkge1xyXG4gICAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xyXG4gICAgfSxcclxuICAgIFwiY2hhbmdlXCI6IFwic2F2ZU9yQ2FuY2VsXCIsXHJcbiAgICBcImtleWRvd25cIjogXCJzYXZlT3JDYW5jZWxcIlxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIFJlbmRlcnMgYSBjaGVja2JveCBhbmQgY2hlY2sgaXQgaWYgdGhlIG1vZGVsIHZhbHVlIG9mIHRoaXMgY29sdW1uIGlzIHRydWUsXHJcbiAgICAgdW5jaGVjayBvdGhlcndpc2UuXHJcbiAgKi9cclxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XHJcbiAgICB2YXIgdmFsID0gdGhpcy5mb3JtYXR0ZXIuZnJvbVJhdyhtb2RlbC5nZXQodGhpcy5jb2x1bW4uZ2V0KFwibmFtZVwiKSksIG1vZGVsKTtcclxuICAgIHRoaXMuJGVsLnByb3AoXCJjaGVja2VkXCIsIHZhbCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBFdmVudCBoYW5kbGVyLiBIYWNrIHRvIGRlYWwgd2l0aCB0aGUgY2FzZSB3aGVyZSBgYmx1cmAgaXMgZmlyZWQgYmVmb3JlXHJcbiAgICAgYGNoYW5nZWAgYW5kIGBjbGlja2Agb24gYSBjaGVja2JveC5cclxuICAqL1xyXG4gIGVudGVyT3JFeGl0RWRpdE1vZGU6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICBpZiAoIXRoaXMubW91c2VEb3duKSB7XHJcbiAgICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWw7XHJcbiAgICAgIG1vZGVsLnRyaWdnZXIoXCJiYWNrZ3JpZDplZGl0ZWRcIiwgbW9kZWwsIHRoaXMuY29sdW1uLCBuZXcgQ29tbWFuZChlKSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgRXZlbnQgaGFuZGxlci4gU2F2ZSB0aGUgdmFsdWUgaW50byB0aGUgbW9kZWwgaWYgdGhlIGV2ZW50IGlzIGBjaGFuZ2VgIG9yXHJcbiAgICAgb25lIG9mIHRoZSBrZXlib2FyZCBuYXZpZ2F0aW9uIGtleSBwcmVzc2VzLiBFeGl0IGVkaXQgbW9kZSB3aXRob3V0IHNhdmluZ1xyXG4gICAgIGlmIGBlc2NhcGVgIHdhcyBwcmVzc2VkLlxyXG4gICovXHJcbiAgc2F2ZU9yQ2FuY2VsOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcclxuICAgIHZhciBjb2x1bW4gPSB0aGlzLmNvbHVtbjtcclxuICAgIHZhciBmb3JtYXR0ZXIgPSB0aGlzLmZvcm1hdHRlcjtcclxuICAgIHZhciBjb21tYW5kID0gbmV3IENvbW1hbmQoZSk7XHJcbiAgICAvLyBza2lwIGFoZWFkIHRvIGBjaGFuZ2VgIHdoZW4gc3BhY2UgaXMgcHJlc3NlZFxyXG4gICAgaWYgKGNvbW1hbmQucGFzc1RocnUoKSAmJiBlLnR5cGUgIT0gXCJjaGFuZ2VcIikgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAoY29tbWFuZC5jYW5jZWwoKSkge1xyXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICBtb2RlbC50cmlnZ2VyKFwiYmFja2dyaWQ6ZWRpdGVkXCIsIG1vZGVsLCBjb2x1bW4sIGNvbW1hbmQpO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciAkZWwgPSB0aGlzLiRlbDtcclxuICAgIGlmIChjb21tYW5kLnNhdmUoKSB8fCBjb21tYW5kLm1vdmVMZWZ0KCkgfHwgY29tbWFuZC5tb3ZlUmlnaHQoKSB8fCBjb21tYW5kLm1vdmVVcCgpIHx8XHJcbiAgICAgICAgY29tbWFuZC5tb3ZlRG93bigpKSB7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgdmFyIHZhbCA9IGZvcm1hdHRlci50b1JhdygkZWwucHJvcChcImNoZWNrZWRcIiksIG1vZGVsKTtcclxuICAgICAgbW9kZWwuc2V0KGNvbHVtbi5nZXQoXCJuYW1lXCIpLCB2YWwpO1xyXG4gICAgICBtb2RlbC50cmlnZ2VyKFwiYmFja2dyaWQ6ZWRpdGVkXCIsIG1vZGVsLCBjb2x1bW4sIGNvbW1hbmQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZS50eXBlID09IFwiY2hhbmdlXCIpIHtcclxuICAgICAgdmFyIHZhbCA9IGZvcm1hdHRlci50b1JhdygkZWwucHJvcChcImNoZWNrZWRcIiksIG1vZGVsKTtcclxuICAgICAgbW9kZWwuc2V0KGNvbHVtbi5nZXQoXCJuYW1lXCIpLCB2YWwpO1xyXG4gICAgICAkZWwuZm9jdXMoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG59KTtcclxuXHJcbi8qKlxyXG4gICBCb29sZWFuQ2VsbCByZW5kZXJzIGEgY2hlY2tib3ggYm90aCBkdXJpbmcgZGlzcGxheSBtb2RlIGFuZCBlZGl0IG1vZGUuIFRoZVxyXG4gICBjaGVja2JveCBpcyBjaGVja2VkIGlmIHRoZSBtb2RlbCB2YWx1ZSBpcyB0cnVlLCB1bmNoZWNrZWQgb3RoZXJ3aXNlLlxyXG5cclxuICAgQGNsYXNzIEJhY2tncmlkLkJvb2xlYW5DZWxsXHJcbiAgIEBleHRlbmRzIEJhY2tncmlkLkNlbGxcclxuKi9cclxudmFyIEJvb2xlYW5DZWxsID0gQmFja2dyaWQuQm9vbGVhbkNlbGwgPSBDZWxsLmV4dGVuZCh7XHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBjbGFzc05hbWU6IFwiYm9vbGVhbi1jZWxsXCIsXHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBlZGl0b3I6IEJvb2xlYW5DZWxsRWRpdG9yLFxyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgZXZlbnRzOiB7XHJcbiAgICBcImNsaWNrXCI6IFwiZW50ZXJFZGl0TW9kZVwiXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgUmVuZGVycyBhIGNoZWNrYm94IGFuZCBjaGVjayBpdCBpZiB0aGUgbW9kZWwgdmFsdWUgb2YgdGhpcyBjb2x1bW4gaXMgdHJ1ZSxcclxuICAgICB1bmNoZWNrIG90aGVyd2lzZS5cclxuICAqL1xyXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy4kZWwuZW1wdHkoKTtcclxuICAgIHZhciBtb2RlbCA9IHRoaXMubW9kZWwsIGNvbHVtbiA9IHRoaXMuY29sdW1uO1xyXG4gICAgdmFyIGVkaXRhYmxlID0gQmFja2dyaWQuY2FsbEJ5TmVlZChjb2x1bW4uZWRpdGFibGUoKSwgY29sdW1uLCBtb2RlbCk7XHJcbiAgICB0aGlzLiRlbC5hcHBlbmQoJChcIjxpbnB1dD5cIiwge1xyXG4gICAgICB0YWJJbmRleDogLTEsXHJcbiAgICAgIHR5cGU6IFwiY2hlY2tib3hcIixcclxuICAgICAgY2hlY2tlZDogdGhpcy5mb3JtYXR0ZXIuZnJvbVJhdyhtb2RlbC5nZXQoY29sdW1uLmdldChcIm5hbWVcIikpLCBtb2RlbCksXHJcbiAgICAgIGRpc2FibGVkOiAhZWRpdGFibGVcclxuICAgIH0pKTtcclxuICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAgIFNlbGVjdENlbGxFZGl0b3IgcmVuZGVycyBhbiBIVE1MIGA8c2VsZWN0PmAgZnJhZ21lbnQgYXMgdGhlIGVkaXRvci5cclxuXHJcbiAgIEBjbGFzcyBCYWNrZ3JpZC5TZWxlY3RDZWxsRWRpdG9yXHJcbiAgIEBleHRlbmRzIEJhY2tncmlkLkNlbGxFZGl0b3JcclxuKi9cclxudmFyIFNlbGVjdENlbGxFZGl0b3IgPSBCYWNrZ3JpZC5TZWxlY3RDZWxsRWRpdG9yID0gQ2VsbEVkaXRvci5leHRlbmQoe1xyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgdGFnTmFtZTogXCJzZWxlY3RcIixcclxuXHJcbiAgLyoqIEBwcm9wZXJ0eSAqL1xyXG4gIGV2ZW50czoge1xyXG4gICAgXCJjaGFuZ2VcIjogXCJzYXZlXCIsXHJcbiAgICBcImJsdXJcIjogXCJjbG9zZVwiLFxyXG4gICAgXCJrZXlkb3duXCI6IFwiY2xvc2VcIlxyXG4gIH0sXHJcblxyXG4gIC8qKiBAcHJvcGVydHkge2Z1bmN0aW9uKE9iamVjdCwgP09iamVjdD0pOiBzdHJpbmd9IHRlbXBsYXRlICovXHJcbiAgdGVtcGxhdGU6IF8udGVtcGxhdGUoJzxvcHRpb24gdmFsdWU9XCI8JS0gdmFsdWUgJT5cIiA8JT0gc2VsZWN0ZWQgPyBcXCdzZWxlY3RlZD1cInNlbGVjdGVkXCJcXCcgOiBcIlwiICU+PjwlLSB0ZXh0ICU+PC9vcHRpb24+JywgbnVsbCwge3ZhcmlhYmxlOiBudWxsfSksXHJcblxyXG4gIHNldE9wdGlvblZhbHVlczogZnVuY3Rpb24gKG9wdGlvblZhbHVlcykge1xyXG4gICAgdGhpcy5vcHRpb25WYWx1ZXMgPSBvcHRpb25WYWx1ZXM7XHJcbiAgICB0aGlzLm9wdGlvblZhbHVlcyA9IF8ucmVzdWx0KHRoaXMsIFwib3B0aW9uVmFsdWVzXCIpO1xyXG4gIH0sXHJcblxyXG4gIHNldE11bHRpcGxlOiBmdW5jdGlvbiAobXVsdGlwbGUpIHtcclxuICAgIHRoaXMubXVsdGlwbGUgPSBtdWx0aXBsZTtcclxuICAgIHRoaXMuJGVsLnByb3AoXCJtdWx0aXBsZVwiLCBtdWx0aXBsZSk7XHJcbiAgfSxcclxuXHJcbiAgX3JlbmRlck9wdGlvbnM6IGZ1bmN0aW9uIChudnBzLCBzZWxlY3RlZFZhbHVlcykge1xyXG4gICAgdmFyIG9wdGlvbnMgPSAnJztcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnZwcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyArIHRoaXMudGVtcGxhdGUoe1xyXG4gICAgICAgIHRleHQ6IG52cHNbaV1bMF0sXHJcbiAgICAgICAgdmFsdWU6IG52cHNbaV1bMV0sXHJcbiAgICAgICAgc2VsZWN0ZWQ6IF8uaW5kZXhPZihzZWxlY3RlZFZhbHVlcywgbnZwc1tpXVsxXSkgPiAtMVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBvcHRpb25zO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIFJlbmRlcnMgdGhlIG9wdGlvbnMgaWYgYG9wdGlvblZhbHVlc2AgaXMgYSBsaXN0IG9mIG5hbWUtdmFsdWUgcGFpcnMuIFRoZVxyXG4gICAgIG9wdGlvbnMgYXJlIGNvbnRhaW5lZCBpbnNpZGUgb3B0aW9uIGdyb3VwcyBpZiBgb3B0aW9uVmFsdWVzYCBpcyBhIGxpc3Qgb2ZcclxuICAgICBvYmplY3QgaGFzaGVzLiBUaGUgbmFtZSBpcyByZW5kZXJlZCBhdCB0aGUgb3B0aW9uIHRleHQgYW5kIHRoZSB2YWx1ZSBpcyB0aGVcclxuICAgICBvcHRpb24gdmFsdWUuIElmIGBvcHRpb25WYWx1ZXNgIGlzIGEgZnVuY3Rpb24sIGl0IGlzIGNhbGxlZCB3aXRob3V0IGFcclxuICAgICBwYXJhbWV0ZXIuXHJcbiAgKi9cclxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuJGVsLmVtcHR5KCk7XHJcblxyXG4gICAgdmFyIG9wdGlvblZhbHVlcyA9IF8ucmVzdWx0KHRoaXMsIFwib3B0aW9uVmFsdWVzXCIpO1xyXG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcclxuICAgIHZhciBzZWxlY3RlZFZhbHVlcyA9IHRoaXMuZm9ybWF0dGVyLmZyb21SYXcobW9kZWwuZ2V0KHRoaXMuY29sdW1uLmdldChcIm5hbWVcIikpLCBtb2RlbCk7XHJcblxyXG4gICAgaWYgKCFfLmlzQXJyYXkob3B0aW9uVmFsdWVzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm9wdGlvblZhbHVlcyBtdXN0IGJlIGFuIGFycmF5XCIpO1xyXG5cclxuICAgIHZhciBvcHRpb25WYWx1ZSA9IG51bGw7XHJcbiAgICB2YXIgb3B0aW9uVGV4dCA9IG51bGw7XHJcbiAgICB2YXIgb3B0aW9uVmFsdWUgPSBudWxsO1xyXG4gICAgdmFyIG9wdGdyb3VwTmFtZSA9IG51bGw7XHJcbiAgICB2YXIgb3B0Z3JvdXAgPSBudWxsO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9uVmFsdWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciBvcHRpb25WYWx1ZSA9IG9wdGlvblZhbHVlc1tpXTtcclxuXHJcbiAgICAgIGlmIChfLmlzQXJyYXkob3B0aW9uVmFsdWUpKSB7XHJcbiAgICAgICAgb3B0aW9uVGV4dCAgPSBvcHRpb25WYWx1ZVswXTtcclxuICAgICAgICBvcHRpb25WYWx1ZSA9IG9wdGlvblZhbHVlWzFdO1xyXG5cclxuICAgICAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy50ZW1wbGF0ZSh7XHJcbiAgICAgICAgICB0ZXh0OiBvcHRpb25UZXh0LFxyXG4gICAgICAgICAgdmFsdWU6IG9wdGlvblZhbHVlLFxyXG4gICAgICAgICAgc2VsZWN0ZWQ6IF8uaW5kZXhPZihzZWxlY3RlZFZhbHVlcywgb3B0aW9uVmFsdWUpID4gLTFcclxuICAgICAgICB9KSk7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBpZiAoXy5pc09iamVjdChvcHRpb25WYWx1ZSkpIHtcclxuICAgICAgICBvcHRncm91cE5hbWUgPSBvcHRpb25WYWx1ZS5uYW1lO1xyXG4gICAgICAgIG9wdGdyb3VwID0gJChcIjxvcHRncm91cD48L29wdGdyb3VwPlwiLCB7IGxhYmVsOiBvcHRncm91cE5hbWUgfSk7XHJcbiAgICAgICAgb3B0Z3JvdXAuYXBwZW5kKHRoaXMuX3JlbmRlck9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25WYWx1ZS52YWx1ZXMsIHNlbGVjdGVkVmFsdWVzKSk7XHJcbiAgICAgICAgdGhpcy4kZWwuYXBwZW5kKG9wdGdyb3VwKTtcclxuICAgICAgfVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib3B0aW9uVmFsdWVzIGVsZW1lbnRzIG11c3QgYmUgYSBuYW1lLXZhbHVlIHBhaXIgb3IgYW4gb2JqZWN0IGhhc2ggb2YgeyBuYW1lOiAnb3B0Z3JvdXAgbGFiZWwnLCB2YWx1ZTogW29wdGlvbiBuYW1lLXZhbHVlIHBhaXJzXSB9XCIpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIFNhdmVzIHRoZSB2YWx1ZSBvZiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBtb2RlbCBhdHRyaWJ1dGUuXHJcbiAgKi9cclxuICBzYXZlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcclxuICAgIHZhciBjb2x1bW4gPSB0aGlzLmNvbHVtbjtcclxuICAgIG1vZGVsLnNldChjb2x1bW4uZ2V0KFwibmFtZVwiKSwgdGhpcy5mb3JtYXR0ZXIudG9SYXcodGhpcy4kZWwudmFsKCksIG1vZGVsKSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgVHJpZ2dlcnMgYSBgYmFja2dyaWQ6ZWRpdGVkYCBldmVudCBmcm9tIHRoZSBtb2RlbCBzbyB0aGUgYm9keSBjYW4gY2xvc2VcclxuICAgICB0aGlzIGVkaXRvci5cclxuICAqL1xyXG4gIGNsb3NlOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcclxuICAgIHZhciBjb2x1bW4gPSB0aGlzLmNvbHVtbjtcclxuICAgIHZhciBjb21tYW5kID0gbmV3IENvbW1hbmQoZSk7XHJcbiAgICBpZiAoY29tbWFuZC5jYW5jZWwoKSkge1xyXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICBtb2RlbC50cmlnZ2VyKFwiYmFja2dyaWQ6ZWRpdGVkXCIsIG1vZGVsLCBjb2x1bW4sIG5ldyBDb21tYW5kKGUpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbW1hbmQuc2F2ZSgpIHx8IGNvbW1hbmQubW92ZUxlZnQoKSB8fCBjb21tYW5kLm1vdmVSaWdodCgpIHx8XHJcbiAgICAgICAgICAgICBjb21tYW5kLm1vdmVVcCgpIHx8IGNvbW1hbmQubW92ZURvd24oKSB8fCBlLnR5cGUgPT0gXCJibHVyXCIpIHtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICB0aGlzLnNhdmUoZSk7XHJcbiAgICAgIG1vZGVsLnRyaWdnZXIoXCJiYWNrZ3JpZDplZGl0ZWRcIiwgbW9kZWwsIGNvbHVtbiwgbmV3IENvbW1hbmQoZSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAgIFNlbGVjdENlbGwgaXMgYWxzbyBhIGRpZmZlcmVudCBraW5kIG9mIGNlbGwgaW4gdGhhdCB1cG9uIGdvaW5nIGludG8gZWRpdCBtb2RlXHJcbiAgIHRoZSBjZWxsIHJlbmRlcnMgYSBsaXN0IG9mIG9wdGlvbnMgdG8gcGljayBmcm9tLCBhcyBvcHBvc2VkIHRvIGFuIGlucHV0IGJveC5cclxuXHJcbiAgIFNlbGVjdENlbGwgY2Fubm90IGJlIHJlZmVyZW5jZWQgYnkgaXRzIHN0cmluZyBuYW1lIHdoZW4gdXNlZCBpbiBhIGNvbHVtblxyXG4gICBkZWZpbml0aW9uIGJlY2F1c2UgaXQgcmVxdWlyZXMgYW4gYG9wdGlvblZhbHVlc2AgY2xhc3MgYXR0cmlidXRlIHRvIGJlXHJcbiAgIGRlZmluZWQuIGBvcHRpb25WYWx1ZXNgIGNhbiBlaXRoZXIgYmUgYSBsaXN0IG9mIG5hbWUtdmFsdWUgcGFpcnMsIHRvIGJlXHJcbiAgIHJlbmRlcmVkIGFzIG9wdGlvbnMsIG9yIGEgbGlzdCBvZiBvYmplY3QgaGFzaGVzIHdoaWNoIGNvbnNpc3Qgb2YgYSBrZXkgKm5hbWUqXHJcbiAgIHdoaWNoIGlzIHRoZSBvcHRpb24gZ3JvdXAgbmFtZSwgYW5kIGEga2V5ICp2YWx1ZXMqIHdoaWNoIGlzIGEgbGlzdCBvZlxyXG4gICBuYW1lLXZhbHVlIHBhaXJzIHRvIGJlIHJlbmRlcmVkIGFzIG9wdGlvbnMgdW5kZXIgdGhhdCBvcHRpb24gZ3JvdXAuXHJcblxyXG4gICBJbiBhZGRpdGlvbiwgYG9wdGlvblZhbHVlc2AgY2FuIGFsc28gYmUgYSBwYXJhbWV0ZXItbGVzcyBmdW5jdGlvbiB0aGF0XHJcbiAgIHJldHVybnMgb25lIG9mIHRoZSBhYm92ZS4gSWYgdGhlIG9wdGlvbnMgYXJlIHN0YXRpYywgaXQgaXMgcmVjb21tZW5kZWQgdGhlXHJcbiAgIHJldHVybmVkIHZhbHVlcyB0byBiZSBtZW1vaXplZC4gYF8ubWVtb2l6ZSgpYCBpcyBhIGdvb2QgZnVuY3Rpb24gdG8gaGVscCB3aXRoXHJcbiAgIHRoYXQuXHJcblxyXG4gICBEdXJpbmcgZGlzcGxheSBtb2RlLCB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIgd2lsbCBub3JtYWxpemUgdGhlIHJhdyBtb2RlbCB2YWx1ZVxyXG4gICB0byBhbiBhcnJheSBvZiB2YWx1ZXMgd2hldGhlciB0aGUgcmF3IG1vZGVsIHZhbHVlIGlzIGEgc2NhbGFyIG9yIGFuXHJcbiAgIGFycmF5LiBFYWNoIHZhbHVlIGlzIGNvbXBhcmVkIHdpdGggdGhlIGBvcHRpb25WYWx1ZXNgIHZhbHVlcyB1c2luZ1xyXG4gICBFY21hc2NyaXB0J3MgaW1wbGljaXQgdHlwZSBjb252ZXJzaW9uIHJ1bGVzLiBXaGVuIGV4aXRpbmcgZWRpdCBtb2RlLCBubyB0eXBlXHJcbiAgIGNvbnZlcnNpb24gaXMgcGVyZm9ybWVkIHdoZW4gc2F2aW5nIGludG8gdGhlIG1vZGVsLiBUaGlzIGJlaGF2aW9yIGlzIG5vdFxyXG4gICBhbHdheXMgZGVzaXJhYmxlIHdoZW4gdGhlIHZhbHVlIHR5cGUgaXMgYW55dGhpbmcgb3RoZXIgdGhhbiBzdHJpbmcuIFRvXHJcbiAgIGNvbnRyb2wgdHlwZSBjb252ZXJzaW9uIG9uIHRoZSBjbGllbnQtc2lkZSwgeW91IHNob3VsZCBzdWJjbGFzcyBTZWxlY3RDZWxsIHRvXHJcbiAgIHByb3ZpZGUgYSBjdXN0b20gZm9ybWF0dGVyIG9yIHByb3ZpZGUgdGhlIGZvcm1hdHRlciB0byB5b3VyIGNvbHVtblxyXG4gICBkZWZpbml0aW9uLlxyXG5cclxuICAgU2VlOlxyXG4gICAgIFskLmZuLnZhbCgpXShodHRwOi8vYXBpLmpxdWVyeS5jb20vdmFsLylcclxuXHJcbiAgIEBjbGFzcyBCYWNrZ3JpZC5TZWxlY3RDZWxsXHJcbiAgIEBleHRlbmRzIEJhY2tncmlkLkNlbGxcclxuKi9cclxudmFyIFNlbGVjdENlbGwgPSBCYWNrZ3JpZC5TZWxlY3RDZWxsID0gQ2VsbC5leHRlbmQoe1xyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgY2xhc3NOYW1lOiBcInNlbGVjdC1jZWxsXCIsXHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBlZGl0b3I6IFNlbGVjdENlbGxFZGl0b3IsXHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBtdWx0aXBsZTogZmFsc2UsXHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBmb3JtYXR0ZXI6IFNlbGVjdEZvcm1hdHRlcixcclxuXHJcbiAgLyoqXHJcbiAgICAgQHByb3BlcnR5IHtBcnJheS48QXJyYXk+fEFycmF5Ljx7bmFtZTogc3RyaW5nLCB2YWx1ZXM6IEFycmF5LjxBcnJheT59Pn0gb3B0aW9uVmFsdWVzXHJcbiAgKi9cclxuICBvcHRpb25WYWx1ZXM6IHVuZGVmaW5lZCxcclxuXHJcbiAgLyoqIEBwcm9wZXJ0eSAqL1xyXG4gIGRlbGltaXRlcjogJywgJyxcclxuXHJcbiAgLyoqXHJcbiAgICAgSW5pdGlhbGl6ZXIuXHJcblxyXG4gICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgQHBhcmFtIHtCYWNrYm9uZS5Nb2RlbH0gb3B0aW9ucy5tb2RlbFxyXG4gICAgIEBwYXJhbSB7QmFja2dyaWQuQ29sdW1ufSBvcHRpb25zLmNvbHVtblxyXG5cclxuICAgICBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvcHRpb25zVmFsdWVzYCBpcyB1bmRlZmluZWQuXHJcbiAgKi9cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgU2VsZWN0Q2VsbC5fX3N1cGVyX18uaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLm1vZGVsLCBcImJhY2tncmlkOmVkaXRcIiwgZnVuY3Rpb24gKG1vZGVsLCBjb2x1bW4sIGNlbGwsIGVkaXRvcikge1xyXG4gICAgICBpZiAoY29sdW1uLmdldChcIm5hbWVcIikgPT0gdGhpcy5jb2x1bW4uZ2V0KFwibmFtZVwiKSkge1xyXG4gICAgICAgIGVkaXRvci5zZXRPcHRpb25WYWx1ZXModGhpcy5vcHRpb25WYWx1ZXMpO1xyXG4gICAgICAgIGVkaXRvci5zZXRNdWx0aXBsZSh0aGlzLm11bHRpcGxlKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgUmVuZGVycyB0aGUgbGFiZWwgdXNpbmcgdGhlIHJhdyB2YWx1ZSBhcyBrZXkgdG8gbG9vayB1cCBmcm9tIGBvcHRpb25WYWx1ZXNgLlxyXG5cclxuICAgICBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGBvcHRpb25WYWx1ZXNgIGlzIG1hbGZvcm1lZC5cclxuICAqL1xyXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy4kZWwuZW1wdHkoKTtcclxuXHJcbiAgICB2YXIgb3B0aW9uVmFsdWVzID0gXy5yZXN1bHQodGhpcywgXCJvcHRpb25WYWx1ZXNcIik7XHJcbiAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xyXG4gICAgdmFyIHJhd0RhdGEgPSB0aGlzLmZvcm1hdHRlci5mcm9tUmF3KG1vZGVsLmdldCh0aGlzLmNvbHVtbi5nZXQoXCJuYW1lXCIpKSwgbW9kZWwpO1xyXG5cclxuICAgIHZhciBzZWxlY3RlZFRleHQgPSBbXTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAoIV8uaXNBcnJheShvcHRpb25WYWx1ZXMpIHx8IF8uaXNFbXB0eShvcHRpb25WYWx1ZXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yO1xyXG5cclxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCByYXdEYXRhLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgdmFyIHJhd0RhdHVtID0gcmF3RGF0YVtrXTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25WYWx1ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIHZhciBvcHRpb25WYWx1ZSA9IG9wdGlvblZhbHVlc1tpXTtcclxuXHJcbiAgICAgICAgICBpZiAoXy5pc0FycmF5KG9wdGlvblZhbHVlKSkge1xyXG4gICAgICAgICAgICB2YXIgb3B0aW9uVGV4dCAgPSBvcHRpb25WYWx1ZVswXTtcclxuICAgICAgICAgICAgdmFyIG9wdGlvblZhbHVlID0gb3B0aW9uVmFsdWVbMV07XHJcblxyXG4gICAgICAgICAgICBpZiAob3B0aW9uVmFsdWUgPT0gcmF3RGF0dW0pIHNlbGVjdGVkVGV4dC5wdXNoKG9wdGlvblRleHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSBpZiAoXy5pc09iamVjdChvcHRpb25WYWx1ZSkpIHtcclxuICAgICAgICAgICAgdmFyIG9wdGlvbkdyb3VwVmFsdWVzID0gb3B0aW9uVmFsdWUudmFsdWVzO1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBvcHRpb25Hcm91cFZhbHVlcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgIHZhciBvcHRpb25Hcm91cFZhbHVlID0gb3B0aW9uR3JvdXBWYWx1ZXNbal07XHJcbiAgICAgICAgICAgICAgaWYgKG9wdGlvbkdyb3VwVmFsdWVbMV0gPT0gcmF3RGF0dW0pIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkVGV4dC5wdXNoKG9wdGlvbkdyb3VwVmFsdWVbMF0pO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3I7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB0aGlzLiRlbC5hcHBlbmQoc2VsZWN0ZWRUZXh0LmpvaW4odGhpcy5kZWxpbWl0ZXIpKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChleCkge1xyXG4gICAgICBpZiAoZXggaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvblZhbHVlcycgbXVzdCBiZSBvZiB0eXBlIHtBcnJheS48QXJyYXk+fEFycmF5Ljx7bmFtZTogc3RyaW5nLCB2YWx1ZXM6IEFycmF5LjxBcnJheT59Pn1cIik7XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgZXg7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLypcclxuICBiYWNrZ3JpZFxyXG4gIGh0dHA6Ly9naXRodWIuY29tL3d5dWVuaG8vYmFja2dyaWRcclxuXHJcbiAgQ29weXJpZ2h0IChjKSAyMDEzIEppbW15IFl1ZW4gSG8gV29uZyBhbmQgY29udHJpYnV0b3JzXHJcbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4qL1xyXG5cclxuLyoqXHJcbiAgIEEgQ29sdW1uIGlzIGEgcGxhY2Vob2xkZXIgZm9yIGNvbHVtbiBtZXRhZGF0YS5cclxuXHJcbiAgIFlvdSB1c3VhbGx5IGRvbid0IG5lZWQgdG8gY3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgeW91cnNlbGYgYXMgYVxyXG4gICBjb2xsZWN0aW9uIG9mIGNvbHVtbiBpbnN0YW5jZXMgd2lsbCBiZSBjcmVhdGVkIGZvciB5b3UgZnJvbSBhIGxpc3Qgb2YgY29sdW1uXHJcbiAgIGF0dHJpYnV0ZXMgaW4gdGhlIEJhY2tncmlkLmpzIHZpZXcgY2xhc3MgY29uc3RydWN0b3JzLlxyXG5cclxuICAgQGNsYXNzIEJhY2tncmlkLkNvbHVtblxyXG4gICBAZXh0ZW5kcyBCYWNrYm9uZS5Nb2RlbFxyXG4qL1xyXG52YXIgQ29sdW1uID0gQmFja2dyaWQuQ29sdW1uID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcclxuXHJcbiAgLyoqXHJcbiAgICAgQGNmZyB7T2JqZWN0fSBkZWZhdWx0cyBDb2x1bW4gZGVmYXVsdHMuIFRvIG92ZXJyaWRlIGFueSBvZiB0aGVzZSBkZWZhdWx0XHJcbiAgICAgdmFsdWVzLCB5b3UgY2FuIGVpdGhlciBjaGFuZ2UgdGhlIHByb3RvdHlwZSBkaXJlY3RseSB0byBvdmVycmlkZVxyXG4gICAgIENvbHVtbi5kZWZhdWx0cyBnbG9iYWxseSBvciBleHRlbmQgQ29sdW1uIGFuZCBzdXBwbHkgdGhlIGN1c3RvbSBjbGFzcyB0b1xyXG4gICAgIEJhY2tncmlkLkdyaWQ6XHJcblxyXG4gICAgICAgICAvLyBPdmVycmlkZSBDb2x1bW4gZGVmYXVsdHMgZ2xvYmFsbHlcclxuICAgICAgICAgQ29sdW1uLnByb3RvdHlwZS5kZWZhdWx0cy5zb3J0YWJsZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgLy8gT3ZlcnJpZGUgQ29sdW1uIGRlZmF1bHRzIGxvY2FsbHlcclxuICAgICAgICAgdmFyIE15Q29sdW1uID0gQ29sdW1uLmV4dGVuZCh7XHJcbiAgICAgICAgICAgZGVmYXVsdHM6IF8uZGVmYXVsdHMoe1xyXG4gICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlXHJcbiAgICAgICAgICAgfSwgQ29sdW1uLnByb3RvdHlwZS5kZWZhdWx0cylcclxuICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICB2YXIgZ3JpZCA9IG5ldyBCYWNrZ3JpZC5HcmlkKGNvbHVtbnM6IG5ldyBDb2x1bW5zKFt7Li4ufSwgey4uLn1dLCB7XHJcbiAgICAgICAgICAgbW9kZWw6IE15Q29sdW1uXHJcbiAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgQGNmZyB7c3RyaW5nfSBbZGVmYXVsdHMubmFtZV0gVGhlIGRlZmF1bHQgbmFtZSBvZiB0aGUgbW9kZWwgYXR0cmlidXRlLlxyXG5cclxuICAgICBAY2ZnIHtzdHJpbmd9IFtkZWZhdWx0cy5sYWJlbF0gVGhlIGRlZmF1bHQgbGFiZWwgdG8gc2hvdyBpbiB0aGUgaGVhZGVyLlxyXG5cclxuICAgICBAY2ZnIHtzdHJpbmd8QmFja2dyaWQuQ2VsbH0gW2RlZmF1bHRzLmNlbGxdIFRoZSBkZWZhdWx0IGNlbGwgdHlwZS4gSWYgdGhpc1xyXG4gICAgIGlzIGEgc3RyaW5nLCB0aGUgY2FwaXRhbGl6ZWQgZm9ybSB3aWxsIGJlIHVzZWQgdG8gbG9vayB1cCBhIGNlbGwgY2xhc3MgaW5cclxuICAgICBCYWNrYm9uZSwgaS5lLjogc3RyaW5nID0+IFN0cmluZ0NlbGwuIElmIGEgQ2VsbCBzdWJjbGFzcyBpcyBzdXBwbGllZCwgaXQgaXNcclxuICAgICBpbml0aWFsaXplZCB3aXRoIGEgaGFzaCBvZiBwYXJhbWV0ZXJzLiBJZiBhIENlbGwgaW5zdGFuY2UgaXMgc3VwcGxpZWQsIGl0XHJcbiAgICAgaXMgdXNlZCBkaXJlY3RseS5cclxuXHJcbiAgICAgQGNmZyB7c3RyaW5nfEJhY2tncmlkLkhlYWRlckNlbGx9IFtkZWZhdWx0cy5oZWFkZXJDZWxsXSBUaGUgZGVmYXVsdCBoZWFkZXJcclxuICAgICBjZWxsIHR5cGUuXHJcblxyXG4gICAgIEBjZmcge2Jvb2xlYW58c3RyaW5nfGZ1bmN0aW9uKCk6IGJvb2xlYW59IFtkZWZhdWx0cy5zb3J0YWJsZT10cnVlXSBXaGV0aGVyXHJcbiAgICAgdGhpcyBjb2x1bW4gaXMgc29ydGFibGUuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgYSBtZXRob2Qgd2lsbCB0aGUgc2FtZVxyXG4gICAgIG5hbWUgd2lsbCBiZSBsb29rZWQgdXAgZnJvbSB0aGUgY29sdW1uIGluc3RhbmNlIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxyXG4gICAgIGNvbHVtbiBzaG91bGQgYmUgc29ydGFibGUuIFRoZSBtZXRob2QncyBzaWduYXR1cmUgbXVzdCBiZSBgZnVuY3Rpb25cclxuICAgICAoQmFja2dyaWQuQ29sdW1uLCBCYWNrYm9uZS5Nb2RlbCk6IGJvb2xlYW5gLlxyXG5cclxuICAgICBAY2ZnIHtib29sZWFufHN0cmluZ3xmdW5jdGlvbigpOiBib29sZWFufSBbZGVmYXVsdHMuZWRpdGFibGU9dHJ1ZV0gV2hldGhlclxyXG4gICAgIHRoaXMgY29sdW1uIGlzIGVkaXRhYmxlLiBJZiB0aGUgdmFsdWUgaXMgYSBzdHJpbmcsIGEgbWV0aG9kIHdpbGwgdGhlIHNhbWVcclxuICAgICBuYW1lIHdpbGwgYmUgbG9va2VkIHVwIGZyb20gdGhlIGNvbHVtbiBpbnN0YW5jZSB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcclxuICAgICBjb2x1bW4gc2hvdWxkIGJlIGVkaXRhYmxlLiBUaGUgbWV0aG9kJ3Mgc2lnbmF0dXJlIG11c3QgYmUgYGZ1bmN0aW9uXHJcbiAgICAgKEJhY2tncmlkLkNvbHVtbiwgQmFja2JvbmUuTW9kZWwpOiBib29sZWFuYC5cclxuXHJcbiAgICAgQGNmZyB7Ym9vbGVhbnxzdHJpbmd8ZnVuY3Rpb24oKTogYm9vbGVhbn0gW2RlZmF1bHRzLnJlbmRlcmFibGU9dHJ1ZV1cclxuICAgICBXaGV0aGVyIHRoaXMgY29sdW1uIGlzIHJlbmRlcmFibGUuIElmIHRoZSB2YWx1ZSBpcyBhIHN0cmluZywgYSBtZXRob2Qgd2lsbFxyXG4gICAgIHRoZSBzYW1lIG5hbWUgd2lsbCBiZSBsb29rZWQgdXAgZnJvbSB0aGUgY29sdW1uIGluc3RhbmNlIHRvIGRldGVybWluZVxyXG4gICAgIHdoZXRoZXIgdGhlIGNvbHVtbiBzaG91bGQgYmUgcmVuZGVyYWJsZS4gVGhlIG1ldGhvZCdzIHNpZ25hdHVyZSBtdXN0IGJlXHJcbiAgICAgYGZ1bmN0aW9uIChCYWNrcmlkLkNvbHVtbiwgQmFja2JvbmUuTW9kZWwpOiBib29sZWFuYC5cclxuXHJcbiAgICAgQGNmZyB7QmFja2dyaWQuQ2VsbEZvcm1hdHRlciB8IE9iamVjdCB8IHN0cmluZ30gW2RlZmF1bHRzLmZvcm1hdHRlcl0gVGhlXHJcbiAgICAgZm9ybWF0dGVyIHRvIHVzZSB0byBjb252ZXJ0IGJldHdlZW4gcmF3IG1vZGVsIHZhbHVlcyBhbmQgdXNlciBpbnB1dC5cclxuXHJcbiAgICAgQGNmZyB7XCJ0b2dnbGVcInxcImN5Y2xlXCJ9IFtkZWZhdWx0cy5zb3J0VHlwZT1cImN5Y2xlXCJdIFdoZXRoZXIgc29ydGluZyB3aWxsXHJcbiAgICAgdG9nZ2xlIGJldHdlZW4gYXNjZW5kaW5nIGFuZCBkZXNjZW5kaW5nIG9yZGVyLCBvciBjeWNsZSBiZXR3ZWVuIGluc2VydGlvblxyXG4gICAgIG9yZGVyLCBhc2NlbmRpbmcgYW5kIGRlc2NlbmRpbmcgb3JkZXIuXHJcblxyXG4gICAgIEBjZmcgeyhmdW5jdGlvbihCYWNrYm9uZS5Nb2RlbCwgc3RyaW5nKTogKikgfCBzdHJpbmd9IFtkZWZhdWx0cy5zb3J0VmFsdWVdXHJcbiAgICAgVGhlIGZ1bmN0aW9uIHRvIHVzZSB0byBleHRyYWN0IGEgdmFsdWUgZnJvbSB0aGUgbW9kZWwgZm9yIGNvbXBhcmlzb24gZHVyaW5nXHJcbiAgICAgc29ydGluZy4gSWYgdGhpcyB2YWx1ZSBpcyBhIHN0cmluZywgYSBtZXRob2Qgd2l0aCB0aGUgc2FtZSBuYW1lIHdpbGwgYmVcclxuICAgICBsb29rZWQgdXAgZnJvbSB0aGUgY29sdW1uIGluc3RhbmNlLlxyXG5cclxuICAgICBAY2ZnIHtcImFzY2VuZGluZ1wifFwiZGVzY2VuZGluZ1wifG51bGx9IFtkZWZhdWx0cy5kaXJlY3Rpb249bnVsbF0gVGhlIGluaXRpYWxcclxuICAgICBzb3J0aW5nIGRpcmVjdGlvbiBmb3IgdGhpcyBjb2x1bW4uIFRoZSBkZWZhdWx0IGlzIG9yZGVyZWQgYnlcclxuICAgICBCYWNrYm9uZS5Nb2RlbC5jaWQsIHdoaWNoIHVzdWFsbHkgbWVhbnMgdGhlIGNvbGxlY3Rpb24gaXMgb3JkZXJlZCBieVxyXG4gICAgIGluc2VydGlvbiBvcmRlci5cclxuICAqL1xyXG4gIGRlZmF1bHRzOiB7XHJcbiAgICBuYW1lOiB1bmRlZmluZWQsXHJcbiAgICBsYWJlbDogdW5kZWZpbmVkLFxyXG4gICAgc29ydGFibGU6IHRydWUsXHJcbiAgICBlZGl0YWJsZTogdHJ1ZSxcclxuICAgIHJlbmRlcmFibGU6IHRydWUsXHJcbiAgICBmb3JtYXR0ZXI6IHVuZGVmaW5lZCxcclxuICAgIHNvcnRUeXBlOiBcImN5Y2xlXCIsXHJcbiAgICBzb3J0VmFsdWU6IHVuZGVmaW5lZCxcclxuICAgIGRpcmVjdGlvbjogbnVsbCxcclxuICAgIGNlbGw6IHVuZGVmaW5lZCxcclxuICAgIGhlYWRlckNlbGw6IHVuZGVmaW5lZFxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIEluaXRpYWxpemVzIHRoaXMgQ29sdW1uIGluc3RhbmNlLlxyXG5cclxuICAgICBAcGFyYW0ge09iamVjdH0gYXR0cnNcclxuXHJcbiAgICAgQHBhcmFtIHtzdHJpbmd9IGF0dHJzLm5hbWUgVGhlIG1vZGVsIGF0dHJpYnV0ZSB0aGlzIGNvbHVtbiBpcyByZXNwb25zaWJsZVxyXG4gICAgIGZvci5cclxuXHJcbiAgICAgQHBhcmFtIHtzdHJpbmd8QmFja2dyaWQuQ2VsbH0gYXR0cnMuY2VsbCBUaGUgY2VsbCB0eXBlIHRvIHVzZSB0byByZW5kZXJcclxuICAgICB0aGlzIGNvbHVtbi5cclxuXHJcbiAgICAgQHBhcmFtIHtzdHJpbmd9IFthdHRycy5sYWJlbF1cclxuXHJcbiAgICAgQHBhcmFtIHtzdHJpbmd8QmFja2dyaWQuSGVhZGVyQ2VsbH0gW2F0dHJzLmhlYWRlckNlbGxdXHJcblxyXG4gICAgIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd8ZnVuY3Rpb24oKTogYm9vbGVhbn0gW2F0dHJzLnNvcnRhYmxlPXRydWVdXHJcblxyXG4gICAgIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd8ZnVuY3Rpb24oKTogYm9vbGVhbn0gW2F0dHJzLmVkaXRhYmxlPXRydWVdXHJcblxyXG4gICAgIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd8ZnVuY3Rpb24oKTogYm9vbGVhbn0gW2F0dHJzLnJlbmRlcmFibGU9dHJ1ZV1cclxuXHJcbiAgICAgQHBhcmFtIHtCYWNrZ3JpZC5DZWxsRm9ybWF0dGVyIHwgT2JqZWN0IHwgc3RyaW5nfSBbYXR0cnMuZm9ybWF0dGVyXVxyXG5cclxuICAgICBAcGFyYW0ge1widG9nZ2xlXCJ8XCJjeWNsZVwifSAgW2F0dHJzLnNvcnRUeXBlPVwiY3ljbGVcIl1cclxuXHJcbiAgICAgQHBhcmFtIHsoZnVuY3Rpb24oQmFja2JvbmUuTW9kZWwsIHN0cmluZyk6ICopIHwgc3RyaW5nfSBbYXR0cnMuc29ydFZhbHVlXVxyXG5cclxuICAgICBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGF0dHJzLmNlbGwgb3IgYXR0cnMub3B0aW9ucyBhcmUgbm90IHN1cHBsaWVkLlxyXG5cclxuICAgICBAdGhyb3dzIHtSZWZlcmVuY2VFcnJvcn0gSWYgZm9ybWF0dGVyIGlzIGEgc3RyaW5nIGJ1dCBhIGZvcm1hdHRlciBjbGFzcyBvZlxyXG4gICAgIHNhaWQgbmFtZSBjYW5ub3QgYmUgZm91bmQgaW4gdGhlIEJhY2tncmlkIG1vZHVsZS5cclxuXHJcbiAgICAgU2VlOlxyXG5cclxuICAgICAtIEJhY2tncmlkLkNvbHVtbi5kZWZhdWx0c1xyXG4gICAgIC0gQmFja2dyaWQuQ2VsbFxyXG4gICAgIC0gQmFja2dyaWQuQ2VsbEZvcm1hdHRlclxyXG4gICAqL1xyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghdGhpcy5oYXMoXCJsYWJlbFwiKSkge1xyXG4gICAgICB0aGlzLnNldCh7IGxhYmVsOiB0aGlzLmdldChcIm5hbWVcIikgfSwgeyBzaWxlbnQ6IHRydWUgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGhlYWRlckNlbGwgPSBCYWNrZ3JpZC5yZXNvbHZlTmFtZVRvQ2xhc3ModGhpcy5nZXQoXCJoZWFkZXJDZWxsXCIpLCBcIkhlYWRlckNlbGxcIik7XHJcblxyXG4gICAgdmFyIGNlbGwgPSBCYWNrZ3JpZC5yZXNvbHZlTmFtZVRvQ2xhc3ModGhpcy5nZXQoXCJjZWxsXCIpLCBcIkNlbGxcIik7XHJcblxyXG4gICAgdGhpcy5zZXQoe2NlbGw6IGNlbGwsIGhlYWRlckNlbGw6IGhlYWRlckNlbGx9LCB7IHNpbGVudDogdHJ1ZSB9KTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBSZXR1cm5zIGFuIGFwcHJvcHJpYXRlIHZhbHVlIGV4dHJhY3Rpb24gZnVuY3Rpb24gZnJvbSBhIG1vZGVsIGZvciBzb3J0aW5nLlxyXG5cclxuICAgICBJZiB0aGUgY29sdW1uIG1vZGVsIGNvbnRhaW5zIGFuIGF0dHJpYnV0ZSBgc29ydFZhbHVlYCwgaWYgaXQgaXMgYSBzdHJpbmcsIGFcclxuICAgICBtZXRob2QgZnJvbSB0aGUgY29sdW1uIGluc3RhbmNlIGlkZW50aWZpZmllZCBieSB0aGUgYHNvcnRWYWx1ZWAgc3RyaW5nIGlzXHJcbiAgICAgcmV0dXJuZWQuIElmIGl0IGlzIGEgZnVuY3Rpb24sIGl0IGl0IHJldHVybmVkIGFzIGlzLiBJZiBgc29ydFZhbHVlYCBpc24ndFxyXG4gICAgIGZvdW5kIGZyb20gdGhlIGNvbHVtbiBtb2RlbCdzIGF0dHJpYnV0ZXMsIGEgZGVmYXVsdCB2YWx1ZSBleHRyYWN0aW9uXHJcbiAgICAgZnVuY3Rpb24gaXMgcmV0dXJuZWQgd2hpY2ggd2lsbCBjb21wYXJlIGFjY29yZGluZyB0byB0aGUgbmF0dXJhbCBvcmRlciBvZlxyXG4gICAgIHRoZSB2YWx1ZSdzIHR5cGUuXHJcblxyXG4gICAgIEByZXR1cm4ge2Z1bmN0aW9uKEJhY2tib25lLk1vZGVsLCBzdHJpbmcpOiAqfVxyXG4gICAqL1xyXG4gIHNvcnRWYWx1ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHNvcnRWYWx1ZSA9IHRoaXMuZ2V0KFwic29ydFZhbHVlXCIpO1xyXG4gICAgaWYgKF8uaXNTdHJpbmcoc29ydFZhbHVlKSkgcmV0dXJuIHRoaXNbc29ydFZhbHVlXTtcclxuICAgIGVsc2UgaWYgKF8uaXNGdW5jdGlvbihzb3J0VmFsdWUpKSByZXR1cm4gc29ydFZhbHVlO1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAobW9kZWwsIGNvbE5hbWUpIHtcclxuICAgICAgcmV0dXJuIG1vZGVsLmdldChjb2xOYW1lKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICBAbWVtYmVyIEJhY2tncmlkLkNvbHVtblxyXG4gICAgIEBwcm90ZWN0ZWRcclxuICAgICBAbWV0aG9kIHNvcnRhYmxlXHJcbiAgICAgQHJldHVybiB7ZnVuY3Rpb24oQmFja2dyaWQuQ29sdW1uLCBCYWNrYm9uZS5Nb2RlbCk6IGJvb2xlYW4gfCBib29sZWFufVxyXG4gICovXHJcblxyXG4gIC8qKlxyXG4gICAgIEBtZW1iZXIgQmFja2dyaWQuQ29sdW1uXHJcbiAgICAgQHByb3RlY3RlZFxyXG4gICAgIEBtZXRob2QgZWRpdGFibGVcclxuICAgICBAcmV0dXJuIHtmdW5jdGlvbihCYWNrZ3JpZC5Db2x1bW4sIEJhY2tib25lLk1vZGVsKTogYm9vbGVhbiB8IGJvb2xlYW59XHJcbiAgKi9cclxuXHJcbiAgLyoqXHJcbiAgICAgQG1lbWJlciBCYWNrZ3JpZC5Db2x1bW5cclxuICAgICBAcHJvdGVjdGVkXHJcbiAgICAgQG1ldGhvZCByZW5kZXJhYmxlXHJcbiAgICAgQHJldHVybiB7ZnVuY3Rpb24oQmFja2dyaWQuQ29sdW1uLCBCYWNrYm9uZS5Nb2RlbCk6IGJvb2xlYW4gfCBib29sZWFufVxyXG4gICovXHJcbn0pO1xyXG5cclxuXy5lYWNoKFtcInNvcnRhYmxlXCIsIFwicmVuZGVyYWJsZVwiLCBcImVkaXRhYmxlXCJdLCBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgQ29sdW1uLnByb3RvdHlwZVtrZXldID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoa2V5KTtcclxuICAgIGlmIChfLmlzU3RyaW5nKHZhbHVlKSkgcmV0dXJuIHRoaXNbdmFsdWVdO1xyXG4gICAgZWxzZSBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xyXG5cclxuICAgIHJldHVybiAhIXZhbHVlO1xyXG4gIH07XHJcbn0pO1xyXG5cclxuLyoqXHJcbiAgIEEgQmFja2JvbmUgY29sbGVjdGlvbiBvZiBDb2x1bW4gaW5zdGFuY2VzLlxyXG5cclxuICAgQGNsYXNzIEJhY2tncmlkLkNvbHVtbnNcclxuICAgQGV4dGVuZHMgQmFja2JvbmUuQ29sbGVjdGlvblxyXG4gKi9cclxudmFyIENvbHVtbnMgPSBCYWNrZ3JpZC5Db2x1bW5zID0gQmFja2JvbmUuQ29sbGVjdGlvbi5leHRlbmQoe1xyXG5cclxuICAvKipcclxuICAgICBAcHJvcGVydHkge0JhY2tncmlkLkNvbHVtbn0gbW9kZWxcclxuICAgKi9cclxuICBtb2RlbDogQ29sdW1uXHJcbn0pO1xyXG5cclxuLypcclxuICBiYWNrZ3JpZFxyXG4gIGh0dHA6Ly9naXRodWIuY29tL3d5dWVuaG8vYmFja2dyaWRcclxuXHJcbiAgQ29weXJpZ2h0IChjKSAyMDEzIEppbW15IFl1ZW4gSG8gV29uZyBhbmQgY29udHJpYnV0b3JzXHJcbiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxyXG4qL1xyXG5cclxuLyoqXHJcbiAgIFJvdyBpcyBhIHNpbXBsZSBjb250YWluZXIgdmlldyB0aGF0IHRha2VzIGEgbW9kZWwgaW5zdGFuY2UgYW5kIGEgbGlzdCBvZlxyXG4gICBjb2x1bW4gbWV0YWRhdGEgZGVzY3JpYmluZyBob3cgZWFjaCBvZiB0aGUgbW9kZWwncyBhdHRyaWJ1dGUgaXMgdG8gYmVcclxuICAgcmVuZGVyZWQsIGFuZCBhcHBseSB0aGUgYXBwcm9wcmlhdGUgY2VsbCB0byBlYWNoIGF0dHJpYnV0ZS5cclxuXHJcbiAgIEBjbGFzcyBCYWNrZ3JpZC5Sb3dcclxuICAgQGV4dGVuZHMgQmFja2JvbmUuVmlld1xyXG4qL1xyXG52YXIgUm93ID0gQmFja2dyaWQuUm93ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgdGFnTmFtZTogXCJ0clwiLFxyXG5cclxuICAvKipcclxuICAgICBJbml0aWFsaXplcyBhIHJvdyB2aWV3IGluc3RhbmNlLlxyXG5cclxuICAgICBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgIEBwYXJhbSB7QmFja2JvbmUuQ29sbGVjdGlvbi48QmFja2dyaWQuQ29sdW1uPnxBcnJheS48QmFja2dyaWQuQ29sdW1uPnxBcnJheS48T2JqZWN0Pn0gb3B0aW9ucy5jb2x1bW5zIENvbHVtbiBtZXRhZGF0YS5cclxuICAgICBAcGFyYW0ge0JhY2tib25lLk1vZGVsfSBvcHRpb25zLm1vZGVsIFRoZSBtb2RlbCBpbnN0YW5jZSB0byByZW5kZXIuXHJcblxyXG4gICAgIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgb3B0aW9ucy5jb2x1bW5zIG9yIG9wdGlvbnMubW9kZWwgaXMgdW5kZWZpbmVkLlxyXG4gICovXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHJcbiAgICB2YXIgY29sdW1ucyA9IHRoaXMuY29sdW1ucyA9IG9wdGlvbnMuY29sdW1ucztcclxuICAgIGlmICghKGNvbHVtbnMgaW5zdGFuY2VvZiBCYWNrYm9uZS5Db2xsZWN0aW9uKSkge1xyXG4gICAgICBjb2x1bW5zID0gdGhpcy5jb2x1bW5zID0gbmV3IENvbHVtbnMoY29sdW1ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNlbGxzID0gdGhpcy5jZWxscyA9IFtdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNlbGxzLnB1c2godGhpcy5tYWtlQ2VsbChjb2x1bW5zLmF0KGkpLCBvcHRpb25zKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5saXN0ZW5Ubyhjb2x1bW5zLCBcImFkZFwiLCBmdW5jdGlvbiAoY29sdW1uLCBjb2x1bW5zKSB7XHJcbiAgICAgIHZhciBpID0gY29sdW1ucy5pbmRleE9mKGNvbHVtbik7XHJcbiAgICAgIHZhciBjZWxsID0gdGhpcy5tYWtlQ2VsbChjb2x1bW4sIG9wdGlvbnMpO1xyXG4gICAgICBjZWxscy5zcGxpY2UoaSwgMCwgY2VsbCk7XHJcblxyXG4gICAgICB2YXIgJGVsID0gdGhpcy4kZWw7XHJcbiAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgJGVsLnByZXBlbmQoY2VsbC5yZW5kZXIoKS4kZWwpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGkgPT09IGNvbHVtbnMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICRlbC5hcHBlbmQoY2VsbC5yZW5kZXIoKS4kZWwpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgICRlbC5jaGlsZHJlbigpLmVxKGkpLmJlZm9yZShjZWxsLnJlbmRlcigpLiRlbCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMubGlzdGVuVG8oY29sdW1ucywgXCJyZW1vdmVcIiwgZnVuY3Rpb24gKGNvbHVtbiwgY29sdW1ucywgb3B0cykge1xyXG4gICAgICBjZWxsc1tvcHRzLmluZGV4XS5yZW1vdmUoKTtcclxuICAgICAgY2VsbHMuc3BsaWNlKG9wdHMuaW5kZXgsIDEpO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgRmFjdG9yeSBtZXRob2QgZm9yIG1ha2luZyBhIGNlbGwuIFVzZWQgYnkgI2luaXRpYWxpemUgaW50ZXJuYWxseS4gT3ZlcnJpZGVcclxuICAgICB0aGlzIHRvIHByb3ZpZGUgYW4gYXBwcm9wcmlhdGUgY2VsbCBpbnN0YW5jZSBmb3IgYSBjdXN0b20gUm93IHN1YmNsYXNzLlxyXG5cclxuICAgICBAcHJvdGVjdGVkXHJcblxyXG4gICAgIEBwYXJhbSB7QmFja2dyaWQuQ29sdW1ufSBjb2x1bW5cclxuICAgICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gI2luaXRpYWxpemUuXHJcblxyXG4gICAgIEByZXR1cm4ge0JhY2tncmlkLkNlbGx9XHJcbiAgKi9cclxuICBtYWtlQ2VsbDogZnVuY3Rpb24gKGNvbHVtbikge1xyXG4gICAgcmV0dXJuIG5ldyAoY29sdW1uLmdldChcImNlbGxcIikpKHtcclxuICAgICAgY29sdW1uOiBjb2x1bW4sXHJcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsXHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBSZW5kZXJzIGEgcm93IG9mIGNlbGxzIGZvciB0aGlzIHJvdydzIG1vZGVsLlxyXG4gICovXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLiRlbC5lbXB0eSgpO1xyXG5cclxuICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jZWxscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNlbGxzW2ldLnJlbmRlcigpLmVsKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmVsLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcclxuXHJcbiAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgQ2xlYW4gdXAgdGhpcyByb3cgYW5kIGl0cyBjZWxscy5cclxuXHJcbiAgICAgQGNoYWluYWJsZVxyXG4gICovXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2VsbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzW2ldO1xyXG4gICAgICBjZWxsLnJlbW92ZS5hcHBseShjZWxsLCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLyoqXHJcbiAgIEVtcHR5Um93IGlzIGEgc2ltcGxlIGNvbnRhaW5lciB2aWV3IHRoYXQgdGFrZXMgYSBsaXN0IG9mIGNvbHVtbiBhbmQgcmVuZGVyIGFcclxuICAgcm93IHdpdGggYSBzaW5nbGUgY29sdW1uLlxyXG5cclxuICAgQGNsYXNzIEJhY2tncmlkLkVtcHR5Um93XHJcbiAgIEBleHRlbmRzIEJhY2tib25lLlZpZXdcclxuKi9cclxudmFyIEVtcHR5Um93ID0gQmFja2dyaWQuRW1wdHlSb3cgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICB0YWdOYW1lOiBcInRyXCIsXHJcblxyXG4gIC8qKiBAcHJvcGVydHkge3N0cmluZ3xmdW5jdGlvbigpOiBzdHJpbmd9ICovXHJcbiAgZW1wdHlUZXh0OiBudWxsLFxyXG5cclxuICAvKipcclxuICAgICBJbml0aWFsaXplci5cclxuXHJcbiAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbigpOiBzdHJpbmd9IG9wdGlvbnMuZW1wdHlUZXh0XHJcbiAgICAgQHBhcmFtIHtCYWNrYm9uZS5Db2xsZWN0aW9uLjxCYWNrZ3JpZC5Db2x1bW4+fEFycmF5LjxCYWNrZ3JpZC5Db2x1bW4+fEFycmF5LjxPYmplY3Q+fSBvcHRpb25zLmNvbHVtbnMgQ29sdW1uIG1ldGFkYXRhLlxyXG4gICAqL1xyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB0aGlzLmVtcHR5VGV4dCA9IG9wdGlvbnMuZW1wdHlUZXh0O1xyXG4gICAgdGhpcy5jb2x1bW5zID0gIG9wdGlvbnMuY29sdW1ucztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBSZW5kZXJzIGFuIGVtcHR5IHJvdy5cclxuICAqL1xyXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy4kZWwuZW1wdHkoKTtcclxuXHJcbiAgICB2YXIgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XHJcbiAgICB0ZC5zZXRBdHRyaWJ1dGUoXCJjb2xzcGFuXCIsIHRoaXMuY29sdW1ucy5sZW5ndGgpO1xyXG4gICAgdGQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXy5yZXN1bHQodGhpcywgXCJlbXB0eVRleHRcIikpKTtcclxuXHJcbiAgICB0aGlzLmVsLmNsYXNzTmFtZSA9IFwiZW1wdHlcIjtcclxuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQodGQpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxufSk7XHJcblxyXG4vKlxyXG4gIGJhY2tncmlkXHJcbiAgaHR0cDovL2dpdGh1Yi5jb20vd3l1ZW5oby9iYWNrZ3JpZFxyXG5cclxuICBDb3B5cmlnaHQgKGMpIDIwMTMgSmltbXkgWXVlbiBIbyBXb25nIGFuZCBjb250cmlidXRvcnNcclxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiovXHJcblxyXG4vKipcclxuICAgSGVhZGVyQ2VsbCBpcyBhIHNwZWNpYWwgY2VsbCBjbGFzcyB0aGF0IHJlbmRlcnMgYSBjb2x1bW4gaGVhZGVyIGNlbGwuIElmIHRoZVxyXG4gICBjb2x1bW4gaXMgc29ydGFibGUsIGEgc29ydGVyIGlzIGFsc28gcmVuZGVyZWQgYW5kIHdpbGwgdHJpZ2dlciBhIHRhYmxlXHJcbiAgIHJlZnJlc2ggYWZ0ZXIgc29ydGluZy5cclxuXHJcbiAgIEBjbGFzcyBCYWNrZ3JpZC5IZWFkZXJDZWxsXHJcbiAgIEBleHRlbmRzIEJhY2tib25lLlZpZXdcclxuICovXHJcbnZhciBIZWFkZXJDZWxsID0gQmFja2dyaWQuSGVhZGVyQ2VsbCA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuXHJcbiAgLyoqIEBwcm9wZXJ0eSAqL1xyXG4gIHRhZ05hbWU6IFwidGhcIixcclxuXHJcbiAgLyoqIEBwcm9wZXJ0eSAqL1xyXG4gIGV2ZW50czoge1xyXG4gICAgXCJjbGljayBhXCI6IFwib25DbGlja1wiXHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgSW5pdGlhbGl6ZXIuXHJcblxyXG4gICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgQHBhcmFtIHtCYWNrZ3JpZC5Db2x1bW58T2JqZWN0fSBvcHRpb25zLmNvbHVtblxyXG5cclxuICAgICBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIG9wdGlvbnMuY29sdW1uIG9yIG9wdGlvbnMuY29sbGVjdGlvbiBpcyB1bmRlZmluZWQuXHJcbiAgICovXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuY29sdW1uID0gb3B0aW9ucy5jb2x1bW47XHJcbiAgICBpZiAoISh0aGlzLmNvbHVtbiBpbnN0YW5jZW9mIENvbHVtbikpIHtcclxuICAgICAgdGhpcy5jb2x1bW4gPSBuZXcgQ29sdW1uKHRoaXMuY29sdW1uKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgY29sdW1uID0gdGhpcy5jb2x1bW4sIGNvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb24sICRlbCA9IHRoaXMuJGVsO1xyXG5cclxuICAgIHRoaXMubGlzdGVuVG8oY29sdW1uLCBcImNoYW5nZTplZGl0YWJsZSBjaGFuZ2U6c29ydGFibGUgY2hhbmdlOnJlbmRlcmFibGVcIixcclxuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNvbHVtbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkID0gY29sdW1uLmNoYW5nZWRBdHRyaWJ1dGVzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGNoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJGVsLnRvZ2dsZUNsYXNzKGtleSwgY2hhbmdlZFtrZXldKTtcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgdGhpcy5saXN0ZW5Ubyhjb2x1bW4sIFwiY2hhbmdlOmRpcmVjdGlvblwiLCB0aGlzLnNldENlbGxEaXJlY3Rpb24pO1xyXG4gICAgdGhpcy5saXN0ZW5Ubyhjb2x1bW4sIFwiY2hhbmdlOm5hbWUgY2hhbmdlOmxhYmVsXCIsIHRoaXMucmVuZGVyKTtcclxuXHJcbiAgICBpZiAoQmFja2dyaWQuY2FsbEJ5TmVlZChjb2x1bW4uZWRpdGFibGUoKSwgY29sdW1uLCBjb2xsZWN0aW9uKSkgJGVsLmFkZENsYXNzKFwiZWRpdGFibGVcIik7XHJcbiAgICBpZiAoQmFja2dyaWQuY2FsbEJ5TmVlZChjb2x1bW4uc29ydGFibGUoKSwgY29sdW1uLCBjb2xsZWN0aW9uKSkgJGVsLmFkZENsYXNzKFwic29ydGFibGVcIik7XHJcbiAgICBpZiAoQmFja2dyaWQuY2FsbEJ5TmVlZChjb2x1bW4ucmVuZGVyYWJsZSgpLCBjb2x1bW4sIGNvbGxlY3Rpb24pKSAkZWwuYWRkQ2xhc3MoXCJyZW5kZXJhYmxlXCIpO1xyXG5cclxuICAgIHRoaXMubGlzdGVuVG8oY29sbGVjdGlvbi5mdWxsQ29sbGVjdGlvbiB8fCBjb2xsZWN0aW9uLCBcInNvcnRcIiwgdGhpcy5yZW1vdmVDZWxsRGlyZWN0aW9uKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBFdmVudCBoYW5kbGVyIGZvciB0aGUgY29sbGVjdGlvbidzIGBzb3J0YCBldmVudC4gUmVtb3ZlcyBhbGwgdGhlIENTU1xyXG4gICAgIGRpcmVjdGlvbiBjbGFzc2VzLlxyXG4gICAqL1xyXG4gIHJlbW92ZUNlbGxEaXJlY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKFwiYXNjZW5kaW5nXCIpLnJlbW92ZUNsYXNzKFwiZGVzY2VuZGluZ1wiKTtcclxuICAgIHRoaXMuY29sdW1uLnNldChcImRpcmVjdGlvblwiLCBudWxsKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBFdmVudCBoYW5kbGVyIGZvciB0aGUgY29sdW1uJ3MgYGNoYW5nZTpkaXJlY3Rpb25gIGV2ZW50LiBJZiB0aGlzXHJcbiAgICAgSGVhZGVyQ2VsbCdzIGNvbHVtbiBpcyBiZWluZyBzb3J0ZWQgb24sIGl0IGFwcGxpZXMgdGhlIGRpcmVjdGlvbiBnaXZlbiBhcyBhXHJcbiAgICAgQ1NTIGNsYXNzIHRvIHRoZSBoZWFkZXIgY2VsbC4gUmVtb3ZlcyBhbGwgdGhlIENTUyBkaXJlY3Rpb24gY2xhc3Nlc1xyXG4gICAgIG90aGVyd2lzZS5cclxuICAgKi9cclxuICBzZXRDZWxsRGlyZWN0aW9uOiBmdW5jdGlvbiAoY29sdW1uLCBkaXJlY3Rpb24pIHtcclxuICAgIHRoaXMuJGVsLnJlbW92ZUNsYXNzKFwiYXNjZW5kaW5nXCIpLnJlbW92ZUNsYXNzKFwiZGVzY2VuZGluZ1wiKTtcclxuICAgIGlmIChjb2x1bW4uY2lkID09IHRoaXMuY29sdW1uLmNpZCkgdGhpcy4kZWwuYWRkQ2xhc3MoZGlyZWN0aW9uKTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBFdmVudCBoYW5kbGVyIGZvciB0aGUgYGNsaWNrYCBldmVudCBvbiB0aGUgY2VsbCdzIGFuY2hvci4gSWYgdGhlIGNvbHVtbiBpc1xyXG4gICAgIHNvcnRhYmxlLCBjbGlja2luZyBvbiB0aGUgYW5jaG9yIHdpbGwgY3ljbGUgdGhyb3VnaCAzIHNvcnRpbmcgb3JkZXJpbmdzIC1cclxuICAgICBgYXNjZW5kaW5nYCwgYGRlc2NlbmRpbmdgLCBhbmQgZGVmYXVsdC5cclxuICAgKi9cclxuICBvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIHZhciBjb2x1bW4gPSB0aGlzLmNvbHVtbjtcclxuICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uO1xyXG4gICAgdmFyIGV2ZW50ID0gXCJiYWNrZ3JpZDpzb3J0XCI7XHJcblxyXG4gICAgZnVuY3Rpb24gY3ljbGVTb3J0KGhlYWRlciwgY29sKSB7XHJcbiAgICAgIGlmIChjb2x1bW4uZ2V0KFwiZGlyZWN0aW9uXCIpID09PSBcImFzY2VuZGluZ1wiKSBjb2xsZWN0aW9uLnRyaWdnZXIoZXZlbnQsIGNvbCwgXCJkZXNjZW5kaW5nXCIpO1xyXG4gICAgICBlbHNlIGlmIChjb2x1bW4uZ2V0KFwiZGlyZWN0aW9uXCIpID09PSBcImRlc2NlbmRpbmdcIikgY29sbGVjdGlvbi50cmlnZ2VyKGV2ZW50LCBjb2wsIG51bGwpO1xyXG4gICAgICBlbHNlIGNvbGxlY3Rpb24udHJpZ2dlcihldmVudCwgY29sLCBcImFzY2VuZGluZ1wiKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b2dnbGVTb3J0KGhlYWRlciwgY29sKSB7XHJcbiAgICAgIGlmIChjb2x1bW4uZ2V0KFwiZGlyZWN0aW9uXCIpID09PSBcImFzY2VuZGluZ1wiKSBjb2xsZWN0aW9uLnRyaWdnZXIoZXZlbnQsIGNvbCwgXCJkZXNjZW5kaW5nXCIpO1xyXG4gICAgICBlbHNlIGNvbGxlY3Rpb24udHJpZ2dlcihldmVudCwgY29sLCBcImFzY2VuZGluZ1wiKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc29ydGFibGUgPSBCYWNrZ3JpZC5jYWxsQnlOZWVkKGNvbHVtbi5zb3J0YWJsZSgpLCBjb2x1bW4sIHRoaXMuY29sbGVjdGlvbik7XHJcbiAgICBpZiAoc29ydGFibGUpIHtcclxuICAgICAgdmFyIHNvcnRUeXBlID0gY29sdW1uLmdldChcInNvcnRUeXBlXCIpO1xyXG4gICAgICBpZiAoc29ydFR5cGUgPT09IFwidG9nZ2xlXCIpIHRvZ2dsZVNvcnQodGhpcywgY29sdW1uKTtcclxuICAgICAgZWxzZSBjeWNsZVNvcnQodGhpcywgY29sdW1uKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBSZW5kZXJzIGEgaGVhZGVyIGNlbGwgd2l0aCBhIHNvcnRlciwgYSBsYWJlbCwgYW5kIGEgY2xhc3MgbmFtZSBmb3IgdGhpc1xyXG4gICAgIGNvbHVtbi5cclxuICAgKi9cclxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuJGVsLmVtcHR5KCk7XHJcbiAgICB2YXIgY29sdW1uID0gdGhpcy5jb2x1bW47XHJcbiAgICB2YXIgc29ydGFibGUgPSBCYWNrZ3JpZC5jYWxsQnlOZWVkKGNvbHVtbi5zb3J0YWJsZSgpLCBjb2x1bW4sIHRoaXMuY29sbGVjdGlvbik7XHJcbiAgICB2YXIgbGFiZWw7XHJcbiAgICBpZihzb3J0YWJsZSl7XHJcbiAgICAgIGxhYmVsID0gJChcIjxhPlwiKS50ZXh0KGNvbHVtbi5nZXQoXCJsYWJlbFwiKSkuYXBwZW5kKFwiPGIgY2xhc3M9J3NvcnQtY2FyZXQnPjwvYj5cIik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNvbHVtbi5nZXQoXCJsYWJlbFwiKSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy4kZWwuYXBwZW5kKGxhYmVsKTtcclxuICAgIHRoaXMuJGVsLmFkZENsYXNzKGNvbHVtbi5nZXQoXCJuYW1lXCIpKTtcclxuICAgIHRoaXMuJGVsLmFkZENsYXNzKGNvbHVtbi5nZXQoXCJkaXJlY3Rpb25cIikpO1xyXG4gICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICAgSGVhZGVyUm93IGlzIGEgY29udHJvbGxlciBmb3IgYSByb3cgb2YgaGVhZGVyIGNlbGxzLlxyXG5cclxuICAgQGNsYXNzIEJhY2tncmlkLkhlYWRlclJvd1xyXG4gICBAZXh0ZW5kcyBCYWNrZ3JpZC5Sb3dcclxuICovXHJcbnZhciBIZWFkZXJSb3cgPSBCYWNrZ3JpZC5IZWFkZXJSb3cgPSBCYWNrZ3JpZC5Sb3cuZXh0ZW5kKHtcclxuXHJcbiAgcmVxdWlyZWRPcHRpb25zOiBbXCJjb2x1bW5zXCIsIFwiY29sbGVjdGlvblwiXSxcclxuXHJcbiAgLyoqXHJcbiAgICAgSW5pdGlhbGl6ZXIuXHJcblxyXG4gICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgQHBhcmFtIHtCYWNrYm9uZS5Db2xsZWN0aW9uLjxCYWNrZ3JpZC5Db2x1bW4+fEFycmF5LjxCYWNrZ3JpZC5Db2x1bW4+fEFycmF5LjxPYmplY3Q+fSBvcHRpb25zLmNvbHVtbnNcclxuICAgICBAcGFyYW0ge0JhY2tncmlkLkhlYWRlckNlbGx9IFtvcHRpb25zLmhlYWRlckNlbGxdIEN1c3RvbWl6ZWQgZGVmYXVsdFxyXG4gICAgIEhlYWRlckNlbGwgZm9yIGFsbCB0aGUgY29sdW1ucy4gU3VwcGx5IGEgSGVhZGVyQ2VsbCBjbGFzcyBvciBpbnN0YW5jZSB0byBhXHJcbiAgICAgdGhlIGBoZWFkZXJDZWxsYCBrZXkgaW4gYSBjb2x1bW4gZGVmaW5pdGlvbiBmb3IgY29sdW1uLXNwZWNpZmljIGhlYWRlclxyXG4gICAgIHJlbmRlcmluZy5cclxuXHJcbiAgICAgQHRocm93cyB7VHlwZUVycm9yfSBJZiBvcHRpb25zLmNvbHVtbnMgb3Igb3B0aW9ucy5jb2xsZWN0aW9uIGlzIHVuZGVmaW5lZC5cclxuICAgKi9cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBCYWNrZ3JpZC5Sb3cucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9LFxyXG5cclxuICBtYWtlQ2VsbDogZnVuY3Rpb24gKGNvbHVtbiwgb3B0aW9ucykge1xyXG4gICAgdmFyIGhlYWRlckNlbGwgPSBjb2x1bW4uZ2V0KFwiaGVhZGVyQ2VsbFwiKSB8fCBvcHRpb25zLmhlYWRlckNlbGwgfHwgSGVhZGVyQ2VsbDtcclxuICAgIGhlYWRlckNlbGwgPSBuZXcgaGVhZGVyQ2VsbCh7XHJcbiAgICAgIGNvbHVtbjogY29sdW1uLFxyXG4gICAgICBjb2xsZWN0aW9uOiB0aGlzLmNvbGxlY3Rpb25cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGhlYWRlckNlbGw7XHJcbiAgfVxyXG5cclxufSk7XHJcblxyXG4vKipcclxuICAgSGVhZGVyIGlzIGEgc3BlY2lhbCBzdHJ1Y3R1cmFsIHZpZXcgY2xhc3MgdGhhdCByZW5kZXJzIGEgdGFibGUgaGVhZCB3aXRoIGFcclxuICAgc2luZ2xlIHJvdyBvZiBoZWFkZXIgY2VsbHMuXHJcblxyXG4gICBAY2xhc3MgQmFja2dyaWQuSGVhZGVyXHJcbiAgIEBleHRlbmRzIEJhY2tib25lLlZpZXdcclxuICovXHJcbnZhciBIZWFkZXIgPSBCYWNrZ3JpZC5IZWFkZXIgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICB0YWdOYW1lOiBcInRoZWFkXCIsXHJcblxyXG4gIC8qKlxyXG4gICAgIEluaXRpYWxpemVyLiBJbml0aWFsaXplcyB0aGlzIHRhYmxlIGhlYWQgdmlldyB0byBjb250YWluIGEgc2luZ2xlIGhlYWRlclxyXG4gICAgIHJvdyB2aWV3LlxyXG5cclxuICAgICBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xyXG4gICAgIEBwYXJhbSB7QmFja2JvbmUuQ29sbGVjdGlvbi48QmFja2dyaWQuQ29sdW1uPnxBcnJheS48QmFja2dyaWQuQ29sdW1uPnxBcnJheS48T2JqZWN0Pn0gb3B0aW9ucy5jb2x1bW5zIENvbHVtbiBtZXRhZGF0YS5cclxuICAgICBAcGFyYW0ge0JhY2tib25lLk1vZGVsfSBvcHRpb25zLm1vZGVsIFRoZSBtb2RlbCBpbnN0YW5jZSB0byByZW5kZXIuXHJcblxyXG4gICAgIEB0aHJvd3Mge1R5cGVFcnJvcn0gSWYgb3B0aW9ucy5jb2x1bW5zIG9yIG9wdGlvbnMubW9kZWwgaXMgdW5kZWZpbmVkLlxyXG4gICAqL1xyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB0aGlzLmNvbHVtbnMgPSBvcHRpb25zLmNvbHVtbnM7XHJcbiAgICBpZiAoISh0aGlzLmNvbHVtbnMgaW5zdGFuY2VvZiBCYWNrYm9uZS5Db2xsZWN0aW9uKSkge1xyXG4gICAgICB0aGlzLmNvbHVtbnMgPSBuZXcgQ29sdW1ucyh0aGlzLmNvbHVtbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMucm93ID0gbmV3IEJhY2tncmlkLkhlYWRlclJvdyh7XHJcbiAgICAgIGNvbHVtbnM6IHRoaXMuY29sdW1ucyxcclxuICAgICAgY29sbGVjdGlvbjogdGhpcy5jb2xsZWN0aW9uXHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBSZW5kZXJzIHRoaXMgdGFibGUgaGVhZCB3aXRoIGEgc2luZ2xlIHJvdyBvZiBoZWFkZXIgY2VsbHMuXHJcbiAgICovXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy5yb3cucmVuZGVyKCkuJGVsKTtcclxuICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIENsZWFuIHVwIHRoaXMgaGVhZGVyIGFuZCBpdHMgcm93LlxyXG5cclxuICAgICBAY2hhaW5hYmxlXHJcbiAgICovXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJvdy5yZW1vdmUuYXBwbHkodGhpcy5yb3csIGFyZ3VtZW50cyk7XHJcbiAgICByZXR1cm4gQmFja2JvbmUuVmlldy5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxufSk7XHJcblxyXG4vKlxyXG4gIGJhY2tncmlkXHJcbiAgaHR0cDovL2dpdGh1Yi5jb20vd3l1ZW5oby9iYWNrZ3JpZFxyXG5cclxuICBDb3B5cmlnaHQgKGMpIDIwMTMgSmltbXkgWXVlbiBIbyBXb25nIGFuZCBjb250cmlidXRvcnNcclxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiovXHJcblxyXG4vKipcclxuICAgQm9keSBpcyB0aGUgdGFibGUgYm9keSB3aGljaCBjb250YWlucyB0aGUgcm93cyBpbnNpZGUgYSB0YWJsZS4gQm9keSBpc1xyXG4gICByZXNwb25zaWJsZSBmb3IgcmVmcmVzaGluZyB0aGUgcm93cyBhZnRlciBzb3J0aW5nLCBpbnNlcnRpb24gYW5kIHJlbW92YWwuXHJcblxyXG4gICBAY2xhc3MgQmFja2dyaWQuQm9keVxyXG4gICBAZXh0ZW5kcyBCYWNrYm9uZS5WaWV3XHJcbiovXHJcbnZhciBCb2R5ID0gQmFja2dyaWQuQm9keSA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuXHJcbiAgLyoqIEBwcm9wZXJ0eSAqL1xyXG4gIHRhZ05hbWU6IFwidGJvZHlcIixcclxuXHJcbiAgLyoqXHJcbiAgICAgSW5pdGlhbGl6ZXIuXHJcblxyXG4gICAgIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAgICAgQHBhcmFtIHtCYWNrYm9uZS5Db2xsZWN0aW9ufSBvcHRpb25zLmNvbGxlY3Rpb25cclxuICAgICBAcGFyYW0ge0JhY2tib25lLkNvbGxlY3Rpb24uPEJhY2tncmlkLkNvbHVtbj58QXJyYXkuPEJhY2tncmlkLkNvbHVtbj58QXJyYXkuPE9iamVjdD59IG9wdGlvbnMuY29sdW1uc1xyXG4gICAgIENvbHVtbiBtZXRhZGF0YS5cclxuICAgICBAcGFyYW0ge0JhY2tncmlkLlJvd30gW29wdGlvbnMucm93PUJhY2tncmlkLlJvd10gVGhlIFJvdyBjbGFzcyB0byB1c2UuXHJcbiAgICAgQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb24oKTogc3RyaW5nfSBbb3B0aW9ucy5lbXB0eVRleHRdIFRoZSB0ZXh0IHRvIGRpc3BsYXkgaW4gdGhlIGVtcHR5IHJvdy5cclxuXHJcbiAgICAgQHRocm93cyB7VHlwZUVycm9yfSBJZiBvcHRpb25zLmNvbHVtbnMgb3Igb3B0aW9ucy5jb2xsZWN0aW9uIGlzIHVuZGVmaW5lZC5cclxuXHJcbiAgICAgU2VlIEJhY2tncmlkLlJvdy5cclxuICAqL1xyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblxyXG4gICAgdGhpcy5jb2x1bW5zID0gb3B0aW9ucy5jb2x1bW5zO1xyXG4gICAgaWYgKCEodGhpcy5jb2x1bW5zIGluc3RhbmNlb2YgQmFja2JvbmUuQ29sbGVjdGlvbikpIHtcclxuICAgICAgdGhpcy5jb2x1bW5zID0gbmV3IENvbHVtbnModGhpcy5jb2x1bW5zKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnJvdyA9IG9wdGlvbnMucm93IHx8IFJvdztcclxuICAgIHRoaXMucm93cyA9IHRoaXMuY29sbGVjdGlvbi5tYXAoZnVuY3Rpb24gKG1vZGVsKSB7XHJcbiAgICAgIHZhciByb3cgPSBuZXcgdGhpcy5yb3coe1xyXG4gICAgICAgIGNvbHVtbnM6IHRoaXMuY29sdW1ucyxcclxuICAgICAgICBtb2RlbDogbW9kZWxcclxuICAgICAgfSk7XHJcblxyXG4gICAgICByZXR1cm4gcm93O1xyXG4gICAgfSwgdGhpcyk7XHJcblxyXG4gICAgdGhpcy5lbXB0eVRleHQgPSBvcHRpb25zLmVtcHR5VGV4dDtcclxuICAgIHRoaXMuX3Vuc2hpZnRFbXB0eVJvd01heUJlKCk7XHJcblxyXG4gICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb247XHJcbiAgICB0aGlzLmxpc3RlblRvKGNvbGxlY3Rpb24sIFwiYWRkXCIsIHRoaXMuaW5zZXJ0Um93KTtcclxuICAgIHRoaXMubGlzdGVuVG8oY29sbGVjdGlvbiwgXCJyZW1vdmVcIiwgdGhpcy5yZW1vdmVSb3cpO1xyXG4gICAgdGhpcy5saXN0ZW5Ubyhjb2xsZWN0aW9uLCBcInNvcnRcIiwgdGhpcy5yZWZyZXNoKTtcclxuICAgIHRoaXMubGlzdGVuVG8oY29sbGVjdGlvbiwgXCJyZXNldFwiLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgdGhpcy5saXN0ZW5Ubyhjb2xsZWN0aW9uLCBcImJhY2tncmlkOnNvcnRcIiwgdGhpcy5zb3J0KTtcclxuICAgIHRoaXMubGlzdGVuVG8oY29sbGVjdGlvbiwgXCJiYWNrZ3JpZDplZGl0ZWRcIiwgdGhpcy5tb3ZlVG9OZXh0Q2VsbCk7XHJcbiAgfSxcclxuXHJcbiAgX3Vuc2hpZnRFbXB0eVJvd01heUJlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5yb3dzLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmVtcHR5VGV4dCAhPSBudWxsKSB7XHJcbiAgICAgIHRoaXMucm93cy51bnNoaWZ0KG5ldyBFbXB0eVJvdyh7XHJcbiAgICAgICAgZW1wdHlUZXh0OiB0aGlzLmVtcHR5VGV4dCxcclxuICAgICAgICBjb2x1bW5zOiB0aGlzLmNvbHVtbnNcclxuICAgICAgfSkpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIFRoaXMgbWV0aG9kIGNhbiBiZSBjYWxsZWQgZWl0aGVyIGRpcmVjdGx5IG9yIGFzIGEgY2FsbGJhY2sgdG8gYVxyXG4gICAgIFtCYWNrYm9uZS5Db2xsZWN0b24jYWRkXShodHRwOi8vYmFja2JvbmVqcy5vcmcvI0NvbGxlY3Rpb24tYWRkKSBldmVudC5cclxuXHJcbiAgICAgV2hlbiBjYWxsZWQgZGlyZWN0bHksIGl0IGFjY2VwdHMgYSBtb2RlbCBvciBhbiBhcnJheSBvZiBtb2RlbHMgYW5kIGFuXHJcbiAgICAgb3B0aW9uIGhhc2gganVzdCBsaWtlXHJcbiAgICAgW0JhY2tib25lLkNvbGxlY3Rpb24jYWRkXShodHRwOi8vYmFja2JvbmVqcy5vcmcvI0NvbGxlY3Rpb24tYWRkKSBhbmRcclxuICAgICBkZWxlZ2F0ZXMgdG8gaXQuIE9uY2UgdGhlIG1vZGVsIGlzIGFkZGVkLCBhIG5ldyByb3cgaXMgaW5zZXJ0ZWQgaW50byB0aGVcclxuICAgICBib2R5IGFuZCBhdXRvbWF0aWNhbGx5IHJlbmRlcmVkLlxyXG5cclxuICAgICBXaGVuIGNhbGxlZCBhcyBhIGNhbGxiYWNrIG9mIGFuIGBhZGRgIGV2ZW50LCBzcGxpY2VzIGEgbmV3IHJvdyBpbnRvIHRoZVxyXG4gICAgIGJvZHkgYW5kIHJlbmRlcnMgaXQuXHJcblxyXG4gICAgIEBwYXJhbSB7QmFja2JvbmUuTW9kZWx9IG1vZGVsIFRoZSBtb2RlbCB0byByZW5kZXIgYXMgYSByb3cuXHJcbiAgICAgQHBhcmFtIHtCYWNrYm9uZS5Db2xsZWN0aW9ufSBjb2xsZWN0aW9uIFdoZW4gY2FsbGVkIGRpcmVjdGx5LCB0aGlzXHJcbiAgICAgcGFyYW1ldGVyIGlzIGFjdHVhbGx5IHRoZSBvcHRpb25zIHRvXHJcbiAgICAgW0JhY2tib25lLkNvbGxlY3Rpb24jYWRkXShodHRwOi8vYmFja2JvbmVqcy5vcmcvI0NvbGxlY3Rpb24tYWRkKS5cclxuICAgICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBXaGVuIGNhbGxlZCBkaXJlY3RseSwgdGhpcyBtdXN0IGJlIG51bGwuXHJcblxyXG4gICAgIFNlZTpcclxuXHJcbiAgICAgLSBbQmFja2JvbmUuQ29sbGVjdGlvbiNhZGRdKGh0dHA6Ly9iYWNrYm9uZWpzLm9yZy8jQ29sbGVjdGlvbi1hZGQpXHJcbiAgKi9cclxuICBpbnNlcnRSb3c6IGZ1bmN0aW9uIChtb2RlbCwgY29sbGVjdGlvbiwgb3B0aW9ucykge1xyXG5cclxuICAgIGlmICh0aGlzLnJvd3NbMF0gaW5zdGFuY2VvZiBFbXB0eVJvdykgdGhpcy5yb3dzLnBvcCgpLnJlbW92ZSgpO1xyXG5cclxuICAgIC8vIGluc2VydFJvdygpIGlzIGNhbGxlZCBkaXJlY3RseVxyXG4gICAgaWYgKCEoY29sbGVjdGlvbiBpbnN0YW5jZW9mIEJhY2tib25lLkNvbGxlY3Rpb24pICYmICFvcHRpb25zKSB7XHJcbiAgICAgIHRoaXMuY29sbGVjdGlvbi5hZGQobW9kZWwsIChvcHRpb25zID0gY29sbGVjdGlvbikpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHJvdyA9IG5ldyB0aGlzLnJvdyh7XHJcbiAgICAgIGNvbHVtbnM6IHRoaXMuY29sdW1ucyxcclxuICAgICAgbW9kZWw6IG1vZGVsXHJcbiAgICB9KTtcclxuXHJcbiAgICB2YXIgaW5kZXggPSBjb2xsZWN0aW9uLmluZGV4T2YobW9kZWwpO1xyXG4gICAgdGhpcy5yb3dzLnNwbGljZShpbmRleCwgMCwgcm93KTtcclxuXHJcbiAgICB2YXIgJGVsID0gdGhpcy4kZWw7XHJcbiAgICB2YXIgJGNoaWxkcmVuID0gJGVsLmNoaWxkcmVuKCk7XHJcbiAgICB2YXIgJHJvd0VsID0gcm93LnJlbmRlcigpLiRlbDtcclxuXHJcbiAgICBpZiAoaW5kZXggPj0gJGNoaWxkcmVuLmxlbmd0aCkge1xyXG4gICAgICAkZWwuYXBwZW5kKCRyb3dFbCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgJGNoaWxkcmVuLmVxKGluZGV4KS5iZWZvcmUoJHJvd0VsKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBUaGUgbWV0aG9kIGNhbiBiZSBjYWxsZWQgZWl0aGVyIGRpcmVjdGx5IG9yIGFzIGEgY2FsbGJhY2sgdG8gYVxyXG4gICAgIFtCYWNrYm9uZS5Db2xsZWN0aW9uI3JlbW92ZV0oaHR0cDovL2JhY2tib25lanMub3JnLyNDb2xsZWN0aW9uLXJlbW92ZSlcclxuICAgICBldmVudC5cclxuXHJcbiAgICAgV2hlbiBjYWxsZWQgZGlyZWN0bHksIGl0IGFjY2VwdHMgYSBtb2RlbCBvciBhbiBhcnJheSBvZiBtb2RlbHMgYW5kIGFuXHJcbiAgICAgb3B0aW9uIGhhc2gganVzdCBsaWtlXHJcbiAgICAgW0JhY2tib25lLkNvbGxlY3Rpb24jcmVtb3ZlXShodHRwOi8vYmFja2JvbmVqcy5vcmcvI0NvbGxlY3Rpb24tcmVtb3ZlKSBhbmRcclxuICAgICBkZWxlZ2F0ZXMgdG8gaXQuIE9uY2UgdGhlIG1vZGVsIGlzIHJlbW92ZWQsIGEgY29ycmVzcG9uZGluZyByb3cgaXMgcmVtb3ZlZFxyXG4gICAgIGZyb20gdGhlIGJvZHkuXHJcblxyXG4gICAgIFdoZW4gY2FsbGVkIGFzIGEgY2FsbGJhY2sgb2YgYSBgcmVtb3ZlYCBldmVudCwgc3BsaWNlcyBpbnRvIHRoZSByb3dzIGFuZFxyXG4gICAgIHJlbW92ZXMgdGhlIHJvdyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIHRoZSBtb2RlbC5cclxuXHJcbiAgICAgQHBhcmFtIHtCYWNrYm9uZS5Nb2RlbH0gbW9kZWwgVGhlIG1vZGVsIHRvIHJlbW92ZSBmcm9tIHRoZSBib2R5LlxyXG4gICAgIEBwYXJhbSB7QmFja2JvbmUuQ29sbGVjdGlvbn0gY29sbGVjdGlvbiBXaGVuIGNhbGxlZCBkaXJlY3RseSwgdGhpc1xyXG4gICAgIHBhcmFtZXRlciBpcyBhY3R1YWxseSB0aGUgb3B0aW9ucyB0b1xyXG4gICAgIFtCYWNrYm9uZS5Db2xsZWN0aW9uI3JlbW92ZV0oaHR0cDovL2JhY2tib25lanMub3JnLyNDb2xsZWN0aW9uLXJlbW92ZSkuXHJcbiAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgV2hlbiBjYWxsZWQgZGlyZWN0bHksIHRoaXMgbXVzdCBiZSBudWxsLlxyXG5cclxuICAgICBTZWU6XHJcblxyXG4gICAgIC0gW0JhY2tib25lLkNvbGxlY3Rpb24jcmVtb3ZlXShodHRwOi8vYmFja2JvbmVqcy5vcmcvI0NvbGxlY3Rpb24tcmVtb3ZlKVxyXG4gICovXHJcbiAgcmVtb3ZlUm93OiBmdW5jdGlvbiAobW9kZWwsIGNvbGxlY3Rpb24sIG9wdGlvbnMpIHtcclxuXHJcbiAgICAvLyByZW1vdmVSb3coKSBpcyBjYWxsZWQgZGlyZWN0bHlcclxuICAgIGlmICghb3B0aW9ucykge1xyXG4gICAgICB0aGlzLmNvbGxlY3Rpb24ucmVtb3ZlKG1vZGVsLCAob3B0aW9ucyA9IGNvbGxlY3Rpb24pKTtcclxuICAgICAgdGhpcy5fdW5zaGlmdEVtcHR5Um93TWF5QmUoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChfLmlzVW5kZWZpbmVkKG9wdGlvbnMucmVuZGVyKSB8fCBvcHRpb25zLnJlbmRlcikge1xyXG4gICAgICB0aGlzLnJvd3Nbb3B0aW9ucy5pbmRleF0ucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yb3dzLnNwbGljZShvcHRpb25zLmluZGV4LCAxKTtcclxuICAgIHRoaXMuX3Vuc2hpZnRFbXB0eVJvd01heUJlKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgUmVpbml0aWFsaXplIGFsbCB0aGUgcm93cyBpbnNpZGUgdGhlIGJvZHkgYW5kIHJlLXJlbmRlciB0aGVtLiBUcmlnZ2VycyBhXHJcbiAgICAgQmFja2JvbmUgYGJhY2tncmlkOnJlZnJlc2hgIGV2ZW50IGZyb20gdGhlIGNvbGxlY3Rpb24gYWxvbmcgd2l0aCB0aGUgYm9keVxyXG4gICAgIGluc3RhbmNlIGFzIGl0cyBzb2xlIHBhcmFtZXRlciB3aGVuIGRvbmUuXHJcbiAgKi9cclxuICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucm93cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICB0aGlzLnJvd3NbaV0ucmVtb3ZlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5yb3dzID0gdGhpcy5jb2xsZWN0aW9uLm1hcChmdW5jdGlvbiAobW9kZWwpIHtcclxuICAgICAgdmFyIHJvdyA9IG5ldyB0aGlzLnJvdyh7XHJcbiAgICAgICAgY29sdW1uczogdGhpcy5jb2x1bW5zLFxyXG4gICAgICAgIG1vZGVsOiBtb2RlbFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiByb3c7XHJcbiAgICB9LCB0aGlzKTtcclxuICAgIHRoaXMuX3Vuc2hpZnRFbXB0eVJvd01heUJlKCk7XHJcblxyXG4gICAgdGhpcy5yZW5kZXIoKTtcclxuXHJcbiAgICB0aGlzLmNvbGxlY3Rpb24udHJpZ2dlcihcImJhY2tncmlkOnJlZnJlc2hcIiwgdGhpcyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgUmVuZGVycyBhbGwgdGhlIHJvd3MgaW5zaWRlIHRoaXMgYm9keS4gSWYgdGhlIGNvbGxlY3Rpb24gaXMgZW1wdHkgYW5kXHJcbiAgICAgYG9wdGlvbnMuZW1wdHlUZXh0YCBpcyBkZWZpbmVkIGFuZCBub3QgbnVsbCBpbiB0aGUgY29uc3RydWN0b3IsIGFuIGVtcHR5XHJcbiAgICAgcm93IGlzIHJlbmRlcmVkLCBvdGhlcndpc2Ugbm8gcm93IGlzIHJlbmRlcmVkLlxyXG4gICovXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLiRlbC5lbXB0eSgpO1xyXG5cclxuICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbaV07XHJcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHJvdy5yZW5kZXIoKS5lbCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5lbC5hcHBlbmRDaGlsZChmcmFnbWVudCk7XHJcblxyXG4gICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIENsZWFuIHVwIHRoaXMgYm9keSBhbmQgaXQncyByb3dzLlxyXG5cclxuICAgICBAY2hhaW5hYmxlXHJcbiAgKi9cclxuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yb3dzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhciByb3cgPSB0aGlzLnJvd3NbaV07XHJcbiAgICAgIHJvdy5yZW1vdmUuYXBwbHkocm93LCBhcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEJhY2tib25lLlZpZXcucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIElmIHRoZSB1bmRlcmx5aW5nIGNvbGxlY3Rpb24gaXMgYSBCYWNrYm9uZS5QYWdlYWJsZUNvbGxlY3Rpb24gaW5cclxuICAgICBzZXJ2ZXItbW9kZSBvciBpbmZpbml0ZS1tb2RlLCBhIHBhZ2Ugb2YgbW9kZWxzIGlzIGZldGNoZWQgYWZ0ZXIgc29ydGluZyBpc1xyXG4gICAgIGRvbmUgb24gdGhlIHNlcnZlci5cclxuXHJcbiAgICAgSWYgdGhlIHVuZGVybHlpbmcgY29sbGVjdGlvbiBpcyBhIEJhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbiBpblxyXG4gICAgIGNsaWVudC1tb2RlLCBvciBhbnlcclxuICAgICBbQmFja2JvbmUuQ29sbGVjdGlvbl0oaHR0cDovL2JhY2tib25lanMub3JnLyNDb2xsZWN0aW9uKSBpbnN0YW5jZSwgc29ydGluZ1xyXG4gICAgIGlzIGRvbmUgb24gdGhlIGNsaWVudCBzaWRlLiBJZiB0aGUgY29sbGVjdGlvbiBpcyBhbiBpbnN0YW5jZSBvZiBhXHJcbiAgICAgQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uLCBzb3J0aW5nIHdpbGwgYmUgZG9uZSBnbG9iYWxseSBvbiBhbGwgdGhlIHBhZ2VzXHJcbiAgICAgYW5kIHRoZSBjdXJyZW50IHBhZ2Ugd2lsbCB0aGVuIGJlIHJldHVybmVkLlxyXG5cclxuICAgICBUcmlnZ2VycyBhIEJhY2tib25lIGBiYWNrZ3JpZDpzb3J0ZWRgIGV2ZW50IGZyb20gdGhlIGNvbGxlY3Rpb24gd2hlbiBkb25lXHJcbiAgICAgd2l0aCB0aGUgY29sdW1uLCBkaXJlY3Rpb24gYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBjb2xsZWN0aW9uLlxyXG5cclxuICAgICBAcGFyYW0ge0JhY2tncmlkLkNvbHVtbn0gY29sdW1uXHJcbiAgICAgQHBhcmFtIHtudWxsfFwiYXNjZW5kaW5nXCJ8XCJkZXNjZW5kaW5nXCJ9IGRpcmVjdGlvblxyXG5cclxuICAgICBTZWUgW0JhY2tib25lLkNvbGxlY3Rpb24jY29tcGFyYXRvcl0oaHR0cDovL2JhY2tib25lanMub3JnLyNDb2xsZWN0aW9uLWNvbXBhcmF0b3IpXHJcbiAgKi9cclxuICBzb3J0OiBmdW5jdGlvbiAoY29sdW1uLCBkaXJlY3Rpb24pIHtcclxuXHJcbiAgICBpZiAoIV8uY29udGFpbnMoW1wiYXNjZW5kaW5nXCIsIFwiZGVzY2VuZGluZ1wiLCBudWxsXSwgZGlyZWN0aW9uKSkge1xyXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZGlyZWN0aW9uIG11c3QgYmUgb25lIG9mIFwiYXNjZW5kaW5nXCIsIFwiZGVzY2VuZGluZ1wiIG9yIGBudWxsYCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChfLmlzU3RyaW5nKGNvbHVtbikpIGNvbHVtbiA9IHRoaXMuY29sdW1ucy5maW5kV2hlcmUoe25hbWU6IGNvbHVtbn0pO1xyXG5cclxuICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5jb2xsZWN0aW9uO1xyXG5cclxuICAgIHZhciBvcmRlcjtcclxuICAgIGlmIChkaXJlY3Rpb24gPT09IFwiYXNjZW5kaW5nXCIpIG9yZGVyID0gLTE7XHJcbiAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFwiZGVzY2VuZGluZ1wiKSBvcmRlciA9IDE7XHJcbiAgICBlbHNlIG9yZGVyID0gbnVsbDtcclxuXHJcbiAgICB2YXIgY29tcGFyYXRvciA9IHRoaXMubWFrZUNvbXBhcmF0b3IoY29sdW1uLmdldChcIm5hbWVcIiksIG9yZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4uc29ydFZhbHVlKCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChtb2RlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsLmNpZC5yZXBsYWNlKCdjJywgJycpICogMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICBpZiAoQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uICYmXHJcbiAgICAgICAgY29sbGVjdGlvbiBpbnN0YW5jZW9mIEJhY2tib25lLlBhZ2VhYmxlQ29sbGVjdGlvbikge1xyXG5cclxuICAgICAgY29sbGVjdGlvbi5zZXRTb3J0aW5nKG9yZGVyICYmIGNvbHVtbi5nZXQoXCJuYW1lXCIpLCBvcmRlcixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtzb3J0VmFsdWU6IGNvbHVtbi5zb3J0VmFsdWUoKX0pO1xyXG5cclxuICAgICAgaWYgKGNvbGxlY3Rpb24uZnVsbENvbGxlY3Rpb24pIHtcclxuICAgICAgICAvLyBJZiBvcmRlciBpcyBudWxsLCBwYWdlYWJsZSB3aWxsIHJlbW92ZSB0aGUgY29tcGFyYXRvciBvbiBib3RoIHNpZGVzLFxyXG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSB0aGUgZGVmYXVsdCBpbnNlcnRpb24gb3JkZXIgY29tcGFyYXRvciBuZWVkcyB0byBiZVxyXG4gICAgICAgIC8vIGF0dGFjaGVkIHRvIGdldCBiYWNrIHRvIHRoZSBvcmRlciBiZWZvcmUgc29ydGluZy5cclxuICAgICAgICBpZiAoY29sbGVjdGlvbi5mdWxsQ29sbGVjdGlvbi5jb21wYXJhdG9yID09IG51bGwpIHtcclxuICAgICAgICAgIGNvbGxlY3Rpb24uZnVsbENvbGxlY3Rpb24uY29tcGFyYXRvciA9IGNvbXBhcmF0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbGxlY3Rpb24uZnVsbENvbGxlY3Rpb24uc29ydCgpO1xyXG4gICAgICAgIGNvbGxlY3Rpb24udHJpZ2dlcihcImJhY2tncmlkOnNvcnRlZFwiLCBjb2x1bW4sIGRpcmVjdGlvbiwgY29sbGVjdGlvbik7XHJcbiAgICAgIH1cclxuICAgICAgZWxzZSBjb2xsZWN0aW9uLmZldGNoKHtyZXNldDogdHJ1ZSwgc3VjY2VzczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbGxlY3Rpb24udHJpZ2dlcihcImJhY2tncmlkOnNvcnRlZFwiLCBjb2x1bW4sIGRpcmVjdGlvbiwgY29sbGVjdGlvbik7XHJcbiAgICAgIH19KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICBjb2xsZWN0aW9uLmNvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xyXG4gICAgICBjb2xsZWN0aW9uLnNvcnQoKTtcclxuICAgICAgY29sbGVjdGlvbi50cmlnZ2VyKFwiYmFja2dyaWQ6c29ydGVkXCIsIGNvbHVtbiwgZGlyZWN0aW9uLCBjb2xsZWN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICBjb2x1bW4uc2V0KFwiZGlyZWN0aW9uXCIsIGRpcmVjdGlvbik7XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgbWFrZUNvbXBhcmF0b3I6IGZ1bmN0aW9uIChhdHRyLCBvcmRlciwgZnVuYykge1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuICAgICAgLy8gZXh0cmFjdCB0aGUgdmFsdWVzIGZyb20gdGhlIG1vZGVsc1xyXG4gICAgICB2YXIgbCA9IGZ1bmMobGVmdCwgYXR0ciksIHIgPSBmdW5jKHJpZ2h0LCBhdHRyKSwgdDtcclxuXHJcbiAgICAgIC8vIGlmIGRlc2NlbmRpbmcgb3JkZXIsIHN3YXAgbGVmdCBhbmQgcmlnaHRcclxuICAgICAgaWYgKG9yZGVyID09PSAxKSB0ID0gbCwgbCA9IHIsIHIgPSB0O1xyXG5cclxuICAgICAgLy8gY29tcGFyZSBhcyB1c3VhbFxyXG4gICAgICBpZiAobCA9PT0gcikgcmV0dXJuIDA7XHJcbiAgICAgIGVsc2UgaWYgKGwgPCByKSByZXR1cm4gLTE7XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgfTtcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBNb3ZlcyBmb2N1cyB0byB0aGUgbmV4dCByZW5kZXJhYmxlIGFuZCBlZGl0YWJsZSBjZWxsIGFuZCByZXR1cm4gdGhlXHJcbiAgICAgY3VycmVudGx5IGVkaXRpbmcgY2VsbCB0byBkaXNwbGF5IG1vZGUuXHJcblxyXG4gICAgIFRyaWdnZXJzIGEgYGJhY2tncmlkOm5leHRgIGV2ZW50IG9uIHRoZSBtb2RlbCB3aXRoIHRoZSBpbmRpY2VzIG9mIHRoZSByb3dcclxuICAgICBhbmQgY29sdW1uIHRoZSB1c2VyICppbnRlbmRlZCogdG8gbW92ZSB0bywgYW5kIHdoZXRoZXIgdGhlIGludGVuZGVkIG1vdmVcclxuICAgICB3YXMgZ29pbmcgdG8gZ28gb3V0IG9mIGJvdW5kcy4gTm90ZSB0aGF0ICpvdXQgb2YgYm91bmQqIGFsd2F5cyBtZWFucyBhblxyXG4gICAgIGF0dGVtcHQgdG8gZ28gcGFzdCB0aGUgZW5kIG9mIHRoZSBsYXN0IHJvdy5cclxuXHJcbiAgICAgQHBhcmFtIHtCYWNrYm9uZS5Nb2RlbH0gbW9kZWwgVGhlIG9yaWdpbmF0aW5nIG1vZGVsXHJcbiAgICAgQHBhcmFtIHtCYWNrZ3JpZC5Db2x1bW59IGNvbHVtbiBUaGUgb3JpZ2luYXRpbmcgbW9kZWwgY29sdW1uXHJcbiAgICAgQHBhcmFtIHtCYWNrZ3JpZC5Db21tYW5kfSBjb21tYW5kIFRoZSBDb21tYW5kIG9iamVjdCBjb25zdHJ1Y3RlZCBmcm9tIGEgRE9NXHJcbiAgICAgZXZlbnRcclxuICAqL1xyXG4gIG1vdmVUb05leHRDZWxsOiBmdW5jdGlvbiAobW9kZWwsIGNvbHVtbiwgY29tbWFuZCkge1xyXG4gICAgdmFyIGkgPSB0aGlzLmNvbGxlY3Rpb24uaW5kZXhPZihtb2RlbCk7XHJcbiAgICB2YXIgaiA9IHRoaXMuY29sdW1ucy5pbmRleE9mKGNvbHVtbik7XHJcbiAgICB2YXIgY2VsbCwgcmVuZGVyYWJsZSwgZWRpdGFibGUsIG0sIG47XHJcblxyXG4gICAgdGhpcy5yb3dzW2ldLmNlbGxzW2pdLmV4aXRFZGl0TW9kZSgpO1xyXG5cclxuICAgIGlmIChjb21tYW5kLm1vdmVVcCgpIHx8IGNvbW1hbmQubW92ZURvd24oKSB8fCBjb21tYW5kLm1vdmVMZWZ0KCkgfHxcclxuICAgICAgICBjb21tYW5kLm1vdmVSaWdodCgpIHx8IGNvbW1hbmQuc2F2ZSgpKSB7XHJcbiAgICAgIHZhciBsID0gdGhpcy5jb2x1bW5zLmxlbmd0aDtcclxuICAgICAgdmFyIG1heE9mZnNldCA9IGwgKiB0aGlzLmNvbGxlY3Rpb24ubGVuZ3RoO1xyXG5cclxuICAgICAgaWYgKGNvbW1hbmQubW92ZVVwKCkgfHwgY29tbWFuZC5tb3ZlRG93bigpKSB7XHJcbiAgICAgICAgbSA9IGkgKyAoY29tbWFuZC5tb3ZlVXAoKSA/IC0xIDogMSk7XHJcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93c1ttXTtcclxuICAgICAgICBpZiAocm93KSB7XHJcbiAgICAgICAgICBjZWxsID0gcm93LmNlbGxzW2pdO1xyXG4gICAgICAgICAgaWYgKEJhY2tncmlkLmNhbGxCeU5lZWQoY2VsbC5jb2x1bW4uZWRpdGFibGUoKSwgY2VsbC5jb2x1bW4sIG1vZGVsKSkge1xyXG4gICAgICAgICAgICBjZWxsLmVudGVyRWRpdE1vZGUoKTtcclxuICAgICAgICAgICAgbW9kZWwudHJpZ2dlcihcImJhY2tncmlkOm5leHRcIiwgbSwgaiwgZmFsc2UpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIG1vZGVsLnRyaWdnZXIoXCJiYWNrZ3JpZDpuZXh0XCIsIG0sIGosIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKGNvbW1hbmQubW92ZUxlZnQoKSB8fCBjb21tYW5kLm1vdmVSaWdodCgpKSB7XHJcbiAgICAgICAgdmFyIHJpZ2h0ID0gY29tbWFuZC5tb3ZlUmlnaHQoKTtcclxuICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSBpICogbCArIGogKyAocmlnaHQgPyAxIDogLTEpO1xyXG4gICAgICAgICAgICAgb2Zmc2V0ID49IDAgJiYgb2Zmc2V0IDwgbWF4T2Zmc2V0O1xyXG4gICAgICAgICAgICAgcmlnaHQgPyBvZmZzZXQrKyA6IG9mZnNldC0tKSB7XHJcbiAgICAgICAgICBtID0gfn4ob2Zmc2V0IC8gbCk7XHJcbiAgICAgICAgICBuID0gb2Zmc2V0IC0gbSAqIGw7XHJcbiAgICAgICAgICBjZWxsID0gdGhpcy5yb3dzW21dLmNlbGxzW25dO1xyXG4gICAgICAgICAgcmVuZGVyYWJsZSA9IEJhY2tncmlkLmNhbGxCeU5lZWQoY2VsbC5jb2x1bW4ucmVuZGVyYWJsZSgpLCBjZWxsLmNvbHVtbiwgY2VsbC5tb2RlbCk7XHJcbiAgICAgICAgICBlZGl0YWJsZSA9IEJhY2tncmlkLmNhbGxCeU5lZWQoY2VsbC5jb2x1bW4uZWRpdGFibGUoKSwgY2VsbC5jb2x1bW4sIG1vZGVsKTtcclxuICAgICAgICAgIGlmIChyZW5kZXJhYmxlICYmIGVkaXRhYmxlKSB7XHJcbiAgICAgICAgICAgIGNlbGwuZW50ZXJFZGl0TW9kZSgpO1xyXG4gICAgICAgICAgICBtb2RlbC50cmlnZ2VyKFwiYmFja2dyaWQ6bmV4dFwiLCBtLCBuLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9mZnNldCA9PSBtYXhPZmZzZXQpIHtcclxuICAgICAgICAgIG1vZGVsLnRyaWdnZXIoXCJiYWNrZ3JpZDpuZXh0XCIsIH5+KG9mZnNldCAvIGwpLCBvZmZzZXQgLSBtICogbCwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG59KTtcclxuXHJcbi8qXHJcbiAgYmFja2dyaWRcclxuICBodHRwOi8vZ2l0aHViLmNvbS93eXVlbmhvL2JhY2tncmlkXHJcblxyXG4gIENvcHlyaWdodCAoYykgMjAxMyBKaW1teSBZdWVuIEhvIFdvbmcgYW5kIGNvbnRyaWJ1dG9yc1xyXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cclxuKi9cclxuXHJcbi8qKlxyXG4gICBBIEZvb3RlciBpcyBhIGdlbmVyaWMgY2xhc3MgdGhhdCBvbmx5IGRlZmluZXMgYSBkZWZhdWx0IHRhZyBgdGZvb3RgIGFuZFxyXG4gICBudW1iZXIgb2YgcmVxdWlyZWQgcGFyYW1ldGVycyBpbiB0aGUgaW5pdGlhbGl6ZXIuXHJcblxyXG4gICBAYWJzdHJhY3RcclxuICAgQGNsYXNzIEJhY2tncmlkLkZvb3RlclxyXG4gICBAZXh0ZW5kcyBCYWNrYm9uZS5WaWV3XHJcbiAqL1xyXG52YXIgRm9vdGVyID0gQmFja2dyaWQuRm9vdGVyID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgdGFnTmFtZTogXCJ0Zm9vdFwiLFxyXG5cclxuICAvKipcclxuICAgICBJbml0aWFsaXplci5cclxuXHJcbiAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICBAcGFyYW0ge0JhY2tib25lLkNvbGxlY3Rpb24uPEJhY2tncmlkLkNvbHVtbj58QXJyYXkuPEJhY2tncmlkLkNvbHVtbj58QXJyYXkuPE9iamVjdD59IG9wdGlvbnMuY29sdW1uc1xyXG4gICAgIENvbHVtbiBtZXRhZGF0YS5cclxuICAgICBAcGFyYW0ge0JhY2tib25lLkNvbGxlY3Rpb259IG9wdGlvbnMuY29sbGVjdGlvblxyXG5cclxuICAgICBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIG9wdGlvbnMuY29sdW1ucyBvciBvcHRpb25zLmNvbGxlY3Rpb24gaXMgdW5kZWZpbmVkLlxyXG4gICovXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHRoaXMuY29sdW1ucyA9IG9wdGlvbnMuY29sdW1ucztcclxuICAgIGlmICghKHRoaXMuY29sdW1ucyBpbnN0YW5jZW9mIEJhY2tib25lLkNvbGxlY3Rpb24pKSB7XHJcbiAgICAgIHRoaXMuY29sdW1ucyA9IG5ldyBCYWNrZ3JpZC5Db2x1bW5zKHRoaXMuY29sdW1ucyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxufSk7XHJcblxyXG4vKlxyXG4gIGJhY2tncmlkXHJcbiAgaHR0cDovL2dpdGh1Yi5jb20vd3l1ZW5oby9iYWNrZ3JpZFxyXG5cclxuICBDb3B5cmlnaHQgKGMpIDIwMTMgSmltbXkgWXVlbiBIbyBXb25nIGFuZCBjb250cmlidXRvcnNcclxuICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbiovXHJcblxyXG4vKipcclxuICAgR3JpZCByZXByZXNlbnRzIGEgZGF0YSBncmlkIHRoYXQgaGFzIGEgaGVhZGVyLCBib2R5IGFuZCBhbiBvcHRpb25hbCBmb290ZXIuXHJcblxyXG4gICBCeSBkZWZhdWx0LCBhIEdyaWQgdHJlYXRzIGVhY2ggbW9kZWwgaW4gYSBjb2xsZWN0aW9uIGFzIGEgcm93LCBhbmQgZWFjaFxyXG4gICBhdHRyaWJ1dGUgaW4gYSBtb2RlbCBhcyBhIGNvbHVtbi4gVG8gcmVuZGVyIGEgZ3JpZCB5b3UgbXVzdCBwcm92aWRlIGEgbGlzdCBvZlxyXG4gICBjb2x1bW4gbWV0YWRhdGEgYW5kIGEgY29sbGVjdGlvbiB0byB0aGUgR3JpZCBjb25zdHJ1Y3Rvci4gSnVzdCBsaWtlIGFueVxyXG4gICBCYWNrYm9uZS5WaWV3IGNsYXNzLCB0aGUgZ3JpZCBpcyByZW5kZXJlZCBhcyBhIERPTSBub2RlIGZyYWdtZW50IHdoZW4geW91XHJcbiAgIGNhbGwgcmVuZGVyKCkuXHJcblxyXG4gICAgICAgdmFyIGdyaWQgPSBCYWNrZ3JpZC5HcmlkKHtcclxuICAgICAgICAgY29sdW1uczogW3sgbmFtZTogXCJpZFwiLCBsYWJlbDogXCJJRFwiLCB0eXBlOiBcInN0cmluZ1wiIH0sXHJcbiAgICAgICAgICAvLyAuLi5cclxuICAgICAgICAgXSxcclxuICAgICAgICAgY29sbGVjdGlvbnM6IGJvb2tzXHJcbiAgICAgICB9KTtcclxuXHJcbiAgICAgICAkKFwiI3RhYmxlLWNvbnRhaW5lclwiKS5hcHBlbmQoZ3JpZC5yZW5kZXIoKS5lbCk7XHJcblxyXG4gICBPcHRpb25hbGx5LCBpZiB5b3Ugd2FudCB0byBjdXN0b21pemUgdGhlIHJlbmRlcmluZyBvZiB0aGUgZ3JpZCdzIGhlYWRlciBhbmRcclxuICAgZm9vdGVyLCB5b3UgbWF5IGNob29zZSB0byBleHRlbmQgQmFja2dyaWQuSGVhZGVyIGFuZCBCYWNrZ3JpZC5Gb290ZXIsIGFuZFxyXG4gICB0aGVuIHN1cHBseSB0aGF0IGNsYXNzIG9yIGFuIGluc3RhbmNlIG9mIHRoYXQgY2xhc3MgdG8gdGhlIEdyaWQgY29uc3RydWN0b3IuXHJcbiAgIFNlZSB0aGUgZG9jdW1lbnRhdGlvbiBmb3IgSGVhZGVyIGFuZCBGb290ZXIgZm9yIGZ1cnRoZXIgZGV0YWlscy5cclxuXHJcbiAgICAgICB2YXIgZ3JpZCA9IEJhY2tncmlkLkdyaWQoe1xyXG4gICAgICAgICBjb2x1bW5zOiBbeyBuYW1lOiBcImlkXCIsIGxhYmVsOiBcIklEXCIsIHR5cGU6IFwic3RyaW5nXCIgfV0sXHJcbiAgICAgICAgIGNvbGxlY3Rpb25zOiBib29rcyxcclxuICAgICAgICAgaGVhZGVyOiBCYWNrZ3JpZC5IZWFkZXIuZXh0ZW5kKHtcclxuICAgICAgICAgICAgICAvLy4uLlxyXG4gICAgICAgICB9KSxcclxuICAgICAgICAgZm9vdGVyOiBCYWNrZ3JpZC5QYWdpbmF0b3JcclxuICAgICAgIH0pO1xyXG5cclxuICAgRmluYWxseSwgaWYgeW91IHdhbnQgdG8gb3ZlcnJpZGUgaG93IHRoZSByb3dzIGFyZSByZW5kZXJlZCBpbiB0aGUgdGFibGUgYm9keSxcclxuICAgeW91IGNhbiBzdXBwbHkgYSBCb2R5IHN1YmNsYXNzIGFzIHRoZSBgYm9keWAgYXR0cmlidXRlIHRoYXQgdXNlcyBhIGRpZmZlcmVudFxyXG4gICBSb3cgY2xhc3MuXHJcblxyXG4gICBAY2xhc3MgQmFja2dyaWQuR3JpZFxyXG4gICBAZXh0ZW5kcyBCYWNrYm9uZS5WaWV3XHJcblxyXG4gICBTZWU6XHJcblxyXG4gICAtIEJhY2tncmlkLkNvbHVtblxyXG4gICAtIEJhY2tncmlkLkhlYWRlclxyXG4gICAtIEJhY2tncmlkLkJvZHlcclxuICAgLSBCYWNrZ3JpZC5Sb3dcclxuICAgLSBCYWNrZ3JpZC5Gb290ZXJcclxuKi9cclxudmFyIEdyaWQgPSBCYWNrZ3JpZC5HcmlkID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgdGFnTmFtZTogXCJ0YWJsZVwiLFxyXG5cclxuICAvKiogQHByb3BlcnR5ICovXHJcbiAgY2xhc3NOYW1lOiBcImJhY2tncmlkXCIsXHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBoZWFkZXI6IEhlYWRlcixcclxuXHJcbiAgLyoqIEBwcm9wZXJ0eSAqL1xyXG4gIGJvZHk6IEJvZHksXHJcblxyXG4gIC8qKiBAcHJvcGVydHkgKi9cclxuICBmb290ZXI6IG51bGwsXHJcblxyXG4gIC8qKlxyXG4gICAgIEluaXRpYWxpemVzIGEgR3JpZCBpbnN0YW5jZS5cclxuXHJcbiAgICAgQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcclxuICAgICBAcGFyYW0ge0JhY2tib25lLkNvbGxlY3Rpb24uPEJhY2tncmlkLkNvbHVtbnM+fEFycmF5LjxCYWNrZ3JpZC5Db2x1bW4+fEFycmF5LjxPYmplY3Q+fSBvcHRpb25zLmNvbHVtbnMgQ29sdW1uIG1ldGFkYXRhLlxyXG4gICAgIEBwYXJhbSB7QmFja2JvbmUuQ29sbGVjdGlvbn0gb3B0aW9ucy5jb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIG9mIHRhYnVsYXIgbW9kZWwgZGF0YSB0byBkaXNwbGF5LlxyXG4gICAgIEBwYXJhbSB7QmFja2dyaWQuSGVhZGVyfSBbb3B0aW9ucy5oZWFkZXI9QmFja2dyaWQuSGVhZGVyXSBBbiBvcHRpb25hbCBIZWFkZXIgY2xhc3MgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQuXHJcbiAgICAgQHBhcmFtIHtCYWNrZ3JpZC5Cb2R5fSBbb3B0aW9ucy5ib2R5PUJhY2tncmlkLkJvZHldIEFuIG9wdGlvbmFsIEJvZHkgY2xhc3MgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQuXHJcbiAgICAgQHBhcmFtIHtCYWNrZ3JpZC5Sb3d9IFtvcHRpb25zLnJvdz1CYWNrZ3JpZC5Sb3ddIEFuIG9wdGlvbmFsIFJvdyBjbGFzcyB0byBvdmVycmlkZSB0aGUgZGVmYXVsdC5cclxuICAgICBAcGFyYW0ge0JhY2tncmlkLkZvb3Rlcn0gW29wdGlvbnMuZm9vdGVyPUJhY2tncmlkLkZvb3Rlcl0gQW4gb3B0aW9uYWwgRm9vdGVyIGNsYXNzLlxyXG4gICAqL1xyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAvLyBDb252ZXJ0IHRoZSBsaXN0IG9mIGNvbHVtbiBvYmplY3RzIGhlcmUgZmlyc3Qgc28gdGhlIHN1YnZpZXdzIGRvbid0IGhhdmVcclxuICAgIC8vIHRvLlxyXG4gICAgaWYgKCEob3B0aW9ucy5jb2x1bW5zIGluc3RhbmNlb2YgQmFja2JvbmUuQ29sbGVjdGlvbikpIHtcclxuICAgICAgb3B0aW9ucy5jb2x1bW5zID0gbmV3IENvbHVtbnMob3B0aW9ucy5jb2x1bW5zKTtcclxuICAgIH1cclxuICAgIHRoaXMuY29sdW1ucyA9IG9wdGlvbnMuY29sdW1ucztcclxuXHJcbiAgICB2YXIgZmlsdGVyZWRPcHRpb25zID0gXy5vbWl0KG9wdGlvbnMsIFtcImVsXCIsIFwiaWRcIiwgXCJhdHRyaWJ1dGVzXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzTmFtZVwiLCBcInRhZ05hbWVcIiwgXCJldmVudHNcIl0pO1xyXG5cclxuICAgIC8vIG11c3QgY29uc3RydWN0IGJvZHkgZmlyc3Qgc28gaXQgbGlzdGVucyB0byBiYWNrZ3JpZDpzb3J0IGZpcnN0XHJcbiAgICB0aGlzLmJvZHkgPSBvcHRpb25zLmJvZHkgfHwgdGhpcy5ib2R5O1xyXG4gICAgdGhpcy5ib2R5ID0gbmV3IHRoaXMuYm9keShmaWx0ZXJlZE9wdGlvbnMpO1xyXG5cclxuICAgIHRoaXMuaGVhZGVyID0gb3B0aW9ucy5oZWFkZXIgfHwgdGhpcy5oZWFkZXI7XHJcbiAgICBpZiAodGhpcy5oZWFkZXIpIHtcclxuICAgICAgdGhpcy5oZWFkZXIgPSBuZXcgdGhpcy5oZWFkZXIoZmlsdGVyZWRPcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLmZvb3RlciA9IG9wdGlvbnMuZm9vdGVyIHx8IHRoaXMuZm9vdGVyO1xyXG4gICAgaWYgKHRoaXMuZm9vdGVyKSB7XHJcbiAgICAgIHRoaXMuZm9vdGVyID0gbmV3IHRoaXMuZm9vdGVyKGZpbHRlcmVkT3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmNvbHVtbnMsIFwicmVzZXRcIiwgZnVuY3Rpb24gKCkge1xyXG4gICAgICBpZiAodGhpcy5oZWFkZXIpIHtcclxuICAgICAgICB0aGlzLmhlYWRlciA9IG5ldyAodGhpcy5oZWFkZXIucmVtb3ZlKCkuY29uc3RydWN0b3IpKGZpbHRlcmVkT3B0aW9ucyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5ib2R5ID0gbmV3ICh0aGlzLmJvZHkucmVtb3ZlKCkuY29uc3RydWN0b3IpKGZpbHRlcmVkT3B0aW9ucyk7XHJcbiAgICAgIGlmICh0aGlzLmZvb3Rlcikge1xyXG4gICAgICAgIHRoaXMuZm9vdGVyID0gbmV3ICh0aGlzLmZvb3Rlci5yZW1vdmUoKS5jb25zdHJ1Y3RvcikoZmlsdGVyZWRPcHRpb25zKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgRGVsZWdhdGVzIHRvIEJhY2tncmlkLkJvZHkjaW5zZXJ0Um93LlxyXG4gICAqL1xyXG4gIGluc2VydFJvdzogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5ib2R5Lmluc2VydFJvdy5hcHBseSh0aGlzLmJvZHksIGFyZ3VtZW50cyk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICAvKipcclxuICAgICBEZWxlZ2F0ZXMgdG8gQmFja2dyaWQuQm9keSNyZW1vdmVSb3cuXHJcbiAgICovXHJcbiAgcmVtb3ZlUm93OiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmJvZHkucmVtb3ZlUm93LmFwcGx5KHRoaXMuYm9keSwgYXJndW1lbnRzKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIERlbGVnYXRlcyB0byBCYWNrZ3JpZC5Db2x1bW5zI2FkZCBmb3IgYWRkaW5nIGEgY29sdW1uLiBTdWJ2aWV3cyBjYW4gbGlzdGVuXHJcbiAgICAgdG8gdGhlIGBhZGRgIGV2ZW50IGZyb20gdGhlaXIgaW50ZXJuYWwgYGNvbHVtbnNgIGlmIHJlcmVuZGVyaW5nIG5lZWRzIHRvXHJcbiAgICAgaGFwcGVuLlxyXG5cclxuICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIGBCYWNrZ3JpZC5Db2x1bW5zI2FkZGAuXHJcbiAgICovXHJcbiAgaW5zZXJ0Q29sdW1uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmNvbHVtbnMuYWRkLmFwcGx5KHRoaXMuY29sdW1ucywgYXJndW1lbnRzKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIERlbGVnYXRlcyB0byBCYWNrZ3JpZC5Db2x1bW5zI3JlbW92ZSBmb3IgcmVtb3ZpbmcgYSBjb2x1bW4uIFN1YnZpZXdzIGNhblxyXG4gICAgIGxpc3RlbiB0byB0aGUgYHJlbW92ZWAgZXZlbnQgZnJvbSB0aGUgaW50ZXJuYWwgYGNvbHVtbnNgIGlmIHJlcmVuZGVyaW5nXHJcbiAgICAgbmVlZHMgdG8gaGFwcGVuLlxyXG5cclxuICAgICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgZm9yIGBCYWNrZ3JpZC5Db2x1bW5zI3JlbW92ZWAuXHJcbiAgICovXHJcbiAgcmVtb3ZlQ29sdW1uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmNvbHVtbnMucmVtb3ZlLmFwcGx5KHRoaXMuY29sdW1ucywgYXJndW1lbnRzKTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIERlbGVnYXRlcyB0byBCYWNrZ3JpZC5Cb2R5I3NvcnQuXHJcbiAgICovXHJcbiAgc29ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5ib2R5LnNvcnQuYXBwbHkodGhpcy5ib2R5LCBhcmd1bWVudHMpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfSxcclxuXHJcbiAgLyoqXHJcbiAgICAgUmVuZGVycyB0aGUgZ3JpZCdzIGhlYWRlciwgdGhlbiBmb290ZXIsIHRoZW4gZmluYWxseSB0aGUgYm9keS4gVHJpZ2dlcnMgYVxyXG4gICAgIEJhY2tib25lIGBiYWNrZ3JpZDpyZW5kZXJlZGAgZXZlbnQgYWxvbmcgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgZ3JpZCB3aGVuXHJcbiAgICAgdGhlIGl0IGhhcyBzdWNjZXNzZnVsbHkgYmVlbiByZW5kZXJlZC5cclxuICAgKi9cclxuICByZW5kZXI6IGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMuJGVsLmVtcHR5KCk7XHJcblxyXG4gICAgaWYgKHRoaXMuaGVhZGVyKSB7XHJcbiAgICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLmhlYWRlci5yZW5kZXIoKS4kZWwpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLmZvb3Rlcikge1xyXG4gICAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy5mb290ZXIucmVuZGVyKCkuJGVsKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLiRlbC5hcHBlbmQodGhpcy5ib2R5LnJlbmRlcigpLiRlbCk7XHJcblxyXG4gICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xyXG5cclxuICAgIHRoaXMudHJpZ2dlcihcImJhY2tncmlkOnJlbmRlcmVkXCIsIHRoaXMpO1xyXG5cclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH0sXHJcblxyXG4gIC8qKlxyXG4gICAgIENsZWFuIHVwIHRoaXMgZ3JpZCBhbmQgaXRzIHN1YnZpZXdzLlxyXG5cclxuICAgICBAY2hhaW5hYmxlXHJcbiAgICovXHJcbiAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmhlYWRlciAmJiB0aGlzLmhlYWRlci5yZW1vdmUuYXBwbHkodGhpcy5oZWFkZXIsIGFyZ3VtZW50cyk7XHJcbiAgICB0aGlzLmJvZHkucmVtb3ZlLmFwcGx5KHRoaXMuYm9keSwgYXJndW1lbnRzKTtcclxuICAgIHRoaXMuZm9vdGVyICYmIHRoaXMuZm9vdGVyLnJlbW92ZS5hcHBseSh0aGlzLmZvb3RlciwgYXJndW1lbnRzKTtcclxuICAgIHJldHVybiBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG59KTtcclxuICByZXR1cm4gQmFja2dyaWQ7XHJcbn0pKTsiLCIvLyAgICAgVW5kZXJzY29yZS5qcyAxLjUuMlxyXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcclxuLy8gICAgIChjKSAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcclxuLy8gICAgIFVuZGVyc2NvcmUgbWF5IGJlIGZyZWVseSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcblxyXG4oZnVuY3Rpb24oKSB7XHJcblxyXG4gIC8vIEJhc2VsaW5lIHNldHVwXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxyXG4gIHZhciByb290ID0gdGhpcztcclxuXHJcbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cclxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xyXG5cclxuICAvLyBFc3RhYmxpc2ggdGhlIG9iamVjdCB0aGF0IGdldHMgcmV0dXJuZWQgdG8gYnJlYWsgb3V0IG9mIGEgbG9vcCBpdGVyYXRpb24uXHJcbiAgdmFyIGJyZWFrZXIgPSB7fTtcclxuXHJcbiAgLy8gU2F2ZSBieXRlcyBpbiB0aGUgbWluaWZpZWQgKGJ1dCBub3QgZ3ppcHBlZCkgdmVyc2lvbjpcclxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XHJcblxyXG4gIC8vIENyZWF0ZSBxdWljayByZWZlcmVuY2UgdmFyaWFibGVzIGZvciBzcGVlZCBhY2Nlc3MgdG8gY29yZSBwcm90b3R5cGVzLlxyXG4gIHZhclxyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcclxuICAgIHNsaWNlICAgICAgICAgICAgPSBBcnJheVByb3RvLnNsaWNlLFxyXG4gICAgY29uY2F0ICAgICAgICAgICA9IEFycmF5UHJvdG8uY29uY2F0LFxyXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxyXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xyXG5cclxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcclxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cclxuICB2YXJcclxuICAgIG5hdGl2ZUZvckVhY2ggICAgICA9IEFycmF5UHJvdG8uZm9yRWFjaCxcclxuICAgIG5hdGl2ZU1hcCAgICAgICAgICA9IEFycmF5UHJvdG8ubWFwLFxyXG4gICAgbmF0aXZlUmVkdWNlICAgICAgID0gQXJyYXlQcm90by5yZWR1Y2UsXHJcbiAgICBuYXRpdmVSZWR1Y2VSaWdodCAgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0LFxyXG4gICAgbmF0aXZlRmlsdGVyICAgICAgID0gQXJyYXlQcm90by5maWx0ZXIsXHJcbiAgICBuYXRpdmVFdmVyeSAgICAgICAgPSBBcnJheVByb3RvLmV2ZXJ5LFxyXG4gICAgbmF0aXZlU29tZSAgICAgICAgID0gQXJyYXlQcm90by5zb21lLFxyXG4gICAgbmF0aXZlSW5kZXhPZiAgICAgID0gQXJyYXlQcm90by5pbmRleE9mLFxyXG4gICAgbmF0aXZlTGFzdEluZGV4T2YgID0gQXJyYXlQcm90by5sYXN0SW5kZXhPZixcclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXHJcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcclxuICAgIG5hdGl2ZUJpbmQgICAgICAgICA9IEZ1bmNQcm90by5iaW5kO1xyXG5cclxuICAvLyBDcmVhdGUgYSBzYWZlIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yIHVzZSBiZWxvdy5cclxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XHJcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgXykpIHJldHVybiBuZXcgXyhvYmopO1xyXG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcclxuICB9O1xyXG5cclxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxyXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cclxuICAvLyB0aGUgYnJvd3NlciwgYWRkIGBfYCBhcyBhIGdsb2JhbCBvYmplY3QgdmlhIGEgc3RyaW5nIGlkZW50aWZpZXIsXHJcbiAgLy8gZm9yIENsb3N1cmUgQ29tcGlsZXIgXCJhZHZhbmNlZFwiIG1vZGUuXHJcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XHJcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF87XHJcbiAgICB9XHJcbiAgICBleHBvcnRzLl8gPSBfO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByb290Ll8gPSBfO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxyXG4gIF8uVkVSU0lPTiA9ICcxLjUuMic7XHJcblxyXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXHJcbiAgLy8gSGFuZGxlcyBvYmplY3RzIHdpdGggdGhlIGJ1aWx0LWluIGBmb3JFYWNoYCwgYXJyYXlzLCBhbmQgcmF3IG9iamVjdHMuXHJcbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGZvckVhY2hgIGlmIGF2YWlsYWJsZS5cclxuICB2YXIgZWFjaCA9IF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcclxuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgaWYgKG5hdGl2ZUZvckVhY2ggJiYgb2JqLmZvckVhY2ggPT09IG5hdGl2ZUZvckVhY2gpIHtcclxuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xyXG4gICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdG9yIHRvIGVhY2ggZWxlbWVudC5cclxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbWFwYCBpZiBhdmFpbGFibGUuXHJcbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0cztcclxuICAgIGlmIChuYXRpdmVNYXAgJiYgb2JqLm1hcCA9PT0gbmF0aXZlTWFwKSByZXR1cm4gb2JqLm1hcChpdGVyYXRvciwgY29udGV4dCk7XHJcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgIHJlc3VsdHMucHVzaChpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9O1xyXG5cclxuICB2YXIgcmVkdWNlRXJyb3IgPSAnUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZSc7XHJcblxyXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcclxuICAvLyBvciBgZm9sZGxgLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgcmVkdWNlYCBpZiBhdmFpbGFibGUuXHJcbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBtZW1vLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgaW5pdGlhbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xyXG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcclxuICAgIGlmIChuYXRpdmVSZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XHJcbiAgICAgIGlmIChjb250ZXh0KSBpdGVyYXRvciA9IF8uYmluZChpdGVyYXRvciwgY29udGV4dCk7XHJcbiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZShpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlKGl0ZXJhdG9yKTtcclxuICAgIH1cclxuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgICAgaWYgKCFpbml0aWFsKSB7XHJcbiAgICAgICAgbWVtbyA9IHZhbHVlO1xyXG4gICAgICAgIGluaXRpYWwgPSB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG1lbW8gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG1lbW8sIHZhbHVlLCBpbmRleCwgbGlzdCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaWYgKCFpbml0aWFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcclxuICAgIHJldHVybiBtZW1vO1xyXG4gIH07XHJcblxyXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxyXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGByZWR1Y2VSaWdodGAgaWYgYXZhaWxhYmxlLlxyXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xyXG4gICAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcclxuICAgIGlmIChvYmogPT0gbnVsbCkgb2JqID0gW107XHJcbiAgICBpZiAobmF0aXZlUmVkdWNlUmlnaHQgJiYgb2JqLnJlZHVjZVJpZ2h0ID09PSBuYXRpdmVSZWR1Y2VSaWdodCkge1xyXG4gICAgICBpZiAoY29udGV4dCkgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpO1xyXG4gICAgICByZXR1cm4gaW5pdGlhbCA/IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvciwgbWVtbykgOiBvYmoucmVkdWNlUmlnaHQoaXRlcmF0b3IpO1xyXG4gICAgfVxyXG4gICAgdmFyIGxlbmd0aCA9IG9iai5sZW5ndGg7XHJcbiAgICBpZiAobGVuZ3RoICE9PSArbGVuZ3RoKSB7XHJcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XHJcbiAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICBpbmRleCA9IGtleXMgPyBrZXlzWy0tbGVuZ3RoXSA6IC0tbGVuZ3RoO1xyXG4gICAgICBpZiAoIWluaXRpYWwpIHtcclxuICAgICAgICBtZW1vID0gb2JqW2luZGV4XTtcclxuICAgICAgICBpbml0aWFsID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaW5kZXhdLCBpbmRleCwgbGlzdCk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgaWYgKCFpbml0aWFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcclxuICAgIHJldHVybiBtZW1vO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiB0aGUgZmlyc3QgdmFsdWUgd2hpY2ggcGFzc2VzIGEgdHJ1dGggdGVzdC4gQWxpYXNlZCBhcyBgZGV0ZWN0YC5cclxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSkge1xyXG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cclxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZmlsdGVyYCBpZiBhdmFpbGFibGUuXHJcbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cclxuICBfLmZpbHRlciA9IF8uc2VsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xyXG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcclxuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICBpZiAobmF0aXZlRmlsdGVyICYmIG9iai5maWx0ZXIgPT09IG5hdGl2ZUZpbHRlcikgcmV0dXJuIG9iai5maWx0ZXIoaXRlcmF0b3IsIGNvbnRleHQpO1xyXG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0cztcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxyXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xyXG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgIHJldHVybiAhaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xyXG4gICAgfSwgY29udGV4dCk7XHJcbiAgfTtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXHJcbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGV2ZXJ5YCBpZiBhdmFpbGFibGUuXHJcbiAgLy8gQWxpYXNlZCBhcyBgYWxsYC5cclxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XHJcbiAgICBpdGVyYXRvciB8fCAoaXRlcmF0b3IgPSBfLmlkZW50aXR5KTtcclxuICAgIHZhciByZXN1bHQgPSB0cnVlO1xyXG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xyXG4gICAgaWYgKG5hdGl2ZUV2ZXJ5ICYmIG9iai5ldmVyeSA9PT0gbmF0aXZlRXZlcnkpIHJldHVybiBvYmouZXZlcnkoaXRlcmF0b3IsIGNvbnRleHQpO1xyXG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICBpZiAoIShyZXN1bHQgPSByZXN1bHQgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAhIXJlc3VsdDtcclxuICB9O1xyXG5cclxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cclxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgc29tZWAgaWYgYXZhaWxhYmxlLlxyXG4gIC8vIEFsaWFzZWQgYXMgYGFueWAuXHJcbiAgdmFyIGFueSA9IF8uc29tZSA9IF8uYW55ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xyXG4gICAgaXRlcmF0b3IgfHwgKGl0ZXJhdG9yID0gXy5pZGVudGl0eSk7XHJcbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XHJcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XHJcbiAgICBpZiAobmF0aXZlU29tZSAmJiBvYmouc29tZSA9PT0gbmF0aXZlU29tZSkgcmV0dXJuIG9iai5zb21lKGl0ZXJhdG9yLCBjb250ZXh0KTtcclxuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcclxuICAgICAgaWYgKHJlc3VsdCB8fCAocmVzdWx0ID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiAhIXJlc3VsdDtcclxuICB9O1xyXG5cclxuICAvLyBEZXRlcm1pbmUgaWYgdGhlIGFycmF5IG9yIG9iamVjdCBjb250YWlucyBhIGdpdmVuIHZhbHVlICh1c2luZyBgPT09YCkuXHJcbiAgLy8gQWxpYXNlZCBhcyBgaW5jbHVkZWAuXHJcbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0KSB7XHJcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIG9iai5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gb2JqLmluZGV4T2YodGFyZ2V0KSAhPSAtMTtcclxuICAgIHJldHVybiBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRhcmdldDtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxyXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcclxuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xyXG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xyXG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgcmV0dXJuIChpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdKS5hcHBseSh2YWx1ZSwgYXJncyk7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxyXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xyXG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpeyByZXR1cm4gdmFsdWVba2V5XTsgfSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xyXG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXHJcbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMsIGZpcnN0KSB7XHJcbiAgICBpZiAoXy5pc0VtcHR5KGF0dHJzKSkgcmV0dXJuIGZpcnN0ID8gdm9pZCAwIDogW107XHJcbiAgICByZXR1cm4gX1tmaXJzdCA/ICdmaW5kJyA6ICdmaWx0ZXInXShvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBhdHRycykge1xyXG4gICAgICAgIGlmIChhdHRyc1trZXldICE9PSB2YWx1ZVtrZXldKSByZXR1cm4gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9KTtcclxuICB9O1xyXG5cclxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XHJcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cclxuICBfLmZpbmRXaGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcclxuICAgIHJldHVybiBfLndoZXJlKG9iaiwgYXR0cnMsIHRydWUpO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IG9yIChlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cclxuICAvLyBDYW4ndCBvcHRpbWl6ZSBhcnJheXMgb2YgaW50ZWdlcnMgbG9uZ2VyIHRoYW4gNjUsNTM1IGVsZW1lbnRzLlxyXG4gIC8vIFNlZSBbV2ViS2l0IEJ1ZyA4MDc5N10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTgwNzk3KVxyXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xyXG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzQXJyYXkob2JqKSAmJiBvYmpbMF0gPT09ICtvYmpbMF0gJiYgb2JqLmxlbmd0aCA8IDY1NTM1KSB7XHJcbiAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBvYmopO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpdGVyYXRvciAmJiBfLmlzRW1wdHkob2JqKSkgcmV0dXJuIC1JbmZpbml0eTtcclxuICAgIHZhciByZXN1bHQgPSB7Y29tcHV0ZWQgOiAtSW5maW5pdHksIHZhbHVlOiAtSW5maW5pdHl9O1xyXG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICB2YXIgY29tcHV0ZWQgPSBpdGVyYXRvciA/IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KSA6IHZhbHVlO1xyXG4gICAgICBjb21wdXRlZCA+IHJlc3VsdC5jb21wdXRlZCAmJiAocmVzdWx0ID0ge3ZhbHVlIDogdmFsdWUsIGNvbXB1dGVkIDogY29tcHV0ZWR9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXHJcbiAgXy5taW4gPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XHJcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopICYmIG9ialswXSA9PT0gK29ialswXSAmJiBvYmoubGVuZ3RoIDwgNjU1MzUpIHtcclxuICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIG9iaik7XHJcbiAgICB9XHJcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNFbXB0eShvYmopKSByZXR1cm4gSW5maW5pdHk7XHJcbiAgICB2YXIgcmVzdWx0ID0ge2NvbXB1dGVkIDogSW5maW5pdHksIHZhbHVlOiBJbmZpbml0eX07XHJcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XHJcbiAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdG9yID8gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpIDogdmFsdWU7XHJcbiAgICAgIGNvbXB1dGVkIDwgcmVzdWx0LmNvbXB1dGVkICYmIChyZXN1bHQgPSB7dmFsdWUgOiB2YWx1ZSwgY29tcHV0ZWQgOiBjb21wdXRlZH0pO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xyXG4gIH07XHJcblxyXG4gIC8vIFNodWZmbGUgYW4gYXJyYXksIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGUgXHJcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxyXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgdmFyIHJhbmQ7XHJcbiAgICB2YXIgaW5kZXggPSAwO1xyXG4gICAgdmFyIHNodWZmbGVkID0gW107XHJcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcclxuICAgICAgcmFuZCA9IF8ucmFuZG9tKGluZGV4KyspO1xyXG4gICAgICBzaHVmZmxlZFtpbmRleCAtIDFdID0gc2h1ZmZsZWRbcmFuZF07XHJcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gdmFsdWU7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzaHVmZmxlZDtcclxuICB9O1xyXG5cclxuICAvLyBTYW1wbGUgKipuKiogcmFuZG9tIHZhbHVlcyBmcm9tIGFuIGFycmF5LlxyXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQgZnJvbSB0aGUgYXJyYXkuXHJcbiAgLy8gVGhlIGludGVybmFsIGBndWFyZGAgYXJndW1lbnQgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgbWFwYC5cclxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMiB8fCBndWFyZCkge1xyXG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gXy5zaHVmZmxlKG9iaikuc2xpY2UoMCwgTWF0aC5tYXgoMCwgbikpO1xyXG4gIH07XHJcblxyXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGxvb2t1cCBpdGVyYXRvcnMuXHJcbiAgdmFyIGxvb2t1cEl0ZXJhdG9yID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiBmdW5jdGlvbihvYmopeyByZXR1cm4gb2JqW3ZhbHVlXTsgfTtcclxuICB9O1xyXG5cclxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0b3IuXHJcbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIHZhbHVlLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgaXRlcmF0b3IgPSBsb29rdXBJdGVyYXRvcih2YWx1ZSk7XHJcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcclxuICAgICAgICBpbmRleDogaW5kZXgsXHJcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KVxyXG4gICAgICB9O1xyXG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xyXG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XHJcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XHJcbiAgICAgIGlmIChhICE9PSBiKSB7XHJcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XHJcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IC0gcmlnaHQuaW5kZXg7XHJcbiAgICB9KSwgJ3ZhbHVlJyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxyXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCB2YWx1ZSwgY29udGV4dCkge1xyXG4gICAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICAgIHZhciBpdGVyYXRvciA9IHZhbHVlID09IG51bGwgPyBfLmlkZW50aXR5IDogbG9va3VwSXRlcmF0b3IodmFsdWUpO1xyXG4gICAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XHJcbiAgICAgICAgdmFyIGtleSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBvYmopO1xyXG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwga2V5LCB2YWx1ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXHJcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXHJcbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCBrZXksIHZhbHVlKSB7XHJcbiAgICAoXy5oYXMocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0gOiAocmVzdWx0W2tleV0gPSBbXSkpLnB1c2godmFsdWUpO1xyXG4gIH0pO1xyXG5cclxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXHJcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxyXG4gIF8uaW5kZXhCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwga2V5LCB2YWx1ZSkge1xyXG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcclxuICB9KTtcclxuXHJcbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXHJcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXHJcbiAgLy8gY3JpdGVyaW9uLlxyXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwga2V5KSB7XHJcbiAgICBfLmhhcyhyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSsrIDogcmVzdWx0W2tleV0gPSAxO1xyXG4gIH0pO1xyXG5cclxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXHJcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxyXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xyXG4gICAgaXRlcmF0b3IgPSBpdGVyYXRvciA9PSBudWxsID8gXy5pZGVudGl0eSA6IGxvb2t1cEl0ZXJhdG9yKGl0ZXJhdG9yKTtcclxuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqKTtcclxuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkubGVuZ3RoO1xyXG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcclxuICAgICAgdmFyIG1pZCA9IChsb3cgKyBoaWdoKSA+Pj4gMTtcclxuICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVttaWRdKSA8IHZhbHVlID8gbG93ID0gbWlkICsgMSA6IGhpZ2ggPSBtaWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbG93O1xyXG4gIH07XHJcblxyXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXHJcbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xyXG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xyXG4gICAgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcclxuICAgIHJldHVybiBfLnZhbHVlcyhvYmopO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybiB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIGFuIG9iamVjdC5cclxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XHJcbiAgICByZXR1cm4gKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSA/IG9iai5sZW5ndGggOiBfLmtleXMob2JqKS5sZW5ndGg7XHJcbiAgfTtcclxuXHJcbiAgLy8gQXJyYXkgRnVuY3Rpb25zXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxyXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcclxuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXHJcbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xyXG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XHJcbiAgICByZXR1cm4gKG4gPT0gbnVsbCkgfHwgZ3VhcmQgPyBhcnJheVswXSA6IHNsaWNlLmNhbGwoYXJyYXksIDAsIG4pO1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxyXG4gIC8vIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIGFsbCB0aGUgdmFsdWVzIGluXHJcbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoXHJcbiAgLy8gYF8ubWFwYC5cclxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcclxuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAoKG4gPT0gbnVsbCkgfHwgZ3VhcmQgPyAxIDogbikpO1xyXG4gIH07XHJcblxyXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cclxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqIGNoZWNrIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cclxuICBfLmxhc3QgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcclxuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xyXG4gICAgaWYgKChuID09IG51bGwpIHx8IGd1YXJkKSB7XHJcbiAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBNYXRoLm1heChhcnJheS5sZW5ndGggLSBuLCAwKSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxyXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXHJcbiAgLy8gdGhlIHJlc3QgTiB2YWx1ZXMgaW4gdGhlIGFycmF5LiBUaGUgKipndWFyZCoqXHJcbiAgLy8gY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxyXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xyXG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIChuID09IG51bGwpIHx8IGd1YXJkID8gMSA6IG4pO1xyXG4gIH07XHJcblxyXG4gIC8vIFRyaW0gb3V0IGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBhbiBhcnJheS5cclxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xyXG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcclxuICB9O1xyXG5cclxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXHJcbiAgdmFyIGZsYXR0ZW4gPSBmdW5jdGlvbihpbnB1dCwgc2hhbGxvdywgb3V0cHV0KSB7XHJcbiAgICBpZiAoc2hhbGxvdyAmJiBfLmV2ZXJ5KGlucHV0LCBfLmlzQXJyYXkpKSB7XHJcbiAgICAgIHJldHVybiBjb25jYXQuYXBwbHkob3V0cHV0LCBpbnB1dCk7XHJcbiAgICB9XHJcbiAgICBlYWNoKGlucHV0LCBmdW5jdGlvbih2YWx1ZSkge1xyXG4gICAgICBpZiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkge1xyXG4gICAgICAgIHNoYWxsb3cgPyBwdXNoLmFwcGx5KG91dHB1dCwgdmFsdWUpIDogZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgb3V0cHV0KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG91dHB1dDtcclxuICB9O1xyXG5cclxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXHJcbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcclxuICAgIHJldHVybiBmbGF0dGVuKGFycmF5LCBzaGFsbG93LCBbXSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIGEgdmVyc2lvbiBvZiB0aGUgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBzcGVjaWZpZWQgdmFsdWUocykuXHJcbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcclxuICAvLyBiZWVuIHNvcnRlZCwgeW91IGhhdmUgdGhlIG9wdGlvbiBvZiB1c2luZyBhIGZhc3RlciBhbGdvcml0aG0uXHJcbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cclxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcclxuICAgIGlmIChfLmlzRnVuY3Rpb24oaXNTb3J0ZWQpKSB7XHJcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRvcjtcclxuICAgICAgaXRlcmF0b3IgPSBpc1NvcnRlZDtcclxuICAgICAgaXNTb3J0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHZhciBpbml0aWFsID0gaXRlcmF0b3IgPyBfLm1hcChhcnJheSwgaXRlcmF0b3IsIGNvbnRleHQpIDogYXJyYXk7XHJcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gICAgdmFyIHNlZW4gPSBbXTtcclxuICAgIGVhY2goaW5pdGlhbCwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XHJcbiAgICAgIGlmIChpc1NvcnRlZCA/ICghaW5kZXggfHwgc2VlbltzZWVuLmxlbmd0aCAtIDFdICE9PSB2YWx1ZSkgOiAhXy5jb250YWlucyhzZWVuLCB2YWx1ZSkpIHtcclxuICAgICAgICBzZWVuLnB1c2godmFsdWUpO1xyXG4gICAgICAgIHJlc3VsdHMucHVzaChhcnJheVtpbmRleF0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHRzO1xyXG4gIH07XHJcblxyXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxyXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxyXG4gIF8udW5pb24gPSBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiBfLnVuaXEoXy5mbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSkpO1xyXG4gIH07XHJcblxyXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcclxuICAvLyBwYXNzZWQtaW4gYXJyYXlzLlxyXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcclxuICAgIHZhciByZXN0ID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xyXG4gICAgcmV0dXJuIF8uZmlsdGVyKF8udW5pcShhcnJheSksIGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgcmV0dXJuIF8uZXZlcnkocmVzdCwgZnVuY3Rpb24ob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gXy5pbmRleE9mKG90aGVyLCBpdGVtKSA+PSAwO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cclxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxyXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XHJcbiAgICB2YXIgcmVzdCA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7IH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcclxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cclxuICBfLnppcCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIGxlbmd0aCA9IF8ubWF4KF8ucGx1Y2soYXJndW1lbnRzLCBcImxlbmd0aFwiKS5jb25jYXQoMCkpO1xyXG4gICAgdmFyIHJlc3VsdHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgcmVzdWx0c1tpXSA9IF8ucGx1Y2soYXJndW1lbnRzLCAnJyArIGkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxyXG4gIC8vIHBhaXJzLCBvciB0d28gcGFyYWxsZWwgYXJyYXlzIG9mIHRoZSBzYW1lIGxlbmd0aCAtLSBvbmUgb2Yga2V5cywgYW5kIG9uZSBvZlxyXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cclxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xyXG4gICAgaWYgKGxpc3QgPT0gbnVsbCkgcmV0dXJuIHt9O1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHZhbHVlcykge1xyXG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH07XHJcblxyXG4gIC8vIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcGx5IHVzIHdpdGggaW5kZXhPZiAoSSdtIGxvb2tpbmcgYXQgeW91LCAqKk1TSUUqKiksXHJcbiAgLy8gd2UgbmVlZCB0aGlzIGZ1bmN0aW9uLiBSZXR1cm4gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGFuXHJcbiAgLy8gaXRlbSBpbiBhbiBhcnJheSwgb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cclxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgaW5kZXhPZmAgaWYgYXZhaWxhYmxlLlxyXG4gIC8vIElmIHRoZSBhcnJheSBpcyBsYXJnZSBhbmQgYWxyZWFkeSBpbiBzb3J0IG9yZGVyLCBwYXNzIGB0cnVlYFxyXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXHJcbiAgXy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlzU29ydGVkKSB7XHJcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xyXG4gICAgdmFyIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XHJcbiAgICBpZiAoaXNTb3J0ZWQpIHtcclxuICAgICAgaWYgKHR5cGVvZiBpc1NvcnRlZCA9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGkgPSAoaXNTb3J0ZWQgPCAwID8gTWF0aC5tYXgoMCwgbGVuZ3RoICsgaXNTb3J0ZWQpIDogaXNTb3J0ZWQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcclxuICAgICAgICByZXR1cm4gYXJyYXlbaV0gPT09IGl0ZW0gPyBpIDogLTE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChuYXRpdmVJbmRleE9mICYmIGFycmF5LmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0sIGlzU29ydGVkKTtcclxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfTtcclxuXHJcbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYGxhc3RJbmRleE9mYCBpZiBhdmFpbGFibGUuXHJcbiAgXy5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBmcm9tKSB7XHJcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xyXG4gICAgdmFyIGhhc0luZGV4ID0gZnJvbSAhPSBudWxsO1xyXG4gICAgaWYgKG5hdGl2ZUxhc3RJbmRleE9mICYmIGFycmF5Lmxhc3RJbmRleE9mID09PSBuYXRpdmVMYXN0SW5kZXhPZikge1xyXG4gICAgICByZXR1cm4gaGFzSW5kZXggPyBhcnJheS5sYXN0SW5kZXhPZihpdGVtLCBmcm9tKSA6IGFycmF5Lmxhc3RJbmRleE9mKGl0ZW0pO1xyXG4gICAgfVxyXG4gICAgdmFyIGkgPSAoaGFzSW5kZXggPyBmcm9tIDogYXJyYXkubGVuZ3RoKTtcclxuICAgIHdoaWxlIChpLS0pIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfTtcclxuXHJcbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxyXG4gIC8vIHRoZSBuYXRpdmUgUHl0aG9uIGByYW5nZSgpYCBmdW5jdGlvbi4gU2VlXHJcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cclxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcclxuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XHJcbiAgICAgIHN0YXJ0ID0gMDtcclxuICAgIH1cclxuICAgIHN0ZXAgPSBhcmd1bWVudHNbMl0gfHwgMTtcclxuXHJcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xyXG4gICAgdmFyIGlkeCA9IDA7XHJcbiAgICB2YXIgcmFuZ2UgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuXHJcbiAgICB3aGlsZShpZHggPCBsZW5ndGgpIHtcclxuICAgICAgcmFuZ2VbaWR4KytdID0gc3RhcnQ7XHJcbiAgICAgIHN0YXJ0ICs9IHN0ZXA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJhbmdlO1xyXG4gIH07XHJcblxyXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgLy8gUmV1c2FibGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHByb3RvdHlwZSBzZXR0aW5nLlxyXG4gIHZhciBjdG9yID0gZnVuY3Rpb24oKXt9O1xyXG5cclxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcclxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXHJcbiAgLy8gYXZhaWxhYmxlLlxyXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcclxuICAgIHZhciBhcmdzLCBib3VuZDtcclxuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yO1xyXG4gICAgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcclxuICAgIHJldHVybiBib3VuZCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYm91bmQpKSByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcclxuICAgICAgdmFyIHNlbGYgPSBuZXcgY3RvcjtcclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBudWxsO1xyXG4gICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShzZWxmLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcclxuICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIHJldHVybiBzZWxmO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXHJcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuXHJcbiAgXy5wYXJ0aWFsID0gZnVuY3Rpb24oZnVuYykge1xyXG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBCaW5kIGFsbCBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXRcclxuICAvLyBhbGwgY2FsbGJhY2tzIGRlZmluZWQgb24gYW4gb2JqZWN0IGJlbG9uZyB0byBpdC5cclxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciBmdW5jcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuICAgIGlmIChmdW5jcy5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcihcImJpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXNcIik7XHJcbiAgICBlYWNoKGZ1bmNzLCBmdW5jdGlvbihmKSB7IG9ialtmXSA9IF8uYmluZChvYmpbZl0sIG9iaik7IH0pO1xyXG4gICAgcmV0dXJuIG9iajtcclxuICB9O1xyXG5cclxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxyXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xyXG4gICAgdmFyIG1lbW8gPSB7fTtcclxuICAgIGhhc2hlciB8fCAoaGFzaGVyID0gXy5pZGVudGl0eSk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBrZXkgPSBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgcmV0dXJuIF8uaGFzKG1lbW8sIGtleSkgPyBtZW1vW2tleV0gOiAobWVtb1trZXldID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xyXG4gIC8vIGl0IHdpdGggdGhlIGFyZ3VtZW50cyBzdXBwbGllZC5cclxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xyXG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XHJcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbigpeyByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTsgfSwgd2FpdCk7XHJcbiAgfTtcclxuXHJcbiAgLy8gRGVmZXJzIGEgZnVuY3Rpb24sIHNjaGVkdWxpbmcgaXQgdG8gcnVuIGFmdGVyIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzXHJcbiAgLy8gY2xlYXJlZC5cclxuICBfLmRlZmVyID0gZnVuY3Rpb24oZnVuYykge1xyXG4gICAgcmV0dXJuIF8uZGVsYXkuYXBwbHkoXywgW2Z1bmMsIDFdLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpKTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcclxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cclxuICAvLyBhcyBtdWNoIGFzIGl0IGNhbiwgd2l0aG91dCBldmVyIGdvaW5nIG1vcmUgdGhhbiBvbmNlIHBlciBgd2FpdGAgZHVyYXRpb247XHJcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcclxuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cclxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgb3B0aW9ucykge1xyXG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcclxuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcclxuICAgIHZhciBwcmV2aW91cyA9IDA7XHJcbiAgICBvcHRpb25zIHx8IChvcHRpb25zID0ge30pO1xyXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBuZXcgRGF0ZTtcclxuICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgbm93ID0gbmV3IERhdGU7XHJcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XHJcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcclxuICAgICAgY29udGV4dCA9IHRoaXM7XHJcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcclxuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICBwcmV2aW91cyA9IG5vdztcclxuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxyXG4gIC8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcclxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxyXG4gIF8uZGVib3VuY2UgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcclxuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcclxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcclxuICAgICAgY29udGV4dCA9IHRoaXM7XHJcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgIHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XHJcbiAgICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHZhciBsYXN0ID0gKG5ldyBEYXRlKCkpIC0gdGltZXN0YW1wO1xyXG4gICAgICAgIGlmIChsYXN0IDwgd2FpdCkge1xyXG4gICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGltZW91dCA9IG51bGw7XHJcbiAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xyXG4gICAgICBpZiAoIXRpbWVvdXQpIHtcclxuICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGNhbGxOb3cpIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xyXG4gIC8vIG9mdGVuIHlvdSBjYWxsIGl0LiBVc2VmdWwgZm9yIGxhenkgaW5pdGlhbGl6YXRpb24uXHJcbiAgXy5vbmNlID0gZnVuY3Rpb24oZnVuYykge1xyXG4gICAgdmFyIHJhbiA9IGZhbHNlLCBtZW1vO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcclxuICAgICAgcmFuID0gdHJ1ZTtcclxuICAgICAgbWVtbyA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgZnVuYyA9IG51bGw7XHJcbiAgICAgIHJldHVybiBtZW1vO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcclxuICAvLyBhbGxvd2luZyB5b3UgdG8gYWRqdXN0IGFyZ3VtZW50cywgcnVuIGNvZGUgYmVmb3JlIGFuZCBhZnRlciwgYW5kXHJcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cclxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBhcmdzID0gW2Z1bmNdO1xyXG4gICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XHJcbiAgICAgIHJldHVybiB3cmFwcGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxyXG4gIC8vIGNvbnN1bWluZyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MuXHJcbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHM7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xyXG4gICAgICBmb3IgKHZhciBpID0gZnVuY3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBhcmdzID0gW2Z1bmNzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gYXJnc1swXTtcclxuICAgIH07XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGFmdGVyIGJlaW5nIGNhbGxlZCBOIHRpbWVzLlxyXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcclxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH07XHJcblxyXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tXHJcblxyXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxyXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBPYmplY3Qua2V5c2BcclxuICBfLmtleXMgPSBuYXRpdmVLZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgaWYgKG9iaiAhPT0gT2JqZWN0KG9iaikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgb2JqZWN0Jyk7XHJcbiAgICB2YXIga2V5cyA9IFtdO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XHJcbiAgICByZXR1cm4ga2V5cztcclxuICB9O1xyXG5cclxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXHJcbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XHJcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICB2YXIgdmFsdWVzID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHZhbHVlc1tpXSA9IG9ialtrZXlzW2ldXTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gQ29udmVydCBhbiBvYmplY3QgaW50byBhIGxpc3Qgb2YgYFtrZXksIHZhbHVlXWAgcGFpcnMuXHJcbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcclxuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuICAgIHZhciBwYWlycyA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhaXJzO1xyXG4gIH07XHJcblxyXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cclxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHJlc3VsdFtvYmpba2V5c1tpXV1dID0ga2V5c1tpXTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxyXG4gIC8vIEFsaWFzZWQgYXMgYG1ldGhvZHNgXHJcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciBuYW1lcyA9IFtdO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5hbWVzLnNvcnQoKTtcclxuICB9O1xyXG5cclxuICAvLyBFeHRlbmQgYSBnaXZlbiBvYmplY3Qgd2l0aCBhbGwgdGhlIHByb3BlcnRpZXMgaW4gcGFzc2VkLWluIG9iamVjdChzKS5cclxuICBfLmV4dGVuZCA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkge1xyXG4gICAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcclxuICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG9iajtcclxuICB9O1xyXG5cclxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxyXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgdmFyIGNvcHkgPSB7fTtcclxuICAgIHZhciBrZXlzID0gY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XHJcbiAgICBlYWNoKGtleXMsIGZ1bmN0aW9uKGtleSkge1xyXG4gICAgICBpZiAoa2V5IGluIG9iaikgY29weVtrZXldID0gb2JqW2tleV07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBjb3B5O1xyXG4gIH07XHJcblxyXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cclxuICBfLm9taXQgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHZhciBjb3B5ID0ge307XHJcbiAgICB2YXIga2V5cyA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xyXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xyXG4gICAgICBpZiAoIV8uY29udGFpbnMoa2V5cywga2V5KSkgY29weVtrZXldID0gb2JqW2tleV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29weTtcclxuICB9O1xyXG5cclxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxyXG4gIF8uZGVmYXVsdHMgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIGVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcclxuICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICBpZiAob2JqW3Byb3BdID09PSB2b2lkIDApIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG9iajtcclxuICB9O1xyXG5cclxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXHJcbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XHJcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xyXG4gIH07XHJcblxyXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cclxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cclxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cclxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcclxuICAgIGludGVyY2VwdG9yKG9iaik7XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXHJcbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcclxuICAgIC8vIElkZW50aWNhbCBvYmplY3RzIGFyZSBlcXVhbC4gYDAgPT09IC0wYCwgYnV0IHRoZXkgYXJlbid0IGlkZW50aWNhbC5cclxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxyXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiO1xyXG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxyXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xyXG4gICAgLy8gVW53cmFwIGFueSB3cmFwcGVkIG9iamVjdHMuXHJcbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xyXG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcclxuICAgIC8vIENvbXBhcmUgYFtbQ2xhc3NdXWAgbmFtZXMuXHJcbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcclxuICAgIGlmIChjbGFzc05hbWUgIT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcclxuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXHJcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XHJcbiAgICAgICAgLy8gUHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3Qgd3JhcHBlcnMgYXJlIGVxdWl2YWxlbnQ7IHRodXMsIGBcIjVcImAgaXNcclxuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXHJcbiAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xyXG4gICAgICBjYXNlICdbb2JqZWN0IE51bWJlcl0nOlxyXG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3JcclxuICAgICAgICAvLyBvdGhlciBudW1lcmljIHZhbHVlcy5cclxuICAgICAgICByZXR1cm4gYSAhPSArYSA/IGIgIT0gK2IgOiAoYSA9PSAwID8gMSAvIGEgPT0gMSAvIGIgOiBhID09ICtiKTtcclxuICAgICAgY2FzZSAnW29iamVjdCBEYXRlXSc6XHJcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxyXG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcclxuICAgICAgICAvLyBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnMuIE5vdGUgdGhhdCBpbnZhbGlkIGRhdGVzIHdpdGggbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zXHJcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxyXG4gICAgICAgIHJldHVybiArYSA9PSArYjtcclxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29tcGFyZWQgYnkgdGhlaXIgc291cmNlIHBhdHRlcm5zIGFuZCBmbGFncy5cclxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcclxuICAgICAgICByZXR1cm4gYS5zb3VyY2UgPT0gYi5zb3VyY2UgJiZcclxuICAgICAgICAgICAgICAgYS5nbG9iYWwgPT0gYi5nbG9iYWwgJiZcclxuICAgICAgICAgICAgICAgYS5tdWx0aWxpbmUgPT0gYi5tdWx0aWxpbmUgJiZcclxuICAgICAgICAgICAgICAgYS5pZ25vcmVDYXNlID09IGIuaWdub3JlQ2FzZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xyXG4gICAgLy8gQXNzdW1lIGVxdWFsaXR5IGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhlIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGN5Y2xpY1xyXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXHJcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcclxuICAgIHdoaWxlIChsZW5ndGgtLSkge1xyXG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcclxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxyXG4gICAgICBpZiAoYVN0YWNrW2xlbmd0aF0gPT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09IGI7XHJcbiAgICB9XHJcbiAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHNcclxuICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXHJcbiAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XHJcbiAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiAoYUN0b3IgaW5zdGFuY2VvZiBhQ3RvcikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIChiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKSkpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxyXG4gICAgYVN0YWNrLnB1c2goYSk7XHJcbiAgICBiU3RhY2sucHVzaChiKTtcclxuICAgIHZhciBzaXplID0gMCwgcmVzdWx0ID0gdHJ1ZTtcclxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxyXG4gICAgaWYgKGNsYXNzTmFtZSA9PSAnW29iamVjdCBBcnJheV0nKSB7XHJcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxyXG4gICAgICBzaXplID0gYS5sZW5ndGg7XHJcbiAgICAgIHJlc3VsdCA9IHNpemUgPT0gYi5sZW5ndGg7XHJcbiAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxyXG4gICAgICAgIHdoaWxlIChzaXplLS0pIHtcclxuICAgICAgICAgIGlmICghKHJlc3VsdCA9IGVxKGFbc2l6ZV0sIGJbc2l6ZV0sIGFTdGFjaywgYlN0YWNrKSkpIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXHJcbiAgICAgIGZvciAodmFyIGtleSBpbiBhKSB7XHJcbiAgICAgICAgaWYgKF8uaGFzKGEsIGtleSkpIHtcclxuICAgICAgICAgIC8vIENvdW50IHRoZSBleHBlY3RlZCBudW1iZXIgb2YgcHJvcGVydGllcy5cclxuICAgICAgICAgIHNpemUrKztcclxuICAgICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlci5cclxuICAgICAgICAgIGlmICghKHJlc3VsdCA9IF8uaGFzKGIsIGtleSkgJiYgZXEoYVtrZXldLCBiW2tleV0sIGFTdGFjaywgYlN0YWNrKSkpIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcy5cclxuICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgIGZvciAoa2V5IGluIGIpIHtcclxuICAgICAgICAgIGlmIChfLmhhcyhiLCBrZXkpICYmICEoc2l6ZS0tKSkgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCA9ICFzaXplO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cclxuICAgIGFTdGFjay5wb3AoKTtcclxuICAgIGJTdGFjay5wb3AoKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXHJcbiAgXy5pc0VxdWFsID0gZnVuY3Rpb24oYSwgYikge1xyXG4gICAgcmV0dXJuIGVxKGEsIGIsIFtdLCBbXSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XHJcbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cclxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XHJcbiAgICBpZiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcclxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cclxuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XHJcbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcclxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xyXG4gIF8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xyXG4gIH07XHJcblxyXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLlxyXG4gIGVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCddLCBmdW5jdGlvbihuYW1lKSB7XHJcbiAgICBfWydpcycgKyBuYW1lXSA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgLy8gRGVmaW5lIGEgZmFsbGJhY2sgdmVyc2lvbiBvZiB0aGUgbWV0aG9kIGluIGJyb3dzZXJzIChhaGVtLCBJRSksIHdoZXJlXHJcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cclxuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xyXG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICByZXR1cm4gISEob2JqICYmIF8uaGFzKG9iaiwgJ2NhbGxlZScpKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuXHJcbiAgaWYgKHR5cGVvZiAoLy4vKSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cclxuICBfLmlzRmluaXRlID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcclxuICB9O1xyXG5cclxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXHJcbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIF8uaXNOdW1iZXIob2JqKSAmJiBvYmogIT0gK29iajtcclxuICB9O1xyXG5cclxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cclxuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiA9PT0gdHJ1ZSB8fCBvYmogPT09IGZhbHNlIHx8IHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBCb29sZWFuXSc7XHJcbiAgfTtcclxuXHJcbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xyXG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xyXG4gIH07XHJcblxyXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xyXG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcclxuICB9O1xyXG5cclxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XHJcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cclxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XHJcbiAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcclxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXHJcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxyXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfTtcclxuXHJcbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdG9ycy5cclxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZTtcclxuICB9O1xyXG5cclxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cclxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcclxuICAgIHZhciBhY2N1bSA9IEFycmF5KE1hdGgubWF4KDAsIG4pKTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSBhY2N1bVtpXSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgaSk7XHJcbiAgICByZXR1cm4gYWNjdW07XHJcbiAgfTtcclxuXHJcbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cclxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XHJcbiAgICBpZiAobWF4ID09IG51bGwpIHtcclxuICAgICAgbWF4ID0gbWluO1xyXG4gICAgICBtaW4gPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XHJcbiAgfTtcclxuXHJcbiAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cclxuICB2YXIgZW50aXR5TWFwID0ge1xyXG4gICAgZXNjYXBlOiB7XHJcbiAgICAgICcmJzogJyZhbXA7JyxcclxuICAgICAgJzwnOiAnJmx0OycsXHJcbiAgICAgICc+JzogJyZndDsnLFxyXG4gICAgICAnXCInOiAnJnF1b3Q7JyxcclxuICAgICAgXCInXCI6ICcmI3gyNzsnXHJcbiAgICB9XHJcbiAgfTtcclxuICBlbnRpdHlNYXAudW5lc2NhcGUgPSBfLmludmVydChlbnRpdHlNYXAuZXNjYXBlKTtcclxuXHJcbiAgLy8gUmVnZXhlcyBjb250YWluaW5nIHRoZSBrZXlzIGFuZCB2YWx1ZXMgbGlzdGVkIGltbWVkaWF0ZWx5IGFib3ZlLlxyXG4gIHZhciBlbnRpdHlSZWdleGVzID0ge1xyXG4gICAgZXNjYXBlOiAgIG5ldyBSZWdFeHAoJ1snICsgXy5rZXlzKGVudGl0eU1hcC5lc2NhcGUpLmpvaW4oJycpICsgJ10nLCAnZycpLFxyXG4gICAgdW5lc2NhcGU6IG5ldyBSZWdFeHAoJygnICsgXy5rZXlzKGVudGl0eU1hcC51bmVzY2FwZSkuam9pbignfCcpICsgJyknLCAnZycpXHJcbiAgfTtcclxuXHJcbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxyXG4gIF8uZWFjaChbJ2VzY2FwZScsICd1bmVzY2FwZSddLCBmdW5jdGlvbihtZXRob2QpIHtcclxuICAgIF9bbWV0aG9kXSA9IGZ1bmN0aW9uKHN0cmluZykge1xyXG4gICAgICBpZiAoc3RyaW5nID09IG51bGwpIHJldHVybiAnJztcclxuICAgICAgcmV0dXJuICgnJyArIHN0cmluZykucmVwbGFjZShlbnRpdHlSZWdleGVzW21ldGhvZF0sIGZ1bmN0aW9uKG1hdGNoKSB7XHJcbiAgICAgICAgcmV0dXJuIGVudGl0eU1hcFttZXRob2RdW21hdGNoXTtcclxuICAgICAgfSk7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG5cclxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxyXG4gIC8vIGBvYmplY3RgIGFzIGNvbnRleHQ7IG90aGVyd2lzZSwgcmV0dXJuIGl0LlxyXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xyXG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xyXG4gICAgdmFyIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcclxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxyXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcclxuICAgIGVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XHJcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XHJcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIEdlbmVyYXRlIGEgdW5pcXVlIGludGVnZXIgaWQgKHVuaXF1ZSB3aXRoaW4gdGhlIGVudGlyZSBjbGllbnQgc2Vzc2lvbikuXHJcbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cclxuICB2YXIgaWRDb3VudGVyID0gMDtcclxuICBfLnVuaXF1ZUlkID0gZnVuY3Rpb24ocHJlZml4KSB7XHJcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xyXG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XHJcbiAgfTtcclxuXHJcbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXHJcbiAgLy8gZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxyXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcclxuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcclxuICAgIGludGVycG9sYXRlIDogLzwlPShbXFxzXFxTXSs/KSU+L2csXHJcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXHJcbiAgfTtcclxuXHJcbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxyXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcclxuICAvLyBndWFyYW50ZWVkIG5vdCB0byBtYXRjaC5cclxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcclxuXHJcbiAgLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcclxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cclxuICB2YXIgZXNjYXBlcyA9IHtcclxuICAgIFwiJ1wiOiAgICAgIFwiJ1wiLFxyXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxyXG4gICAgJ1xccic6ICAgICAncicsXHJcbiAgICAnXFxuJzogICAgICduJyxcclxuICAgICdcXHQnOiAgICAgJ3QnLFxyXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxyXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXHJcbiAgfTtcclxuXHJcbiAgdmFyIGVzY2FwZXIgPSAvXFxcXHwnfFxccnxcXG58XFx0fFxcdTIwMjh8XFx1MjAyOS9nO1xyXG5cclxuICAvLyBKYXZhU2NyaXB0IG1pY3JvLXRlbXBsYXRpbmcsIHNpbWlsYXIgdG8gSm9obiBSZXNpZydzIGltcGxlbWVudGF0aW9uLlxyXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcclxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cclxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgZGF0YSwgc2V0dGluZ3MpIHtcclxuICAgIHZhciByZW5kZXI7XHJcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xyXG5cclxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxyXG4gICAgdmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFtcclxuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgIChzZXR0aW5ncy5pbnRlcnBvbGF0ZSB8fCBub01hdGNoKS5zb3VyY2UsXHJcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcclxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcclxuXHJcbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxyXG4gICAgdmFyIGluZGV4ID0gMDtcclxuICAgIHZhciBzb3VyY2UgPSBcIl9fcCs9J1wiO1xyXG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XHJcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpXHJcbiAgICAgICAgLnJlcGxhY2UoZXNjYXBlciwgZnVuY3Rpb24obWF0Y2gpIHsgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdOyB9KTtcclxuXHJcbiAgICAgIGlmIChlc2NhcGUpIHtcclxuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbnRlcnBvbGF0ZSkge1xyXG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgaW50ZXJwb2xhdGUgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChldmFsdWF0ZSkge1xyXG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XHJcbiAgICAgIH1cclxuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XHJcbiAgICAgIHJldHVybiBtYXRjaDtcclxuICAgIH0pO1xyXG4gICAgc291cmNlICs9IFwiJztcXG5cIjtcclxuXHJcbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxyXG4gICAgaWYgKCFzZXR0aW5ncy52YXJpYWJsZSkgc291cmNlID0gJ3dpdGgob2JqfHx7fSl7XFxuJyArIHNvdXJjZSArICd9XFxuJztcclxuXHJcbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXHJcbiAgICAgIFwicHJpbnQ9ZnVuY3Rpb24oKXtfX3ArPV9fai5jYWxsKGFyZ3VtZW50cywnJyk7fTtcXG5cIiArXHJcbiAgICAgIHNvdXJjZSArIFwicmV0dXJuIF9fcDtcXG5cIjtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICByZW5kZXIgPSBuZXcgRnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicsICdfJywgc291cmNlKTtcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICAgIHRocm93IGU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGRhdGEpIHJldHVybiByZW5kZXIoZGF0YSwgXyk7XHJcbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24gc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxyXG4gICAgdGVtcGxhdGUuc291cmNlID0gJ2Z1bmN0aW9uKCcgKyAoc2V0dGluZ3MudmFyaWFibGUgfHwgJ29iaicpICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcclxuXHJcbiAgICByZXR1cm4gdGVtcGxhdGU7XHJcbiAgfTtcclxuXHJcbiAgLy8gQWRkIGEgXCJjaGFpblwiIGZ1bmN0aW9uLCB3aGljaCB3aWxsIGRlbGVnYXRlIHRvIHRoZSB3cmFwcGVyLlxyXG4gIF8uY2hhaW4gPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiBfKG9iaikuY2hhaW4oKTtcclxuICB9O1xyXG5cclxuICAvLyBPT1BcclxuICAvLyAtLS0tLS0tLS0tLS0tLS1cclxuICAvLyBJZiBVbmRlcnNjb3JlIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCBpdCByZXR1cm5zIGEgd3JhcHBlZCBvYmplY3QgdGhhdFxyXG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXHJcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cclxuXHJcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxyXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihvYmopIHtcclxuICAgIHJldHVybiB0aGlzLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xyXG4gIH07XHJcblxyXG4gIC8vIEFkZCBhbGwgb2YgdGhlIFVuZGVyc2NvcmUgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyIG9iamVjdC5cclxuICBfLm1peGluKF8pO1xyXG5cclxuICAvLyBBZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxyXG4gIGVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XHJcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcclxuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcclxuICAgICAgaWYgKChuYW1lID09ICdzaGlmdCcgfHwgbmFtZSA9PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcclxuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG9iaik7XHJcbiAgICB9O1xyXG4gIH0pO1xyXG5cclxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cclxuICBlYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xyXG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XHJcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gcmVzdWx0LmNhbGwodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xyXG4gICAgfTtcclxuICB9KTtcclxuXHJcbiAgXy5leHRlbmQoXy5wcm90b3R5cGUsIHtcclxuXHJcbiAgICAvLyBTdGFydCBjaGFpbmluZyBhIHdyYXBwZWQgVW5kZXJzY29yZSBvYmplY3QuXHJcbiAgICBjaGFpbjogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHRoaXMuX2NoYWluID0gdHJ1ZTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxyXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcclxuICAgIH1cclxuXHJcbiAgfSk7XHJcblxyXG59KS5jYWxsKHRoaXMpO1xyXG4iLCIvKiFcclxuICogalF1ZXJ5IEphdmFTY3JpcHQgTGlicmFyeSB2Mi4xLjFcclxuICogaHR0cDovL2pxdWVyeS5jb20vXHJcbiAqXHJcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xyXG4gKiBodHRwOi8vc2l6emxlanMuY29tL1xyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAwNSwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXHJcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxyXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXHJcbiAqXHJcbiAqIERhdGU6IDIwMTQtMDUtMDFUMTc6MTFaXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XHJcblxyXG5cdGlmICggdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XHJcblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIHdpbmRvdyBpcyBwcmVzZW50LFxyXG5cdFx0Ly8gZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeVxyXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBpbmhlcmVudGx5IHBvc3NlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcclxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBqUXVlcnktbWFraW5nIGZhY3RvcnkgYXMgbW9kdWxlLmV4cG9ydHNcclxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgd2luZG93XHJcblx0XHQvLyBlLmcuIHZhciBqUXVlcnkgPSByZXF1aXJlKFwianF1ZXJ5XCIpKHdpbmRvdyk7XHJcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5kb2N1bWVudCA/XHJcblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcclxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XHJcblx0XHRcdFx0aWYgKCAhdy5kb2N1bWVudCApIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGZhY3RvcnkoIHcgKTtcclxuXHRcdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0ZmFjdG9yeSggZ2xvYmFsICk7XHJcblx0fVxyXG5cclxuLy8gUGFzcyB0aGlzIGlmIHdpbmRvdyBpcyBub3QgZGVmaW5lZCB5ZXRcclxufSh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XHJcblxyXG4vLyBDYW4ndCBkbyB0aGlzIGJlY2F1c2Ugc2V2ZXJhbCBhcHBzIGluY2x1ZGluZyBBU1AuTkVUIHRyYWNlXHJcbi8vIHRoZSBzdGFjayB2aWEgYXJndW1lbnRzLmNhbGxlci5jYWxsZWUgYW5kIEZpcmVmb3ggZGllcyBpZlxyXG4vLyB5b3UgdHJ5IHRvIHRyYWNlIHRocm91Z2ggXCJ1c2Ugc3RyaWN0XCIgY2FsbCBjaGFpbnMuICgjMTMzMzUpXHJcbi8vIFN1cHBvcnQ6IEZpcmVmb3ggMTgrXHJcbi8vXHJcblxyXG52YXIgYXJyID0gW107XHJcblxyXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XHJcblxyXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcclxuXHJcbnZhciBwdXNoID0gYXJyLnB1c2g7XHJcblxyXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xyXG5cclxudmFyIGNsYXNzMnR5cGUgPSB7fTtcclxuXHJcbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XHJcblxyXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcbnZhciBzdXBwb3J0ID0ge307XHJcblxyXG5cclxuXHJcbnZhclxyXG5cdC8vIFVzZSB0aGUgY29ycmVjdCBkb2N1bWVudCBhY2NvcmRpbmdseSB3aXRoIHdpbmRvdyBhcmd1bWVudCAoc2FuZGJveClcclxuXHRkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcclxuXHJcblx0dmVyc2lvbiA9IFwiMi4xLjFcIixcclxuXHJcblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcclxuXHRqUXVlcnkgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XHJcblx0XHQvLyBUaGUgalF1ZXJ5IG9iamVjdCBpcyBhY3R1YWxseSBqdXN0IHRoZSBpbml0IGNvbnN0cnVjdG9yICdlbmhhbmNlZCdcclxuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXHJcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xyXG5cdH0sXHJcblxyXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXHJcblx0Ly8gTWFrZSBzdXJlIHdlIHRyaW0gQk9NIGFuZCBOQlNQXHJcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXHJcblxyXG5cdC8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xyXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXHJcblx0cmRhc2hBbHBoYSA9IC8tKFtcXGRhLXpdKS9naSxcclxuXHJcblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxyXG5cdGZjYW1lbENhc2UgPSBmdW5jdGlvbiggYWxsLCBsZXR0ZXIgKSB7XHJcblx0XHRyZXR1cm4gbGV0dGVyLnRvVXBwZXJDYXNlKCk7XHJcblx0fTtcclxuXHJcbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XHJcblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxyXG5cdGpxdWVyeTogdmVyc2lvbixcclxuXHJcblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcclxuXHJcblx0Ly8gU3RhcnQgd2l0aCBhbiBlbXB0eSBzZWxlY3RvclxyXG5cdHNlbGVjdG9yOiBcIlwiLFxyXG5cclxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcclxuXHRsZW5ndGg6IDAsXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHNsaWNlLmNhbGwoIHRoaXMgKTtcclxuXHR9LFxyXG5cclxuXHQvLyBHZXQgdGhlIE50aCBlbGVtZW50IGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0IE9SXHJcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcclxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XHJcblx0XHRyZXR1cm4gbnVtICE9IG51bGwgP1xyXG5cclxuXHRcdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxyXG5cdFx0XHQoIG51bSA8IDAgPyB0aGlzWyBudW0gKyB0aGlzLmxlbmd0aCBdIDogdGhpc1sgbnVtIF0gKSA6XHJcblxyXG5cdFx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XHJcblx0XHRcdHNsaWNlLmNhbGwoIHRoaXMgKTtcclxuXHR9LFxyXG5cclxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXHJcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXHJcblx0cHVzaFN0YWNrOiBmdW5jdGlvbiggZWxlbXMgKSB7XHJcblxyXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcclxuXHRcdHZhciByZXQgPSBqUXVlcnkubWVyZ2UoIHRoaXMuY29uc3RydWN0b3IoKSwgZWxlbXMgKTtcclxuXHJcblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxyXG5cdFx0cmV0LnByZXZPYmplY3QgPSB0aGlzO1xyXG5cdFx0cmV0LmNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XHJcblxyXG5cdFx0Ly8gUmV0dXJuIHRoZSBuZXdseS1mb3JtZWQgZWxlbWVudCBzZXRcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fSxcclxuXHJcblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cclxuXHQvLyAoWW91IGNhbiBzZWVkIHRoZSBhcmd1bWVudHMgd2l0aCBhbiBhcnJheSBvZiBhcmdzLCBidXQgdGhpcyBpc1xyXG5cdC8vIG9ubHkgdXNlZCBpbnRlcm5hbGx5LilcclxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2ssIGFyZ3MgKSB7XHJcblx0XHRyZXR1cm4galF1ZXJ5LmVhY2goIHRoaXMsIGNhbGxiYWNrLCBhcmdzICk7XHJcblx0fSxcclxuXHJcblx0bWFwOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAodGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XHJcblx0XHRcdHJldHVybiBjYWxsYmFjay5jYWxsKCBlbGVtLCBpLCBlbGVtICk7XHJcblx0XHR9KSk7XHJcblx0fSxcclxuXHJcblx0c2xpY2U6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcclxuXHR9LFxyXG5cclxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xyXG5cdH0sXHJcblxyXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZXEoIC0xICk7XHJcblx0fSxcclxuXHJcblx0ZXE6IGZ1bmN0aW9uKCBpICkge1xyXG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxyXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xyXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqID49IDAgJiYgaiA8IGxlbiA/IFsgdGhpc1tqXSBdIDogW10gKTtcclxuXHR9LFxyXG5cclxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJldk9iamVjdCB8fCB0aGlzLmNvbnN0cnVjdG9yKG51bGwpO1xyXG5cdH0sXHJcblxyXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cclxuXHQvLyBCZWhhdmVzIGxpa2UgYW4gQXJyYXkncyBtZXRob2QsIG5vdCBsaWtlIGEgalF1ZXJ5IG1ldGhvZC5cclxuXHRwdXNoOiBwdXNoLFxyXG5cdHNvcnQ6IGFyci5zb3J0LFxyXG5cdHNwbGljZTogYXJyLnNwbGljZVxyXG59O1xyXG5cclxualF1ZXJ5LmV4dGVuZCA9IGpRdWVyeS5mbi5leHRlbmQgPSBmdW5jdGlvbigpIHtcclxuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXHJcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXHJcblx0XHRpID0gMSxcclxuXHRcdGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXHJcblx0XHRkZWVwID0gZmFsc2U7XHJcblxyXG5cdC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cclxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xyXG5cdFx0ZGVlcCA9IHRhcmdldDtcclxuXHJcblx0XHQvLyBza2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XHJcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcclxuXHRcdGkrKztcclxuXHR9XHJcblxyXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxyXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24odGFyZ2V0KSApIHtcclxuXHRcdHRhcmdldCA9IHt9O1xyXG5cdH1cclxuXHJcblx0Ly8gZXh0ZW5kIGpRdWVyeSBpdHNlbGYgaWYgb25seSBvbmUgYXJndW1lbnQgaXMgcGFzc2VkXHJcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XHJcblx0XHR0YXJnZXQgPSB0aGlzO1xyXG5cdFx0aS0tO1xyXG5cdH1cclxuXHJcblx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XHJcblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXHJcblx0XHRpZiAoIChvcHRpb25zID0gYXJndW1lbnRzWyBpIF0pICE9IG51bGwgKSB7XHJcblx0XHRcdC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcclxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xyXG5cdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xyXG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XHJcblxyXG5cdFx0XHRcdC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcclxuXHRcdFx0XHRpZiAoIHRhcmdldCA9PT0gY29weSApIHtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXHJcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheShjb3B5KSkgKSApIHtcclxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XHJcblx0XHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdGNsb25lID0gc3JjICYmIGpRdWVyeS5pc0FycmF5KHNyYykgPyBzcmMgOiBbXTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYyAmJiBqUXVlcnkuaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXHJcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XHJcblxyXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxyXG5cdHJldHVybiB0YXJnZXQ7XHJcbn07XHJcblxyXG5qUXVlcnkuZXh0ZW5kKHtcclxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2VcclxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxyXG5cclxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxyXG5cdGlzUmVhZHk6IHRydWUsXHJcblxyXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcclxuXHR9LFxyXG5cclxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxyXG5cclxuXHQvLyBTZWUgdGVzdC91bml0L2NvcmUuanMgZm9yIGRldGFpbHMgY29uY2VybmluZyBpc0Z1bmN0aW9uLlxyXG5cdC8vIFNpbmNlIHZlcnNpb24gMS4zLCBET00gbWV0aG9kcyBhbmQgZnVuY3Rpb25zIGxpa2UgYWxlcnRcclxuXHQvLyBhcmVuJ3Qgc3VwcG9ydGVkLiBUaGV5IHJldHVybiBmYWxzZSBvbiBJRSAoIzI5NjgpLlxyXG5cdGlzRnVuY3Rpb246IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUob2JqKSA9PT0gXCJmdW5jdGlvblwiO1xyXG5cdH0sXHJcblxyXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXksXHJcblxyXG5cdGlzV2luZG93OiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcclxuXHR9LFxyXG5cclxuXHRpc051bWVyaWM6IGZ1bmN0aW9uKCBvYmogKSB7XHJcblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAobnVsbHx0cnVlfGZhbHNlfFwiXCIpXHJcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXHJcblx0XHQvLyBzdWJ0cmFjdGlvbiBmb3JjZXMgaW5maW5pdGllcyB0byBOYU5cclxuXHRcdHJldHVybiAhalF1ZXJ5LmlzQXJyYXkoIG9iaiApICYmIG9iaiAtIHBhcnNlRmxvYXQoIG9iaiApID49IDA7XHJcblx0fSxcclxuXHJcblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdC8vIE5vdCBwbGFpbiBvYmplY3RzOlxyXG5cdFx0Ly8gLSBBbnkgb2JqZWN0IG9yIHZhbHVlIHdob3NlIGludGVybmFsIFtbQ2xhc3NdXSBwcm9wZXJ0eSBpcyBub3QgXCJbb2JqZWN0IE9iamVjdF1cIlxyXG5cdFx0Ly8gLSBET00gbm9kZXNcclxuXHRcdC8vIC0gd2luZG93XHJcblx0XHRpZiAoIGpRdWVyeS50eXBlKCBvYmogKSAhPT0gXCJvYmplY3RcIiB8fCBvYmoubm9kZVR5cGUgfHwgalF1ZXJ5LmlzV2luZG93KCBvYmogKSApIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqLmNvbnN0cnVjdG9yICYmXHJcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIiApICkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgdGhlIGZ1bmN0aW9uIGhhc24ndCByZXR1cm5lZCBhbHJlYWR5LCB3ZSdyZSBjb25maWRlbnQgdGhhdFxyXG5cdFx0Ly8gfG9ianwgaXMgYSBwbGFpbiBvYmplY3QsIGNyZWF0ZWQgYnkge30gb3IgY29uc3RydWN0ZWQgd2l0aCBuZXcgT2JqZWN0XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0dmFyIG5hbWU7XHJcblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0dHlwZTogZnVuY3Rpb24oIG9iaiApIHtcclxuXHRcdGlmICggb2JqID09IG51bGwgKSB7XHJcblx0XHRcdHJldHVybiBvYmogKyBcIlwiO1xyXG5cdFx0fVxyXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8IDQuMCwgaU9TIDwgNiAoZnVuY3Rpb25pc2ggUmVnRXhwKVxyXG5cdFx0cmV0dXJuIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIG9iaiA9PT0gXCJmdW5jdGlvblwiID9cclxuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbChvYmopIF0gfHwgXCJvYmplY3RcIiA6XHJcblx0XHRcdHR5cGVvZiBvYmo7XHJcblx0fSxcclxuXHJcblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcclxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSApIHtcclxuXHRcdHZhciBzY3JpcHQsXHJcblx0XHRcdGluZGlyZWN0ID0gZXZhbDtcclxuXHJcblx0XHRjb2RlID0galF1ZXJ5LnRyaW0oIGNvZGUgKTtcclxuXHJcblx0XHRpZiAoIGNvZGUgKSB7XHJcblx0XHRcdC8vIElmIHRoZSBjb2RlIGluY2x1ZGVzIGEgdmFsaWQsIHByb2xvZ3VlIHBvc2l0aW9uXHJcblx0XHRcdC8vIHN0cmljdCBtb2RlIHByYWdtYSwgZXhlY3V0ZSBjb2RlIGJ5IGluamVjdGluZyBhXHJcblx0XHRcdC8vIHNjcmlwdCB0YWcgaW50byB0aGUgZG9jdW1lbnQuXHJcblx0XHRcdGlmICggY29kZS5pbmRleE9mKFwidXNlIHN0cmljdFwiKSA9PT0gMSApIHtcclxuXHRcdFx0XHRzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG5cdFx0XHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcclxuXHRcdFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCBzY3JpcHQgKS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBzY3JpcHQgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gT3RoZXJ3aXNlLCBhdm9pZCB0aGUgRE9NIG5vZGUgY3JlYXRpb24sIGluc2VydGlvblxyXG5cdFx0XHQvLyBhbmQgcmVtb3ZhbCBieSB1c2luZyBhbiBpbmRpcmVjdCBnbG9iYWwgZXZhbFxyXG5cdFx0XHRcdGluZGlyZWN0KCBjb2RlICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBDb252ZXJ0IGRhc2hlZCB0byBjYW1lbENhc2U7IHVzZWQgYnkgdGhlIGNzcyBhbmQgZGF0YSBtb2R1bGVzXHJcblx0Ly8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxyXG5cdGNhbWVsQ2FzZTogZnVuY3Rpb24oIHN0cmluZyApIHtcclxuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xyXG5cdH0sXHJcblxyXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcclxuXHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFyZ3MgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcclxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjaywgYXJncyApIHtcclxuXHRcdHZhciB2YWx1ZSxcclxuXHRcdFx0aSA9IDAsXHJcblx0XHRcdGxlbmd0aCA9IG9iai5sZW5ndGgsXHJcblx0XHRcdGlzQXJyYXkgPSBpc0FycmF5bGlrZSggb2JqICk7XHJcblxyXG5cdFx0aWYgKCBhcmdzICkge1xyXG5cdFx0XHRpZiAoIGlzQXJyYXkgKSB7XHJcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KCBvYmpbIGkgXSwgYXJncyApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Zm9yICggaSBpbiBvYmogKSB7XHJcblx0XHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrLmFwcGx5KCBvYmpbIGkgXSwgYXJncyApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHQvLyBBIHNwZWNpYWwsIGZhc3QsIGNhc2UgZm9yIHRoZSBtb3N0IGNvbW1vbiB1c2Ugb2YgZWFjaFxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKCBpc0FycmF5ICkge1xyXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xyXG5cdFx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG9iajtcclxuXHR9LFxyXG5cclxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxyXG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xyXG5cdFx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XHJcblx0XHRcdFwiXCIgOlxyXG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XHJcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xyXG5cdFx0dmFyIHJldCA9IHJlc3VsdHMgfHwgW107XHJcblxyXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcclxuXHRcdFx0aWYgKCBpc0FycmF5bGlrZSggT2JqZWN0KGFycikgKSApIHtcclxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHJldCxcclxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xyXG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJldDtcclxuXHR9LFxyXG5cclxuXHRpbkFycmF5OiBmdW5jdGlvbiggZWxlbSwgYXJyLCBpICkge1xyXG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xyXG5cdH0sXHJcblxyXG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcclxuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcclxuXHRcdFx0aiA9IDAsXHJcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XHJcblxyXG5cdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XHJcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XHJcblxyXG5cdFx0cmV0dXJuIGZpcnN0O1xyXG5cdH0sXHJcblxyXG5cdGdyZXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGludmVydCApIHtcclxuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXHJcblx0XHRcdG1hdGNoZXMgPSBbXSxcclxuXHRcdFx0aSA9IDAsXHJcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcclxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xyXG5cclxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcclxuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXHJcblx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcclxuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XHJcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcclxuXHRcdFx0XHRtYXRjaGVzLnB1c2goIGVsZW1zWyBpIF0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtYXRjaGVzO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxyXG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xyXG5cdFx0dmFyIHZhbHVlLFxyXG5cdFx0XHRpID0gMCxcclxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxyXG5cdFx0XHRpc0FycmF5ID0gaXNBcnJheWxpa2UoIGVsZW1zICksXHJcblx0XHRcdHJldCA9IFtdO1xyXG5cclxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXHJcblx0XHRpZiAoIGlzQXJyYXkgKSB7XHJcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XHJcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Zm9yICggaSBpbiBlbGVtcyApIHtcclxuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcclxuXHJcblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xyXG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmxhdHRlbiBhbnkgbmVzdGVkIGFycmF5c1xyXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xyXG5cdH0sXHJcblxyXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xyXG5cdGd1aWQ6IDEsXHJcblxyXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxyXG5cdC8vIGFyZ3VtZW50cy5cclxuXHRwcm94eTogZnVuY3Rpb24oIGZuLCBjb250ZXh0ICkge1xyXG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcclxuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcclxuXHRcdFx0Y29udGV4dCA9IGZuO1xyXG5cdFx0XHRmbiA9IHRtcDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xyXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cclxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCBmbiApICkge1xyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNpbXVsYXRlZCBiaW5kXHJcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XHJcblx0XHRwcm94eSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXHJcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcclxuXHJcblx0XHRyZXR1cm4gcHJveHk7XHJcblx0fSxcclxuXHJcblx0bm93OiBEYXRlLm5vdyxcclxuXHJcblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXHJcblx0Ly8gcHJvcGVydGllcyB0byBpdCBzbyBpdCBuZWVkcyB0byBleGlzdC5cclxuXHRzdXBwb3J0OiBzdXBwb3J0XHJcbn0pO1xyXG5cclxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXHJcbmpRdWVyeS5lYWNoKFwiQm9vbGVhbiBOdW1iZXIgU3RyaW5nIEZ1bmN0aW9uIEFycmF5IERhdGUgUmVnRXhwIE9iamVjdCBFcnJvclwiLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oaSwgbmFtZSkge1xyXG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xyXG59KTtcclxuXHJcbmZ1bmN0aW9uIGlzQXJyYXlsaWtlKCBvYmogKSB7XHJcblx0dmFyIGxlbmd0aCA9IG9iai5sZW5ndGgsXHJcblx0XHR0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xyXG5cclxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxuXHJcblx0aWYgKCBvYmoubm9kZVR5cGUgPT09IDEgJiYgbGVuZ3RoICkge1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxyXG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcclxufVxyXG52YXIgU2l6emxlID1cclxuLyohXHJcbiAqIFNpenpsZSBDU1MgU2VsZWN0b3IgRW5naW5lIHYxLjEwLjE5XHJcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXHJcbiAqXHJcbiAqIENvcHlyaWdodCAyMDEzIGpRdWVyeSBGb3VuZGF0aW9uLCBJbmMuIGFuZCBvdGhlciBjb250cmlidXRvcnNcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXHJcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcclxuICpcclxuICogRGF0ZTogMjAxNC0wNC0xOFxyXG4gKi9cclxuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XHJcblxyXG52YXIgaSxcclxuXHRzdXBwb3J0LFxyXG5cdEV4cHIsXHJcblx0Z2V0VGV4dCxcclxuXHRpc1hNTCxcclxuXHR0b2tlbml6ZSxcclxuXHRjb21waWxlLFxyXG5cdHNlbGVjdCxcclxuXHRvdXRlcm1vc3RDb250ZXh0LFxyXG5cdHNvcnRJbnB1dCxcclxuXHRoYXNEdXBsaWNhdGUsXHJcblxyXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcclxuXHRzZXREb2N1bWVudCxcclxuXHRkb2N1bWVudCxcclxuXHRkb2NFbGVtLFxyXG5cdGRvY3VtZW50SXNIVE1MLFxyXG5cdHJidWdneVFTQSxcclxuXHRyYnVnZ3lNYXRjaGVzLFxyXG5cdG1hdGNoZXMsXHJcblx0Y29udGFpbnMsXHJcblxyXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcclxuXHRleHBhbmRvID0gXCJzaXp6bGVcIiArIC0obmV3IERhdGUoKSksXHJcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxyXG5cdGRpcnJ1bnMgPSAwLFxyXG5cdGRvbmUgPSAwLFxyXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxyXG5cdHRva2VuQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxyXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxyXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xyXG5cdFx0aWYgKCBhID09PSBiICkge1xyXG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIDA7XHJcblx0fSxcclxuXHJcblx0Ly8gR2VuZXJhbC1wdXJwb3NlIGNvbnN0YW50c1xyXG5cdHN0cnVuZGVmaW5lZCA9IHR5cGVvZiB1bmRlZmluZWQsXHJcblx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcclxuXHJcblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xyXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXHJcblx0YXJyID0gW10sXHJcblx0cG9wID0gYXJyLnBvcCxcclxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxyXG5cdHB1c2ggPSBhcnIucHVzaCxcclxuXHRzbGljZSA9IGFyci5zbGljZSxcclxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgaWYgd2UgY2FuJ3QgdXNlIGEgbmF0aXZlIG9uZVxyXG5cdGluZGV4T2YgPSBhcnIuaW5kZXhPZiB8fCBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdHZhciBpID0gMCxcclxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGg7XHJcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcclxuXHRcdFx0aWYgKCB0aGlzW2ldID09PSBlbGVtICkge1xyXG5cdFx0XHRcdHJldHVybiBpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fSxcclxuXHJcblx0Ym9vbGVhbnMgPSBcImNoZWNrZWR8c2VsZWN0ZWR8YXN5bmN8YXV0b2ZvY3VzfGF1dG9wbGF5fGNvbnRyb2xzfGRlZmVyfGRpc2FibGVkfGhpZGRlbnxpc21hcHxsb29wfG11bHRpcGxlfG9wZW58cmVhZG9ubHl8cmVxdWlyZWR8c2NvcGVkXCIsXHJcblxyXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcclxuXHJcblx0Ly8gV2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGh0dHA6Ly93d3cudzMub3JnL1RSL2NzczMtc2VsZWN0b3JzLyN3aGl0ZXNwYWNlXHJcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcclxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXN5bnRheC8jY2hhcmFjdGVyc1xyXG5cdGNoYXJhY3RlckVuY29kaW5nID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXFxceDAwLVxcXFx4YTBdKStcIixcclxuXHJcblx0Ly8gTG9vc2VseSBtb2RlbGVkIG9uIENTUyBpZGVudGlmaWVyIGNoYXJhY3RlcnNcclxuXHQvLyBBbiB1bnF1b3RlZCB2YWx1ZSBzaG91bGQgYmUgYSBDU1MgaWRlbnRpZmllciBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xyXG5cdC8vIFByb3BlciBzeW50YXg6IGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxyXG5cdGlkZW50aWZpZXIgPSBjaGFyYWN0ZXJFbmNvZGluZy5yZXBsYWNlKCBcIndcIiwgXCJ3I1wiICksXHJcblxyXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xyXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xyXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcclxuXHRcdFwiKihbKl4kfCF+XT89KVwiICsgd2hpdGVzcGFjZSArXHJcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxyXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xyXG5cdFx0XCIqXFxcXF1cIixcclxuXHJcblx0cHNldWRvcyA9IFwiOihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpKD86XFxcXCgoXCIgK1xyXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcclxuXHRcdC8vIDEuIHF1b3RlZCAoY2FwdHVyZSAzOyBjYXB0dXJlIDQgb3IgY2FwdHVyZSA1KVxyXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXHJcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcclxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcclxuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcclxuXHRcdFwiLipcIiArXHJcblx0XHRcIilcXFxcKXwpXCIsXHJcblxyXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcclxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXHJcblxyXG5cdHJjb21tYSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKixcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxyXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxyXG5cclxuXHRyYXR0cmlidXRlUXVvdGVzID0gbmV3IFJlZ0V4cCggXCI9XCIgKyB3aGl0ZXNwYWNlICsgXCIqKFteXFxcXF0nXFxcIl0qPylcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLCBcImdcIiApLFxyXG5cclxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxyXG5cdHJpZGVudGlmaWVyID0gbmV3IFJlZ0V4cCggXCJeXCIgKyBpZGVudGlmaWVyICsgXCIkXCIgKSxcclxuXHJcblx0bWF0Y2hFeHByID0ge1xyXG5cdFx0XCJJRFwiOiBuZXcgUmVnRXhwKCBcIl4jKFwiICsgY2hhcmFjdGVyRW5jb2RpbmcgKyBcIilcIiApLFxyXG5cdFx0XCJDTEFTU1wiOiBuZXcgUmVnRXhwKCBcIl5cXFxcLihcIiArIGNoYXJhY3RlckVuY29kaW5nICsgXCIpXCIgKSxcclxuXHRcdFwiVEFHXCI6IG5ldyBSZWdFeHAoIFwiXihcIiArIGNoYXJhY3RlckVuY29kaW5nLnJlcGxhY2UoIFwid1wiLCBcIncqXCIgKSArIFwiKVwiICksXHJcblx0XHRcIkFUVFJcIjogbmV3IFJlZ0V4cCggXCJeXCIgKyBhdHRyaWJ1dGVzICksXHJcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcclxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXHJcblx0XHRcdFwiKihldmVufG9kZHwoKFsrLV18KShcXFxcZCopbnwpXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86KFsrLV18KVwiICsgd2hpdGVzcGFjZSArXHJcblx0XHRcdFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxyXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXHJcblx0XHQvLyBGb3IgdXNlIGluIGxpYnJhcmllcyBpbXBsZW1lbnRpbmcgLmlzKClcclxuXHRcdC8vIFdlIHVzZSB0aGlzIGZvciBQT1MgbWF0Y2hpbmcgaW4gYHNlbGVjdGBcclxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXHJcblx0XHRcdHdoaXRlc3BhY2UgKyBcIiooKD86LVxcXFxkKT9cXFxcZCopXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KSg/PVteLV18JClcIiwgXCJpXCIgKVxyXG5cdH0sXHJcblxyXG5cdHJpbnB1dHMgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxyXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXHJcblxyXG5cdHJuYXRpdmUgPSAvXltee10rXFx7XFxzKlxcW25hdGl2ZSBcXHcvLFxyXG5cclxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcclxuXHRycXVpY2tFeHByID0gL14oPzojKFtcXHctXSspfChcXHcrKXxcXC4oW1xcdy1dKykpJC8sXHJcblxyXG5cdHJzaWJsaW5nID0gL1srfl0vLFxyXG5cdHJlc2NhcGUgPSAvJ3xcXFxcL2csXHJcblxyXG5cdC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcclxuXHRydW5lc2NhcGUgPSBuZXcgUmVnRXhwKCBcIlxcXFxcXFxcKFtcXFxcZGEtZl17MSw2fVwiICsgd2hpdGVzcGFjZSArIFwiP3woXCIgKyB3aGl0ZXNwYWNlICsgXCIpfC4pXCIsIFwiaWdcIiApLFxyXG5cdGZ1bmVzY2FwZSA9IGZ1bmN0aW9uKCBfLCBlc2NhcGVkLCBlc2NhcGVkV2hpdGVzcGFjZSApIHtcclxuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XHJcblx0XHQvLyBOYU4gbWVhbnMgbm9uLWNvZGVwb2ludFxyXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyNFxyXG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXHJcblx0XHRyZXR1cm4gaGlnaCAhPT0gaGlnaCB8fCBlc2NhcGVkV2hpdGVzcGFjZSA/XHJcblx0XHRcdGVzY2FwZWQgOlxyXG5cdFx0XHRoaWdoIDwgMCA/XHJcblx0XHRcdFx0Ly8gQk1QIGNvZGVwb2ludFxyXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggKyAweDEwMDAwICkgOlxyXG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxyXG5cdFx0XHRcdFN0cmluZy5mcm9tQ2hhckNvZGUoIGhpZ2ggPj4gMTAgfCAweEQ4MDAsIGhpZ2ggJiAweDNGRiB8IDB4REMwMCApO1xyXG5cdH07XHJcblxyXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxyXG50cnkge1xyXG5cdHB1c2guYXBwbHkoXHJcblx0XHQoYXJyID0gc2xpY2UuY2FsbCggcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMgKSksXHJcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xyXG5cdCk7XHJcblx0Ly8gU3VwcG9ydDogQW5kcm9pZDw0LjBcclxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XHJcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcclxufSBjYXRjaCAoIGUgKSB7XHJcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xyXG5cclxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXHJcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XHJcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xyXG5cdFx0fSA6XHJcblxyXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxyXG5cdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZCBkaXJlY3RseVxyXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xyXG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXHJcblx0XHRcdFx0aSA9IDA7XHJcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxyXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XHJcblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xyXG5cdHZhciBtYXRjaCwgZWxlbSwgbSwgbm9kZVR5cGUsXHJcblx0XHQvLyBRU0EgdmFyc1xyXG5cdFx0aSwgZ3JvdXBzLCBvbGQsIG5pZCwgbmV3Q29udGV4dCwgbmV3U2VsZWN0b3I7XHJcblxyXG5cdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XHJcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xyXG5cdH1cclxuXHJcblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XHJcblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XHJcblxyXG5cdGlmICggIXNlbGVjdG9yIHx8IHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcclxuXHRcdHJldHVybiByZXN1bHRzO1xyXG5cdH1cclxuXHJcblx0aWYgKCAobm9kZVR5cGUgPSBjb250ZXh0Lm5vZGVUeXBlKSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSApIHtcclxuXHRcdHJldHVybiBbXTtcclxuXHR9XHJcblxyXG5cdGlmICggZG9jdW1lbnRJc0hUTUwgJiYgIXNlZWQgKSB7XHJcblxyXG5cdFx0Ly8gU2hvcnRjdXRzXHJcblx0XHRpZiAoIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XHJcblx0XHRcdC8vIFNwZWVkLXVwOiBTaXp6bGUoXCIjSURcIilcclxuXHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcclxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xyXG5cdFx0XHRcdFx0ZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKTtcclxuXHRcdFx0XHRcdC8vIENoZWNrIHBhcmVudE5vZGUgdG8gY2F0Y2ggd2hlbiBCbGFja2JlcnJ5IDQuNiByZXR1cm5zXHJcblx0XHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50IChqUXVlcnkgIzY5NjMpXHJcblx0XHRcdFx0XHRpZiAoIGVsZW0gJiYgZWxlbS5wYXJlbnROb2RlICkge1xyXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgSUUsIE9wZXJhLCBhbmQgV2Via2l0IHJldHVybiBpdGVtc1xyXG5cdFx0XHRcdFx0XHQvLyBieSBuYW1lIGluc3RlYWQgb2YgSURcclxuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xyXG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0Ly8gQ29udGV4dCBpcyBub3QgYSBkb2N1bWVudFxyXG5cdFx0XHRcdFx0aWYgKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgJiYgKGVsZW0gPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgJiZcclxuXHRcdFx0XHRcdFx0Y29udGFpbnMoIGNvbnRleHQsIGVsZW0gKSAmJiBlbGVtLmlkID09PSBtICkge1xyXG5cdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gU3BlZWQtdXA6IFNpenpsZShcIlRBR1wiKVxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFsyXSApIHtcclxuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCBzZWxlY3RvciApICk7XHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XHJcblxyXG5cdFx0XHQvLyBTcGVlZC11cDogU2l6emxlKFwiLkNMQVNTXCIpXHJcblx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XHJcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBtICkgKTtcclxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFFTQSBwYXRoXHJcblx0XHRpZiAoIHN1cHBvcnQucXNhICYmICghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgKSB7XHJcblx0XHRcdG5pZCA9IG9sZCA9IGV4cGFuZG87XHJcblx0XHRcdG5ld0NvbnRleHQgPSBjb250ZXh0O1xyXG5cdFx0XHRuZXdTZWxlY3RvciA9IG5vZGVUeXBlID09PSA5ICYmIHNlbGVjdG9yO1xyXG5cclxuXHRcdFx0Ly8gcVNBIHdvcmtzIHN0cmFuZ2VseSBvbiBFbGVtZW50LXJvb3RlZCBxdWVyaWVzXHJcblx0XHRcdC8vIFdlIGNhbiB3b3JrIGFyb3VuZCB0aGlzIGJ5IHNwZWNpZnlpbmcgYW4gZXh0cmEgSUQgb24gdGhlIHJvb3RcclxuXHRcdFx0Ly8gYW5kIHdvcmtpbmcgdXAgZnJvbSB0aGVyZSAoVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoZSB0ZWNobmlxdWUpXHJcblx0XHRcdC8vIElFIDggZG9lc24ndCB3b3JrIG9uIG9iamVjdCBlbGVtZW50c1xyXG5cdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcclxuXHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcclxuXHJcblx0XHRcdFx0aWYgKCAob2xkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoXCJpZFwiKSkgKSB7XHJcblx0XHRcdFx0XHRuaWQgPSBvbGQucmVwbGFjZSggcmVzY2FwZSwgXCJcXFxcJCZcIiApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb250ZXh0LnNldEF0dHJpYnV0ZSggXCJpZFwiLCBuaWQgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bmlkID0gXCJbaWQ9J1wiICsgbmlkICsgXCInXSBcIjtcclxuXHJcblx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XHJcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XHJcblx0XHRcdFx0XHRncm91cHNbaV0gPSBuaWQgKyB0b1NlbGVjdG9yKCBncm91cHNbaV0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHQ7XHJcblx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbihcIixcIik7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbmV3U2VsZWN0b3IgKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXHJcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xyXG5cdFx0XHRcdH0gY2F0Y2gocXNhRXJyb3IpIHtcclxuXHRcdFx0XHR9IGZpbmFsbHkge1xyXG5cdFx0XHRcdFx0aWYgKCAhb2xkICkge1xyXG5cdFx0XHRcdFx0XHRjb250ZXh0LnJlbW92ZUF0dHJpYnV0ZShcImlkXCIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQWxsIG90aGVyc1xyXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xyXG59XHJcblxyXG4vKipcclxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXHJcbiAqIEByZXR1cm5zIHtGdW5jdGlvbihzdHJpbmcsIE9iamVjdCl9IFJldHVybnMgdGhlIE9iamVjdCBkYXRhIGFmdGVyIHN0b3JpbmcgaXQgb24gaXRzZWxmIHdpdGhcclxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXHJcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcclxuXHR2YXIga2V5cyA9IFtdO1xyXG5cclxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcclxuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXHJcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XHJcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xyXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcclxuXHR9XHJcblx0cmV0dXJuIGNhY2hlO1xyXG59XHJcblxyXG4vKipcclxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcclxuICovXHJcbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XHJcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XHJcblx0cmV0dXJuIGZuO1xyXG59XHJcblxyXG4vKipcclxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGRpdiBhbmQgZXhwZWN0cyBhIGJvb2xlYW4gcmVzdWx0XHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xyXG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG5cclxuXHR0cnkge1xyXG5cdFx0cmV0dXJuICEhZm4oIGRpdiApO1xyXG5cdH0gY2F0Y2ggKGUpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9IGZpbmFsbHkge1xyXG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XHJcblx0XHRpZiAoIGRpdi5wYXJlbnROb2RlICkge1xyXG5cdFx0XHRkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZGl2ICk7XHJcblx0XHR9XHJcblx0XHQvLyByZWxlYXNlIG1lbW9yeSBpbiBJRVxyXG5cdFx0ZGl2ID0gbnVsbDtcclxuXHR9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xyXG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdChcInxcIiksXHJcblx0XHRpID0gYXR0cnMubGVuZ3RoO1xyXG5cclxuXHR3aGlsZSAoIGktLSApIHtcclxuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xyXG5cdH1cclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcclxuICogQHBhcmFtIHtFbGVtZW50fSBhXHJcbiAqIEBwYXJhbSB7RWxlbWVudH0gYlxyXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcclxuICovXHJcbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayggYSwgYiApIHtcclxuXHR2YXIgY3VyID0gYiAmJiBhLFxyXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcclxuXHRcdFx0KCB+Yi5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKSAtXHJcblx0XHRcdCggfmEuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICk7XHJcblxyXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xyXG5cdGlmICggZGlmZiApIHtcclxuXHRcdHJldHVybiBkaWZmO1xyXG5cdH1cclxuXHJcblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcclxuXHRpZiAoIGN1ciApIHtcclxuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5uZXh0U2libGluZykgKSB7XHJcblx0XHRcdGlmICggY3VyID09PSBiICkge1xyXG5cdFx0XHRcdHJldHVybiAtMTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGEgPyAxIDogLTE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGlucHV0IHR5cGVzXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVJbnB1dFBzZXVkbyggdHlwZSApIHtcclxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSB0eXBlO1xyXG5cdH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcclxuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcclxuXHR9O1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XHJcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XHJcblx0XHRhcmd1bWVudCA9ICthcmd1bWVudDtcclxuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XHJcblx0XHRcdHZhciBqLFxyXG5cdFx0XHRcdG1hdGNoSW5kZXhlcyA9IGZuKCBbXSwgc2VlZC5sZW5ndGgsIGFyZ3VtZW50ICksXHJcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHQvLyBNYXRjaCBlbGVtZW50cyBmb3VuZCBhdCB0aGUgc3BlY2lmaWVkIGluZGV4ZXNcclxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XHJcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcclxuXHRcdFx0XHRcdHNlZWRbal0gPSAhKG1hdGNoZXNbal0gPSBzZWVkW2pdKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH0pO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxyXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0PX0gY29udGV4dFxyXG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcclxuICovXHJcbmZ1bmN0aW9uIHRlc3RDb250ZXh0KCBjb250ZXh0ICkge1xyXG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBzdHJ1bmRlZmluZWQgJiYgY29udGV4dDtcclxufVxyXG5cclxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2Vcclxuc3VwcG9ydCA9IFNpenpsZS5zdXBwb3J0ID0ge307XHJcblxyXG4vKipcclxuICogRGV0ZWN0cyBYTUwgbm9kZXNcclxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcclxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxyXG4gKi9cclxuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcclxuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XHJcblx0Ly8gKHN1Y2ggYXMgbG9hZGluZyBpZnJhbWVzIGluIElFIC0gIzQ4MzMpXHJcblx0dmFyIGRvY3VtZW50RWxlbWVudCA9IGVsZW0gJiYgKGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtKS5kb2N1bWVudEVsZW1lbnQ7XHJcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXRzIGRvY3VtZW50LXJlbGF0ZWQgdmFyaWFibGVzIG9uY2UgYmFzZWQgb24gdGhlIGN1cnJlbnQgZG9jdW1lbnRcclxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcclxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxyXG4gKi9cclxuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcclxuXHR2YXIgaGFzQ29tcGFyZSxcclxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYyxcclxuXHRcdHBhcmVudCA9IGRvYy5kZWZhdWx0VmlldztcclxuXHJcblx0Ly8gSWYgbm8gZG9jdW1lbnQgYW5kIGRvY3VtZW50RWxlbWVudCBpcyBhdmFpbGFibGUsIHJldHVyblxyXG5cdGlmICggZG9jID09PSBkb2N1bWVudCB8fCBkb2Mubm9kZVR5cGUgIT09IDkgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQ7XHJcblx0fVxyXG5cclxuXHQvLyBTZXQgb3VyIGRvY3VtZW50XHJcblx0ZG9jdW1lbnQgPSBkb2M7XHJcblx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG5cdC8vIFN1cHBvcnQgdGVzdHNcclxuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jICk7XHJcblxyXG5cdC8vIFN1cHBvcnQ6IElFPjhcclxuXHQvLyBJZiBpZnJhbWUgZG9jdW1lbnQgaXMgYXNzaWduZWQgdG8gXCJkb2N1bWVudFwiIHZhcmlhYmxlIGFuZCBpZiBpZnJhbWUgaGFzIGJlZW4gcmVsb2FkZWQsXHJcblx0Ly8gSUUgd2lsbCB0aHJvdyBcInBlcm1pc3Npb24gZGVuaWVkXCIgZXJyb3Igd2hlbiBhY2Nlc3NpbmcgXCJkb2N1bWVudFwiIHZhcmlhYmxlLCBzZWUgalF1ZXJ5ICMxMzkzNlxyXG5cdC8vIElFNi04IGRvIG5vdCBzdXBwb3J0IHRoZSBkZWZhdWx0VmlldyBwcm9wZXJ0eSBzbyBwYXJlbnQgd2lsbCBiZSB1bmRlZmluZWRcclxuXHRpZiAoIHBhcmVudCAmJiBwYXJlbnQgIT09IHBhcmVudC50b3AgKSB7XHJcblx0XHQvLyBJRTExIGRvZXMgbm90IGhhdmUgYXR0YWNoRXZlbnQsIHNvIGFsbCBtdXN0IHN1ZmZlclxyXG5cdFx0aWYgKCBwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciApIHtcclxuXHRcdFx0cGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHNldERvY3VtZW50KCk7XHJcblx0XHRcdH0sIGZhbHNlICk7XHJcblx0XHR9IGVsc2UgaWYgKCBwYXJlbnQuYXR0YWNoRXZlbnQgKSB7XHJcblx0XHRcdHBhcmVudC5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzZXREb2N1bWVudCgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qIEF0dHJpYnV0ZXNcclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG5cdC8vIFN1cHBvcnQ6IElFPDhcclxuXHQvLyBWZXJpZnkgdGhhdCBnZXRBdHRyaWJ1dGUgcmVhbGx5IHJldHVybnMgYXR0cmlidXRlcyBhbmQgbm90IHByb3BlcnRpZXMgKGV4Y2VwdGluZyBJRTggYm9vbGVhbnMpXHJcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XHJcblx0XHRkaXYuY2xhc3NOYW1lID0gXCJpXCI7XHJcblx0XHRyZXR1cm4gIWRpdi5nZXRBdHRyaWJ1dGUoXCJjbGFzc05hbWVcIik7XHJcblx0fSk7XHJcblxyXG5cdC8qIGdldEVsZW1lbnQocylCeSpcclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcclxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XHJcblx0XHRkaXYuYXBwZW5kQ2hpbGQoIGRvYy5jcmVhdGVDb21tZW50KFwiXCIpICk7XHJcblx0XHRyZXR1cm4gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZShcIipcIikubGVuZ3RoO1xyXG5cdH0pO1xyXG5cclxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIGNhbiBiZSB0cnVzdGVkXHJcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2MuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApICYmIGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xyXG5cdFx0ZGl2LmlubmVySFRNTCA9IFwiPGRpdiBjbGFzcz0nYSc+PC9kaXY+PGRpdiBjbGFzcz0nYSBpJz48L2Rpdj5cIjtcclxuXHJcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmk8NFxyXG5cdFx0Ly8gQ2F0Y2ggY2xhc3Mgb3Zlci1jYWNoaW5nXHJcblx0XHRkaXYuZmlyc3RDaGlsZC5jbGFzc05hbWUgPSBcImlcIjtcclxuXHRcdC8vIFN1cHBvcnQ6IE9wZXJhPDEwXHJcblx0XHQvLyBDYXRjaCBnRUJDTiBmYWlsdXJlIHRvIGZpbmQgbm9uLWxlYWRpbmcgY2xhc3Nlc1xyXG5cdFx0cmV0dXJuIGRpdi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiaVwiKS5sZW5ndGggPT09IDI7XHJcblx0fSk7XHJcblxyXG5cdC8vIFN1cHBvcnQ6IElFPDEwXHJcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXHJcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcclxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3RcclxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcclxuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcclxuXHRcdHJldHVybiAhZG9jLmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2MuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XHJcblx0fSk7XHJcblxyXG5cdC8vIElEIGZpbmQgYW5kIGZpbHRlclxyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xyXG5cdFx0RXhwci5maW5kW1wiSURcIl0gPSBmdW5jdGlvbiggaWQsIGNvbnRleHQgKSB7XHJcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IHN0cnVuZGVmaW5lZCAmJiBkb2N1bWVudElzSFRNTCApIHtcclxuXHRcdFx0XHR2YXIgbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIGlkICk7XHJcblx0XHRcdFx0Ly8gQ2hlY2sgcGFyZW50Tm9kZSB0byBjYXRjaCB3aGVuIEJsYWNrYmVycnkgNC42IHJldHVybnNcclxuXHRcdFx0XHQvLyBub2RlcyB0aGF0IGFyZSBubyBsb25nZXIgaW4gdGhlIGRvY3VtZW50ICM2OTYzXHJcblx0XHRcdFx0cmV0dXJuIG0gJiYgbS5wYXJlbnROb2RlID8gWyBtIF0gOiBbXTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHRcdEV4cHIuZmlsdGVyW1wiSURcIl0gPSBmdW5jdGlvbiggaWQgKSB7XHJcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwiaWRcIikgPT09IGF0dHJJZDtcclxuXHRcdFx0fTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIFN1cHBvcnQ6IElFNi83XHJcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XHJcblx0XHRkZWxldGUgRXhwci5maW5kW1wiSURcIl07XHJcblxyXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XHJcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBzdHJ1bmRlZmluZWQgJiYgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XHJcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xyXG5cdFx0XHR9O1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8vIFRhZ1xyXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xyXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcclxuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gc3RydW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdHJldHVybiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSA6XHJcblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xyXG5cdFx0XHR2YXIgZWxlbSxcclxuXHRcdFx0XHR0bXAgPSBbXSxcclxuXHRcdFx0XHRpID0gMCxcclxuXHRcdFx0XHRyZXN1bHRzID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XHJcblxyXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXHJcblx0XHRcdGlmICggdGFnID09PSBcIipcIiApIHtcclxuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcclxuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcclxuXHRcdFx0XHRcdFx0dG1wLnB1c2goIGVsZW0gKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB0bXA7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHJlc3VsdHM7XHJcblx0XHR9O1xyXG5cclxuXHQvLyBDbGFzc1xyXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XHJcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IHN0cnVuZGVmaW5lZCAmJiBkb2N1bWVudElzSFRNTCApIHtcclxuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxyXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxyXG5cclxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxyXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcclxuXHJcblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcclxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3JcclxuXHQvLyB3aGVuZXZlciBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYWNjZXNzZWQgb24gYW4gaWZyYW1lXHJcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3JcclxuXHQvLyBTZWUgaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzNzhcclxuXHRyYnVnZ3lRU0EgPSBbXTtcclxuXHJcblx0aWYgKCAoc3VwcG9ydC5xc2EgPSBybmF0aXZlLnRlc3QoIGRvYy5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xyXG5cdFx0Ly8gQnVpbGQgUVNBIHJlZ2V4XHJcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXHJcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcclxuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxyXG5cdFx0XHQvLyBUaGlzIGlzIHRvIHRlc3QgSUUncyB0cmVhdG1lbnQgb2Ygbm90IGV4cGxpY2l0bHlcclxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXHJcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXHJcblx0XHRcdC8vIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMzU5XHJcblx0XHRcdGRpdi5pbm5lckhUTUwgPSBcIjxzZWxlY3QgbXNhbGxvd2NsaXA9Jyc+PG9wdGlvbiBzZWxlY3RlZD0nJz48L29wdGlvbj48L3NlbGVjdD5cIjtcclxuXHJcblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcclxuXHRcdFx0Ly8gTm90aGluZyBzaG91bGQgYmUgc2VsZWN0ZWQgd2hlbiBlbXB0eSBzdHJpbmdzIGZvbGxvdyBePSBvciAkPSBvciAqPVxyXG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcclxuXHRcdFx0Ly8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2hoNDY1Mzg4LmFzcHgjYXR0cmlidXRlX3NlY3Rpb25cclxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIlttc2FsbG93Y2xpcF49JyddXCIpLmxlbmd0aCApIHtcclxuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcclxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxyXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xyXG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXHJcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXHJcblx0XHRcdC8vIElFOCB0aHJvd3MgZXJyb3IgaGVyZSBhbmQgd2lsbCBub3Qgc2VlIGxhdGVyIHRlc3RzXHJcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xyXG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xyXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcclxuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XHJcblx0XHRcdHZhciBpbnB1dCA9IGRvYy5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XHJcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcclxuXHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XHJcblxyXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcclxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXHJcblx0XHRcdGlmICggZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbmFtZT1kXVwiKS5sZW5ndGggKSB7XHJcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxyXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xyXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCApIHtcclxuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXHJcblx0XHRcdGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiKiw6eFwiKTtcclxuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIsLio6XCIpO1xyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcclxuXHRcdGRvY0VsZW0ud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8XHJcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxyXG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XHJcblx0XHRkb2NFbGVtLm1zTWF0Y2hlc1NlbGVjdG9yKSApKSApIHtcclxuXHJcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcclxuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXHJcblx0XHRcdC8vIG9uIGEgZGlzY29ubmVjdGVkIG5vZGUgKElFIDkpXHJcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGRpdiwgXCJkaXZcIiApO1xyXG5cclxuXHRcdFx0Ly8gVGhpcyBzaG91bGQgZmFpbCB3aXRoIGFuIGV4Y2VwdGlvblxyXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXHJcblx0XHRcdG1hdGNoZXMuY2FsbCggZGl2LCBcIltzIT0nJ106eFwiICk7XHJcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XHJcblx0cmJ1Z2d5TWF0Y2hlcyA9IHJidWdneU1hdGNoZXMubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneU1hdGNoZXMuam9pbihcInxcIikgKTtcclxuXHJcblx0LyogQ29udGFpbnNcclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xyXG5cclxuXHQvLyBFbGVtZW50IGNvbnRhaW5zIGFub3RoZXJcclxuXHQvLyBQdXJwb3NlZnVsbHkgZG9lcyBub3QgaW1wbGVtZW50IGluY2x1c2l2ZSBkZXNjZW5kZW50XHJcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcclxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xyXG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XHJcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXHJcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XHJcblx0XHRcdHJldHVybiBhID09PSBidXAgfHwgISEoIGJ1cCAmJiBidXAubm9kZVR5cGUgPT09IDEgJiYgKFxyXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cclxuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XHJcblx0XHRcdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGJ1cCApICYgMTZcclxuXHRcdFx0KSk7XHJcblx0XHR9IDpcclxuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xyXG5cdFx0XHRpZiAoIGIgKSB7XHJcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XHJcblx0XHRcdFx0XHRpZiAoIGIgPT09IGEgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9O1xyXG5cclxuXHQvKiBTb3J0aW5nXHJcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXHJcblx0c29ydE9yZGVyID0gaGFzQ29tcGFyZSA/XHJcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XHJcblxyXG5cdFx0Ly8gRmxhZyBmb3IgZHVwbGljYXRlIHJlbW92YWxcclxuXHRcdGlmICggYSA9PT0gYiApIHtcclxuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcclxuXHRcdFx0cmV0dXJuIDA7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU29ydCBvbiBtZXRob2QgZXhpc3RlbmNlIGlmIG9ubHkgb25lIGlucHV0IGhhcyBjb21wYXJlRG9jdW1lbnRQb3NpdGlvblxyXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xyXG5cdFx0aWYgKCBjb21wYXJlICkge1xyXG5cdFx0XHRyZXR1cm4gY29tcGFyZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDYWxjdWxhdGUgcG9zaXRpb24gaWYgYm90aCBpbnB1dHMgYmVsb25nIHRvIHRoZSBzYW1lIGRvY3VtZW50XHJcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xyXG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxyXG5cclxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXHJcblx0XHRcdDE7XHJcblxyXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXHJcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XHJcblx0XHRcdCghc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlKSApIHtcclxuXHJcblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxyXG5cdFx0XHRpZiAoIGEgPT09IGRvYyB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xyXG5cdFx0XHRcdHJldHVybiAtMTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIGIgPT09IGRvYyB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xyXG5cdFx0XHRcdHJldHVybiAxO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxyXG5cdFx0XHRyZXR1cm4gc29ydElucHV0ID9cclxuXHRcdFx0XHQoIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBhICkgLSBpbmRleE9mLmNhbGwoIHNvcnRJbnB1dCwgYiApICkgOlxyXG5cdFx0XHRcdDA7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xyXG5cdH0gOlxyXG5cdGZ1bmN0aW9uKCBhLCBiICkge1xyXG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxyXG5cdFx0aWYgKCBhID09PSBiICkge1xyXG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY3VyLFxyXG5cdFx0XHRpID0gMCxcclxuXHRcdFx0YXVwID0gYS5wYXJlbnROb2RlLFxyXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXHJcblx0XHRcdGFwID0gWyBhIF0sXHJcblx0XHRcdGJwID0gWyBiIF07XHJcblxyXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcclxuXHRcdGlmICggIWF1cCB8fCAhYnVwICkge1xyXG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jID8gLTEgOlxyXG5cdFx0XHRcdGIgPT09IGRvYyA/IDEgOlxyXG5cdFx0XHRcdGF1cCA/IC0xIDpcclxuXHRcdFx0XHRidXAgPyAxIDpcclxuXHRcdFx0XHRzb3J0SW5wdXQgP1xyXG5cdFx0XHRcdCggaW5kZXhPZi5jYWxsKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YuY2FsbCggc29ydElucHV0LCBiICkgKSA6XHJcblx0XHRcdFx0MDtcclxuXHJcblx0XHQvLyBJZiB0aGUgbm9kZXMgYXJlIHNpYmxpbmdzLCB3ZSBjYW4gZG8gYSBxdWljayBjaGVja1xyXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XHJcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxyXG5cdFx0Y3VyID0gYTtcclxuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcclxuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XHJcblx0XHR9XHJcblx0XHRjdXIgPSBiO1xyXG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xyXG5cdFx0XHRicC51bnNoaWZ0KCBjdXIgKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBXYWxrIGRvd24gdGhlIHRyZWUgbG9va2luZyBmb3IgYSBkaXNjcmVwYW5jeVxyXG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XHJcblx0XHRcdGkrKztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaSA/XHJcblx0XHRcdC8vIERvIGEgc2libGluZyBjaGVjayBpZiB0aGUgbm9kZXMgaGF2ZSBhIGNvbW1vbiBhbmNlc3RvclxyXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcclxuXHJcblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxyXG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxyXG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XHJcblx0XHRcdDA7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIGRvYztcclxufTtcclxuXHJcblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xyXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XHJcbn07XHJcblxyXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XHJcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXHJcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xyXG5cdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcclxuXHR9XHJcblxyXG5cdC8vIE1ha2Ugc3VyZSB0aGF0IGF0dHJpYnV0ZSBzZWxlY3RvcnMgYXJlIHF1b3RlZFxyXG5cdGV4cHIgPSBleHByLnJlcGxhY2UoIHJhdHRyaWJ1dGVRdW90ZXMsIFwiPSckMSddXCIgKTtcclxuXHJcblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxyXG5cdFx0KCAhcmJ1Z2d5TWF0Y2hlcyB8fCAhcmJ1Z2d5TWF0Y2hlcy50ZXN0KCBleHByICkgKSAmJlxyXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xyXG5cclxuXHRcdHRyeSB7XHJcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcclxuXHJcblx0XHRcdC8vIElFIDkncyBtYXRjaGVzU2VsZWN0b3IgcmV0dXJucyBmYWxzZSBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcclxuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxyXG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcclxuXHRcdFx0XHRcdC8vIGZyYWdtZW50IGluIElFIDlcclxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJldDtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaChlKSB7fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcclxufTtcclxuXHJcblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xyXG5cdC8vIFNldCBkb2N1bWVudCB2YXJzIGlmIG5lZWRlZFxyXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcclxuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XHJcblx0fVxyXG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xyXG59O1xyXG5cclxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcclxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcclxuXHRpZiAoICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKSAhPT0gZG9jdW1lbnQgKSB7XHJcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xyXG5cdH1cclxuXHJcblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcclxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxyXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xyXG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxyXG5cdFx0XHR1bmRlZmluZWQ7XHJcblxyXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XHJcblx0XHR2YWwgOlxyXG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XHJcblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxyXG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cclxuXHRcdFx0XHR2YWwudmFsdWUgOlxyXG5cdFx0XHRcdG51bGw7XHJcbn07XHJcblxyXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xyXG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcclxuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcclxuICovXHJcblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XHJcblx0dmFyIGVsZW0sXHJcblx0XHRkdXBsaWNhdGVzID0gW10sXHJcblx0XHRqID0gMCxcclxuXHRcdGkgPSAwO1xyXG5cclxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXHJcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcclxuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcclxuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xyXG5cclxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcclxuXHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xyXG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcclxuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHdoaWxlICggai0tICkge1xyXG5cdFx0XHRyZXN1bHRzLnNwbGljZSggZHVwbGljYXRlc1sgaiBdLCAxICk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xyXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxyXG5cdHNvcnRJbnB1dCA9IG51bGw7XHJcblxyXG5cdHJldHVybiByZXN1bHRzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHJldHJpZXZpbmcgdGhlIHRleHQgdmFsdWUgb2YgYW4gYXJyYXkgb2YgRE9NIG5vZGVzXHJcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxyXG4gKi9cclxuZ2V0VGV4dCA9IFNpenpsZS5nZXRUZXh0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0dmFyIG5vZGUsXHJcblx0XHRyZXQgPSBcIlwiLFxyXG5cdFx0aSA9IDAsXHJcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XHJcblxyXG5cdGlmICggIW5vZGVUeXBlICkge1xyXG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcclxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xyXG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xyXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xyXG5cdFx0fVxyXG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcclxuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcclxuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXHJcblx0XHRpZiAoIHR5cGVvZiBlbGVtLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiICkge1xyXG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIFRyYXZlcnNlIGl0cyBjaGlsZHJlblxyXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcclxuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XHJcblx0XHRyZXR1cm4gZWxlbS5ub2RlVmFsdWU7XHJcblx0fVxyXG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xyXG5cclxuXHRyZXR1cm4gcmV0O1xyXG59O1xyXG5cclxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XHJcblxyXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcclxuXHJcblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXHJcblxyXG5cdG1hdGNoOiBtYXRjaEV4cHIsXHJcblxyXG5cdGF0dHJIYW5kbGU6IHt9LFxyXG5cclxuXHRmaW5kOiB7fSxcclxuXHJcblx0cmVsYXRpdmU6IHtcclxuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXHJcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXHJcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXHJcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxyXG5cdH0sXHJcblxyXG5cdHByZUZpbHRlcjoge1xyXG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcclxuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xyXG5cclxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcclxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xyXG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XHJcblx0XHRcdC8qIG1hdGNoZXMgZnJvbSBtYXRjaEV4cHJbXCJDSElMRFwiXVxyXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxyXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcclxuXHRcdFx0XHQzIGFyZ3VtZW50IChldmVufG9kZHxcXGQqfFxcZCpuKFsrLV1cXGQrKT98Li4uKVxyXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxyXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcclxuXHRcdFx0XHQ2IHggb2YgeG4tY29tcG9uZW50XHJcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XHJcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XHJcblx0XHRcdCovXHJcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcclxuXHJcblx0XHRcdGlmICggbWF0Y2hbMV0uc2xpY2UoIDAsIDMgKSA9PT0gXCJudGhcIiApIHtcclxuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxyXG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xyXG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gbnVtZXJpYyB4IGFuZCB5IHBhcmFtZXRlcnMgZm9yIEV4cHIuZmlsdGVyLkNISUxEXHJcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxyXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XHJcblx0XHRcdFx0bWF0Y2hbNV0gPSArKCAoIG1hdGNoWzddICsgbWF0Y2hbOF0gKSB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApO1xyXG5cclxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzNdICkge1xyXG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG1hdGNoO1xyXG5cdFx0fSxcclxuXHJcblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XHJcblx0XHRcdHZhciBleGNlc3MsXHJcblx0XHRcdFx0dW5xdW90ZWQgPSAhbWF0Y2hbNl0gJiYgbWF0Y2hbMl07XHJcblxyXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXHJcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XHJcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xyXG5cclxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcclxuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXHJcblx0XHRcdFx0Ly8gR2V0IGV4Y2VzcyBmcm9tIHRva2VuaXplIChyZWN1cnNpdmVseSlcclxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXHJcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXHJcblx0XHRcdFx0KGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XHJcblx0XHRcdFx0bWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCwgZXhjZXNzICk7XHJcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxyXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRmaWx0ZXI6IHtcclxuXHJcblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcclxuXHRcdFx0dmFyIG5vZGVOYW1lID0gbm9kZU5hbWVTZWxlY3Rvci5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XHJcblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcclxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XHJcblx0XHRcdFx0fTtcclxuXHRcdH0sXHJcblxyXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xyXG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XHJcblxyXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxyXG5cdFx0XHRcdChwYXR0ZXJuID0gbmV3IFJlZ0V4cCggXCIoXnxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSkgJiZcclxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gc3RydW5kZWZpbmVkICYmIGVsZW0uZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikgfHwgXCJcIiApO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fSxcclxuXHJcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRcdHZhciByZXN1bHQgPSBTaXp6bGUuYXR0ciggZWxlbSwgbmFtZSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIiE9XCI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXN1bHQgKz0gXCJcIjtcclxuXHJcblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxyXG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiIT1cIiA/IHJlc3VsdCAhPT0gY2hlY2sgOlxyXG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcclxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcclxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiQ9XCIgPyBjaGVjayAmJiByZXN1bHQuc2xpY2UoIC1jaGVjay5sZW5ndGggKSA9PT0gY2hlY2sgOlxyXG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XHJcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XHJcblx0XHRcdFx0XHRmYWxzZTtcclxuXHRcdFx0fTtcclxuXHRcdH0sXHJcblxyXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xyXG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxyXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcclxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcclxuXHJcblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cclxuXHJcblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxyXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xyXG5cdFx0XHRcdH0gOlxyXG5cclxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xyXG5cdFx0XHRcdFx0dmFyIGNhY2hlLCBvdXRlckNhY2hlLCBub2RlLCBkaWZmLCBub2RlSW5kZXgsIHN0YXJ0LFxyXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxyXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXHJcblx0XHRcdFx0XHRcdG5hbWUgPSBvZlR5cGUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLFxyXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHBhcmVudCApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcclxuXHRcdFx0XHRcdFx0aWYgKCBzaW1wbGUgKSB7XHJcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcclxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSBub2RlWyBkaXIgXSkgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID8gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDogbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxyXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIG5vbi14bWwgOm50aC1jaGlsZCguLi4pIHN0b3JlcyBjYWNoZSBkYXRhIG9uIGBwYXJlbnRgXHJcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcclxuXHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gcGFyZW50WyBleHBhbmRvIF0gfHwgKHBhcmVudFsgZXhwYW5kbyBdID0ge30pO1xyXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gb3V0ZXJDYWNoZVsgdHlwZSBdIHx8IFtdO1xyXG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWzBdID09PSBkaXJydW5zICYmIGNhY2hlWzFdO1xyXG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBjYWNoZVswXSA9PT0gZGlycnVucyAmJiBjYWNoZVsyXTtcclxuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBGYWxsYmFjayB0byBzZWVraW5nIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxyXG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gV2hlbiBmb3VuZCwgY2FjaGUgaW5kZXhlcyBvbiBgcGFyZW50YCBhbmQgYnJlYWtcclxuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZVsgdHlwZSBdID0gWyBkaXJydW5zLCBub2RlSW5kZXgsIGRpZmYgXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHVzZUNhY2hlICYmIChjYWNoZSA9IChlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KSlbIHR5cGUgXSkgJiYgY2FjaGVbMF0gPT09IGRpcnJ1bnMgKSB7XHJcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IGNhY2hlWzFdO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKSBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHRoZSBzYW1lIGxvb3AgYXMgYWJvdmUgdG8gc2VlayBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcclxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6IG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJiArK2RpZmYgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQobm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSkpWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxyXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XHJcblx0XHRcdFx0XHRcdHJldHVybiBkaWZmID09PSBmaXJzdCB8fCAoIGRpZmYgJSBmaXJzdCA9PT0gMCAmJiBkaWZmIC8gZmlyc3QgPj0gMCApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH07XHJcblx0XHR9LFxyXG5cclxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xyXG5cdFx0XHQvLyBwc2V1ZG8tY2xhc3MgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcclxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xyXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xyXG5cdFx0XHQvLyBSZW1lbWJlciB0aGF0IHNldEZpbHRlcnMgaW5oZXJpdHMgZnJvbSBwc2V1ZG9zXHJcblx0XHRcdHZhciBhcmdzLFxyXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcclxuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggXCJ1bnN1cHBvcnRlZCBwc2V1ZG86IFwiICsgcHNldWRvICk7XHJcblxyXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XHJcblx0XHRcdC8vIGFyZ3VtZW50cyBhcmUgbmVlZGVkIHRvIGNyZWF0ZSB0aGUgZmlsdGVyIGZ1bmN0aW9uXHJcblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcclxuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xyXG5cdFx0XHRcdHJldHVybiBmbiggYXJndW1lbnQgKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQnV0IG1haW50YWluIHN1cHBvcnQgZm9yIG9sZCBzaWduYXR1cmVzXHJcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcclxuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcclxuXHRcdFx0XHRyZXR1cm4gRXhwci5zZXRGaWx0ZXJzLmhhc093blByb3BlcnR5KCBwc2V1ZG8udG9Mb3dlckNhc2UoKSApID9cclxuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcclxuXHRcdFx0XHRcdFx0dmFyIGlkeCxcclxuXHRcdFx0XHRcdFx0XHRtYXRjaGVkID0gZm4oIHNlZWQsIGFyZ3VtZW50ICksXHJcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcclxuXHRcdFx0XHRcdFx0XHRpZHggPSBpbmRleE9mLmNhbGwoIHNlZWQsIG1hdGNoZWRbaV0gKTtcclxuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9KSA6XHJcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZuKCBlbGVtLCAwLCBhcmdzICk7XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZm47XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cHNldWRvczoge1xyXG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXHJcblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xyXG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxyXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xyXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcclxuXHRcdFx0dmFyIGlucHV0ID0gW10sXHJcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxyXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcclxuXHJcblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xyXG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xyXG5cdFx0XHRcdFx0dmFyIGVsZW0sXHJcblx0XHRcdFx0XHRcdHVubWF0Y2hlZCA9IG1hdGNoZXIoIHNlZWQsIG51bGwsIHhtbCwgW10gKSxcclxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIHVubWF0Y2hlZCBieSBgbWF0Y2hlcmBcclxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcclxuXHRcdFx0XHRcdFx0XHRzZWVkW2ldID0gIShtYXRjaGVzW2ldID0gZWxlbSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KSA6XHJcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcclxuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcclxuXHRcdFx0XHRcdG1hdGNoZXIoIGlucHV0LCBudWxsLCB4bWwsIHJlc3VsdHMgKTtcclxuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0fSksXHJcblxyXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcclxuXHRcdFx0fTtcclxuXHRcdH0pLFxyXG5cclxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xyXG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBlbGVtLmlubmVyVGV4dCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcclxuXHRcdFx0fTtcclxuXHRcdH0pLFxyXG5cclxuXHRcdC8vIFwiV2hldGhlciBhbiBlbGVtZW50IGlzIHJlcHJlc2VudGVkIGJ5IGEgOmxhbmcoKSBzZWxlY3RvclxyXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcclxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXHJcblx0XHQvLyBvciBiZWdpbm5pbmcgd2l0aCB0aGUgaWRlbnRpZmllciBDIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFwiLVwiLlxyXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXHJcblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXHJcblx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2xhbmctcHNldWRvXHJcblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcclxuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KGxhbmcgfHwgXCJcIikgKSB7XHJcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxhbmcgPSBsYW5nLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRcdHZhciBlbGVtTGFuZztcclxuXHRcdFx0XHRkbyB7XHJcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cclxuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcclxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoXCJ4bWw6bGFuZ1wiKSB8fCBlbGVtLmdldEF0dHJpYnV0ZShcImxhbmdcIikpICkge1xyXG5cclxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbUxhbmcgPT09IGxhbmcgfHwgZWxlbUxhbmcuaW5kZXhPZiggbGFuZyArIFwiLVwiICkgPT09IDA7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9O1xyXG5cdFx0fSksXHJcblxyXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xyXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xyXG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XHJcblx0XHR9LFxyXG5cclxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XHJcblx0XHR9LFxyXG5cclxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmICghZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSkgJiYgISEoZWxlbS50eXBlIHx8IGVsZW0uaHJlZiB8fCB+ZWxlbS50YWJJbmRleCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xyXG5cdFx0XCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2U7XHJcblx0XHR9LFxyXG5cclxuXHRcdFwiZGlzYWJsZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdHJldHVybiBlbGVtLmRpc2FibGVkID09PSB0cnVlO1xyXG5cdFx0fSxcclxuXHJcblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xyXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxyXG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcclxuXHRcdFx0Ly8gb3B0aW9ucyBpbiBTYWZhcmkgd29yayBwcm9wZXJseVxyXG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcclxuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIENvbnRlbnRzXHJcblx0XHRcImVtcHR5XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xyXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXHJcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXHJcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cclxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XHJcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9LFxyXG5cclxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcclxuXHRcdFwiaGVhZGVyXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XHJcblx0XHR9LFxyXG5cclxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xyXG5cdFx0fSxcclxuXHJcblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdHZhciBhdHRyO1xyXG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgJiZcclxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXHJcblxyXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFPDhcclxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxyXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXHJcblx0XHRcImZpcnN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oKSB7XHJcblx0XHRcdHJldHVybiBbIDAgXTtcclxuXHRcdH0pLFxyXG5cclxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcclxuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xyXG5cdFx0fSksXHJcblxyXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XHJcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcclxuXHRcdH0pLFxyXG5cclxuXHRcdFwiZXZlblwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcclxuXHRcdFx0dmFyIGkgPSAwO1xyXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcclxuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XHJcblx0XHR9KSxcclxuXHJcblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcclxuXHRcdFx0dmFyIGkgPSAxO1xyXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcclxuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XHJcblx0XHR9KSxcclxuXHJcblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcclxuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xyXG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcclxuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XHJcblx0XHR9KSxcclxuXHJcblx0XHRcImd0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcclxuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xyXG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XHJcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xyXG5cdFx0fSlcclxuXHR9XHJcbn07XHJcblxyXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcclxuXHJcbi8vIEFkZCBidXR0b24vaW5wdXQgdHlwZSBwc2V1ZG9zXHJcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xyXG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcclxufVxyXG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xyXG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XHJcbn1cclxuXHJcbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xyXG5mdW5jdGlvbiBzZXRGaWx0ZXJzKCkge31cclxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XHJcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XHJcblxyXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xyXG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxyXG5cdFx0c29GYXIsIGdyb3VwcywgcHJlRmlsdGVycyxcclxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcclxuXHJcblx0aWYgKCBjYWNoZWQgKSB7XHJcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xyXG5cdH1cclxuXHJcblx0c29GYXIgPSBzZWxlY3RvcjtcclxuXHRncm91cHMgPSBbXTtcclxuXHRwcmVGaWx0ZXJzID0gRXhwci5wcmVGaWx0ZXI7XHJcblxyXG5cdHdoaWxlICggc29GYXIgKSB7XHJcblxyXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxyXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XHJcblx0XHRcdGlmICggbWF0Y2ggKSB7XHJcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcclxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0ZhcjtcclxuXHRcdFx0fVxyXG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcclxuXHJcblx0XHQvLyBDb21iaW5hdG9yc1xyXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XHJcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xyXG5cdFx0XHR0b2tlbnMucHVzaCh7XHJcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXHJcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXHJcblx0XHRcdFx0dHlwZTogbWF0Y2hbMF0ucmVwbGFjZSggcnRyaW0sIFwiIFwiIClcclxuXHRcdFx0fSk7XHJcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmlsdGVyc1xyXG5cdFx0Zm9yICggdHlwZSBpbiBFeHByLmZpbHRlciApIHtcclxuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxyXG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xyXG5cdFx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcclxuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxyXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hlZC5sZW5ndGggKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggIW1hdGNoZWQgKSB7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gUmV0dXJuIHRoZSBsZW5ndGggb2YgdGhlIGludmFsaWQgZXhjZXNzXHJcblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXHJcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXHJcblx0cmV0dXJuIHBhcnNlT25seSA/XHJcblx0XHRzb0Zhci5sZW5ndGggOlxyXG5cdFx0c29GYXIgP1xyXG5cdFx0XHRTaXp6bGUuZXJyb3IoIHNlbGVjdG9yICkgOlxyXG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXHJcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xyXG5cdHZhciBpID0gMCxcclxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXHJcblx0XHRzZWxlY3RvciA9IFwiXCI7XHJcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XHJcblx0fVxyXG5cdHJldHVybiBzZWxlY3RvcjtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkQ29tYmluYXRvciggbWF0Y2hlciwgY29tYmluYXRvciwgYmFzZSApIHtcclxuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXHJcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBkaXIgPT09IFwicGFyZW50Tm9kZVwiLFxyXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XHJcblxyXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cclxuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxyXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcclxuXHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcclxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcclxuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0gOlxyXG5cclxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xyXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcclxuXHRcdFx0dmFyIG9sZENhY2hlLCBvdXRlckNhY2hlLFxyXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xyXG5cclxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gZGlyIGNhY2hpbmdcclxuXHRcdFx0aWYgKCB4bWwgKSB7XHJcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcclxuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XHJcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcclxuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xyXG5cdFx0XHRcdFx0XHRpZiAoIChvbGRDYWNoZSA9IG91dGVyQ2FjaGVbIGRpciBdKSAmJlxyXG5cdFx0XHRcdFx0XHRcdG9sZENhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgb2xkQ2FjaGVbIDEgXSA9PT0gZG9uZU5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIChuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xyXG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGVbIGRpciBdID0gbmV3Q2FjaGU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xyXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcclxuXHRyZXR1cm4gbWF0Y2hlcnMubGVuZ3RoID4gMSA/XHJcblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xyXG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcclxuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XHJcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH0gOlxyXG5cdFx0bWF0Y2hlcnNbMF07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcclxuXHR2YXIgaSA9IDAsXHJcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XHJcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xyXG5cdH1cclxuXHRyZXR1cm4gcmVzdWx0cztcclxufVxyXG5cclxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcclxuXHR2YXIgZWxlbSxcclxuXHRcdG5ld1VubWF0Y2hlZCA9IFtdLFxyXG5cdFx0aSA9IDAsXHJcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxyXG5cdFx0bWFwcGVkID0gbWFwICE9IG51bGw7XHJcblxyXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XHJcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xyXG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XHJcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XHJcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xyXG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xyXG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcclxuXHR9XHJcblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XHJcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XHJcblx0fVxyXG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcclxuXHRcdHZhciB0ZW1wLCBpLCBlbGVtLFxyXG5cdFx0XHRwcmVNYXAgPSBbXSxcclxuXHRcdFx0cG9zdE1hcCA9IFtdLFxyXG5cdFx0XHRwcmVleGlzdGluZyA9IHJlc3VsdHMubGVuZ3RoLFxyXG5cclxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcclxuXHRcdFx0ZWxlbXMgPSBzZWVkIHx8IG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yIHx8IFwiKlwiLCBjb250ZXh0Lm5vZGVUeXBlID8gWyBjb250ZXh0IF0gOiBjb250ZXh0LCBbXSApLFxyXG5cclxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXHJcblx0XHRcdG1hdGNoZXJJbiA9IHByZUZpbHRlciAmJiAoIHNlZWQgfHwgIXNlbGVjdG9yICkgP1xyXG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcclxuXHRcdFx0XHRlbGVtcyxcclxuXHJcblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cclxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxyXG5cdFx0XHRcdHBvc3RGaW5kZXIgfHwgKCBzZWVkID8gcHJlRmlsdGVyIDogcHJlZXhpc3RpbmcgfHwgcG9zdEZpbHRlciApID9cclxuXHJcblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3NhcnlcclxuXHRcdFx0XHRcdFtdIDpcclxuXHJcblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcclxuXHRcdFx0XHRcdHJlc3VsdHMgOlxyXG5cdFx0XHRcdG1hdGNoZXJJbjtcclxuXHJcblx0XHQvLyBGaW5kIHByaW1hcnkgbWF0Y2hlc1xyXG5cdFx0aWYgKCBtYXRjaGVyICkge1xyXG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcclxuXHRcdGlmICggcG9zdEZpbHRlciApIHtcclxuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XHJcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcclxuXHJcblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cclxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xyXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcclxuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XHJcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBzZWVkICkge1xyXG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xyXG5cdFx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcclxuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xyXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xyXG5cdFx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xyXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XHJcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBSZXN0b3JlIG1hdGNoZXJJbiBzaW5jZSBlbGVtIGlzIG5vdCB5ZXQgYSBmaW5hbCBtYXRjaFxyXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXHJcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xyXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xyXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXHJcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YuY2FsbCggc2VlZCwgZWxlbSApIDogcHJlTWFwW2ldKSA+IC0xICkge1xyXG5cclxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxyXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xyXG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcclxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcclxuXHRcdFx0KTtcclxuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xyXG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xyXG5cdHZhciBjaGVja0NvbnRleHQsIG1hdGNoZXIsIGosXHJcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxyXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcclxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVtcIiBcIl0sXHJcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXHJcblxyXG5cdFx0Ly8gVGhlIGZvdW5kYXRpb25hbCBtYXRjaGVyIGVuc3VyZXMgdGhhdCBlbGVtZW50cyBhcmUgcmVhY2hhYmxlIGZyb20gdG9wLWxldmVsIGNvbnRleHQocylcclxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xyXG5cdFx0fSwgaW1wbGljaXRSZWxhdGl2ZSwgdHJ1ZSApLFxyXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGNoZWNrQ29udGV4dCwgZWxlbSApID4gLTE7XHJcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXHJcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcclxuXHRcdFx0cmV0dXJuICggIWxlYWRpbmdSZWxhdGl2ZSAmJiAoIHhtbCB8fCBjb250ZXh0ICE9PSBvdXRlcm1vc3RDb250ZXh0ICkgKSB8fCAoXHJcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cclxuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxyXG5cdFx0XHRcdFx0bWF0Y2hBbnlDb250ZXh0KCBlbGVtLCBjb250ZXh0LCB4bWwgKSApO1xyXG5cdFx0fSBdO1xyXG5cclxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcclxuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcclxuXHRcdFx0bWF0Y2hlcnMgPSBbIGFkZENvbWJpbmF0b3IoZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksIG1hdGNoZXIpIF07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XHJcblxyXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcclxuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcclxuXHRcdFx0XHRqID0gKytpO1xyXG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xyXG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbal0udHlwZSBdICkge1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXHJcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcclxuXHRcdFx0XHRcdGkgPiAxICYmIHRvU2VsZWN0b3IoXHJcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXHJcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXHJcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcclxuXHRcdFx0XHRcdG1hdGNoZXIsXHJcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcclxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICh0b2tlbnMgPSB0b2tlbnMuc2xpY2UoIGogKSkgKSxcclxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcclxuXHRcdFx0XHQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcclxufVxyXG5cclxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xyXG5cdHZhciBieVNldCA9IHNldE1hdGNoZXJzLmxlbmd0aCA+IDAsXHJcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcclxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcclxuXHRcdFx0dmFyIGVsZW0sIGosIG1hdGNoZXIsXHJcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcclxuXHRcdFx0XHRpID0gXCIwXCIsXHJcblx0XHRcdFx0dW5tYXRjaGVkID0gc2VlZCAmJiBbXSxcclxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXHJcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXHJcblx0XHRcdFx0Ly8gV2UgbXVzdCBhbHdheXMgaGF2ZSBlaXRoZXIgc2VlZCBlbGVtZW50cyBvciBvdXRlcm1vc3QgY29udGV4dFxyXG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXHJcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcclxuXHRcdFx0XHRkaXJydW5zVW5pcXVlID0gKGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xKSxcclxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRpZiAoIG91dGVybW9zdCApIHtcclxuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCAhPT0gZG9jdW1lbnQgJiYgY29udGV4dDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcclxuXHRcdFx0Ly8gS2VlcCBgaWAgYSBzdHJpbmcgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIHNvIGBtYXRjaGVkQ291bnRgIHdpbGwgYmUgXCIwMFwiIGJlbG93XHJcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxyXG5cdFx0XHQvLyBUb2xlcmF0ZSBOb2RlTGlzdCBwcm9wZXJ0aWVzIChJRTogXCJsZW5ndGhcIjsgU2FmYXJpOiA8bnVtYmVyPikgbWF0Y2hpbmcgZWxlbWVudHMgYnkgaWRcclxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xyXG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XHJcblx0XHRcdFx0XHRqID0gMDtcclxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XHJcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XHJcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xyXG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcclxuXHRcdFx0XHRpZiAoIGJ5U2V0ICkge1xyXG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xyXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xyXG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XHJcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XHJcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcclxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XHJcblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xyXG5cdFx0XHRcdGogPSAwO1xyXG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcclxuXHRcdFx0XHRcdG1hdGNoZXIoIHVubWF0Y2hlZCwgc2V0TWF0Y2hlZCwgY29udGV4dCwgeG1sICk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHNlZWQgKSB7XHJcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXHJcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XHJcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xyXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXHJcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgc2V0TWF0Y2hlZCApO1xyXG5cclxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcclxuXHRcdFx0XHRpZiAoIG91dGVybW9zdCAmJiAhc2VlZCAmJiBzZXRNYXRjaGVkLmxlbmd0aCA+IDAgJiZcclxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xyXG5cclxuXHRcdFx0XHRcdFNpenpsZS51bmlxdWVTb3J0KCByZXN1bHRzICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcclxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XHJcblx0XHRcdFx0ZGlycnVucyA9IGRpcnJ1bnNVbmlxdWU7XHJcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XHJcblx0XHR9O1xyXG5cclxuXHRyZXR1cm4gYnlTZXQgP1xyXG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XHJcblx0XHRzdXBlck1hdGNoZXI7XHJcbn1cclxuXHJcbmNvbXBpbGUgPSBTaXp6bGUuY29tcGlsZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgbWF0Y2ggLyogSW50ZXJuYWwgVXNlIE9ubHkgKi8gKSB7XHJcblx0dmFyIGksXHJcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxyXG5cdFx0ZWxlbWVudE1hdGNoZXJzID0gW10sXHJcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XHJcblxyXG5cdGlmICggIWNhY2hlZCApIHtcclxuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxyXG5cdFx0aWYgKCAhbWF0Y2ggKSB7XHJcblx0XHRcdG1hdGNoID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XHJcblx0XHR9XHJcblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xyXG5cdFx0d2hpbGUgKCBpLS0gKSB7XHJcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xyXG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xyXG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxyXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XHJcblxyXG5cdFx0Ly8gU2F2ZSBzZWxlY3RvciBhbmQgdG9rZW5pemF0aW9uXHJcblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuXHR9XHJcblx0cmV0dXJuIGNhY2hlZDtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXHJcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcclxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHNlbGVjdG9yIEEgc2VsZWN0b3Igb3IgYSBwcmUtY29tcGlsZWRcclxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcclxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XHJcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHRzXVxyXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxyXG4gKi9cclxuc2VsZWN0ID0gU2l6emxlLnNlbGVjdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcclxuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcclxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXHJcblx0XHRtYXRjaCA9ICFzZWVkICYmIHRva2VuaXplKCAoc2VsZWN0b3IgPSBjb21waWxlZC5zZWxlY3RvciB8fCBzZWxlY3RvcikgKTtcclxuXHJcblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XHJcblxyXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG5vIHNlZWQgYW5kIG9ubHkgb25lIGdyb3VwXHJcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XHJcblxyXG5cdFx0Ly8gVGFrZSBhIHNob3J0Y3V0IGFuZCBzZXQgdGhlIGNvbnRleHQgaWYgdGhlIHJvb3Qgc2VsZWN0b3IgaXMgYW4gSURcclxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcclxuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcclxuXHRcdFx0XHRzdXBwb3J0LmdldEJ5SWQgJiYgY29udGV4dC5ub2RlVHlwZSA9PT0gOSAmJiBkb2N1bWVudElzSFRNTCAmJlxyXG5cdFx0XHRcdEV4cHIucmVsYXRpdmVbIHRva2Vuc1sxXS50eXBlIF0gKSB7XHJcblxyXG5cdFx0XHRjb250ZXh0ID0gKCBFeHByLmZpbmRbXCJJRFwiXSggdG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKHJ1bmVzY2FwZSwgZnVuZXNjYXBlKSwgY29udGV4dCApIHx8IFtdIClbMF07XHJcblx0XHRcdGlmICggIWNvbnRleHQgKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XHJcblxyXG5cdFx0XHQvLyBQcmVjb21waWxlZCBtYXRjaGVycyB3aWxsIHN0aWxsIHZlcmlmeSBhbmNlc3RyeSwgc28gc3RlcCB1cCBhIGxldmVsXHJcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xyXG5cdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0LnBhcmVudE5vZGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNlbGVjdG9yID0gc2VsZWN0b3Iuc2xpY2UoIHRva2Vucy5zaGlmdCgpLnZhbHVlLmxlbmd0aCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZldGNoIGEgc2VlZCBzZXQgZm9yIHJpZ2h0LXRvLWxlZnQgbWF0Y2hpbmdcclxuXHRcdGkgPSBtYXRjaEV4cHJbXCJuZWVkc0NvbnRleHRcIl0udGVzdCggc2VsZWN0b3IgKSA/IDAgOiB0b2tlbnMubGVuZ3RoO1xyXG5cdFx0d2hpbGUgKCBpLS0gKSB7XHJcblx0XHRcdHRva2VuID0gdG9rZW5zW2ldO1xyXG5cclxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxyXG5cdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbICh0eXBlID0gdG9rZW4udHlwZSkgXSApIHtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIChmaW5kID0gRXhwci5maW5kWyB0eXBlIF0pICkge1xyXG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xyXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxyXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1swXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLFxyXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWzBdLnR5cGUgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxyXG5cdFx0XHRcdCkpICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIElmIHNlZWQgaXMgZW1wdHkgb3Igbm8gdG9rZW5zIHJlbWFpbiwgd2UgY2FuIHJldHVybiBlYXJseVxyXG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xyXG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcclxuXHRcdFx0XHRcdGlmICggIXNlbGVjdG9yICkge1xyXG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XHJcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXHJcblx0Ly8gUHJvdmlkZSBgbWF0Y2hgIHRvIGF2b2lkIHJldG9rZW5pemF0aW9uIGlmIHdlIG1vZGlmaWVkIHRoZSBzZWxlY3RvciBhYm92ZVxyXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcclxuXHRcdHNlZWQsXHJcblx0XHRjb250ZXh0LFxyXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxyXG5cdFx0cmVzdWx0cyxcclxuXHRcdHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8IGNvbnRleHRcclxuXHQpO1xyXG5cdHJldHVybiByZXN1bHRzO1xyXG59O1xyXG5cclxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcclxuXHJcbi8vIFNvcnQgc3RhYmlsaXR5XHJcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoXCJcIikuc29ydCggc29ydE9yZGVyICkuam9pbihcIlwiKSA9PT0gZXhwYW5kbztcclxuXHJcbi8vIFN1cHBvcnQ6IENocm9tZTwxNFxyXG4vLyBBbHdheXMgYXNzdW1lIGR1cGxpY2F0ZXMgaWYgdGhleSBhcmVuJ3QgcGFzc2VkIHRvIHRoZSBjb21wYXJpc29uIGZ1bmN0aW9uXHJcbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xyXG5cclxuLy8gSW5pdGlhbGl6ZSBhZ2FpbnN0IHRoZSBkZWZhdWx0IGRvY3VtZW50XHJcbnNldERvY3VtZW50KCk7XHJcblxyXG4vLyBTdXBwb3J0OiBXZWJraXQ8NTM3LjMyIC0gU2FmYXJpIDYuMC4zL0Nocm9tZSAyNSAoZml4ZWQgaW4gQ2hyb21lIDI3KVxyXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcclxuc3VwcG9ydC5zb3J0RGV0YWNoZWQgPSBhc3NlcnQoZnVuY3Rpb24oIGRpdjEgKSB7XHJcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXHJcblx0cmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XHJcbn0pO1xyXG5cclxuLy8gU3VwcG9ydDogSUU8OFxyXG4vLyBQcmV2ZW50IGF0dHJpYnV0ZS9wcm9wZXJ0eSBcImludGVycG9sYXRpb25cIlxyXG4vLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY0MjklMjhWUy44NSUyOS5hc3B4XHJcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xyXG5cdGRpdi5pbm5lckhUTUwgPSBcIjxhIGhyZWY9JyMnPjwvYT5cIjtcclxuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA9PT0gXCIjXCIgO1xyXG59KSApIHtcclxuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XHJcblx0XHRpZiAoICFpc1hNTCApIHtcclxuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcclxuXHRcdH1cclxuXHR9KTtcclxufVxyXG5cclxuLy8gU3VwcG9ydDogSUU8OVxyXG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXHJcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XHJcblx0ZGl2LmlubmVySFRNTCA9IFwiPGlucHV0Lz5cIjtcclxuXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xyXG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBcIlwiO1xyXG59KSApIHtcclxuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xyXG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XHJcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcclxuXHRcdH1cclxuXHR9KTtcclxufVxyXG5cclxuLy8gU3VwcG9ydDogSUU8OVxyXG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXHJcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xyXG5cdHJldHVybiBkaXYuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcclxufSkgKSB7XHJcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xyXG5cdFx0dmFyIHZhbDtcclxuXHRcdGlmICggIWlzWE1MICkge1xyXG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcclxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XHJcblx0XHRcdFx0XHR2YWwudmFsdWUgOlxyXG5cdFx0XHRcdG51bGw7XHJcblx0XHR9XHJcblx0fSk7XHJcbn1cclxuXHJcbnJldHVybiBTaXp6bGU7XHJcblxyXG59KSggd2luZG93ICk7XHJcblxyXG5cclxuXHJcbmpRdWVyeS5maW5kID0gU2l6emxlO1xyXG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XHJcbmpRdWVyeS5leHByW1wiOlwiXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XHJcbmpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcclxualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcclxualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xyXG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XHJcblxyXG5cclxuXHJcbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xyXG5cclxudmFyIHJzaW5nbGVUYWcgPSAoL148KFxcdyspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvKTtcclxuXHJcblxyXG5cclxudmFyIHJpc1NpbXBsZSA9IC9eLlteOiNcXFtcXC4sXSokLztcclxuXHJcbi8vIEltcGxlbWVudCB0aGUgaWRlbnRpY2FsIGZ1bmN0aW9uYWxpdHkgZm9yIGZpbHRlciBhbmQgbm90XHJcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xyXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xyXG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XHJcblx0XHRcdC8qIGpzaGludCAtVzAxOCAqL1xyXG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XHJcblx0XHR9KTtcclxuXHJcblx0fVxyXG5cclxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcclxuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xyXG5cdFx0fSk7XHJcblxyXG5cdH1cclxuXHJcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyID09PSBcInN0cmluZ1wiICkge1xyXG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XHJcblx0XHRcdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcclxuXHRcdH1cclxuXHJcblx0XHRxdWFsaWZpZXIgPSBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzICk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdHJldHVybiAoIGluZGV4T2YuY2FsbCggcXVhbGlmaWVyLCBlbGVtICkgPj0gMCApICE9PSBub3Q7XHJcblx0fSk7XHJcbn1cclxuXHJcbmpRdWVyeS5maWx0ZXIgPSBmdW5jdGlvbiggZXhwciwgZWxlbXMsIG5vdCApIHtcclxuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XHJcblxyXG5cdGlmICggbm90ICkge1xyXG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcclxuXHR9XHJcblxyXG5cdHJldHVybiBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSA/XHJcblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW10gOlxyXG5cdFx0alF1ZXJ5LmZpbmQubWF0Y2hlcyggZXhwciwgalF1ZXJ5LmdyZXAoIGVsZW1zLCBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XHJcblx0XHR9KSk7XHJcbn07XHJcblxyXG5qUXVlcnkuZm4uZXh0ZW5kKHtcclxuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XHJcblx0XHR2YXIgaSxcclxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXHJcblx0XHRcdHJldCA9IFtdLFxyXG5cdFx0XHRzZWxmID0gdGhpcztcclxuXHJcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBqUXVlcnkoIHNlbGVjdG9yICkuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0XHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggc2VsZlsgaSBdLCB0aGlzICkgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSkgKTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTmVlZGVkIGJlY2F1c2UgJCggc2VsZWN0b3IsIGNvbnRleHQgKSBiZWNvbWVzICQoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApXHJcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XHJcblx0XHRyZXQuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yID8gdGhpcy5zZWxlY3RvciArIFwiIFwiICsgc2VsZWN0b3IgOiBzZWxlY3RvcjtcclxuXHRcdHJldHVybiByZXQ7XHJcblx0fSxcclxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcclxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSkgKTtcclxuXHR9LFxyXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xyXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3codGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUpICk7XHJcblx0fSxcclxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xyXG5cdFx0cmV0dXJuICEhd2lubm93KFxyXG5cdFx0XHR0aGlzLFxyXG5cclxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxyXG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXHJcblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xyXG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XHJcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXHJcblx0XHRcdGZhbHNlXHJcblx0XHQpLmxlbmd0aDtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XHJcblxyXG5cclxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXHJcbnZhciByb290alF1ZXJ5LFxyXG5cclxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xyXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcclxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcclxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXHJcblxyXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcclxuXHRcdHZhciBtYXRjaCwgZWxlbTtcclxuXHJcblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcclxuXHRcdGlmICggIXNlbGVjdG9yICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXHJcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcclxuXHRcdFx0aWYgKCBzZWxlY3RvclswXSA9PT0gXCI8XCIgJiYgc2VsZWN0b3JbIHNlbGVjdG9yLmxlbmd0aCAtIDEgXSA9PT0gXCI+XCIgJiYgc2VsZWN0b3IubGVuZ3RoID49IDMgKSB7XHJcblx0XHRcdFx0Ly8gQXNzdW1lIHRoYXQgc3RyaW5ncyB0aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCA8PiBhcmUgSFRNTCBhbmQgc2tpcCB0aGUgcmVnZXggY2hlY2tcclxuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcclxuXHRcdFx0aWYgKCBtYXRjaCAmJiAobWF0Y2hbMV0gfHwgIWNvbnRleHQpICkge1xyXG5cclxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcclxuXHRcdFx0XHRpZiAoIG1hdGNoWzFdICkge1xyXG5cdFx0XHRcdFx0Y29udGV4dCA9IGNvbnRleHQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZXh0WzBdIDogY29udGV4dDtcclxuXHJcblx0XHRcdFx0XHQvLyBzY3JpcHRzIGlzIHRydWUgZm9yIGJhY2stY29tcGF0XHJcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxyXG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxyXG5cdFx0XHRcdFx0XHRtYXRjaFsxXSxcclxuXHRcdFx0XHRcdFx0Y29udGV4dCAmJiBjb250ZXh0Lm5vZGVUeXBlID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBkb2N1bWVudCxcclxuXHRcdFx0XHRcdFx0dHJ1ZVxyXG5cdFx0XHRcdFx0KSApO1xyXG5cclxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcclxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsxXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XHJcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XHJcblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxyXG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRoaXNbIG1hdGNoIF0oIGNvbnRleHRbIG1hdGNoIF0gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbMl0gKTtcclxuXHJcblx0XHRcdFx0XHQvLyBDaGVjayBwYXJlbnROb2RlIHRvIGNhdGNoIHdoZW4gQmxhY2tiZXJyeSA0LjYgcmV0dXJuc1xyXG5cdFx0XHRcdFx0Ly8gbm9kZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHRoZSBkb2N1bWVudCAjNjk2M1xyXG5cdFx0XHRcdFx0aWYgKCBlbGVtICYmIGVsZW0ucGFyZW50Tm9kZSApIHtcclxuXHRcdFx0XHRcdFx0Ly8gSW5qZWN0IHRoZSBlbGVtZW50IGRpcmVjdGx5IGludG8gdGhlIGpRdWVyeSBvYmplY3RcclxuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xyXG5cdFx0XHRcdFx0XHR0aGlzWzBdID0gZWxlbTtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0aGlzLmNvbnRleHQgPSBkb2N1bWVudDtcclxuXHRcdFx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcclxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEhBTkRMRTogJChleHByLCAkKC4uLikpXHJcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xyXG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdGpRdWVyeSApLmZpbmQoIHNlbGVjdG9yICk7XHJcblxyXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcclxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXHJcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcclxuXHRcdFx0dGhpcy5jb250ZXh0ID0gdGhpc1swXSA9IHNlbGVjdG9yO1xyXG5cdFx0XHR0aGlzLmxlbmd0aCA9IDE7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdC8vIEhBTkRMRTogJChmdW5jdGlvbilcclxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxyXG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XHJcblx0XHRcdHJldHVybiB0eXBlb2Ygcm9vdGpRdWVyeS5yZWFkeSAhPT0gXCJ1bmRlZmluZWRcIiA/XHJcblx0XHRcdFx0cm9vdGpRdWVyeS5yZWFkeSggc2VsZWN0b3IgKSA6XHJcblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxyXG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHNlbGVjdG9yLnNlbGVjdG9yICE9PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvci5zZWxlY3RvcjtcclxuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcclxuXHR9O1xyXG5cclxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxyXG5pbml0LnByb3RvdHlwZSA9IGpRdWVyeS5mbjtcclxuXHJcbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2Vcclxucm9vdGpRdWVyeSA9IGpRdWVyeSggZG9jdW1lbnQgKTtcclxuXHJcblxyXG52YXIgcnBhcmVudHNwcmV2ID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXHJcblx0Ly8gbWV0aG9kcyBndWFyYW50ZWVkIHRvIHByb2R1Y2UgYSB1bmlxdWUgc2V0IHdoZW4gc3RhcnRpbmcgZnJvbSBhIHVuaXF1ZSBzZXRcclxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xyXG5cdFx0Y2hpbGRyZW46IHRydWUsXHJcblx0XHRjb250ZW50czogdHJ1ZSxcclxuXHRcdG5leHQ6IHRydWUsXHJcblx0XHRwcmV2OiB0cnVlXHJcblx0fTtcclxuXHJcbmpRdWVyeS5leHRlbmQoe1xyXG5cdGRpcjogZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XHJcblx0XHR2YXIgbWF0Y2hlZCA9IFtdLFxyXG5cdFx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xyXG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XHJcblx0XHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG1hdGNoZWQ7XHJcblx0fSxcclxuXHJcblx0c2libGluZzogZnVuY3Rpb24oIG4sIGVsZW0gKSB7XHJcblx0XHR2YXIgbWF0Y2hlZCA9IFtdO1xyXG5cclxuXHRcdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XHJcblx0XHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xyXG5cdFx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG1hdGNoZWQ7XHJcblx0fVxyXG59KTtcclxuXHJcbmpRdWVyeS5mbi5leHRlbmQoe1xyXG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcclxuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcclxuXHRcdFx0bCA9IHRhcmdldHMubGVuZ3RoO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIGkgPSAwO1xyXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XHJcblx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHRoaXMsIHRhcmdldHNbaV0gKSApIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcclxuXHRcdHZhciBjdXIsXHJcblx0XHRcdGkgPSAwLFxyXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXHJcblx0XHRcdG1hdGNoZWQgPSBbXSxcclxuXHRcdFx0cG9zID0gcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSB8fCB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiID9cclxuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9ycywgY29udGV4dCB8fCB0aGlzLmNvbnRleHQgKSA6XHJcblx0XHRcdFx0MDtcclxuXHJcblx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XHJcblx0XHRcdGZvciAoIGN1ciA9IHRoaXNbaV07IGN1ciAmJiBjdXIgIT09IGNvbnRleHQ7IGN1ciA9IGN1ci5wYXJlbnROb2RlICkge1xyXG5cdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xyXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKHBvcyA/XHJcblx0XHRcdFx0XHRwb3MuaW5kZXgoY3VyKSA+IC0xIDpcclxuXHJcblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcclxuXHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxyXG5cdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoY3VyLCBzZWxlY3RvcnMpKSApIHtcclxuXHJcblx0XHRcdFx0XHRtYXRjaGVkLnB1c2goIGN1ciApO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkLmxlbmd0aCA+IDEgPyBqUXVlcnkudW5pcXVlKCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XHJcblx0fSxcclxuXHJcblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpblxyXG5cdC8vIHRoZSBtYXRjaGVkIHNldCBvZiBlbGVtZW50c1xyXG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHJcblx0XHQvLyBObyBhcmd1bWVudCwgcmV0dXJuIGluZGV4IGluIHBhcmVudFxyXG5cdFx0aWYgKCAhZWxlbSApIHtcclxuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGluZGV4IGluIHNlbGVjdG9yXHJcblx0XHRpZiAoIHR5cGVvZiBlbGVtID09PSBcInN0cmluZ1wiICkge1xyXG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XHJcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxyXG5cclxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXHJcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcclxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcclxuXHRcdFx0alF1ZXJ5LnVuaXF1ZShcclxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXHJcblx0XHRcdClcclxuXHRcdCk7XHJcblx0fSxcclxuXHJcblx0YWRkQmFjazogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cclxuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihzZWxlY3RvcilcclxuXHRcdCk7XHJcblx0fVxyXG59KTtcclxuXHJcbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xyXG5cdHdoaWxlICggKGN1ciA9IGN1cltkaXJdKSAmJiBjdXIubm9kZVR5cGUgIT09IDEgKSB7fVxyXG5cdHJldHVybiBjdXI7XHJcbn1cclxuXHJcbmpRdWVyeS5lYWNoKHtcclxuXHRwYXJlbnQ6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcclxuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XHJcblx0fSxcclxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdHJldHVybiBqUXVlcnkuZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xyXG5cdH0sXHJcblx0cGFyZW50c1VudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XHJcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XHJcblx0fSxcclxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcclxuXHR9LFxyXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcclxuXHR9LFxyXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0cmV0dXJuIGpRdWVyeS5kaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xyXG5cdH0sXHJcblx0cHJldkFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiApO1xyXG5cdH0sXHJcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XHJcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiLCB1bnRpbCApO1xyXG5cdH0sXHJcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XHJcblx0XHRyZXR1cm4galF1ZXJ5LmRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcclxuXHR9LFxyXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdHJldHVybiBqUXVlcnkuc2libGluZyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XHJcblx0fSxcclxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRyZXR1cm4galF1ZXJ5LnNpYmxpbmcoIGVsZW0uZmlyc3RDaGlsZCApO1xyXG5cdH0sXHJcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xyXG5cdH1cclxufSwgZnVuY3Rpb24oIG5hbWUsIGZuICkge1xyXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcclxuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XHJcblxyXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XHJcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XHJcblx0XHRcdG1hdGNoZWQgPSBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgbWF0Y2hlZCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5sZW5ndGggPiAxICkge1xyXG5cdFx0XHQvLyBSZW1vdmUgZHVwbGljYXRlc1xyXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XHJcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZSggbWF0Y2hlZCApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBSZXZlcnNlIG9yZGVyIGZvciBwYXJlbnRzKiBhbmQgcHJldi1kZXJpdmF0aXZlc1xyXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XHJcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQgKTtcclxuXHR9O1xyXG59KTtcclxudmFyIHJub3R3aGl0ZSA9ICgvXFxTKy9nKTtcclxuXHJcblxyXG5cclxuLy8gU3RyaW5nIHRvIE9iamVjdCBvcHRpb25zIGZvcm1hdCBjYWNoZVxyXG52YXIgb3B0aW9uc0NhY2hlID0ge307XHJcblxyXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lcyBhbmQgc3RvcmUgaW4gY2FjaGVcclxuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcclxuXHR2YXIgb2JqZWN0ID0gb3B0aW9uc0NhY2hlWyBvcHRpb25zIF0gPSB7fTtcclxuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10sIGZ1bmN0aW9uKCBfLCBmbGFnICkge1xyXG5cdFx0b2JqZWN0WyBmbGFnIF0gPSB0cnVlO1xyXG5cdH0pO1xyXG5cdHJldHVybiBvYmplY3Q7XHJcbn1cclxuXHJcbi8qXHJcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxyXG4gKlxyXG4gKlx0b3B0aW9uczogYW4gb3B0aW9uYWwgbGlzdCBvZiBzcGFjZS1zZXBhcmF0ZWQgb3B0aW9ucyB0aGF0IHdpbGwgY2hhbmdlIGhvd1xyXG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcclxuICpcclxuICogQnkgZGVmYXVsdCBhIGNhbGxiYWNrIGxpc3Qgd2lsbCBhY3QgbGlrZSBhbiBldmVudCBjYWxsYmFjayBsaXN0IGFuZCBjYW4gYmVcclxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxyXG4gKlxyXG4gKiBQb3NzaWJsZSBvcHRpb25zOlxyXG4gKlxyXG4gKlx0b25jZTpcdFx0XHR3aWxsIGVuc3VyZSB0aGUgY2FsbGJhY2sgbGlzdCBjYW4gb25seSBiZSBmaXJlZCBvbmNlIChsaWtlIGEgRGVmZXJyZWQpXHJcbiAqXHJcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxyXG4gKlx0XHRcdFx0XHRhZnRlciB0aGUgbGlzdCBoYXMgYmVlbiBmaXJlZCByaWdodCBhd2F5IHdpdGggdGhlIGxhdGVzdCBcIm1lbW9yaXplZFwiXHJcbiAqXHRcdFx0XHRcdHZhbHVlcyAobGlrZSBhIERlZmVycmVkKVxyXG4gKlxyXG4gKlx0dW5pcXVlOlx0XHRcdHdpbGwgZW5zdXJlIGEgY2FsbGJhY2sgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSAobm8gZHVwbGljYXRlIGluIHRoZSBsaXN0KVxyXG4gKlxyXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcclxuICpcclxuICovXHJcbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcclxuXHJcblx0Ly8gQ29udmVydCBvcHRpb25zIGZyb20gU3RyaW5nLWZvcm1hdHRlZCB0byBPYmplY3QtZm9ybWF0dGVkIGlmIG5lZWRlZFxyXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcclxuXHRvcHRpb25zID0gdHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIgP1xyXG5cdFx0KCBvcHRpb25zQ2FjaGVbIG9wdGlvbnMgXSB8fCBjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgKSA6XHJcblx0XHRqUXVlcnkuZXh0ZW5kKCB7fSwgb3B0aW9ucyApO1xyXG5cclxuXHR2YXIgLy8gTGFzdCBmaXJlIHZhbHVlIChmb3Igbm9uLWZvcmdldHRhYmxlIGxpc3RzKVxyXG5cdFx0bWVtb3J5LFxyXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3Qgd2FzIGFscmVhZHkgZmlyZWRcclxuXHRcdGZpcmVkLFxyXG5cdFx0Ly8gRmxhZyB0byBrbm93IGlmIGxpc3QgaXMgY3VycmVudGx5IGZpcmluZ1xyXG5cdFx0ZmlyaW5nLFxyXG5cdFx0Ly8gRmlyc3QgY2FsbGJhY2sgdG8gZmlyZSAodXNlZCBpbnRlcm5hbGx5IGJ5IGFkZCBhbmQgZmlyZVdpdGgpXHJcblx0XHRmaXJpbmdTdGFydCxcclxuXHRcdC8vIEVuZCBvZiB0aGUgbG9vcCB3aGVuIGZpcmluZ1xyXG5cdFx0ZmlyaW5nTGVuZ3RoLFxyXG5cdFx0Ly8gSW5kZXggb2YgY3VycmVudGx5IGZpcmluZyBjYWxsYmFjayAobW9kaWZpZWQgYnkgcmVtb3ZlIGlmIG5lZWRlZClcclxuXHRcdGZpcmluZ0luZGV4LFxyXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3RcclxuXHRcdGxpc3QgPSBbXSxcclxuXHRcdC8vIFN0YWNrIG9mIGZpcmUgY2FsbHMgZm9yIHJlcGVhdGFibGUgbGlzdHNcclxuXHRcdHN0YWNrID0gIW9wdGlvbnMub25jZSAmJiBbXSxcclxuXHRcdC8vIEZpcmUgY2FsbGJhY2tzXHJcblx0XHRmaXJlID0gZnVuY3Rpb24oIGRhdGEgKSB7XHJcblx0XHRcdG1lbW9yeSA9IG9wdGlvbnMubWVtb3J5ICYmIGRhdGE7XHJcblx0XHRcdGZpcmVkID0gdHJ1ZTtcclxuXHRcdFx0ZmlyaW5nSW5kZXggPSBmaXJpbmdTdGFydCB8fCAwO1xyXG5cdFx0XHRmaXJpbmdTdGFydCA9IDA7XHJcblx0XHRcdGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoO1xyXG5cdFx0XHRmaXJpbmcgPSB0cnVlO1xyXG5cdFx0XHRmb3IgKCA7IGxpc3QgJiYgZmlyaW5nSW5kZXggPCBmaXJpbmdMZW5ndGg7IGZpcmluZ0luZGV4KysgKSB7XHJcblx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBkYXRhWyAwIF0sIGRhdGFbIDEgXSApID09PSBmYWxzZSAmJiBvcHRpb25zLnN0b3BPbkZhbHNlICkge1xyXG5cdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7IC8vIFRvIHByZXZlbnQgZnVydGhlciBjYWxscyB1c2luZyBhZGRcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcclxuXHRcdFx0aWYgKCBsaXN0ICkge1xyXG5cdFx0XHRcdGlmICggc3RhY2sgKSB7XHJcblx0XHRcdFx0XHRpZiAoIHN0YWNrLmxlbmd0aCApIHtcclxuXHRcdFx0XHRcdFx0ZmlyZSggc3RhY2suc2hpZnQoKSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1lbW9yeSApIHtcclxuXHRcdFx0XHRcdGxpc3QgPSBbXTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c2VsZi5kaXNhYmxlKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3RcclxuXHRcdHNlbGYgPSB7XHJcblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3RcclxuXHRcdFx0YWRkOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XHJcblx0XHRcdFx0XHQvLyBGaXJzdCwgd2Ugc2F2ZSB0aGUgY3VycmVudCBsZW5ndGhcclxuXHRcdFx0XHRcdHZhciBzdGFydCA9IGxpc3QubGVuZ3RoO1xyXG5cdFx0XHRcdFx0KGZ1bmN0aW9uIGFkZCggYXJncyApIHtcclxuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggYXJnICk7XHJcblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImZ1bmN0aW9uXCIgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFvcHRpb25zLnVuaXF1ZSB8fCAhc2VsZi5oYXMoIGFyZyApICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRsaXN0LnB1c2goIGFyZyApO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGFyZyAmJiBhcmcubGVuZ3RoICYmIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XHJcblx0XHRcdFx0XHRcdFx0XHRhZGQoIGFyZyApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHR9KSggYXJndW1lbnRzICk7XHJcblx0XHRcdFx0XHQvLyBEbyB3ZSBuZWVkIHRvIGFkZCB0aGUgY2FsbGJhY2tzIHRvIHRoZVxyXG5cdFx0XHRcdFx0Ly8gY3VycmVudCBmaXJpbmcgYmF0Y2g/XHJcblx0XHRcdFx0XHRpZiAoIGZpcmluZyApIHtcclxuXHRcdFx0XHRcdFx0ZmlyaW5nTGVuZ3RoID0gbGlzdC5sZW5ndGg7XHJcblx0XHRcdFx0XHQvLyBXaXRoIG1lbW9yeSwgaWYgd2UncmUgbm90IGZpcmluZyB0aGVuXHJcblx0XHRcdFx0XHQvLyB3ZSBzaG91bGQgY2FsbCByaWdodCBhd2F5XHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBtZW1vcnkgKSB7XHJcblx0XHRcdFx0XHRcdGZpcmluZ1N0YXJ0ID0gc3RhcnQ7XHJcblx0XHRcdFx0XHRcdGZpcmUoIG1lbW9yeSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fSxcclxuXHRcdFx0Ly8gUmVtb3ZlIGEgY2FsbGJhY2sgZnJvbSB0aGUgbGlzdFxyXG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmICggbGlzdCApIHtcclxuXHRcdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XHJcblx0XHRcdFx0XHRcdHZhciBpbmRleDtcclxuXHRcdFx0XHRcdFx0d2hpbGUgKCAoIGluZGV4ID0galF1ZXJ5LmluQXJyYXkoIGFyZywgbGlzdCwgaW5kZXggKSApID4gLTEgKSB7XHJcblx0XHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XHJcblx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGZpcmluZyBpbmRleGVzXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0xlbmd0aCApIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZmlyaW5nTGVuZ3RoLS07XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4IDw9IGZpcmluZ0luZGV4ICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRmaXJpbmdJbmRleC0tO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxyXG5cdFx0XHQvLyBJZiBubyBhcmd1bWVudCBpcyBnaXZlbiwgcmV0dXJuIHdoZXRoZXIgb3Igbm90IGxpc3QgaGFzIGNhbGxiYWNrcyBhdHRhY2hlZC5cclxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZuID8galF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6ICEhKCBsaXN0ICYmIGxpc3QubGVuZ3RoICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdC8vIFJlbW92ZSBhbGwgY2FsbGJhY2tzIGZyb20gdGhlIGxpc3RcclxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGxpc3QgPSBbXTtcclxuXHRcdFx0XHRmaXJpbmdMZW5ndGggPSAwO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHQvLyBIYXZlIHRoZSBsaXN0IGRvIG5vdGhpbmcgYW55bW9yZVxyXG5cdFx0XHRkaXNhYmxlOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRsaXN0ID0gc3RhY2sgPSBtZW1vcnkgPSB1bmRlZmluZWQ7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH0sXHJcblx0XHRcdC8vIElzIGl0IGRpc2FibGVkP1xyXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0cmV0dXJuICFsaXN0O1xyXG5cdFx0XHR9LFxyXG5cdFx0XHQvLyBMb2NrIHRoZSBsaXN0IGluIGl0cyBjdXJyZW50IHN0YXRlXHJcblx0XHRcdGxvY2s6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHN0YWNrID0gdW5kZWZpbmVkO1xyXG5cdFx0XHRcdGlmICggIW1lbW9yeSApIHtcclxuXHRcdFx0XHRcdHNlbGYuZGlzYWJsZSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fSxcclxuXHRcdFx0Ly8gSXMgaXQgbG9ja2VkP1xyXG5cdFx0XHRsb2NrZWQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAhc3RhY2s7XHJcblx0XHRcdH0sXHJcblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcclxuXHRcdFx0ZmlyZVdpdGg6IGZ1bmN0aW9uKCBjb250ZXh0LCBhcmdzICkge1xyXG5cdFx0XHRcdGlmICggbGlzdCAmJiAoICFmaXJlZCB8fCBzdGFjayApICkge1xyXG5cdFx0XHRcdFx0YXJncyA9IGFyZ3MgfHwgW107XHJcblx0XHRcdFx0XHRhcmdzID0gWyBjb250ZXh0LCBhcmdzLnNsaWNlID8gYXJncy5zbGljZSgpIDogYXJncyBdO1xyXG5cdFx0XHRcdFx0aWYgKCBmaXJpbmcgKSB7XHJcblx0XHRcdFx0XHRcdHN0YWNrLnB1c2goIGFyZ3MgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdGZpcmUoIGFyZ3MgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH0sXHJcblx0XHRcdC8vIENhbGwgYWxsIHRoZSBjYWxsYmFja3Mgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzXHJcblx0XHRcdGZpcmU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHQvLyBUbyBrbm93IGlmIHRoZSBjYWxsYmFja3MgaGF2ZSBhbHJlYWR5IGJlZW4gY2FsbGVkIGF0IGxlYXN0IG9uY2VcclxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJldHVybiAhIWZpcmVkO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRyZXR1cm4gc2VsZjtcclxufTtcclxuXHJcblxyXG5qUXVlcnkuZXh0ZW5kKHtcclxuXHJcblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xyXG5cdFx0dmFyIHR1cGxlcyA9IFtcclxuXHRcdFx0XHQvLyBhY3Rpb24sIGFkZCBsaXN0ZW5lciwgbGlzdGVuZXIgbGlzdCwgZmluYWwgc3RhdGVcclxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyhcIm9uY2UgbWVtb3J5XCIpLCBcInJlc29sdmVkXCIgXSxcclxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIiksIFwicmVqZWN0ZWRcIiBdLFxyXG5cdFx0XHRcdFsgXCJub3RpZnlcIiwgXCJwcm9ncmVzc1wiLCBqUXVlcnkuQ2FsbGJhY2tzKFwibWVtb3J5XCIpIF1cclxuXHRcdFx0XSxcclxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcclxuXHRcdFx0cHJvbWlzZSA9IHtcclxuXHRcdFx0XHRzdGF0ZTogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XHJcblx0XHRcdFx0fSxcclxuXHRcdFx0XHRhbHdheXM6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcclxuXHRcdFx0XHRcdHZhciBmbnMgPSBhcmd1bWVudHM7XHJcblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcclxuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xyXG5cdFx0XHRcdFx0XHRcdHZhciBmbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBmbnNbIGkgXSApICYmIGZuc1sgaSBdO1xyXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkWyBkb25lIHwgZmFpbCB8IHByb2dyZXNzIF0gZm9yIGZvcndhcmRpbmcgYWN0aW9ucyB0byBuZXdEZWZlclxyXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsxXSBdKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKTtcclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gcHJvbWlzZSA/IG5ld0RlZmVyLnByb21pc2UoKSA6IHRoaXMsIGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzICk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xyXG5cdFx0XHRcdFx0fSkucHJvbWlzZSgpO1xyXG5cdFx0XHRcdH0sXHJcblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxyXG5cdFx0XHRcdC8vIElmIG9iaiBpcyBwcm92aWRlZCwgdGhlIHByb21pc2UgYXNwZWN0IGlzIGFkZGVkIHRvIHRoZSBvYmplY3RcclxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcclxuXHJcblx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XHJcblx0XHRwcm9taXNlLnBpcGUgPSBwcm9taXNlLnRoZW47XHJcblxyXG5cdFx0Ly8gQWRkIGxpc3Qtc3BlY2lmaWMgbWV0aG9kc1xyXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xyXG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXHJcblx0XHRcdFx0c3RhdGVTdHJpbmcgPSB0dXBsZVsgMyBdO1xyXG5cclxuXHRcdFx0Ly8gcHJvbWlzZVsgZG9uZSB8IGZhaWwgfCBwcm9ncmVzcyBdID0gbGlzdC5hZGRcclxuXHRcdFx0cHJvbWlzZVsgdHVwbGVbMV0gXSA9IGxpc3QuYWRkO1xyXG5cclxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXHJcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XHJcblx0XHRcdFx0bGlzdC5hZGQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXHJcblx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xyXG5cclxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXHJcblx0XHRcdFx0fSwgdHVwbGVzWyBpIF4gMSBdWyAyIF0uZGlzYWJsZSwgdHVwbGVzWyAyIF1bIDIgXS5sb2NrICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGRlZmVycmVkWyByZXNvbHZlIHwgcmVqZWN0IHwgbm90aWZ5IF1cclxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdIF0gPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbMF0gKyBcIldpdGhcIiBdKCB0aGlzID09PSBkZWZlcnJlZCA/IHByb21pc2UgOiB0aGlzLCBhcmd1bWVudHMgKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fTtcclxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWzBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2VcclxuXHRcdHByb21pc2UucHJvbWlzZSggZGVmZXJyZWQgKTtcclxuXHJcblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XHJcblx0XHRpZiAoIGZ1bmMgKSB7XHJcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWxsIGRvbmUhXHJcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XHJcblx0fSxcclxuXHJcblx0Ly8gRGVmZXJyZWQgaGVscGVyXHJcblx0d2hlbjogZnVuY3Rpb24oIHN1Ym9yZGluYXRlIC8qICwgLi4uLCBzdWJvcmRpbmF0ZU4gKi8gKSB7XHJcblx0XHR2YXIgaSA9IDAsXHJcblx0XHRcdHJlc29sdmVWYWx1ZXMgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSxcclxuXHRcdFx0bGVuZ3RoID0gcmVzb2x2ZVZhbHVlcy5sZW5ndGgsXHJcblxyXG5cdFx0XHQvLyB0aGUgY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXHJcblx0XHRcdHJlbWFpbmluZyA9IGxlbmd0aCAhPT0gMSB8fCAoIHN1Ym9yZGluYXRlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBzdWJvcmRpbmF0ZS5wcm9taXNlICkgKSA/IGxlbmd0aCA6IDAsXHJcblxyXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkLiBJZiByZXNvbHZlVmFsdWVzIGNvbnNpc3Qgb2Ygb25seSBhIHNpbmdsZSBEZWZlcnJlZCwganVzdCB1c2UgdGhhdC5cclxuXHRcdFx0ZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIGZ1bmN0aW9uIGZvciBib3RoIHJlc29sdmUgYW5kIHByb2dyZXNzIHZhbHVlc1xyXG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGksIGNvbnRleHRzLCB2YWx1ZXMgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHRcdFx0XHRcdGNvbnRleHRzWyBpIF0gPSB0aGlzO1xyXG5cdFx0XHRcdFx0dmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XHJcblx0XHRcdFx0XHRpZiAoIHZhbHVlcyA9PT0gcHJvZ3Jlc3NWYWx1ZXMgKSB7XHJcblx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGNvbnRleHRzLCB2YWx1ZXMgKTtcclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XHJcblx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjb250ZXh0cywgdmFsdWVzICk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XHJcblxyXG5cdFx0Ly8gYWRkIGxpc3RlbmVycyB0byBEZWZlcnJlZCBzdWJvcmRpbmF0ZXM7IHRyZWF0IG90aGVycyBhcyByZXNvbHZlZFxyXG5cdFx0aWYgKCBsZW5ndGggPiAxICkge1xyXG5cdFx0XHRwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XHJcblx0XHRcdHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xyXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xyXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcclxuXHRcdFx0XHRpZiAoIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiBqUXVlcnkuaXNGdW5jdGlvbiggcmVzb2x2ZVZhbHVlc1sgaSBdLnByb21pc2UgKSApIHtcclxuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKClcclxuXHRcdFx0XHRcdFx0LmRvbmUoIHVwZGF0ZUZ1bmMoIGksIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApIClcclxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApXHJcblx0XHRcdFx0XHRcdC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQtLXJlbWFpbmluZztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBpZiB3ZSdyZSBub3Qgd2FpdGluZyBvbiBhbnl0aGluZywgcmVzb2x2ZSB0aGUgbWFzdGVyXHJcblx0XHRpZiAoICFyZW1haW5pbmcgKSB7XHJcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XHJcbnZhciByZWFkeUxpc3Q7XHJcblxyXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XHJcblx0Ly8gQWRkIHRoZSBjYWxsYmFja1xyXG5cdGpRdWVyeS5yZWFkeS5wcm9taXNlKCkuZG9uZSggZm4gKTtcclxuXHJcblx0cmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG5qUXVlcnkuZXh0ZW5kKHtcclxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxyXG5cdGlzUmVhZHk6IGZhbHNlLFxyXG5cclxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXHJcblx0Ly8gdGhlIHJlYWR5IGV2ZW50IGZpcmVzLiBTZWUgIzY3ODFcclxuXHRyZWFkeVdhaXQ6IDEsXHJcblxyXG5cdC8vIEhvbGQgKG9yIHJlbGVhc2UpIHRoZSByZWFkeSBldmVudFxyXG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XHJcblx0XHRpZiAoIGhvbGQgKSB7XHJcblx0XHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIEhhbmRsZSB3aGVuIHRoZSBET00gaXMgcmVhZHlcclxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XHJcblxyXG5cdFx0Ly8gQWJvcnQgaWYgdGhlcmUgYXJlIHBlbmRpbmcgaG9sZHMgb3Igd2UncmUgYWxyZWFkeSByZWFkeVxyXG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcclxuXHRcdGpRdWVyeS5pc1JlYWR5ID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxyXG5cdFx0aWYgKCB3YWl0ICE9PSB0cnVlICYmIC0talF1ZXJ5LnJlYWR5V2FpdCA+IDAgKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXHJcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XHJcblxyXG5cdFx0Ly8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXHJcblx0XHRpZiAoIGpRdWVyeS5mbi50cmlnZ2VySGFuZGxlciApIHtcclxuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLnRyaWdnZXJIYW5kbGVyKCBcInJlYWR5XCIgKTtcclxuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLm9mZiggXCJyZWFkeVwiICk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBUaGUgcmVhZHkgZXZlbnQgaGFuZGxlciBhbmQgc2VsZiBjbGVhbnVwIG1ldGhvZFxyXG4gKi9cclxuZnVuY3Rpb24gY29tcGxldGVkKCkge1xyXG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XHJcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQsIGZhbHNlICk7XHJcblx0alF1ZXJ5LnJlYWR5KCk7XHJcbn1cclxuXHJcbmpRdWVyeS5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24oIG9iaiApIHtcclxuXHRpZiAoICFyZWFkeUxpc3QgKSB7XHJcblxyXG5cdFx0cmVhZHlMaXN0ID0galF1ZXJ5LkRlZmVycmVkKCk7XHJcblxyXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWQgYWZ0ZXIgdGhlIGJyb3dzZXIgZXZlbnQgaGFzIGFscmVhZHkgb2NjdXJyZWQuXHJcblx0XHQvLyB3ZSBvbmNlIHRyaWVkIHRvIHVzZSByZWFkeVN0YXRlIFwiaW50ZXJhY3RpdmVcIiBoZXJlLCBidXQgaXQgY2F1c2VkIGlzc3VlcyBsaWtlIHRoZSBvbmVcclxuXHRcdC8vIGRpc2NvdmVyZWQgYnkgQ2hyaXNTIGhlcmU6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEyMjgyI2NvbW1lbnQ6MTVcclxuXHRcdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiICkge1xyXG5cdFx0XHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcclxuXHRcdFx0c2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcclxuXHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCwgZmFsc2UgKTtcclxuXHJcblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXHJcblx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkLCBmYWxzZSApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xyXG59O1xyXG5cclxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XHJcbmpRdWVyeS5yZWFkeS5wcm9taXNlKCk7XHJcblxyXG5cclxuXHJcblxyXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cclxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXHJcbnZhciBhY2Nlc3MgPSBqUXVlcnkuYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xyXG5cdHZhciBpID0gMCxcclxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcclxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcclxuXHJcblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xyXG5cdGlmICggalF1ZXJ5LnR5cGUoIGtleSApID09PSBcIm9iamVjdFwiICkge1xyXG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcclxuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xyXG5cdFx0XHRqUXVlcnkuYWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVtpXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xyXG5cdFx0fVxyXG5cclxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxyXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XHJcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xyXG5cclxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xyXG5cdFx0XHRyYXcgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggYnVsayApIHtcclxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XHJcblx0XHRcdGlmICggcmF3ICkge1xyXG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xyXG5cdFx0XHRcdGZuID0gbnVsbDtcclxuXHJcblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRidWxrID0gZm47XHJcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcclxuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGZuICkge1xyXG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcclxuXHRcdFx0XHRmbiggZWxlbXNbaV0sIGtleSwgcmF3ID8gdmFsdWUgOiB2YWx1ZS5jYWxsKCBlbGVtc1tpXSwgaSwgZm4oIGVsZW1zW2ldLCBrZXkgKSApICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBjaGFpbmFibGUgP1xyXG5cdFx0ZWxlbXMgOlxyXG5cclxuXHRcdC8vIEdldHNcclxuXHRcdGJ1bGsgP1xyXG5cdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcclxuXHRcdFx0bGVuID8gZm4oIGVsZW1zWzBdLCBrZXkgKSA6IGVtcHR5R2V0O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gb2JqZWN0IGNhbiBoYXZlIGRhdGFcclxuICovXHJcbmpRdWVyeS5hY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xyXG5cdC8vIEFjY2VwdHMgb25seTpcclxuXHQvLyAgLSBOb2RlXHJcblx0Ly8gICAgLSBOb2RlLkVMRU1FTlRfTk9ERVxyXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXHJcblx0Ly8gIC0gT2JqZWN0XHJcblx0Ly8gICAgLSBBbnlcclxuXHQvKiBqc2hpbnQgLVcwMTggKi9cclxuXHRyZXR1cm4gb3duZXIubm9kZVR5cGUgPT09IDEgfHwgb3duZXIubm9kZVR5cGUgPT09IDkgfHwgISggK293bmVyLm5vZGVUeXBlICk7XHJcbn07XHJcblxyXG5cclxuZnVuY3Rpb24gRGF0YSgpIHtcclxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDwgNCxcclxuXHQvLyBPbGQgV2ViS2l0IGRvZXMgbm90IGhhdmUgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zL2ZyZWV6ZSBtZXRob2QsXHJcblx0Ly8gcmV0dXJuIG5ldyBlbXB0eSBvYmplY3QgaW5zdGVhZCB3aXRoIG5vIFtbc2V0XV0gYWNjZXNzb3JcclxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMuY2FjaGUgPSB7fSwgMCwge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIHt9O1xyXG5cdFx0fVxyXG5cdH0pO1xyXG5cclxuXHR0aGlzLmV4cGFuZG8gPSBqUXVlcnkuZXhwYW5kbyArIE1hdGgucmFuZG9tKCk7XHJcbn1cclxuXHJcbkRhdGEudWlkID0gMTtcclxuRGF0YS5hY2NlcHRzID0galF1ZXJ5LmFjY2VwdERhdGE7XHJcblxyXG5EYXRhLnByb3RvdHlwZSA9IHtcclxuXHRrZXk6IGZ1bmN0aW9uKCBvd25lciApIHtcclxuXHRcdC8vIFdlIGNhbiBhY2NlcHQgZGF0YSBmb3Igbm9uLWVsZW1lbnQgbm9kZXMgaW4gbW9kZXJuIGJyb3dzZXJzLFxyXG5cdFx0Ly8gYnV0IHdlIHNob3VsZCBub3QsIHNlZSAjODMzNS5cclxuXHRcdC8vIEFsd2F5cyByZXR1cm4gdGhlIGtleSBmb3IgYSBmcm96ZW4gb2JqZWN0LlxyXG5cdFx0aWYgKCAhRGF0YS5hY2NlcHRzKCBvd25lciApICkge1xyXG5cdFx0XHRyZXR1cm4gMDtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGVzY3JpcHRvciA9IHt9LFxyXG5cdFx0XHQvLyBDaGVjayBpZiB0aGUgb3duZXIgb2JqZWN0IGFscmVhZHkgaGFzIGEgY2FjaGUga2V5XHJcblx0XHRcdHVubG9jayA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcclxuXHJcblx0XHQvLyBJZiBub3QsIGNyZWF0ZSBvbmVcclxuXHRcdGlmICggIXVubG9jayApIHtcclxuXHRcdFx0dW5sb2NrID0gRGF0YS51aWQrKztcclxuXHJcblx0XHRcdC8vIFNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlLCBub24td3JpdGFibGUgcHJvcGVydHlcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRkZXNjcmlwdG9yWyB0aGlzLmV4cGFuZG8gXSA9IHsgdmFsdWU6IHVubG9jayB9O1xyXG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBvd25lciwgZGVzY3JpcHRvciApO1xyXG5cclxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8IDRcclxuXHRcdFx0Ly8gRmFsbGJhY2sgdG8gYSBsZXNzIHNlY3VyZSBkZWZpbml0aW9uXHJcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xyXG5cdFx0XHRcdGRlc2NyaXB0b3JbIHRoaXMuZXhwYW5kbyBdID0gdW5sb2NrO1xyXG5cdFx0XHRcdGpRdWVyeS5leHRlbmQoIG93bmVyLCBkZXNjcmlwdG9yICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBFbnN1cmUgdGhlIGNhY2hlIG9iamVjdFxyXG5cdFx0aWYgKCAhdGhpcy5jYWNoZVsgdW5sb2NrIF0gKSB7XHJcblx0XHRcdHRoaXMuY2FjaGVbIHVubG9jayBdID0ge307XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHVubG9jaztcclxuXHR9LFxyXG5cdHNldDogZnVuY3Rpb24oIG93bmVyLCBkYXRhLCB2YWx1ZSApIHtcclxuXHRcdHZhciBwcm9wLFxyXG5cdFx0XHQvLyBUaGVyZSBtYXkgYmUgYW4gdW5sb2NrIGFzc2lnbmVkIHRvIHRoaXMgbm9kZSxcclxuXHRcdFx0Ly8gaWYgdGhlcmUgaXMgbm8gZW50cnkgZm9yIHRoaXMgXCJvd25lclwiLCBjcmVhdGUgb25lIGlubGluZVxyXG5cdFx0XHQvLyBhbmQgc2V0IHRoZSB1bmxvY2sgYXMgdGhvdWdoIGFuIG93bmVyIGVudHJ5IGhhZCBhbHdheXMgZXhpc3RlZFxyXG5cdFx0XHR1bmxvY2sgPSB0aGlzLmtleSggb3duZXIgKSxcclxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlWyB1bmxvY2sgXTtcclxuXHJcblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIGtleSwgdmFsdWUgXSBhcmdzXHJcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xyXG5cdFx0XHRjYWNoZVsgZGF0YSBdID0gdmFsdWU7XHJcblxyXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCB7IHByb3BlcnRpZXMgfSBdIGFyZ3NcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIEZyZXNoIGFzc2lnbm1lbnRzIGJ5IG9iamVjdCBhcmUgc2hhbGxvdyBjb3BpZWRcclxuXHRcdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcclxuXHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLmNhY2hlWyB1bmxvY2sgXSwgZGF0YSApO1xyXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBkYXRhICkge1xyXG5cdFx0XHRcdFx0Y2FjaGVbIHByb3AgXSA9IGRhdGFbIHByb3AgXTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBjYWNoZTtcclxuXHR9LFxyXG5cdGdldDogZnVuY3Rpb24oIG93bmVyLCBrZXkgKSB7XHJcblx0XHQvLyBFaXRoZXIgYSB2YWxpZCBjYWNoZSBpcyBmb3VuZCwgb3Igd2lsbCBiZSBjcmVhdGVkLlxyXG5cdFx0Ly8gTmV3IGNhY2hlcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSB1bmxvY2sgcmV0dXJuZWQsXHJcblx0XHQvLyBhbGxvd2luZyBkaXJlY3QgYWNjZXNzIHRvIHRoZSBuZXdseSBjcmVhdGVkXHJcblx0XHQvLyBlbXB0eSBkYXRhIG9iamVjdC4gQSB2YWxpZCBvd25lciBvYmplY3QgbXVzdCBiZSBwcm92aWRlZC5cclxuXHRcdHZhciBjYWNoZSA9IHRoaXMuY2FjaGVbIHRoaXMua2V5KCBvd25lciApIF07XHJcblxyXG5cdFx0cmV0dXJuIGtleSA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0Y2FjaGUgOiBjYWNoZVsga2V5IF07XHJcblx0fSxcclxuXHRhY2Nlc3M6IGZ1bmN0aW9uKCBvd25lciwga2V5LCB2YWx1ZSApIHtcclxuXHRcdHZhciBzdG9yZWQ7XHJcblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XHJcblx0XHQvL1xyXG5cdFx0Ly8gICAxLiBObyBrZXkgd2FzIHNwZWNpZmllZFxyXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXHJcblx0XHQvL1xyXG5cdFx0Ly8gVGFrZSB0aGUgXCJyZWFkXCIgcGF0aCBhbmQgYWxsb3cgdGhlIGdldCBtZXRob2QgdG8gZGV0ZXJtaW5lXHJcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XHJcblx0XHQvL1xyXG5cdFx0Ly8gICAxLiBUaGUgZW50aXJlIGNhY2hlIG9iamVjdFxyXG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxyXG5cdFx0Ly9cclxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHxcclxuXHRcdFx0XHQoKGtleSAmJiB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSApIHtcclxuXHJcblx0XHRcdHN0b3JlZCA9IHRoaXMuZ2V0KCBvd25lciwga2V5ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gc3RvcmVkICE9PSB1bmRlZmluZWQgP1xyXG5cdFx0XHRcdHN0b3JlZCA6IHRoaXMuZ2V0KCBvd25lciwgalF1ZXJ5LmNhbWVsQ2FzZShrZXkpICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gWypdV2hlbiB0aGUga2V5IGlzIG5vdCBhIHN0cmluZywgb3IgYm90aCBhIGtleSBhbmQgdmFsdWVcclxuXHRcdC8vIGFyZSBzcGVjaWZpZWQsIHNldCBvciBleHRlbmQgKGV4aXN0aW5nIG9iamVjdHMpIHdpdGggZWl0aGVyOlxyXG5cdFx0Ly9cclxuXHRcdC8vICAgMS4gQW4gb2JqZWN0IG9mIHByb3BlcnRpZXNcclxuXHRcdC8vICAgMi4gQSBrZXkgYW5kIHZhbHVlXHJcblx0XHQvL1xyXG5cdFx0dGhpcy5zZXQoIG93bmVyLCBrZXksIHZhbHVlICk7XHJcblxyXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXHJcblx0XHQvLyByZXR1cm4gdGhlIGV4cGVjdGVkIGRhdGEgYmFzZWQgb24gd2hpY2ggcGF0aCB3YXMgdGFrZW5bKl1cclxuXHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiBrZXk7XHJcblx0fSxcclxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBvd25lciwga2V5ICkge1xyXG5cdFx0dmFyIGksIG5hbWUsIGNhbWVsLFxyXG5cdFx0XHR1bmxvY2sgPSB0aGlzLmtleSggb3duZXIgKSxcclxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlWyB1bmxvY2sgXTtcclxuXHJcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHR0aGlzLmNhY2hlWyB1bmxvY2sgXSA9IHt9O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXHJcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIGtleSApICkge1xyXG5cdFx0XHRcdC8vIElmIFwibmFtZVwiIGlzIGFuIGFycmF5IG9mIGtleXMuLi5cclxuXHRcdFx0XHQvLyBXaGVuIGRhdGEgaXMgaW5pdGlhbGx5IGNyZWF0ZWQsIHZpYSAoXCJrZXlcIiwgXCJ2YWxcIikgc2lnbmF0dXJlLFxyXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxyXG5cdFx0XHRcdC8vIFNpbmNlIHRoZXJlIGlzIG5vIHdheSB0byB0ZWxsIF9ob3dfIGEga2V5IHdhcyBhZGRlZCwgcmVtb3ZlXHJcblx0XHRcdFx0Ly8gYm90aCBwbGFpbiBrZXkgYW5kIGNhbWVsQ2FzZSBrZXkuICMxMjc4NlxyXG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxyXG5cdFx0XHRcdG5hbWUgPSBrZXkuY29uY2F0KCBrZXkubWFwKCBqUXVlcnkuY2FtZWxDYXNlICkgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRjYW1lbCA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xyXG5cdFx0XHRcdC8vIFRyeSB0aGUgc3RyaW5nIGFzIGEga2V5IGJlZm9yZSBhbnkgbWFuaXB1bGF0aW9uXHJcblx0XHRcdFx0aWYgKCBrZXkgaW4gY2FjaGUgKSB7XHJcblx0XHRcdFx0XHRuYW1lID0gWyBrZXksIGNhbWVsIF07XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cclxuXHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgY3JlYXRlIGFuIGFycmF5IGJ5IG1hdGNoaW5nIG5vbi13aGl0ZXNwYWNlXHJcblx0XHRcdFx0XHRuYW1lID0gY2FtZWw7XHJcblx0XHRcdFx0XHRuYW1lID0gbmFtZSBpbiBjYWNoZSA/XHJcblx0XHRcdFx0XHRcdFsgbmFtZSBdIDogKCBuYW1lLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aSA9IG5hbWUubGVuZ3RoO1xyXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcclxuXHRcdFx0XHRkZWxldGUgY2FjaGVbIG5hbWVbIGkgXSBdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHRoYXNEYXRhOiBmdW5jdGlvbiggb3duZXIgKSB7XHJcblx0XHRyZXR1cm4gIWpRdWVyeS5pc0VtcHR5T2JqZWN0KFxyXG5cdFx0XHR0aGlzLmNhY2hlWyBvd25lclsgdGhpcy5leHBhbmRvIF0gXSB8fCB7fVxyXG5cdFx0KTtcclxuXHR9LFxyXG5cdGRpc2NhcmQ6IGZ1bmN0aW9uKCBvd25lciApIHtcclxuXHRcdGlmICggb3duZXJbIHRoaXMuZXhwYW5kbyBdICkge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5jYWNoZVsgb3duZXJbIHRoaXMuZXhwYW5kbyBdIF07XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG52YXIgZGF0YV9wcml2ID0gbmV3IERhdGEoKTtcclxuXHJcbnZhciBkYXRhX3VzZXIgPSBuZXcgRGF0YSgpO1xyXG5cclxuXHJcblxyXG4vKlxyXG5cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcclxuXHJcblx0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxyXG5cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxyXG5cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxyXG5cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXHJcblx0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxyXG5cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxyXG5cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxyXG4qL1xyXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxyXG5cdHJtdWx0aURhc2ggPSAvKFtBLVpdKS9nO1xyXG5cclxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcclxuXHR2YXIgbmFtZTtcclxuXHJcblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxyXG5cdC8vIGRhdGEgZnJvbSB0aGUgSFRNTDUgZGF0YS0qIGF0dHJpYnV0ZVxyXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XHJcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQxXCIgKS50b0xvd2VyQ2FzZSgpO1xyXG5cdFx0ZGF0YSA9IGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICk7XHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcclxuXHRcdFx0XHRcdGRhdGEgPT09IFwiZmFsc2VcIiA/IGZhbHNlIDpcclxuXHRcdFx0XHRcdGRhdGEgPT09IFwibnVsbFwiID8gbnVsbCA6XHJcblx0XHRcdFx0XHQvLyBPbmx5IGNvbnZlcnQgdG8gYSBudW1iZXIgaWYgaXQgZG9lc24ndCBjaGFuZ2UgdGhlIHN0cmluZ1xyXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxyXG5cdFx0XHRcdFx0cmJyYWNlLnRlc3QoIGRhdGEgKSA/IGpRdWVyeS5wYXJzZUpTT04oIGRhdGEgKSA6XHJcblx0XHRcdFx0XHRkYXRhO1xyXG5cdFx0XHR9IGNhdGNoKCBlICkge31cclxuXHJcblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxyXG5cdFx0XHRkYXRhX3VzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBkYXRhO1xyXG59XHJcblxyXG5qUXVlcnkuZXh0ZW5kKHtcclxuXHRoYXNEYXRhOiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdHJldHVybiBkYXRhX3VzZXIuaGFzRGF0YSggZWxlbSApIHx8IGRhdGFfcHJpdi5oYXNEYXRhKCBlbGVtICk7XHJcblx0fSxcclxuXHJcblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XHJcblx0XHRyZXR1cm4gZGF0YV91c2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xyXG5cdFx0ZGF0YV91c2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXHJcblx0Ly8gd2l0aCBkaXJlY3QgY2FsbHMgdG8gZGF0YV9wcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxyXG5cdF9kYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZGF0YSApIHtcclxuXHRcdHJldHVybiBkYXRhX3ByaXYuYWNjZXNzKCBlbGVtLCBuYW1lLCBkYXRhICk7XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xyXG5cdFx0ZGF0YV9wcml2LnJlbW92ZSggZWxlbSwgbmFtZSApO1xyXG5cdH1cclxufSk7XHJcblxyXG5qUXVlcnkuZm4uZXh0ZW5kKHtcclxuXHRkYXRhOiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcclxuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxyXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdLFxyXG5cdFx0XHRhdHRycyA9IGVsZW0gJiYgZWxlbS5hdHRyaWJ1dGVzO1xyXG5cclxuXHRcdC8vIEdldHMgYWxsIHZhbHVlc1xyXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcclxuXHRcdFx0XHRkYXRhID0gZGF0YV91c2VyLmdldCggZWxlbSApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgIWRhdGFfcHJpdi5nZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIgKSApIHtcclxuXHRcdFx0XHRcdGkgPSBhdHRycy5sZW5ndGg7XHJcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFMTErXHJcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxyXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XHJcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGF0dHJzWyBpIF0ubmFtZTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZS5zbGljZSg1KSApO1xyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YUF0dHIoIGVsZW0sIG5hbWUsIGRhdGFbIG5hbWUgXSApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZGF0YV9wcml2LnNldCggZWxlbSwgXCJoYXNEYXRhQXR0cnNcIiwgdHJ1ZSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGRhdGE7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcclxuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRkYXRhX3VzZXIuc2V0KCB0aGlzLCBrZXkgKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xyXG5cdFx0XHR2YXIgZGF0YSxcclxuXHRcdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xyXG5cclxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcclxuXHRcdFx0Ly8gKGFuZCB0aGVyZWZvcmUgaGFzIGFuIGVsZW1lbnQgYXBwZWFycyBhdCB0aGlzWyAwIF0pIGFuZCB0aGVcclxuXHRcdFx0Ly8gYHZhbHVlYCBwYXJhbWV0ZXIgd2FzIG5vdCB1bmRlZmluZWQuIEFuIGVtcHR5IGpRdWVyeSBvYmplY3RcclxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxyXG5cdFx0XHQvLyB0aHJvdyBhbiBleGNlcHRpb24gaWYgYW4gYXR0ZW1wdCB0byByZWFkIGEgZGF0YSBjYWNoZSBpcyBtYWRlLlxyXG5cdFx0XHRpZiAoIGVsZW0gJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXHJcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGFzLWlzXHJcblx0XHRcdFx0ZGF0YSA9IGRhdGFfdXNlci5nZXQoIGVsZW0sIGtleSApO1xyXG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIGdldCBkYXRhIGZyb20gdGhlIGNhY2hlXHJcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGNhbWVsaXplZFxyXG5cdFx0XHRcdGRhdGEgPSBkYXRhX3VzZXIuZ2V0KCBlbGVtLCBjYW1lbEtleSApO1xyXG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBBdHRlbXB0IHRvIFwiZGlzY292ZXJcIiB0aGUgZGF0YSBpblxyXG5cdFx0XHRcdC8vIEhUTUw1IGN1c3RvbSBkYXRhLSogYXR0cnNcclxuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGNhbWVsS2V5LCB1bmRlZmluZWQgKTtcclxuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gV2UgdHJpZWQgcmVhbGx5IGhhcmQsIGJ1dCB0aGUgZGF0YSBkb2Vzbid0IGV4aXN0LlxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXHJcblx0XHRcdHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvLyBGaXJzdCwgYXR0ZW1wdCB0byBzdG9yZSBhIGNvcHkgb3IgcmVmZXJlbmNlIG9mIGFueVxyXG5cdFx0XHRcdC8vIGRhdGEgdGhhdCBtaWdodCd2ZSBiZWVuIHN0b3JlIHdpdGggYSBjYW1lbENhc2VkIGtleS5cclxuXHRcdFx0XHR2YXIgZGF0YSA9IGRhdGFfdXNlci5nZXQoIHRoaXMsIGNhbWVsS2V5ICk7XHJcblxyXG5cdFx0XHRcdC8vIEZvciBIVE1MNSBkYXRhLSogYXR0cmlidXRlIGludGVyb3AsIHdlIGhhdmUgdG9cclxuXHRcdFx0XHQvLyBzdG9yZSBwcm9wZXJ0eSBuYW1lcyB3aXRoIGRhc2hlcyBpbiBhIGNhbWVsQ2FzZSBmb3JtLlxyXG5cdFx0XHRcdC8vIFRoaXMgbWlnaHQgbm90IGFwcGx5IHRvIGFsbCBwcm9wZXJ0aWVzLi4uKlxyXG5cdFx0XHRcdGRhdGFfdXNlci5zZXQoIHRoaXMsIGNhbWVsS2V5LCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0XHQvLyAqLi4uIEluIHRoZSBjYXNlIG9mIHByb3BlcnRpZXMgdGhhdCBtaWdodCBfYWN0dWFsbHlfXHJcblx0XHRcdFx0Ly8gaGF2ZSBkYXNoZXMsIHdlIG5lZWQgdG8gYWxzbyBzdG9yZSBhIGNvcHkgb2YgdGhhdFxyXG5cdFx0XHRcdC8vIHVuY2hhbmdlZCBwcm9wZXJ0eS5cclxuXHRcdFx0XHRpZiAoIGtleS5pbmRleE9mKFwiLVwiKSAhPT0gLTEgJiYgZGF0YSAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdFx0ZGF0YV91c2VyLnNldCggdGhpcywga2V5LCB2YWx1ZSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0ZGF0YV91c2VyLnJlbW92ZSggdGhpcywga2V5ICk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbmpRdWVyeS5leHRlbmQoe1xyXG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcclxuXHRcdHZhciBxdWV1ZTtcclxuXHJcblx0XHRpZiAoIGVsZW0gKSB7XHJcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XHJcblx0XHRcdHF1ZXVlID0gZGF0YV9wcml2LmdldCggZWxlbSwgdHlwZSApO1xyXG5cclxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxyXG5cdFx0XHRpZiAoIGRhdGEgKSB7XHJcblx0XHRcdFx0aWYgKCAhcXVldWUgfHwgalF1ZXJ5LmlzQXJyYXkoIGRhdGEgKSApIHtcclxuXHRcdFx0XHRcdHF1ZXVlID0gZGF0YV9wcml2LmFjY2VzcyggZWxlbSwgdHlwZSwgalF1ZXJ5Lm1ha2VBcnJheShkYXRhKSApO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCBkYXRhICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBxdWV1ZSB8fCBbXTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcclxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcclxuXHJcblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcclxuXHRcdFx0c3RhcnRMZW5ndGggPSBxdWV1ZS5sZW5ndGgsXHJcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKSxcclxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcclxuXHRcdFx0bmV4dCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCBlbGVtLCB0eXBlICk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0Ly8gSWYgdGhlIGZ4IHF1ZXVlIGlzIGRlcXVldWVkLCBhbHdheXMgcmVtb3ZlIHRoZSBwcm9ncmVzcyBzZW50aW5lbFxyXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XHJcblx0XHRcdGZuID0gcXVldWUuc2hpZnQoKTtcclxuXHRcdFx0c3RhcnRMZW5ndGgtLTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGZuICkge1xyXG5cclxuXHRcdFx0Ly8gQWRkIGEgcHJvZ3Jlc3Mgc2VudGluZWwgdG8gcHJldmVudCB0aGUgZnggcXVldWUgZnJvbSBiZWluZ1xyXG5cdFx0XHQvLyBhdXRvbWF0aWNhbGx5IGRlcXVldWVkXHJcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xyXG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoIFwiaW5wcm9ncmVzc1wiICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGNsZWFyIHVwIHRoZSBsYXN0IHF1ZXVlIHN0b3AgZnVuY3Rpb25cclxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XHJcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XHJcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHQvLyBub3QgaW50ZW5kZWQgZm9yIHB1YmxpYyBjb25zdW1wdGlvbiAtIGdlbmVyYXRlcyBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm5zIHRoZSBjdXJyZW50IG9uZVxyXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcclxuXHRcdHZhciBrZXkgPSB0eXBlICsgXCJxdWV1ZUhvb2tzXCI7XHJcblx0XHRyZXR1cm4gZGF0YV9wcml2LmdldCggZWxlbSwga2V5ICkgfHwgZGF0YV9wcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XHJcblx0XHRcdGVtcHR5OiBqUXVlcnkuQ2FsbGJhY2tzKFwib25jZSBtZW1vcnlcIikuYWRkKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIFsgdHlwZSArIFwicXVldWVcIiwga2V5IF0gKTtcclxuXHRcdFx0fSlcclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5qUXVlcnkuZm4uZXh0ZW5kKHtcclxuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XHJcblx0XHR2YXIgc2V0dGVyID0gMjtcclxuXHJcblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xyXG5cdFx0XHRkYXRhID0gdHlwZTtcclxuXHRcdFx0dHlwZSA9IFwiZnhcIjtcclxuXHRcdFx0c2V0dGVyLS07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xyXG5cdFx0XHRyZXR1cm4galF1ZXJ5LnF1ZXVlKCB0aGlzWzBdLCB0eXBlICk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdHRoaXMgOlxyXG5cdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIHF1ZXVlID0galF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBkYXRhICk7XHJcblxyXG5cdFx0XHRcdC8vIGVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXHJcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCB0aGlzLCB0eXBlICk7XHJcblxyXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWzBdICE9PSBcImlucHJvZ3Jlc3NcIiApIHtcclxuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHR9LFxyXG5cdGRlcXVldWU6IGZ1bmN0aW9uKCB0eXBlICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIHR5cGUgKTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XHJcblx0fSxcclxuXHQvLyBHZXQgYSBwcm9taXNlIHJlc29sdmVkIHdoZW4gcXVldWVzIG9mIGEgY2VydGFpbiB0eXBlXHJcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXHJcblx0cHJvbWlzZTogZnVuY3Rpb24oIHR5cGUsIG9iaiApIHtcclxuXHRcdHZhciB0bXAsXHJcblx0XHRcdGNvdW50ID0gMSxcclxuXHRcdFx0ZGVmZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcclxuXHRcdFx0ZWxlbWVudHMgPSB0aGlzLFxyXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXHJcblx0XHRcdHJlc29sdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoICEoIC0tY291bnQgKSApIHtcclxuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XHJcblx0XHRcdG9iaiA9IHR5cGU7XHJcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XHJcblxyXG5cdFx0d2hpbGUgKCBpLS0gKSB7XHJcblx0XHRcdHRtcCA9IGRhdGFfcHJpdi5nZXQoIGVsZW1lbnRzWyBpIF0sIHR5cGUgKyBcInF1ZXVlSG9va3NcIiApO1xyXG5cdFx0XHRpZiAoIHRtcCAmJiB0bXAuZW1wdHkgKSB7XHJcblx0XHRcdFx0Y291bnQrKztcclxuXHRcdFx0XHR0bXAuZW1wdHkuYWRkKCByZXNvbHZlICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJlc29sdmUoKTtcclxuXHRcdHJldHVybiBkZWZlci5wcm9taXNlKCBvYmogKTtcclxuXHR9XHJcbn0pO1xyXG52YXIgcG51bSA9ICgvWystXT8oPzpcXGQqXFwufClcXGQrKD86W2VFXVsrLV0/XFxkK3wpLykuc291cmNlO1xyXG5cclxudmFyIGNzc0V4cGFuZCA9IFsgXCJUb3BcIiwgXCJSaWdodFwiLCBcIkJvdHRvbVwiLCBcIkxlZnRcIiBdO1xyXG5cclxudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24oIGVsZW0sIGVsICkge1xyXG5cdFx0Ly8gaXNIaWRkZW4gbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcclxuXHRcdC8vIGluIHRoYXQgY2FzZSwgZWxlbWVudCB3aWxsIGJlIHNlY29uZCBhcmd1bWVudFxyXG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XHJcblx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCIgfHwgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XHJcblx0fTtcclxuXHJcbnZhciByY2hlY2thYmxlVHlwZSA9ICgvXig/OmNoZWNrYm94fHJhZGlvKSQvaSk7XHJcblxyXG5cclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHR2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXHJcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXHJcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xyXG5cclxuXHQvLyAjMTEyMTcgLSBXZWJLaXQgbG9zZXMgY2hlY2sgd2hlbiB0aGUgbmFtZSBpcyBhZnRlciB0aGUgY2hlY2tlZCBhdHRyaWJ1dGVcclxuXHQvLyBTdXBwb3J0OiBXaW5kb3dzIFdlYiBBcHBzIChXV0EpXHJcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbmVlZCAuc2V0QXR0cmlidXRlIGZvciBXV0FcclxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwidHlwZVwiLCBcInJhZGlvXCIgKTtcclxuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xyXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XHJcblxyXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcclxuXHJcblx0Ly8gU3VwcG9ydDogU2FmYXJpIDUuMSwgaU9TIDUuMSwgQW5kcm9pZCA0LngsIEFuZHJvaWQgMi4zXHJcblx0Ly8gb2xkIFdlYktpdCBkb2Vzbid0IGNsb25lIGNoZWNrZWQgc3RhdGUgY29ycmVjdGx5IGluIGZyYWdtZW50c1xyXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcclxuXHJcblx0Ly8gTWFrZSBzdXJlIHRleHRhcmVhIChhbmQgY2hlY2tib3gpIGRlZmF1bHRWYWx1ZSBpcyBwcm9wZXJseSBjbG9uZWRcclxuXHQvLyBTdXBwb3J0OiBJRTktSUUxMStcclxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XHJcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XHJcbn0pKCk7XHJcbnZhciBzdHJ1bmRlZmluZWQgPSB0eXBlb2YgdW5kZWZpbmVkO1xyXG5cclxuXHJcblxyXG5zdXBwb3J0LmZvY3VzaW5CdWJibGVzID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XHJcblxyXG5cclxudmFyXHJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxyXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51KXxjbGljay8sXHJcblx0cmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXHJcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkkLztcclxuXHJcbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XHJcblx0cmV0dXJuIHRydWU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xyXG5cdHJldHVybiBmYWxzZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XHJcblx0dHJ5IHtcclxuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cclxufVxyXG5cclxuLypcclxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxyXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxyXG4gKi9cclxualF1ZXJ5LmV2ZW50ID0ge1xyXG5cclxuXHRnbG9iYWw6IHt9LFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XHJcblxyXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxyXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcclxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxyXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFfcHJpdi5nZXQoIGVsZW0gKTtcclxuXHJcblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxyXG5cdFx0aWYgKCAhZWxlbURhdGEgKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xyXG5cdFx0XHRoYW5kbGVPYmpJbiA9IGhhbmRsZXI7XHJcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xyXG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xyXG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3RcclxuXHRcdGlmICggIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpICkge1xyXG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSB7fTtcclxuXHRcdH1cclxuXHRcdGlmICggIShldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSkgKSB7XHJcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XHJcblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcclxuXHRcdFx0XHQvLyB3aGVuIGFuIGV2ZW50IGlzIGNhbGxlZCBhZnRlciBhIHBhZ2UgaGFzIHVubG9hZGVkXHJcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IHN0cnVuZGVmaW5lZCAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xyXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmRpc3BhdGNoLmFwcGx5KCBlbGVtLCBhcmd1bWVudHMgKSA6IHVuZGVmaW5lZDtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXHJcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcclxuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XHJcblx0XHR3aGlsZSAoIHQtLSApIHtcclxuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbdF0gKSB8fCBbXTtcclxuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWzFdO1xyXG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbMl0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcclxuXHJcblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xyXG5cdFx0XHRpZiAoICF0eXBlICkge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcclxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XHJcblxyXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcclxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxyXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcclxuXHJcblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXHJcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoe1xyXG5cdFx0XHRcdHR5cGU6IHR5cGUsXHJcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxyXG5cdFx0XHRcdGRhdGE6IGRhdGEsXHJcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcclxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXHJcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxyXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXHJcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oXCIuXCIpXHJcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XHJcblxyXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxyXG5cdFx0XHRpZiAoICEoaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSkgKSB7XHJcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xyXG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xyXG5cclxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2VcclxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8IHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XHJcblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcclxuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSwgZmFsc2UgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XHJcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XHJcblxyXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XHJcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcclxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcclxuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cclxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XHJcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcclxuXHJcblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXHJcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxyXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXHJcblx0XHRcdGVsZW1EYXRhID0gZGF0YV9wcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhX3ByaXYuZ2V0KCBlbGVtICk7XHJcblxyXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgIShldmVudHMgPSBlbGVtRGF0YS5ldmVudHMpICkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxyXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XHJcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xyXG5cdFx0d2hpbGUgKCB0LS0gKSB7XHJcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzW3RdICkgfHwgW107XHJcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsxXTtcclxuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWzJdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XHJcblxyXG5cdFx0XHQvLyBVbmJpbmQgYWxsIGV2ZW50cyAob24gdGhpcyBuYW1lc3BhY2UsIGlmIHByb3ZpZGVkKSBmb3IgdGhlIGVsZW1lbnRcclxuXHRcdFx0aWYgKCAhdHlwZSApIHtcclxuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcclxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKyB0eXBlc1sgdCBdLCBoYW5kbGVyLCBzZWxlY3RvciwgdHJ1ZSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XHJcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcclxuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcclxuXHRcdFx0dG1wID0gdG1wWzJdICYmIG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oXCJcXFxcLig/Oi4qXFxcXC58KVwiKSArIFwiKFxcXFwufCQpXCIgKTtcclxuXHJcblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcclxuXHRcdFx0b3JpZ0NvdW50ID0gaiA9IGhhbmRsZXJzLmxlbmd0aDtcclxuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XHJcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcclxuXHJcblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxyXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcclxuXHRcdFx0XHRcdCggIXRtcCB8fCB0bXAudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkgJiZcclxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcclxuXHRcdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaiwgMSApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xyXG5cdFx0XHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LS07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xyXG5cdFx0XHRcdFx0XHRzcGVjaWFsLnJlbW92ZS5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3RcclxuXHRcdFx0Ly8gKGF2b2lkcyBwb3RlbnRpYWwgZm9yIGVuZGxlc3MgcmVjdXJzaW9uIGR1cmluZyByZW1vdmFsIG9mIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMpXHJcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XHJcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fCBzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZW1vdmUgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxyXG5cdFx0aWYgKCBqUXVlcnkuaXNFbXB0eU9iamVjdCggZXZlbnRzICkgKSB7XHJcblx0XHRcdGRlbGV0ZSBlbGVtRGF0YS5oYW5kbGU7XHJcblx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGVsZW0sIFwiZXZlbnRzXCIgKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggZXZlbnQsIGRhdGEsIGVsZW0sIG9ubHlIYW5kbGVycyApIHtcclxuXHJcblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLFxyXG5cdFx0XHRldmVudFBhdGggPSBbIGVsZW0gfHwgZG9jdW1lbnQgXSxcclxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcclxuXHRcdFx0bmFtZXNwYWNlcyA9IGhhc093bi5jYWxsKCBldmVudCwgXCJuYW1lc3BhY2VcIiApID8gZXZlbnQubmFtZXNwYWNlLnNwbGl0KFwiLlwiKSA6IFtdO1xyXG5cclxuXHRcdGN1ciA9IHRtcCA9IGVsZW0gPSBlbGVtIHx8IGRvY3VtZW50O1xyXG5cclxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXHJcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDMgfHwgZWxlbS5ub2RlVHlwZSA9PT0gOCApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xyXG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0eXBlLmluZGV4T2YoXCIuXCIpID49IDAgKSB7XHJcblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcclxuXHRcdFx0bmFtZXNwYWNlcyA9IHR5cGUuc3BsaXQoXCIuXCIpO1xyXG5cdFx0XHR0eXBlID0gbmFtZXNwYWNlcy5zaGlmdCgpO1xyXG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcclxuXHRcdH1cclxuXHRcdG9udHlwZSA9IHR5cGUuaW5kZXhPZihcIjpcIikgPCAwICYmIFwib25cIiArIHR5cGU7XHJcblxyXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXHJcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cclxuXHRcdFx0ZXZlbnQgOlxyXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcclxuXHJcblx0XHQvLyBUcmlnZ2VyIGJpdG1hc2s6ICYgMSBmb3IgbmF0aXZlIGhhbmRsZXJzOyAmIDIgZm9yIGpRdWVyeSAoYWx3YXlzIHRydWUpXHJcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcclxuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbihcIi5cIik7XHJcblx0XHRldmVudC5uYW1lc3BhY2VfcmUgPSBldmVudC5uYW1lc3BhY2UgP1xyXG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKFwiXFxcXC4oPzouKlxcXFwufClcIikgKyBcIihcXFxcLnwkKVwiICkgOlxyXG5cdFx0XHRudWxsO1xyXG5cclxuXHRcdC8vIENsZWFuIHVwIHRoZSBldmVudCBpbiBjYXNlIGl0IGlzIGJlaW5nIHJldXNlZFxyXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xyXG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xyXG5cdFx0XHRldmVudC50YXJnZXQgPSBlbGVtO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENsb25lIGFueSBpbmNvbWluZyBkYXRhIGFuZCBwcmVwZW5kIHRoZSBldmVudCwgY3JlYXRpbmcgdGhlIGhhbmRsZXIgYXJnIGxpc3RcclxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xyXG5cdFx0XHRbIGV2ZW50IF0gOlxyXG5cdFx0XHRqUXVlcnkubWFrZUFycmF5KCBkYXRhLCBbIGV2ZW50IF0gKTtcclxuXHJcblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXHJcblx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcclxuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXHJcblx0XHQvLyBCdWJibGUgdXAgdG8gZG9jdW1lbnQsIHRoZW4gdG8gd2luZG93OyB3YXRjaCBmb3IgYSBnbG9iYWwgb3duZXJEb2N1bWVudCB2YXIgKCM5NzI0KVxyXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcclxuXHJcblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xyXG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xyXG5cdFx0XHRcdGN1ciA9IGN1ci5wYXJlbnROb2RlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcclxuXHRcdFx0XHRldmVudFBhdGgucHVzaCggY3VyICk7XHJcblx0XHRcdFx0dG1wID0gY3VyO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcclxuXHRcdFx0aWYgKCB0bXAgPT09IChlbGVtLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpICkge1xyXG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpcmUgaGFuZGxlcnMgb24gdGhlIGV2ZW50IHBhdGhcclxuXHRcdGkgPSAwO1xyXG5cdFx0d2hpbGUgKCAoY3VyID0gZXZlbnRQYXRoW2krK10pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xyXG5cclxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cclxuXHRcdFx0XHRidWJibGVUeXBlIDpcclxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XHJcblxyXG5cdFx0XHQvLyBqUXVlcnkgaGFuZGxlclxyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFfcHJpdi5nZXQoIGN1ciwgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSAmJiBkYXRhX3ByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcclxuXHRcdFx0aWYgKCBoYW5kbGUgKSB7XHJcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XHJcblx0XHRcdGlmICggaGFuZGxlICYmIGhhbmRsZS5hcHBseSAmJiBqUXVlcnkuYWNjZXB0RGF0YSggY3VyICkgKSB7XHJcblx0XHRcdFx0ZXZlbnQucmVzdWx0ID0gaGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcclxuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XHJcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0ZXZlbnQudHlwZSA9IHR5cGU7XHJcblxyXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xyXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcclxuXHJcblx0XHRcdGlmICggKCFzcGVjaWFsLl9kZWZhdWx0IHx8IHNwZWNpYWwuX2RlZmF1bHQuYXBwbHkoIGV2ZW50UGF0aC5wb3AoKSwgZGF0YSApID09PSBmYWxzZSkgJiZcclxuXHRcdFx0XHRqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xyXG5cclxuXHRcdFx0XHQvLyBDYWxsIGEgbmF0aXZlIERPTSBtZXRob2Qgb24gdGhlIHRhcmdldCB3aXRoIHRoZSBzYW1lIG5hbWUgbmFtZSBhcyB0aGUgZXZlbnQuXHJcblx0XHRcdFx0Ly8gRG9uJ3QgZG8gZGVmYXVsdCBhY3Rpb25zIG9uIHdpbmRvdywgdGhhdCdzIHdoZXJlIGdsb2JhbCB2YXJpYWJsZXMgYmUgKCM2MTcwKVxyXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gRG9uJ3QgcmUtdHJpZ2dlciBhbiBvbkZPTyBldmVudCB3aGVuIHdlIGNhbGwgaXRzIEZPTygpIG1ldGhvZFxyXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XHJcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxyXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHR5cGU7XHJcblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcclxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0bXAgKSB7XHJcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XHJcblx0fSxcclxuXHJcblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHJcblx0XHQvLyBNYWtlIGEgd3JpdGFibGUgalF1ZXJ5LkV2ZW50IGZyb20gdGhlIG5hdGl2ZSBldmVudCBvYmplY3RcclxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcclxuXHJcblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosXHJcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxyXG5cdFx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXHJcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhX3ByaXYuZ2V0KCB0aGlzLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdIHx8IFtdLFxyXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcclxuXHJcblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxyXG5cdFx0YXJnc1swXSA9IGV2ZW50O1xyXG5cdFx0ZXZlbnQuZGVsZWdhdGVUYXJnZXQgPSB0aGlzO1xyXG5cclxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcclxuXHRcdGlmICggc3BlY2lhbC5wcmVEaXNwYXRjaCAmJiBzcGVjaWFsLnByZURpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICkgPT09IGZhbHNlICkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXHJcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XHJcblxyXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcclxuXHRcdGkgPSAwO1xyXG5cdFx0d2hpbGUgKCAobWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0pICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xyXG5cdFx0XHRldmVudC5jdXJyZW50VGFyZ2V0ID0gbWF0Y2hlZC5lbGVtO1xyXG5cclxuXHRcdFx0aiA9IDA7XHJcblx0XHRcdHdoaWxlICggKGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdKSAmJiAhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvclxyXG5cdFx0XHRcdC8vIDIpIGhhdmUgbmFtZXNwYWNlKHMpIGEgc3Vic2V0IG9yIGVxdWFsIHRvIHRob3NlIGluIHRoZSBib3VuZCBldmVudCAoYm90aCBjYW4gaGF2ZSBubyBuYW1lc3BhY2UpLlxyXG5cdFx0XHRcdGlmICggIWV2ZW50Lm5hbWVzcGFjZV9yZSB8fCBldmVudC5uYW1lc3BhY2VfcmUudGVzdCggaGFuZGxlT2JqLm5hbWVzcGFjZSApICkge1xyXG5cclxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcclxuXHRcdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVPYmouZGF0YTtcclxuXHJcblx0XHRcdFx0XHRyZXQgPSAoIChqUXVlcnkuZXZlbnQuc3BlY2lhbFsgaGFuZGxlT2JqLm9yaWdUeXBlIF0gfHwge30pLmhhbmRsZSB8fCBoYW5kbGVPYmouaGFuZGxlciApXHJcblx0XHRcdFx0XHRcdFx0LmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIChldmVudC5yZXN1bHQgPSByZXQpID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0XHRcdFx0XHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxyXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcclxuXHRcdFx0c3BlY2lhbC5wb3N0RGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZXZlbnQucmVzdWx0O1xyXG5cdH0sXHJcblxyXG5cdGhhbmRsZXJzOiBmdW5jdGlvbiggZXZlbnQsIGhhbmRsZXJzICkge1xyXG5cdFx0dmFyIGksIG1hdGNoZXMsIHNlbCwgaGFuZGxlT2JqLFxyXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcclxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXHJcblx0XHRcdGN1ciA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXHJcblx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxyXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgYnViYmxpbmcgaW4gRmlyZWZveCAoIzM4NjEpXHJcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgJiYgY3VyLm5vZGVUeXBlICYmICghZXZlbnQuYnV0dG9uIHx8IGV2ZW50LnR5cGUgIT09IFwiY2xpY2tcIikgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCA7IGN1ciAhPT0gdGhpczsgY3VyID0gY3VyLnBhcmVudE5vZGUgfHwgdGhpcyApIHtcclxuXHJcblx0XHRcdFx0Ly8gRG9uJ3QgcHJvY2VzcyBjbGlja3Mgb24gZGlzYWJsZWQgZWxlbWVudHMgKCM2OTExLCAjODE2NSwgIzExMzgyLCAjMTE3NjQpXHJcblx0XHRcdFx0aWYgKCBjdXIuZGlzYWJsZWQgIT09IHRydWUgfHwgZXZlbnQudHlwZSAhPT0gXCJjbGlja1wiICkge1xyXG5cdFx0XHRcdFx0bWF0Y2hlcyA9IFtdO1xyXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XHJcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxyXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRcdFx0XHRtYXRjaGVzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xyXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPj0gMCA6XHJcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gKSB7XHJcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcclxuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBtYXRjaGVzIH0pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcclxuXHRcdGlmICggZGVsZWdhdGVDb3VudCA8IGhhbmRsZXJzLmxlbmd0aCApIHtcclxuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xyXG5cdH0sXHJcblxyXG5cdC8vIEluY2x1ZGVzIHNvbWUgZXZlbnQgcHJvcHMgc2hhcmVkIGJ5IEtleUV2ZW50IGFuZCBNb3VzZUV2ZW50XHJcblx0cHJvcHM6IFwiYWx0S2V5IGJ1YmJsZXMgY2FuY2VsYWJsZSBjdHJsS2V5IGN1cnJlbnRUYXJnZXQgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXCIuc3BsaXQoXCIgXCIpLFxyXG5cclxuXHRmaXhIb29rczoge30sXHJcblxyXG5cdGtleUhvb2tzOiB7XHJcblx0XHRwcm9wczogXCJjaGFyIGNoYXJDb2RlIGtleSBrZXlDb2RlXCIuc3BsaXQoXCIgXCIpLFxyXG5cdFx0ZmlsdGVyOiBmdW5jdGlvbiggZXZlbnQsIG9yaWdpbmFsICkge1xyXG5cclxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXHJcblx0XHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCApIHtcclxuXHRcdFx0XHRldmVudC53aGljaCA9IG9yaWdpbmFsLmNoYXJDb2RlICE9IG51bGwgPyBvcmlnaW5hbC5jaGFyQ29kZSA6IG9yaWdpbmFsLmtleUNvZGU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBldmVudDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRtb3VzZUhvb2tzOiB7XHJcblx0XHRwcm9wczogXCJidXR0b24gYnV0dG9ucyBjbGllbnRYIGNsaWVudFkgb2Zmc2V0WCBvZmZzZXRZIHBhZ2VYIHBhZ2VZIHNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIi5zcGxpdChcIiBcIiksXHJcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XHJcblx0XHRcdHZhciBldmVudERvYywgZG9jLCBib2R5LFxyXG5cdFx0XHRcdGJ1dHRvbiA9IG9yaWdpbmFsLmJ1dHRvbjtcclxuXHJcblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcclxuXHRcdFx0aWYgKCBldmVudC5wYWdlWCA9PSBudWxsICYmIG9yaWdpbmFsLmNsaWVudFggIT0gbnVsbCApIHtcclxuXHRcdFx0XHRldmVudERvYyA9IGV2ZW50LnRhcmdldC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50O1xyXG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcclxuXHRcdFx0XHRib2R5ID0gZXZlbnREb2MuYm9keTtcclxuXHJcblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICsgKCBkb2MgJiYgZG9jLnNjcm9sbExlZnQgfHwgYm9keSAmJiBib2R5LnNjcm9sbExlZnQgfHwgMCApIC0gKCBkb2MgJiYgZG9jLmNsaWVudExlZnQgfHwgYm9keSAmJiBib2R5LmNsaWVudExlZnQgfHwgMCApO1xyXG5cdFx0XHRcdGV2ZW50LnBhZ2VZID0gb3JpZ2luYWwuY2xpZW50WSArICggZG9jICYmIGRvYy5zY3JvbGxUb3AgIHx8IGJvZHkgJiYgYm9keS5zY3JvbGxUb3AgIHx8IDAgKSAtICggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxyXG5cdFx0XHQvLyBOb3RlOiBidXR0b24gaXMgbm90IG5vcm1hbGl6ZWQsIHNvIGRvbid0IHVzZSBpdFxyXG5cdFx0XHRpZiAoICFldmVudC53aGljaCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBldmVudDtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRmaXg6IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHRcdGlmICggZXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gKSB7XHJcblx0XHRcdHJldHVybiBldmVudDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcclxuXHRcdHZhciBpLCBwcm9wLCBjb3B5LFxyXG5cdFx0XHR0eXBlID0gZXZlbnQudHlwZSxcclxuXHRcdFx0b3JpZ2luYWxFdmVudCA9IGV2ZW50LFxyXG5cdFx0XHRmaXhIb29rID0gdGhpcy5maXhIb29rc1sgdHlwZSBdO1xyXG5cclxuXHRcdGlmICggIWZpeEhvb2sgKSB7XHJcblx0XHRcdHRoaXMuZml4SG9va3NbIHR5cGUgXSA9IGZpeEhvb2sgPVxyXG5cdFx0XHRcdHJtb3VzZUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMubW91c2VIb29rcyA6XHJcblx0XHRcdFx0cmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxyXG5cdFx0XHRcdHt9O1xyXG5cdFx0fVxyXG5cdFx0Y29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcclxuXHJcblx0XHRldmVudCA9IG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcclxuXHJcblx0XHRpID0gY29weS5sZW5ndGg7XHJcblx0XHR3aGlsZSAoIGktLSApIHtcclxuXHRcdFx0cHJvcCA9IGNvcHlbIGkgXTtcclxuXHRcdFx0ZXZlbnRbIHByb3AgXSA9IG9yaWdpbmFsRXZlbnRbIHByb3AgXTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTdXBwb3J0OiBDb3Jkb3ZhIDIuNSAoV2ViS2l0KSAoIzEzMjU1KVxyXG5cdFx0Ly8gQWxsIGV2ZW50cyBzaG91bGQgaGF2ZSBhIHRhcmdldDsgQ29yZG92YSBkZXZpY2VyZWFkeSBkb2Vzbid0XHJcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XHJcblx0XHRcdGV2ZW50LnRhcmdldCA9IGRvY3VtZW50O1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA2LjArLCBDaHJvbWUgPCAyOFxyXG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0MylcclxuXHRcdGlmICggZXZlbnQudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkge1xyXG5cdFx0XHRldmVudC50YXJnZXQgPSBldmVudC50YXJnZXQucGFyZW50Tm9kZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZml4SG9vay5maWx0ZXIgPyBmaXhIb29rLmZpbHRlciggZXZlbnQsIG9yaWdpbmFsRXZlbnQgKSA6IGV2ZW50O1xyXG5cdH0sXHJcblxyXG5cdHNwZWNpYWw6IHtcclxuXHRcdGxvYWQ6IHtcclxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxyXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxyXG5cdFx0fSxcclxuXHRcdGZvY3VzOiB7XHJcblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxyXG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoIHRoaXMgIT09IHNhZmVBY3RpdmVFbGVtZW50KCkgJiYgdGhpcy5mb2N1cyApIHtcclxuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c2luXCJcclxuXHRcdH0sXHJcblx0XHRibHVyOiB7XHJcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmICggdGhpcyA9PT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmJsdXIgKSB7XHJcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcclxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sXHJcblx0XHRcdGRlbGVnYXRlVHlwZTogXCJmb2N1c291dFwiXHJcblx0XHR9LFxyXG5cdFx0Y2xpY2s6IHtcclxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcclxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aWYgKCB0aGlzLnR5cGUgPT09IFwiY2hlY2tib3hcIiAmJiB0aGlzLmNsaWNrICYmIGpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJpbnB1dFwiICkgKSB7XHJcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9LFxyXG5cclxuXHRcdFx0Ly8gRm9yIGNyb3NzLWJyb3dzZXIgY29uc2lzdGVuY3ksIGRvbid0IGZpcmUgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXHJcblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5ub2RlTmFtZSggZXZlbnQudGFyZ2V0LCBcImFcIiApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdGJlZm9yZXVubG9hZDoge1xyXG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHJcblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCAyMCtcclxuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXHJcblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xyXG5cdFx0XHRcdFx0ZXZlbnQub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGV2ZW50LnJlc3VsdDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRzaW11bGF0ZTogZnVuY3Rpb24oIHR5cGUsIGVsZW0sIGV2ZW50LCBidWJibGUgKSB7XHJcblx0XHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmUuXHJcblx0XHQvLyBGYWtlIG9yaWdpbmFsRXZlbnQgdG8gYXZvaWQgZG9ub3IncyBzdG9wUHJvcGFnYXRpb24sIGJ1dCBpZiB0aGVcclxuXHRcdC8vIHNpbXVsYXRlZCBldmVudCBwcmV2ZW50cyBkZWZhdWx0IHRoZW4gd2UgZG8gdGhlIHNhbWUgb24gdGhlIGRvbm9yLlxyXG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxyXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXHJcblx0XHRcdGV2ZW50LFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0XHRpc1NpbXVsYXRlZDogdHJ1ZSxcclxuXHRcdFx0XHRvcmlnaW5hbEV2ZW50OiB7fVxyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cdFx0aWYgKCBidWJibGUgKSB7XHJcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guY2FsbCggZWxlbSwgZSApO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCBlLmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xyXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XHJcblx0aWYgKCBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIgKSB7XHJcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSwgZmFsc2UgKTtcclxuXHR9XHJcbn07XHJcblxyXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcclxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcclxuXHRpZiAoICEodGhpcyBpbnN0YW5jZW9mIGpRdWVyeS5FdmVudCkgKSB7XHJcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xyXG5cdH1cclxuXHJcblx0Ly8gRXZlbnQgb2JqZWN0XHJcblx0aWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XHJcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XHJcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcclxuXHJcblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxyXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXHJcblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHNyYy5kZWZhdWx0UHJldmVudGVkIHx8XHJcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxyXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPCA0LjBcclxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cclxuXHRcdFx0cmV0dXJuVHJ1ZSA6XHJcblx0XHRcdHJldHVybkZhbHNlO1xyXG5cclxuXHQvLyBFdmVudCB0eXBlXHJcblx0fSBlbHNlIHtcclxuXHRcdHRoaXMudHlwZSA9IHNyYztcclxuXHR9XHJcblxyXG5cdC8vIFB1dCBleHBsaWNpdGx5IHByb3ZpZGVkIHByb3BlcnRpZXMgb250byB0aGUgZXZlbnQgb2JqZWN0XHJcblx0aWYgKCBwcm9wcyApIHtcclxuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XHJcblx0fVxyXG5cclxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxyXG5cdHRoaXMudGltZVN0YW1wID0gc3JjICYmIHNyYy50aW1lU3RhbXAgfHwgalF1ZXJ5Lm5vdygpO1xyXG5cclxuXHQvLyBNYXJrIGl0IGFzIGZpeGVkXHJcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XHJcbn07XHJcblxyXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcclxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXHJcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XHJcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcclxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXHJcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxyXG5cclxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcclxuXHJcblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XHJcblxyXG5cdFx0aWYgKCBlICYmIGUucHJldmVudERlZmF1bHQgKSB7XHJcblx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cdHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcclxuXHJcblx0XHR0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcclxuXHJcblx0XHRpZiAoIGUgJiYgZS5zdG9wUHJvcGFnYXRpb24gKSB7XHJcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHRzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XHJcblxyXG5cdFx0dGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XHJcblxyXG5cdFx0aWYgKCBlICYmIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uICkge1xyXG5cdFx0XHRlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0fVxyXG59O1xyXG5cclxuLy8gQ3JlYXRlIG1vdXNlZW50ZXIvbGVhdmUgZXZlbnRzIHVzaW5nIG1vdXNlb3Zlci9vdXQgYW5kIGV2ZW50LXRpbWUgY2hlY2tzXHJcbi8vIFN1cHBvcnQ6IENocm9tZSAxNStcclxualF1ZXJ5LmVhY2goe1xyXG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXHJcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxyXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxyXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcclxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcclxuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xyXG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXHJcblx0XHRiaW5kVHlwZTogZml4LFxyXG5cclxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdFx0XHR2YXIgcmV0LFxyXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXHJcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXHJcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xyXG5cclxuXHRcdFx0Ly8gRm9yIG1vdXNlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxyXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xyXG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkpICkge1xyXG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XHJcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xyXG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHJldDtcclxuXHRcdH1cclxuXHR9O1xyXG59KTtcclxuXHJcbi8vIENyZWF0ZSBcImJ1YmJsaW5nXCIgZm9jdXMgYW5kIGJsdXIgZXZlbnRzXHJcbi8vIFN1cHBvcnQ6IEZpcmVmb3gsIENocm9tZSwgU2FmYXJpXHJcbmlmICggIXN1cHBvcnQuZm9jdXNpbkJ1YmJsZXMgKSB7XHJcblx0alF1ZXJ5LmVhY2goeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xyXG5cclxuXHRcdC8vIEF0dGFjaCBhIHNpbmdsZSBjYXB0dXJpbmcgaGFuZGxlciBvbiB0aGUgZG9jdW1lbnQgd2hpbGUgc29tZW9uZSB3YW50cyBmb2N1c2luL2ZvY3Vzb3V0XHJcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcclxuXHRcdFx0XHRqUXVlcnkuZXZlbnQuc2ltdWxhdGUoIGZpeCwgZXZlbnQudGFyZ2V0LCBqUXVlcnkuZXZlbnQuZml4KCBldmVudCApLCB0cnVlICk7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xyXG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxyXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCApO1xyXG5cclxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcclxuXHRcdFx0XHRcdGRvYy5hZGRFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGRhdGFfcHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcclxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YV9wcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XHJcblxyXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xyXG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcclxuXHRcdFx0XHRcdGRhdGFfcHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRkYXRhX3ByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fSk7XHJcbn1cclxuXHJcbmpRdWVyeS5mbi5leHRlbmQoe1xyXG5cclxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIC8qSU5URVJOQUwqLyBvbmUgKSB7XHJcblx0XHR2YXIgb3JpZ0ZuLCB0eXBlO1xyXG5cclxuXHRcdC8vIFR5cGVzIGNhbiBiZSBhIG1hcCBvZiB0eXBlcy9oYW5kbGVyc1xyXG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XHJcblx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBzZWxlY3RvciwgZGF0YSApXHJcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xyXG5cdFx0XHRcdC8vICggdHlwZXMtT2JqZWN0LCBkYXRhIClcclxuXHRcdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3RvcjtcclxuXHRcdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcclxuXHRcdFx0fVxyXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xyXG5cdFx0XHRcdHRoaXMub24oIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xyXG5cdFx0XHQvLyAoIHR5cGVzLCBmbiApXHJcblx0XHRcdGZuID0gc2VsZWN0b3I7XHJcblx0XHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcclxuXHRcdH0gZWxzZSBpZiAoIGZuID09IG51bGwgKSB7XHJcblx0XHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xyXG5cdFx0XHRcdC8vICggdHlwZXMsIHNlbGVjdG9yLCBmbiApXHJcblx0XHRcdFx0Zm4gPSBkYXRhO1xyXG5cdFx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxyXG5cdFx0XHRcdGZuID0gZGF0YTtcclxuXHRcdFx0XHRkYXRhID0gc2VsZWN0b3I7XHJcblx0XHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xyXG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xyXG5cdFx0fSBlbHNlIGlmICggIWZuICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9uZSA9PT0gMSApIHtcclxuXHRcdFx0b3JpZ0ZuID0gZm47XHJcblx0XHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xyXG5cdFx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xyXG5cdFx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcclxuXHRcdFx0XHRyZXR1cm4gb3JpZ0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuXHRcdFx0fTtcclxuXHRcdFx0Ly8gVXNlIHNhbWUgZ3VpZCBzbyBjYWxsZXIgY2FuIHJlbW92ZSB1c2luZyBvcmlnRm5cclxuXHRcdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcclxuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHRvbmU6IGZ1bmN0aW9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICkge1xyXG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcclxuXHR9LFxyXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XHJcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xyXG5cdFx0aWYgKCB0eXBlcyAmJiB0eXBlcy5wcmV2ZW50RGVmYXVsdCAmJiB0eXBlcy5oYW5kbGVPYmogKSB7XHJcblx0XHRcdC8vICggZXZlbnQgKSAgZGlzcGF0Y2hlZCBqUXVlcnkuRXZlbnRcclxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xyXG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxyXG5cdFx0XHRcdGhhbmRsZU9iai5uYW1lc3BhY2UgPyBoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOiBoYW5kbGVPYmoub3JpZ1R5cGUsXHJcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxyXG5cdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyXHJcblx0XHRcdCk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XHJcblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXHJcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XHJcblx0XHRcdFx0dGhpcy5vZmYoIHR5cGUsIHNlbGVjdG9yLCB0eXBlc1sgdHlwZSBdICk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcclxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxyXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xyXG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xyXG5cdFx0XHRmbiA9IHJldHVybkZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0dHJpZ2dlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgdGhpcyApO1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XHJcblx0XHR2YXIgZWxlbSA9IHRoaXNbMF07XHJcblx0XHRpZiAoIGVsZW0gKSB7XHJcblx0XHRcdHJldHVybiBqUXVlcnkuZXZlbnQudHJpZ2dlciggdHlwZSwgZGF0YSwgZWxlbSwgdHJ1ZSApO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5cclxudmFyXHJcblx0cnhodG1sVGFnID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcdzpdKylbXj5dKilcXC8+L2dpLFxyXG5cdHJ0YWdOYW1lID0gLzwoW1xcdzpdKykvLFxyXG5cdHJodG1sID0gLzx8JiM/XFx3KzsvLFxyXG5cdHJub0lubmVyaHRtbCA9IC88KD86c2NyaXB0fHN0eWxlfGxpbmspL2ksXHJcblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXHJcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxyXG5cdHJzY3JpcHRUeXBlID0gL14kfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSxcclxuXHRyc2NyaXB0VHlwZU1hc2tlZCA9IC9edHJ1ZVxcLyguKikvLFxyXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZyxcclxuXHJcblx0Ly8gV2UgaGF2ZSB0byBjbG9zZSB0aGVzZSB0YWdzIHRvIHN1cHBvcnQgWEhUTUwgKCMxMzIwMClcclxuXHR3cmFwTWFwID0ge1xyXG5cclxuXHRcdC8vIFN1cHBvcnQ6IElFIDlcclxuXHRcdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxyXG5cclxuXHRcdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcclxuXHRcdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXHJcblx0XHR0cjogWyAyLCBcIjx0YWJsZT48dGJvZHk+XCIsIFwiPC90Ym9keT48L3RhYmxlPlwiIF0sXHJcblx0XHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXHJcblxyXG5cdFx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXHJcblx0fTtcclxuXHJcbi8vIFN1cHBvcnQ6IElFIDlcclxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xyXG5cclxud3JhcE1hcC50Ym9keSA9IHdyYXBNYXAudGZvb3QgPSB3cmFwTWFwLmNvbGdyb3VwID0gd3JhcE1hcC5jYXB0aW9uID0gd3JhcE1hcC50aGVhZDtcclxud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XHJcblxyXG4vLyBTdXBwb3J0OiAxLnggY29tcGF0aWJpbGl0eVxyXG4vLyBNYW5pcHVsYXRpbmcgdGFibGVzIHJlcXVpcmVzIGEgdGJvZHlcclxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xyXG5cdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwidGFibGVcIiApICYmXHJcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgP1xyXG5cclxuXHRcdGVsZW0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0Ym9keVwiKVswXSB8fFxyXG5cdFx0XHRlbGVtLmFwcGVuZENoaWxkKCBlbGVtLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRib2R5XCIpICkgOlxyXG5cdFx0ZWxlbTtcclxufVxyXG5cclxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxyXG5mdW5jdGlvbiBkaXNhYmxlU2NyaXB0KCBlbGVtICkge1xyXG5cdGVsZW0udHlwZSA9IChlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikgIT09IG51bGwpICsgXCIvXCIgKyBlbGVtLnR5cGU7XHJcblx0cmV0dXJuIGVsZW07XHJcbn1cclxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcclxuXHR2YXIgbWF0Y2ggPSByc2NyaXB0VHlwZU1hc2tlZC5leGVjKCBlbGVtLnR5cGUgKTtcclxuXHJcblx0aWYgKCBtYXRjaCApIHtcclxuXHRcdGVsZW0udHlwZSA9IG1hdGNoWyAxIF07XHJcblx0fSBlbHNlIHtcclxuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBlbGVtO1xyXG59XHJcblxyXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcclxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xyXG5cdHZhciBpID0gMCxcclxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XHJcblxyXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcclxuXHRcdGRhdGFfcHJpdi5zZXQoXHJcblx0XHRcdGVsZW1zWyBpIF0sIFwiZ2xvYmFsRXZhbFwiLCAhcmVmRWxlbWVudHMgfHwgZGF0YV9wcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxyXG5cdFx0KTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XHJcblx0dmFyIGksIGwsIHR5cGUsIHBkYXRhT2xkLCBwZGF0YUN1ciwgdWRhdGFPbGQsIHVkYXRhQ3VyLCBldmVudHM7XHJcblxyXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdC8vIDEuIENvcHkgcHJpdmF0ZSBkYXRhOiBldmVudHMsIGhhbmRsZXJzLCBldGMuXHJcblx0aWYgKCBkYXRhX3ByaXYuaGFzRGF0YSggc3JjICkgKSB7XHJcblx0XHRwZGF0YU9sZCA9IGRhdGFfcHJpdi5hY2Nlc3MoIHNyYyApO1xyXG5cdFx0cGRhdGFDdXIgPSBkYXRhX3ByaXYuc2V0KCBkZXN0LCBwZGF0YU9sZCApO1xyXG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xyXG5cclxuXHRcdGlmICggZXZlbnRzICkge1xyXG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xyXG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcclxuXHJcblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xyXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZGVzdCwgdHlwZSwgZXZlbnRzWyB0eXBlIF1bIGkgXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gMi4gQ29weSB1c2VyIGRhdGFcclxuXHRpZiAoIGRhdGFfdXNlci5oYXNEYXRhKCBzcmMgKSApIHtcclxuXHRcdHVkYXRhT2xkID0gZGF0YV91c2VyLmFjY2Vzcyggc3JjICk7XHJcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xyXG5cclxuXHRcdGRhdGFfdXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcclxuXHR2YXIgcmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcclxuXHRcdFx0Y29udGV4dC5xdWVyeVNlbGVjdG9yQWxsID8gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgfHwgXCIqXCIgKSA6XHJcblx0XHRcdFtdO1xyXG5cclxuXHRyZXR1cm4gdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIGpRdWVyeS5ub2RlTmFtZSggY29udGV4dCwgdGFnICkgP1xyXG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxyXG5cdFx0cmV0O1xyXG59XHJcblxyXG4vLyBTdXBwb3J0OiBJRSA+PSA5XHJcbmZ1bmN0aW9uIGZpeElucHV0KCBzcmMsIGRlc3QgKSB7XHJcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuXHQvLyBGYWlscyB0byBwZXJzaXN0IHRoZSBjaGVja2VkIHN0YXRlIG9mIGEgY2xvbmVkIGNoZWNrYm94IG9yIHJhZGlvIGJ1dHRvbi5cclxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcclxuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xyXG5cclxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xyXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcclxuXHRcdGRlc3QuZGVmYXVsdFZhbHVlID0gc3JjLmRlZmF1bHRWYWx1ZTtcclxuXHR9XHJcbn1cclxuXHJcbmpRdWVyeS5leHRlbmQoe1xyXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XHJcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcclxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxyXG5cdFx0XHRpblBhZ2UgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xyXG5cclxuXHRcdC8vIFN1cHBvcnQ6IElFID49IDlcclxuXHRcdC8vIEZpeCBDbG9uaW5nIGlzc3Vlc1xyXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxyXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcclxuXHJcblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cDovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXHJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcclxuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxyXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xyXG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xyXG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XHJcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XHJcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XHJcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XHJcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xyXG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcclxuXHRcdHJldHVybiBjbG9uZTtcclxuXHR9LFxyXG5cclxuXHRidWlsZEZyYWdtZW50OiBmdW5jdGlvbiggZWxlbXMsIGNvbnRleHQsIHNjcmlwdHMsIHNlbGVjdGlvbiApIHtcclxuXHRcdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgY29udGFpbnMsIGosXHJcblx0XHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXHJcblx0XHRcdG5vZGVzID0gW10sXHJcblx0XHRcdGkgPSAwLFxyXG5cdFx0XHRsID0gZWxlbXMubGVuZ3RoO1xyXG5cclxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcclxuXHRcdFx0ZWxlbSA9IGVsZW1zWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGVsZW0gfHwgZWxlbSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gQWRkIG5vZGVzIGRpcmVjdGx5XHJcblx0XHRcdFx0aWYgKCBqUXVlcnkudHlwZSggZWxlbSApID09PSBcIm9iamVjdFwiICkge1xyXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXRcclxuXHRcdFx0XHRcdC8vIGpRdWVyeS5tZXJnZSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3NcclxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIGVsZW0ubm9kZVR5cGUgPyBbIGVsZW0gXSA6IGVsZW0gKTtcclxuXHJcblx0XHRcdFx0Ly8gQ29udmVydCBub24taHRtbCBpbnRvIGEgdGV4dCBub2RlXHJcblx0XHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcclxuXHRcdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xyXG5cclxuXHRcdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKTtcclxuXHJcblx0XHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXHJcblx0XHRcdFx0XHR0YWcgPSAoIHJ0YWdOYW1lLmV4ZWMoIGVsZW0gKSB8fCBbIFwiXCIsIFwiXCIgXSApWyAxIF0udG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xyXG5cdFx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGVsZW0ucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICkgKyB3cmFwWyAyIF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XHJcblx0XHRcdFx0XHRqID0gd3JhcFsgMCBdO1xyXG5cdFx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XHJcblx0XHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogUXRXZWJLaXRcclxuXHRcdFx0XHRcdC8vIGpRdWVyeS5tZXJnZSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3NcclxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcclxuXHRcdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XHJcblxyXG5cdFx0XHRcdFx0Ly8gRml4ZXMgIzEyMzQ2XHJcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBXZWJraXQsIElFXHJcblx0XHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcclxuXHRcdGZyYWdtZW50LnRleHRDb250ZW50ID0gXCJcIjtcclxuXHJcblx0XHRpID0gMDtcclxuXHRcdHdoaWxlICggKGVsZW0gPSBub2Rlc1sgaSsrIF0pICkge1xyXG5cclxuXHRcdFx0Ly8gIzQwODcgLSBJZiBvcmlnaW4gYW5kIGRlc3RpbmF0aW9uIGVsZW1lbnRzIGFyZSB0aGUgc2FtZSwgYW5kIHRoaXMgaXNcclxuXHRcdFx0Ly8gdGhhdCBlbGVtZW50LCBkbyBub3QgZG8gYW55dGhpbmdcclxuXHRcdFx0aWYgKCBzZWxlY3Rpb24gJiYgalF1ZXJ5LmluQXJyYXkoIGVsZW0sIHNlbGVjdGlvbiApICE9PSAtMSApIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Y29udGFpbnMgPSBqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApO1xyXG5cclxuXHRcdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XHJcblx0XHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xyXG5cclxuXHRcdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxyXG5cdFx0XHRpZiAoIGNvbnRhaW5zICkge1xyXG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXHJcblx0XHRcdGlmICggc2NyaXB0cyApIHtcclxuXHRcdFx0XHRqID0gMDtcclxuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gdG1wWyBqKysgXSkgKSB7XHJcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XHJcblx0XHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmcmFnbWVudDtcclxuXHR9LFxyXG5cclxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcclxuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLCBrZXksXHJcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcclxuXHRcdFx0aSA9IDA7XHJcblxyXG5cdFx0Zm9yICggOyAoZWxlbSA9IGVsZW1zWyBpIF0pICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcclxuXHRcdFx0aWYgKCBqUXVlcnkuYWNjZXB0RGF0YSggZWxlbSApICkge1xyXG5cdFx0XHRcdGtleSA9IGVsZW1bIGRhdGFfcHJpdi5leHBhbmRvIF07XHJcblxyXG5cdFx0XHRcdGlmICgga2V5ICYmIChkYXRhID0gZGF0YV9wcml2LmNhY2hlWyBrZXkgXSkgKSB7XHJcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xyXG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xyXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmICggZGF0YV9wcml2LmNhY2hlWyBrZXkgXSApIHtcclxuXHRcdFx0XHRcdFx0Ly8gRGlzY2FyZCBhbnkgcmVtYWluaW5nIGBwcml2YXRlYCBkYXRhXHJcblx0XHRcdFx0XHRcdGRlbGV0ZSBkYXRhX3ByaXYuY2FjaGVbIGtleSBdO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBEaXNjYXJkIGFueSByZW1haW5pbmcgYHVzZXJgIGRhdGFcclxuXHRcdFx0ZGVsZXRlIGRhdGFfdXNlci5jYWNoZVsgZWxlbVsgZGF0YV91c2VyLmV4cGFuZG8gXSBdO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5qUXVlcnkuZm4uZXh0ZW5kKHtcclxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XHJcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XHJcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcclxuXHRcdFx0XHR0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnRleHRDb250ZW50ID0gdmFsdWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xyXG5cdH0sXHJcblxyXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XHJcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xyXG5cdFx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZCggZWxlbSApO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRwcmVwZW5kOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcclxuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XHJcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcclxuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzICk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdGFmdGVyOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmRvbU1hbmlwKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcclxuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCBrZWVwRGF0YSAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcclxuXHRcdHZhciBlbGVtLFxyXG5cdFx0XHRlbGVtcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIHRoaXMgKSA6IHRoaXMsXHJcblx0XHRcdGkgPSAwO1xyXG5cclxuXHRcdGZvciAoIDsgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xyXG5cdFx0XHRpZiAoICFrZWVwRGF0YSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xyXG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSApICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xyXG5cdFx0XHRcdGlmICgga2VlcERhdGEgJiYgalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKSApIHtcclxuXHRcdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsZW0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWxlbSApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGVsZW0sXHJcblx0XHRcdGkgPSAwO1xyXG5cclxuXHRcdGZvciAoIDsgKGVsZW0gPSB0aGlzW2ldKSAhPSBudWxsOyBpKysgKSB7XHJcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcclxuXHJcblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3NcclxuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcclxuXHJcblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcclxuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiggZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XHJcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xyXG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIGpRdWVyeS5jbG9uZSggdGhpcywgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXHJcblx0XHRcdFx0aSA9IDAsXHJcblx0XHRcdFx0bCA9IHRoaXMubGVuZ3RoO1xyXG5cclxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGVsZW0uaW5uZXJIVE1MO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBTZWUgaWYgd2UgY2FuIHRha2UgYSBzaG9ydGN1dCBhbmQganVzdCB1c2UgaW5uZXJIVE1MXHJcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxyXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcclxuXHJcblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcclxuXHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcclxuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xyXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XHJcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XHJcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGVsZW0gPSAwO1xyXG5cclxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2RcclxuXHRcdFx0XHR9IGNhdGNoKCBlICkge31cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBlbGVtICkge1xyXG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XHJcblx0XHRcdH1cclxuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XHJcblx0fSxcclxuXHJcblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGFyZyA9IGFyZ3VtZW50c1sgMCBdO1xyXG5cclxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxyXG5cdFx0dGhpcy5kb21NYW5pcCggYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0YXJnID0gdGhpcy5wYXJlbnROb2RlO1xyXG5cclxuXHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcclxuXHJcblx0XHRcdGlmICggYXJnICkge1xyXG5cdFx0XHRcdGFyZy5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gRm9yY2UgcmVtb3ZhbCBpZiB0aGVyZSB3YXMgbm8gbmV3IGNvbnRlbnQgKGUuZy4sIGZyb20gZW1wdHkgYXJndW1lbnRzKVxyXG5cdFx0cmV0dXJuIGFyZyAmJiAoYXJnLmxlbmd0aCB8fCBhcmcubm9kZVR5cGUpID8gdGhpcyA6IHRoaXMucmVtb3ZlKCk7XHJcblx0fSxcclxuXHJcblx0ZGV0YWNoOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmUoIHNlbGVjdG9yLCB0cnVlICk7XHJcblx0fSxcclxuXHJcblx0ZG9tTWFuaXA6IGZ1bmN0aW9uKCBhcmdzLCBjYWxsYmFjayApIHtcclxuXHJcblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXHJcblx0XHRhcmdzID0gY29uY2F0LmFwcGx5KCBbXSwgYXJncyApO1xyXG5cclxuXHRcdHZhciBmcmFnbWVudCwgZmlyc3QsIHNjcmlwdHMsIGhhc1NjcmlwdHMsIG5vZGUsIGRvYyxcclxuXHRcdFx0aSA9IDAsXHJcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcclxuXHRcdFx0c2V0ID0gdGhpcyxcclxuXHRcdFx0aU5vQ2xvbmUgPSBsIC0gMSxcclxuXHRcdFx0dmFsdWUgPSBhcmdzWyAwIF0sXHJcblx0XHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcclxuXHJcblx0XHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcclxuXHRcdGlmICggaXNGdW5jdGlvbiB8fFxyXG5cdFx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXHJcblx0XHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiggaW5kZXggKSB7XHJcblx0XHRcdFx0dmFyIHNlbGYgPSBzZXQuZXEoIGluZGV4ICk7XHJcblx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xyXG5cdFx0XHRcdFx0YXJnc1sgMCBdID0gdmFsdWUuY2FsbCggdGhpcywgaW5kZXgsIHNlbGYuaHRtbCgpICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHNlbGYuZG9tTWFuaXAoIGFyZ3MsIGNhbGxiYWNrICk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbCApIHtcclxuXHRcdFx0ZnJhZ21lbnQgPSBqUXVlcnkuYnVpbGRGcmFnbWVudCggYXJncywgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCB0aGlzICk7XHJcblx0XHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcclxuXHJcblx0XHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XHJcblx0XHRcdFx0ZnJhZ21lbnQgPSBmaXJzdDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBmaXJzdCApIHtcclxuXHRcdFx0XHRzY3JpcHRzID0galF1ZXJ5Lm1hcCggZ2V0QWxsKCBmcmFnbWVudCwgXCJzY3JpcHRcIiApLCBkaXNhYmxlU2NyaXB0ICk7XHJcblx0XHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtIGluc3RlYWQgb2YgdGhlIGZpcnN0IGJlY2F1c2UgaXQgY2FuIGVuZCB1cFxyXG5cdFx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXHJcblx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xyXG5cdFx0XHRcdFx0bm9kZSA9IGZyYWdtZW50O1xyXG5cclxuXHRcdFx0XHRcdGlmICggaSAhPT0gaU5vQ2xvbmUgKSB7XHJcblx0XHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcclxuXHJcblx0XHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cclxuXHRcdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xyXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XHJcblx0XHRcdFx0XHRcdFx0Ly8galF1ZXJ5Lm1lcmdlIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93c1xyXG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoIHRoaXNbIGkgXSwgbm9kZSwgaSApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xyXG5cdFx0XHRcdFx0ZG9jID0gc2NyaXB0c1sgc2NyaXB0cy5sZW5ndGggLSAxIF0ub3duZXJEb2N1bWVudDtcclxuXHJcblx0XHRcdFx0XHQvLyBSZWVuYWJsZSBzY3JpcHRzXHJcblx0XHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxyXG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XHJcblx0XHRcdFx0XHRcdG5vZGUgPSBzY3JpcHRzWyBpIF07XHJcblx0XHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxyXG5cdFx0XHRcdFx0XHRcdCFkYXRhX3ByaXYuYWNjZXNzKCBub2RlLCBcImdsb2JhbEV2YWxcIiApICYmIGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxyXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuX2V2YWxVcmwgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMgKTtcclxuXHRcdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5Lmdsb2JhbEV2YWwoIG5vZGUudGV4dENvbnRlbnQucmVwbGFjZSggcmNsZWFuU2NyaXB0LCBcIlwiICkgKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxualF1ZXJ5LmVhY2goe1xyXG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxyXG5cdHByZXBlbmRUbzogXCJwcmVwZW5kXCIsXHJcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxyXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXHJcblx0cmVwbGFjZUFsbDogXCJyZXBsYWNlV2l0aFwiXHJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcclxuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcclxuXHRcdHZhciBlbGVtcyxcclxuXHRcdFx0cmV0ID0gW10sXHJcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcclxuXHRcdFx0bGFzdCA9IGluc2VydC5sZW5ndGggLSAxLFxyXG5cdFx0XHRpID0gMDtcclxuXHJcblx0XHRmb3IgKCA7IGkgPD0gbGFzdDsgaSsrICkge1xyXG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xyXG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XHJcblxyXG5cdFx0XHQvLyBTdXBwb3J0OiBRdFdlYktpdFxyXG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXHJcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xyXG5cdH07XHJcbn0pO1xyXG5cclxuXHJcbnZhciBpZnJhbWUsXHJcblx0ZWxlbWRpc3BsYXkgPSB7fTtcclxuXHJcbi8qKlxyXG4gKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG5vZGVOYW1lIG9mIHRoZSBlbGVtZW50XHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBkb2MgRG9jdW1lbnQgb2JqZWN0XHJcbiAqL1xyXG4vLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxyXG5mdW5jdGlvbiBhY3R1YWxEaXNwbGF5KCBuYW1lLCBkb2MgKSB7XHJcblx0dmFyIHN0eWxlLFxyXG5cdFx0ZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxyXG5cclxuXHRcdC8vIGdldERlZmF1bHRDb21wdXRlZFN0eWxlIG1pZ2h0IGJlIHJlbGlhYmx5IHVzZWQgb25seSBvbiBhdHRhY2hlZCBlbGVtZW50XHJcblx0XHRkaXNwbGF5ID0gd2luZG93LmdldERlZmF1bHRDb21wdXRlZFN0eWxlICYmICggc3R5bGUgPSB3aW5kb3cuZ2V0RGVmYXVsdENvbXB1dGVkU3R5bGUoIGVsZW1bIDAgXSApICkgP1xyXG5cclxuXHRcdFx0Ly8gVXNlIG9mIHRoaXMgbWV0aG9kIGlzIGEgdGVtcG9yYXJ5IGZpeCAobW9yZSBsaWtlIG9wdG1pemF0aW9uKSB1bnRpbCBzb21ldGhpbmcgYmV0dGVyIGNvbWVzIGFsb25nLFxyXG5cdFx0XHQvLyBzaW5jZSBpdCB3YXMgcmVtb3ZlZCBmcm9tIHNwZWNpZmljYXRpb24gYW5kIHN1cHBvcnRlZCBvbmx5IGluIEZGXHJcblx0XHRcdHN0eWxlLmRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtWyAwIF0sIFwiZGlzcGxheVwiICk7XHJcblxyXG5cdC8vIFdlIGRvbid0IGhhdmUgYW55IGRhdGEgc3RvcmVkIG9uIHRoZSBlbGVtZW50LFxyXG5cdC8vIHNvIHVzZSBcImRldGFjaFwiIG1ldGhvZCBhcyBmYXN0IHdheSB0byBnZXQgcmlkIG9mIHRoZSBlbGVtZW50XHJcblx0ZWxlbS5kZXRhY2goKTtcclxuXHJcblx0cmV0dXJuIGRpc3BsYXk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbm9kZU5hbWVcclxuICovXHJcbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcclxuXHR2YXIgZG9jID0gZG9jdW1lbnQsXHJcblx0XHRkaXNwbGF5ID0gZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF07XHJcblxyXG5cdGlmICggIWRpc3BsYXkgKSB7XHJcblx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xyXG5cclxuXHRcdC8vIElmIHRoZSBzaW1wbGUgd2F5IGZhaWxzLCByZWFkIGZyb20gaW5zaWRlIGFuIGlmcmFtZVxyXG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiB8fCAhZGlzcGxheSApIHtcclxuXHJcblx0XHRcdC8vIFVzZSB0aGUgYWxyZWFkeS1jcmVhdGVkIGlmcmFtZSBpZiBwb3NzaWJsZVxyXG5cdFx0XHRpZnJhbWUgPSAoaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSkuYXBwZW5kVG8oIGRvYy5kb2N1bWVudEVsZW1lbnQgKTtcclxuXHJcblx0XHRcdC8vIEFsd2F5cyB3cml0ZSBhIG5ldyBIVE1MIHNrZWxldG9uIHNvIFdlYmtpdCBhbmQgRmlyZWZveCBkb24ndCBjaG9rZSBvbiByZXVzZVxyXG5cdFx0XHRkb2MgPSBpZnJhbWVbIDAgXS5jb250ZW50RG9jdW1lbnQ7XHJcblxyXG5cdFx0XHQvLyBTdXBwb3J0OiBJRVxyXG5cdFx0XHRkb2Mud3JpdGUoKTtcclxuXHRcdFx0ZG9jLmNsb3NlKCk7XHJcblxyXG5cdFx0XHRkaXNwbGF5ID0gYWN0dWFsRGlzcGxheSggbm9kZU5hbWUsIGRvYyApO1xyXG5cdFx0XHRpZnJhbWUuZGV0YWNoKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XHJcblx0XHRlbGVtZGlzcGxheVsgbm9kZU5hbWUgXSA9IGRpc3BsYXk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gZGlzcGxheTtcclxufVxyXG52YXIgcm1hcmdpbiA9ICgvXm1hcmdpbi8pO1xyXG5cclxudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xyXG5cclxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdFx0cmV0dXJuIGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtLCBudWxsICk7XHJcblx0fTtcclxuXHJcblxyXG5cclxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcclxuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxyXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xyXG5cclxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xyXG5cclxuXHQvLyBTdXBwb3J0OiBJRTlcclxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSBpbiBJRTksIHNlZSAjMTI1MzdcclxuXHRpZiAoIGNvbXB1dGVkICkge1xyXG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XHJcblx0fVxyXG5cclxuXHRpZiAoIGNvbXB1dGVkICkge1xyXG5cclxuXHRcdGlmICggcmV0ID09PSBcIlwiICYmICFqUXVlcnkuY29udGFpbnMoIGVsZW0ub3duZXJEb2N1bWVudCwgZWxlbSApICkge1xyXG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTdXBwb3J0OiBpT1MgPCA2XHJcblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXHJcblx0XHQvLyBpT1MgPCA2IChhdCBsZWFzdCkgcmV0dXJucyBwZXJjZW50YWdlIGZvciBhIGxhcmdlciBzZXQgb2YgdmFsdWVzLCBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzXHJcblx0XHQvLyB0aGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6IGh0dHA6Ly9kZXYudzMub3JnL2Nzc3dnL2Nzc29tLyNyZXNvbHZlZC12YWx1ZXNcclxuXHRcdGlmICggcm51bW5vbnB4LnRlc3QoIHJldCApICYmIHJtYXJnaW4udGVzdCggbmFtZSApICkge1xyXG5cclxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xyXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xyXG5cdFx0XHRtaW5XaWR0aCA9IHN0eWxlLm1pbldpZHRoO1xyXG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xyXG5cclxuXHRcdFx0Ly8gUHV0IGluIHRoZSBuZXcgdmFsdWVzIHRvIGdldCBhIGNvbXB1dGVkIHZhbHVlIG91dFxyXG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XHJcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xyXG5cclxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xyXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xyXG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IG1pbldpZHRoO1xyXG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cclxuXHRcdC8vIFN1cHBvcnQ6IElFXHJcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxyXG5cdFx0cmV0ICsgXCJcIiA6XHJcblx0XHRyZXQ7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XHJcblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xyXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZSB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLFxyXG5cdFx0XHRcdC8vIHJlbW92ZSBpdC5cclxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBhcmUgbm8gb3RoZXIgaG9va3MgZm9yIG1hcmdpblJpZ2h0LCByZW1vdmUgdGhlIHdob2xlIG9iamVjdC5cclxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cclxuXHJcblx0XHRcdHJldHVybiAodGhpcy5nZXQgPSBob29rRm4pLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcclxuXHRcdH1cclxuXHR9O1xyXG59XHJcblxyXG5cclxuKGZ1bmN0aW9uKCkge1xyXG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCxcclxuXHRcdGRvY0VsZW0gPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXHJcblx0XHRjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICksXHJcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XHJcblxyXG5cdGlmICggIWRpdi5zdHlsZSApIHtcclxuXHRcdHJldHVybjtcclxuXHR9XHJcblxyXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcclxuXHRkaXYuY2xvbmVOb2RlKCB0cnVlICkuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcIlwiO1xyXG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XHJcblxyXG5cdGNvbnRhaW5lci5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6MDt3aWR0aDowO2hlaWdodDowO3RvcDowO2xlZnQ6LTk5OTlweDttYXJnaW4tdG9wOjFweDtcIiArXHJcblx0XHRcInBvc2l0aW9uOmFic29sdXRlXCI7XHJcblx0Y29udGFpbmVyLmFwcGVuZENoaWxkKCBkaXYgKTtcclxuXHJcblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XHJcblx0Ly8gc28gdGhleSdyZSBleGVjdXRlZCBhdCB0aGUgc2FtZSB0aW1lIHRvIHNhdmUgdGhlIHNlY29uZCBjb21wdXRhdGlvbi5cclxuXHRmdW5jdGlvbiBjb21wdXRlUGl4ZWxQb3NpdGlvbkFuZEJveFNpemluZ1JlbGlhYmxlKCkge1xyXG5cdFx0ZGl2LnN0eWxlLmNzc1RleHQgPVxyXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI5LCBBbmRyb2lkIDIuM1xyXG5cdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcclxuXHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtcIiArXHJcblx0XHRcdFwiYm94LXNpemluZzpib3JkZXItYm94O2Rpc3BsYXk6YmxvY2s7bWFyZ2luLXRvcDoxJTt0b3A6MSU7XCIgK1xyXG5cdFx0XHRcImJvcmRlcjoxcHg7cGFkZGluZzoxcHg7d2lkdGg6NHB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XHJcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcclxuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xyXG5cclxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYsIG51bGwgKTtcclxuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcclxuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XHJcblxyXG5cdFx0ZG9jRWxlbS5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XHJcblx0fVxyXG5cclxuXHQvLyBTdXBwb3J0OiBub2RlLmpzIGpzZG9tXHJcblx0Ly8gRG9uJ3QgYXNzdW1lIHRoYXQgZ2V0Q29tcHV0ZWRTdHlsZSBpcyBhIHByb3BlcnR5IG9mIHRoZSBnbG9iYWwgb2JqZWN0XHJcblx0aWYgKCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSApIHtcclxuXHRcdGpRdWVyeS5leHRlbmQoIHN1cHBvcnQsIHtcclxuXHRcdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Ly8gVGhpcyB0ZXN0IGlzIGV4ZWN1dGVkIG9ubHkgb25jZSBidXQgd2Ugc3RpbGwgZG8gbWVtb2l6aW5nXHJcblx0XHRcdFx0Ly8gc2luY2Ugd2UgY2FuIHVzZSB0aGUgYm94U2l6aW5nUmVsaWFibGUgcHJlLWNvbXB1dGluZy5cclxuXHRcdFx0XHQvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0ZXN0IHdhcyBhbHJlYWR5IHBlcmZvcm1lZCwgdGhvdWdoLlxyXG5cdFx0XHRcdGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKTtcclxuXHRcdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcclxuXHRcdFx0fSxcclxuXHRcdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcclxuXHRcdFx0XHRcdGNvbXB1dGVQaXhlbFBvc2l0aW9uQW5kQm94U2l6aW5nUmVsaWFibGUoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xyXG5cdFx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcclxuXHRcdFx0XHQvLyBnZXRzIGNvbXB1dGVkIG1hcmdpbi1yaWdodCBiYXNlZCBvbiB3aWR0aCBvZiBjb250YWluZXIuICgjMzMzMylcclxuXHRcdFx0XHQvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcclxuXHRcdFx0XHQvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXHJcblx0XHRcdFx0dmFyIHJldCxcclxuXHRcdFx0XHRcdG1hcmdpbkRpdiA9IGRpdi5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XHJcblxyXG5cdFx0XHRcdC8vIFJlc2V0IENTUzogYm94LXNpemluZzsgZGlzcGxheTsgbWFyZ2luOyBib3JkZXI7IHBhZGRpbmdcclxuXHRcdFx0XHRtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cclxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3g8MjksIEFuZHJvaWQgMi4zXHJcblx0XHRcdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcclxuXHRcdFx0XHRcdFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94Oy1tb3otYm94LXNpemluZzpjb250ZW50LWJveDtcIiArXHJcblx0XHRcdFx0XHRcImJveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcIjtcclxuXHRcdFx0XHRtYXJnaW5EaXYuc3R5bGUubWFyZ2luUmlnaHQgPSBtYXJnaW5EaXYuc3R5bGUud2lkdGggPSBcIjBcIjtcclxuXHRcdFx0XHRkaXYuc3R5bGUud2lkdGggPSBcIjFweFwiO1xyXG5cdFx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xyXG5cclxuXHRcdFx0XHRyZXQgPSAhcGFyc2VGbG9hdCggd2luZG93LmdldENvbXB1dGVkU3R5bGUoIG1hcmdpbkRpdiwgbnVsbCApLm1hcmdpblJpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdGRvY0VsZW0ucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcmV0O1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcbn0pKCk7XHJcblxyXG5cclxuLy8gQSBtZXRob2QgZm9yIHF1aWNrbHkgc3dhcHBpbmcgaW4vb3V0IENTUyBwcm9wZXJ0aWVzIHRvIGdldCBjb3JyZWN0IGNhbGN1bGF0aW9ucy5cclxualF1ZXJ5LnN3YXAgPSBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgY2FsbGJhY2ssIGFyZ3MgKSB7XHJcblx0dmFyIHJldCwgbmFtZSxcclxuXHRcdG9sZCA9IHt9O1xyXG5cclxuXHQvLyBSZW1lbWJlciB0aGUgb2xkIHZhbHVlcywgYW5kIGluc2VydCB0aGUgbmV3IG9uZXNcclxuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XHJcblx0XHRvbGRbIG5hbWUgXSA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcclxuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9wdGlvbnNbIG5hbWUgXTtcclxuXHR9XHJcblxyXG5cdHJldCA9IGNhbGxiYWNrLmFwcGx5KCBlbGVtLCBhcmdzIHx8IFtdICk7XHJcblxyXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xyXG5cdGZvciAoIG5hbWUgaW4gb3B0aW9ucyApIHtcclxuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHJldDtcclxufTtcclxuXHJcblxyXG52YXJcclxuXHQvLyBzd2FwcGFibGUgaWYgZGlzcGxheSBpcyBub25lIG9yIHN0YXJ0cyB3aXRoIHRhYmxlIGV4Y2VwdCBcInRhYmxlXCIsIFwidGFibGUtY2VsbFwiLCBvciBcInRhYmxlLWNhcHRpb25cIlxyXG5cdC8vIHNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxyXG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcclxuXHRybnVtc3BsaXQgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKC4qKSRcIiwgXCJpXCIgKSxcclxuXHRycmVsTnVtID0gbmV3IFJlZ0V4cCggXCJeKFsrLV0pPShcIiArIHBudW0gKyBcIilcIiwgXCJpXCIgKSxcclxuXHJcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXHJcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xyXG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXHJcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXHJcblx0fSxcclxuXHJcblx0Y3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiT1wiLCBcIk1velwiLCBcIm1zXCIgXTtcclxuXHJcbi8vIHJldHVybiBhIGNzcyBwcm9wZXJ0eSBtYXBwZWQgdG8gYSBwb3RlbnRpYWxseSB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcclxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIHN0eWxlLCBuYW1lICkge1xyXG5cclxuXHQvLyBzaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxyXG5cdGlmICggbmFtZSBpbiBzdHlsZSApIHtcclxuXHRcdHJldHVybiBuYW1lO1xyXG5cdH1cclxuXHJcblx0Ly8gY2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xyXG5cdHZhciBjYXBOYW1lID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKSxcclxuXHRcdG9yaWdOYW1lID0gbmFtZSxcclxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XHJcblxyXG5cdHdoaWxlICggaS0tICkge1xyXG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xyXG5cdFx0aWYgKCBuYW1lIGluIHN0eWxlICkge1xyXG5cdFx0XHRyZXR1cm4gbmFtZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBvcmlnTmFtZTtcclxufVxyXG5cclxuZnVuY3Rpb24gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApIHtcclxuXHR2YXIgbWF0Y2hlcyA9IHJudW1zcGxpdC5leGVjKCB2YWx1ZSApO1xyXG5cdHJldHVybiBtYXRjaGVzID9cclxuXHRcdC8vIEd1YXJkIGFnYWluc3QgdW5kZWZpbmVkIFwic3VidHJhY3RcIiwgZS5nLiwgd2hlbiB1c2VkIGFzIGluIGNzc0hvb2tzXHJcblx0XHRNYXRoLm1heCggMCwgbWF0Y2hlc1sgMSBdIC0gKCBzdWJ0cmFjdCB8fCAwICkgKSArICggbWF0Y2hlc1sgMiBdIHx8IFwicHhcIiApIDpcclxuXHRcdHZhbHVlO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XHJcblx0dmFyIGkgPSBleHRyYSA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApID9cclxuXHRcdC8vIElmIHdlIGFscmVhZHkgaGF2ZSB0aGUgcmlnaHQgbWVhc3VyZW1lbnQsIGF2b2lkIGF1Z21lbnRhdGlvblxyXG5cdFx0NCA6XHJcblx0XHQvLyBPdGhlcndpc2UgaW5pdGlhbGl6ZSBmb3IgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbCBwcm9wZXJ0aWVzXHJcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcclxuXHJcblx0XHR2YWwgPSAwO1xyXG5cclxuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgKSB7XHJcblx0XHQvLyBib3RoIGJveCBtb2RlbHMgZXhjbHVkZSBtYXJnaW4sIHNvIGFkZCBpdCBpZiB3ZSB3YW50IGl0XHJcblx0XHRpZiAoIGV4dHJhID09PSBcIm1hcmdpblwiICkge1xyXG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcclxuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XHJcblx0XHRcdGlmICggZXh0cmEgPT09IFwiY29udGVudFwiICkge1xyXG5cdFx0XHRcdHZhbCAtPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgYm9yZGVyIG5vciBtYXJnaW4sIHNvIHJlbW92ZSBib3JkZXJcclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcclxuXHRcdFx0XHR2YWwgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcclxuXHRcdFx0dmFsICs9IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xyXG5cclxuXHRcdFx0Ly8gYXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxyXG5cdFx0XHRpZiAoIGV4dHJhICE9PSBcInBhZGRpbmdcIiApIHtcclxuXHRcdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHZhbDtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEgKSB7XHJcblxyXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXHJcblx0dmFyIHZhbHVlSXNCb3JkZXJCb3ggPSB0cnVlLFxyXG5cdFx0dmFsID0gbmFtZSA9PT0gXCJ3aWR0aFwiID8gZWxlbS5vZmZzZXRXaWR0aCA6IGVsZW0ub2Zmc2V0SGVpZ2h0LFxyXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXHJcblx0XHRpc0JvcmRlckJveCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCI7XHJcblxyXG5cdC8vIHNvbWUgbm9uLWh0bWwgZWxlbWVudHMgcmV0dXJuIHVuZGVmaW5lZCBmb3Igb2Zmc2V0V2lkdGgsIHNvIGNoZWNrIGZvciBudWxsL3VuZGVmaW5lZFxyXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxyXG5cdC8vIE1hdGhNTCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTQ5MTY2OFxyXG5cdGlmICggdmFsIDw9IDAgfHwgdmFsID09IG51bGwgKSB7XHJcblx0XHQvLyBGYWxsIGJhY2sgdG8gY29tcHV0ZWQgdGhlbiB1bmNvbXB1dGVkIGNzcyBpZiBuZWNlc3NhcnlcclxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XHJcblx0XHRpZiAoIHZhbCA8IDAgfHwgdmFsID09IG51bGwgKSB7XHJcblx0XHRcdHZhbCA9IGVsZW0uc3R5bGVbIG5hbWUgXTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDb21wdXRlZCB1bml0IGlzIG5vdCBwaXhlbHMuIFN0b3AgaGVyZSBhbmQgcmV0dXJuLlxyXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCh2YWwpICkge1xyXG5cdFx0XHRyZXR1cm4gdmFsO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHdlIG5lZWQgdGhlIGNoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXHJcblx0XHQvLyBmb3IgZ2V0Q29tcHV0ZWRTdHlsZSBzaWxlbnRseSBmYWxscyBiYWNrIHRvIHRoZSByZWxpYWJsZSBlbGVtLnN0eWxlXHJcblx0XHR2YWx1ZUlzQm9yZGVyQm94ID0gaXNCb3JkZXJCb3ggJiZcclxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcclxuXHJcblx0XHQvLyBOb3JtYWxpemUgXCJcIiwgYXV0bywgYW5kIHByZXBhcmUgZm9yIGV4dHJhXHJcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xyXG5cdH1cclxuXHJcblx0Ly8gdXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcclxuXHRyZXR1cm4gKCB2YWwgK1xyXG5cdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXHJcblx0XHRcdGVsZW0sXHJcblx0XHRcdG5hbWUsXHJcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcclxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcclxuXHRcdFx0c3R5bGVzXHJcblx0XHQpXHJcblx0KSArIFwicHhcIjtcclxufVxyXG5cclxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xyXG5cdHZhciBkaXNwbGF5LCBlbGVtLCBoaWRkZW4sXHJcblx0XHR2YWx1ZXMgPSBbXSxcclxuXHRcdGluZGV4ID0gMCxcclxuXHRcdGxlbmd0aCA9IGVsZW1lbnRzLmxlbmd0aDtcclxuXHJcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcclxuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcclxuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFfcHJpdi5nZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiICk7XHJcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xyXG5cdFx0aWYgKCBzaG93ICkge1xyXG5cdFx0XHQvLyBSZXNldCB0aGUgaW5saW5lIGRpc3BsYXkgb2YgdGhpcyBlbGVtZW50IHRvIGxlYXJuIGlmIGl0IGlzXHJcblx0XHRcdC8vIGJlaW5nIGhpZGRlbiBieSBjYXNjYWRlZCBydWxlcyBvciBub3RcclxuXHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICYmIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xyXG5cdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFNldCBlbGVtZW50cyB3aGljaCBoYXZlIGJlZW4gb3ZlcnJpZGRlbiB3aXRoIGRpc3BsYXk6IG5vbmVcclxuXHRcdFx0Ly8gaW4gYSBzdHlsZXNoZWV0IHRvIHdoYXRldmVyIHRoZSBkZWZhdWx0IGJyb3dzZXIgc3R5bGUgaXNcclxuXHRcdFx0Ly8gZm9yIHN1Y2ggYW4gZWxlbWVudFxyXG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbiggZWxlbSApICkge1xyXG5cdFx0XHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFfcHJpdi5hY2Nlc3MoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBkZWZhdWx0RGlzcGxheShlbGVtLm5vZGVOYW1lKSApO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xyXG5cclxuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiB8fCAhaGlkZGVuICkge1xyXG5cdFx0XHRcdGRhdGFfcHJpdi5zZXQoIGVsZW0sIFwib2xkZGlzcGxheVwiLCBoaWRkZW4gPyBkaXNwbGF5IDogalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgbW9zdCBvZiB0aGUgZWxlbWVudHMgaW4gYSBzZWNvbmQgbG9vcFxyXG5cdC8vIHRvIGF2b2lkIHRoZSBjb25zdGFudCByZWZsb3dcclxuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xyXG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xyXG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcclxuXHRcdFx0Y29udGludWU7XHJcblx0XHR9XHJcblx0XHRpZiAoICFzaG93IHx8IGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICkge1xyXG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gdmFsdWVzWyBpbmRleCBdIHx8IFwiXCIgOiBcIm5vbmVcIjtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiBlbGVtZW50cztcclxufVxyXG5cclxualF1ZXJ5LmV4dGVuZCh7XHJcblx0Ly8gQWRkIGluIHN0eWxlIHByb3BlcnR5IGhvb2tzIGZvciBvdmVycmlkaW5nIHRoZSBkZWZhdWx0XHJcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XHJcblx0Y3NzSG9va3M6IHtcclxuXHRcdG9wYWNpdHk6IHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XHJcblx0XHRcdFx0aWYgKCBjb21wdXRlZCApIHtcclxuXHRcdFx0XHRcdC8vIFdlIHNob3VsZCBhbHdheXMgZ2V0IGEgbnVtYmVyIGJhY2sgZnJvbSBvcGFjaXR5XHJcblx0XHRcdFx0XHR2YXIgcmV0ID0gY3VyQ1NTKCBlbGVtLCBcIm9wYWNpdHlcIiApO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXHJcblx0Y3NzTnVtYmVyOiB7XHJcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXHJcblx0XHRcImZpbGxPcGFjaXR5XCI6IHRydWUsXHJcblx0XHRcImZsZXhHcm93XCI6IHRydWUsXHJcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcclxuXHRcdFwiZm9udFdlaWdodFwiOiB0cnVlLFxyXG5cdFx0XCJsaW5lSGVpZ2h0XCI6IHRydWUsXHJcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcclxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcclxuXHRcdFwib3JwaGFuc1wiOiB0cnVlLFxyXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcclxuXHRcdFwiekluZGV4XCI6IHRydWUsXHJcblx0XHRcInpvb21cIjogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdC8vIEFkZCBpbiBwcm9wZXJ0aWVzIHdob3NlIG5hbWVzIHlvdSB3aXNoIHRvIGZpeCBiZWZvcmVcclxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXHJcblx0Y3NzUHJvcHM6IHtcclxuXHRcdC8vIG5vcm1hbGl6ZSBmbG9hdCBjc3MgcHJvcGVydHlcclxuXHRcdFwiZmxvYXRcIjogXCJjc3NGbG9hdFwiXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IGFuZCBzZXQgdGhlIHN0eWxlIHByb3BlcnR5IG9uIGEgRE9NIE5vZGVcclxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcclxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xyXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB3ZSdyZSB3b3JraW5nIHdpdGggdGhlIHJpZ2h0IG5hbWVcclxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxyXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKSxcclxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xyXG5cclxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHwgKCBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggc3R5bGUsIG9yaWdOYW1lICkgKTtcclxuXHJcblx0XHQvLyBnZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uXHJcblx0XHQvLyBmb2xsb3dlZCBieSB0aGUgdW5wcmVmaXhlZCB2ZXJzaW9uXHJcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcclxuXHJcblx0XHQvLyBDaGVjayBpZiB3ZSdyZSBzZXR0aW5nIGEgdmFsdWVcclxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcclxuXHJcblx0XHRcdC8vIGNvbnZlcnQgcmVsYXRpdmUgbnVtYmVyIHN0cmluZ3MgKCs9IG9yIC09KSB0byByZWxhdGl2ZSBudW1iZXJzLiAjNzM0NVxyXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgJiYgKHJldCA9IHJyZWxOdW0uZXhlYyggdmFsdWUgKSkgKSB7XHJcblx0XHRcdFx0dmFsdWUgPSAoIHJldFsxXSArIDEgKSAqIHJldFsyXSArIHBhcnNlRmxvYXQoIGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKSApO1xyXG5cdFx0XHRcdC8vIEZpeGVzIGJ1ZyAjOTIzN1xyXG5cdFx0XHRcdHR5cGUgPSBcIm51bWJlclwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBNYWtlIHN1cmUgdGhhdCBudWxsIGFuZCBOYU4gdmFsdWVzIGFyZW4ndCBzZXQuIFNlZTogIzcxMTZcclxuXHRcdFx0aWYgKCB2YWx1ZSA9PSBudWxsIHx8IHZhbHVlICE9PSB2YWx1ZSApIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCAncHgnIHRvIHRoZSAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxyXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWpRdWVyeS5jc3NOdW1iZXJbIG9yaWdOYW1lIF0gKSB7XHJcblx0XHRcdFx0dmFsdWUgKz0gXCJweFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBGaXhlcyAjODkwOCwgaXQgY2FuIGJlIGRvbmUgbW9yZSBjb3JyZWN0bHkgYnkgc3BlY2lmeWluZyBzZXR0ZXJzIGluIGNzc0hvb2tzLFxyXG5cdFx0XHQvLyBidXQgaXQgd291bGQgbWVhbiB0byBkZWZpbmUgZWlnaHQgKGZvciBldmVyeSBwcm9ibGVtYXRpYyBwcm9wZXJ0eSkgaWRlbnRpY2FsIGZ1bmN0aW9uc1xyXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XHJcblx0XHRcdFx0c3R5bGVbIG5hbWUgXSA9IFwiaW5oZXJpdFwiO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJZiBhIGhvb2sgd2FzIHByb3ZpZGVkLCB1c2UgdGhhdCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3Qgc2V0IHRoZSBzcGVjaWZpZWQgdmFsdWVcclxuXHRcdFx0aWYgKCAhaG9va3MgfHwgIShcInNldFwiIGluIGhvb2tzKSB8fCAodmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApKSAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxyXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLmdldCggZWxlbSwgZmFsc2UsIGV4dHJhICkpICE9PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdFx0cmV0dXJuIHJldDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3RcclxuXHRcdFx0cmV0dXJuIHN0eWxlWyBuYW1lIF07XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Y3NzOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgZXh0cmEsIHN0eWxlcyApIHtcclxuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXHJcblx0XHRcdG9yaWdOYW1lID0galF1ZXJ5LmNhbWVsQ2FzZSggbmFtZSApO1xyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxyXG5cdFx0bmFtZSA9IGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSB8fCAoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBlbGVtLnN0eWxlLCBvcmlnTmFtZSApICk7XHJcblxyXG5cdFx0Ly8gZ2V0cyBob29rIGZvciB0aGUgcHJlZml4ZWQgdmVyc2lvblxyXG5cdFx0Ly8gZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgdmVyc2lvblxyXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSB8fCBqUXVlcnkuY3NzSG9va3NbIG9yaWdOYW1lIF07XHJcblxyXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcclxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyApIHtcclxuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XHJcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHR2YWwgPSBjdXJDU1MoIGVsZW0sIG5hbWUsIHN0eWxlcyApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vY29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXHJcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcclxuXHRcdFx0dmFsID0gY3NzTm9ybWFsVHJhbnNmb3JtWyBuYW1lIF07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmV0dXJuLCBjb252ZXJ0aW5nIHRvIG51bWJlciBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xyXG5cdFx0aWYgKCBleHRyYSA9PT0gXCJcIiB8fCBleHRyYSApIHtcclxuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XHJcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBqUXVlcnkuaXNOdW1lcmljKCBudW0gKSA/IG51bSB8fCAwIDogdmFsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbDtcclxuXHR9XHJcbn0pO1xyXG5cclxualF1ZXJ5LmVhY2goWyBcImhlaWdodFwiLCBcIndpZHRoXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XHJcblx0alF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gPSB7XHJcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XHJcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XHJcblx0XHRcdFx0Ly8gY2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXHJcblx0XHRcdFx0Ly8gaG93ZXZlciwgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdCBmcm9tIHRoaXNcclxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJiBlbGVtLm9mZnNldFdpZHRoID09PSAwID9cclxuXHRcdFx0XHRcdGpRdWVyeS5zd2FwKCBlbGVtLCBjc3NTaG93LCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XHJcblx0XHRcdFx0XHR9KSA6XHJcblx0XHRcdFx0XHRnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcclxuXHRcdFx0dmFyIHN0eWxlcyA9IGV4dHJhICYmIGdldFN0eWxlcyggZWxlbSApO1xyXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBleHRyYSA/XHJcblx0XHRcdFx0YXVnbWVudFdpZHRoT3JIZWlnaHQoXHJcblx0XHRcdFx0XHRlbGVtLFxyXG5cdFx0XHRcdFx0bmFtZSxcclxuXHRcdFx0XHRcdGV4dHJhLFxyXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcclxuXHRcdFx0XHRcdHN0eWxlc1xyXG5cdFx0XHRcdCkgOiAwXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblx0fTtcclxufSk7XHJcblxyXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xyXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luUmlnaHQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5SaWdodCxcclxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XHJcblx0XHRpZiAoIGNvbXB1dGVkICkge1xyXG5cdFx0XHQvLyBXZWJLaXQgQnVnIDEzMzQzIC0gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHdyb25nIHZhbHVlIGZvciBtYXJnaW4tcmlnaHRcclxuXHRcdFx0Ly8gV29yayBhcm91bmQgYnkgdGVtcG9yYXJpbHkgc2V0dGluZyBlbGVtZW50IGRpc3BsYXkgdG8gaW5saW5lLWJsb2NrXHJcblx0XHRcdHJldHVybiBqUXVlcnkuc3dhcCggZWxlbSwgeyBcImRpc3BsYXlcIjogXCJpbmxpbmUtYmxvY2tcIiB9LFxyXG5cdFx0XHRcdGN1ckNTUywgWyBlbGVtLCBcIm1hcmdpblJpZ2h0XCIgXSApO1xyXG5cdFx0fVxyXG5cdH1cclxuKTtcclxuXHJcbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcclxualF1ZXJ5LmVhY2goe1xyXG5cdG1hcmdpbjogXCJcIixcclxuXHRwYWRkaW5nOiBcIlwiLFxyXG5cdGJvcmRlcjogXCJXaWR0aFwiXHJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcclxuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xyXG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XHJcblx0XHRcdHZhciBpID0gMCxcclxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxyXG5cclxuXHRcdFx0XHQvLyBhc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcclxuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KFwiIFwiKSA6IFsgdmFsdWUgXTtcclxuXHJcblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcclxuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XHJcblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBleHBhbmRlZDtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRpZiAoICFybWFyZ2luLnRlc3QoIHByZWZpeCApICkge1xyXG5cdFx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXS5zZXQgPSBzZXRQb3NpdGl2ZU51bWJlcjtcclxuXHR9XHJcbn0pO1xyXG5cclxualF1ZXJ5LmZuLmV4dGVuZCh7XHJcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XHJcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XHJcblx0XHRcdHZhciBzdHlsZXMsIGxlbixcclxuXHRcdFx0XHRtYXAgPSB7fSxcclxuXHRcdFx0XHRpID0gMDtcclxuXHJcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcclxuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcclxuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbWFwO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcclxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XHJcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcclxuXHR9LFxyXG5cdHNob3c6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzLCB0cnVlICk7XHJcblx0fSxcclxuXHRoaWRlOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcyApO1xyXG5cdH0sXHJcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XHJcblx0XHRpZiAoIHR5cGVvZiBzdGF0ZSA9PT0gXCJib29sZWFuXCIgKSB7XHJcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYgKCBpc0hpZGRlbiggdGhpcyApICkge1xyXG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuZnVuY3Rpb24gVHdlZW4oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICkge1xyXG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XHJcbn1cclxualF1ZXJ5LlR3ZWVuID0gVHdlZW47XHJcblxyXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XHJcblx0Y29uc3RydWN0b3I6IFR3ZWVuLFxyXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcclxuXHRcdHRoaXMuZWxlbSA9IGVsZW07XHJcblx0XHR0aGlzLnByb3AgPSBwcm9wO1xyXG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgXCJzd2luZ1wiO1xyXG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XHJcblx0XHR0aGlzLmVuZCA9IGVuZDtcclxuXHRcdHRoaXMudW5pdCA9IHVuaXQgfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gPyBcIlwiIDogXCJweFwiICk7XHJcblx0fSxcclxuXHRjdXI6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGhvb2tzID0gVHdlZW4ucHJvcEhvb2tzWyB0aGlzLnByb3AgXTtcclxuXHJcblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cclxuXHRcdFx0aG9va3MuZ2V0KCB0aGlzICkgOlxyXG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XHJcblx0fSxcclxuXHRydW46IGZ1bmN0aW9uKCBwZXJjZW50ICkge1xyXG5cdFx0dmFyIGVhc2VkLFxyXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XHJcblxyXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XHJcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxyXG5cdFx0XHRcdHBlcmNlbnQsIHRoaXMub3B0aW9ucy5kdXJhdGlvbiAqIHBlcmNlbnQsIDAsIDEsIHRoaXMub3B0aW9ucy5kdXJhdGlvblxyXG5cdFx0XHQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5wb3MgPSBlYXNlZCA9IHBlcmNlbnQ7XHJcblx0XHR9XHJcblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xyXG5cdFx0XHRob29rcy5zZXQoIHRoaXMgKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxufTtcclxuXHJcblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcclxuXHJcblR3ZWVuLnByb3BIb29rcyA9IHtcclxuXHRfZGVmYXVsdDoge1xyXG5cdFx0Z2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XHJcblx0XHRcdHZhciByZXN1bHQ7XHJcblxyXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmXHJcblx0XHRcdFx0KCF0d2Vlbi5lbGVtLnN0eWxlIHx8IHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsKSApIHtcclxuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBwYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcclxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlsc1xyXG5cdFx0XHQvLyBzbywgc2ltcGxlIHZhbHVlcyBzdWNoIGFzIFwiMTBweFwiIGFyZSBwYXJzZWQgdG8gRmxvYXQuXHJcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMgaXMuXHJcblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcclxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXHJcblx0XHRcdHJldHVybiAhcmVzdWx0IHx8IHJlc3VsdCA9PT0gXCJhdXRvXCIgPyAwIDogcmVzdWx0O1xyXG5cdFx0fSxcclxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xyXG5cdFx0XHQvLyB1c2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdCAtIHVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZSAtIHVzZSAuc3R5bGUgaWYgaXRzXHJcblx0XHRcdC8vIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlXHJcblx0XHRcdGlmICggalF1ZXJ5LmZ4LnN0ZXBbIHR3ZWVuLnByb3AgXSApIHtcclxuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xyXG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLnN0eWxlICYmICggdHdlZW4uZWxlbS5zdHlsZVsgalF1ZXJ5LmNzc1Byb3BzWyB0d2Vlbi5wcm9wIF0gXSAhPSBudWxsIHx8IGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XHJcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuLy8gU3VwcG9ydDogSUU5XHJcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xyXG5cclxuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xyXG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xyXG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcclxuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xyXG5cdFx0fVxyXG5cdH1cclxufTtcclxuXHJcbmpRdWVyeS5lYXNpbmcgPSB7XHJcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcclxuXHRcdHJldHVybiBwO1xyXG5cdH0sXHJcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xyXG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcclxuXHR9XHJcbn07XHJcblxyXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcclxuXHJcbi8vIEJhY2sgQ29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XHJcbmpRdWVyeS5meC5zdGVwID0ge307XHJcblxyXG5cclxuXHJcblxyXG52YXJcclxuXHRmeE5vdywgdGltZXJJZCxcclxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcclxuXHRyZnhudW0gPSBuZXcgUmVnRXhwKCBcIl4oPzooWystXSk9fCkoXCIgKyBwbnVtICsgXCIpKFthLXolXSopJFwiLCBcImlcIiApLFxyXG5cdHJydW4gPSAvcXVldWVIb29rcyQvLFxyXG5cdGFuaW1hdGlvblByZWZpbHRlcnMgPSBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcclxuXHR0d2VlbmVycyA9IHtcclxuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcclxuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKSxcclxuXHRcdFx0XHR0YXJnZXQgPSB0d2Vlbi5jdXIoKSxcclxuXHRcdFx0XHRwYXJ0cyA9IHJmeG51bS5leGVjKCB2YWx1ZSApLFxyXG5cdFx0XHRcdHVuaXQgPSBwYXJ0cyAmJiBwYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxyXG5cclxuXHRcdFx0XHQvLyBTdGFydGluZyB2YWx1ZSBjb21wdXRhdGlvbiBpcyByZXF1aXJlZCBmb3IgcG90ZW50aWFsIHVuaXQgbWlzbWF0Y2hlc1xyXG5cdFx0XHRcdHN0YXJ0ID0gKCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICt0YXJnZXQgKSAmJlxyXG5cdFx0XHRcdFx0cmZ4bnVtLmV4ZWMoIGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHByb3AgKSApLFxyXG5cdFx0XHRcdHNjYWxlID0gMSxcclxuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMjA7XHJcblxyXG5cdFx0XHRpZiAoIHN0YXJ0ICYmIHN0YXJ0WyAzIF0gIT09IHVuaXQgKSB7XHJcblx0XHRcdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xyXG5cdFx0XHRcdHVuaXQgPSB1bml0IHx8IHN0YXJ0WyAzIF07XHJcblxyXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIHR3ZWVuIHByb3BlcnRpZXMgbGF0ZXIgb25cclxuXHRcdFx0XHRwYXJ0cyA9IHBhcnRzIHx8IFtdO1xyXG5cclxuXHRcdFx0XHQvLyBJdGVyYXRpdmVseSBhcHByb3hpbWF0ZSBmcm9tIGEgbm9uemVybyBzdGFydGluZyBwb2ludFxyXG5cdFx0XHRcdHN0YXJ0ID0gK3RhcmdldCB8fCAxO1xyXG5cclxuXHRcdFx0XHRkbyB7XHJcblx0XHRcdFx0XHQvLyBJZiBwcmV2aW91cyBpdGVyYXRpb24gemVyb2VkIG91dCwgZG91YmxlIHVudGlsIHdlIGdldCAqc29tZXRoaW5nKlxyXG5cdFx0XHRcdFx0Ly8gVXNlIGEgc3RyaW5nIGZvciBkb3VibGluZyBmYWN0b3Igc28gd2UgZG9uJ3QgYWNjaWRlbnRhbGx5IHNlZSBzY2FsZSBhcyB1bmNoYW5nZWQgYmVsb3dcclxuXHRcdFx0XHRcdHNjYWxlID0gc2NhbGUgfHwgXCIuNVwiO1xyXG5cclxuXHRcdFx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcclxuXHRcdFx0XHRcdHN0YXJ0ID0gc3RhcnQgLyBzY2FsZTtcclxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgcHJvcCwgc3RhcnQgKyB1bml0ICk7XHJcblxyXG5cdFx0XHRcdC8vIFVwZGF0ZSBzY2FsZSwgdG9sZXJhdGluZyB6ZXJvIG9yIE5hTiBmcm9tIHR3ZWVuLmN1cigpXHJcblx0XHRcdFx0Ly8gQW5kIGJyZWFraW5nIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2hcclxuXHRcdFx0XHR9IHdoaWxlICggc2NhbGUgIT09IChzY2FsZSA9IHR3ZWVuLmN1cigpIC8gdGFyZ2V0KSAmJiBzY2FsZSAhPT0gMSAmJiAtLW1heEl0ZXJhdGlvbnMgKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVXBkYXRlIHR3ZWVuIHByb3BlcnRpZXNcclxuXHRcdFx0aWYgKCBwYXJ0cyApIHtcclxuXHRcdFx0XHRzdGFydCA9IHR3ZWVuLnN0YXJ0ID0gK3N0YXJ0IHx8ICt0YXJnZXQgfHwgMDtcclxuXHRcdFx0XHR0d2Vlbi51bml0ID0gdW5pdDtcclxuXHRcdFx0XHQvLyBJZiBhICs9Ly09IHRva2VuIHdhcyBwcm92aWRlZCwgd2UncmUgZG9pbmcgYSByZWxhdGl2ZSBhbmltYXRpb25cclxuXHRcdFx0XHR0d2Vlbi5lbmQgPSBwYXJ0c1sgMSBdID9cclxuXHRcdFx0XHRcdHN0YXJ0ICsgKCBwYXJ0c1sgMSBdICsgMSApICogcGFydHNbIDIgXSA6XHJcblx0XHRcdFx0XHQrcGFydHNbIDIgXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xyXG5cdFx0fSBdXHJcblx0fTtcclxuXHJcbi8vIEFuaW1hdGlvbnMgY3JlYXRlZCBzeW5jaHJvbm91c2x5IHdpbGwgcnVuIHN5bmNocm9ub3VzbHlcclxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XHJcblx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xyXG5cdH0pO1xyXG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XHJcbn1cclxuXHJcbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXHJcbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XHJcblx0dmFyIHdoaWNoLFxyXG5cdFx0aSA9IDAsXHJcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XHJcblxyXG5cdC8vIGlmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcclxuXHQvLyBpZiB3ZSBkb24ndCBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XHJcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XHJcblx0Zm9yICggOyBpIDwgNCA7IGkgKz0gMiAtIGluY2x1ZGVXaWR0aCApIHtcclxuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XHJcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcclxuXHR9XHJcblxyXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xyXG5cdFx0YXR0cnMub3BhY2l0eSA9IGF0dHJzLndpZHRoID0gdHlwZTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBhdHRycztcclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlVHdlZW4oIHZhbHVlLCBwcm9wLCBhbmltYXRpb24gKSB7XHJcblx0dmFyIHR3ZWVuLFxyXG5cdFx0Y29sbGVjdGlvbiA9ICggdHdlZW5lcnNbIHByb3AgXSB8fCBbXSApLmNvbmNhdCggdHdlZW5lcnNbIFwiKlwiIF0gKSxcclxuXHRcdGluZGV4ID0gMCxcclxuXHRcdGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoO1xyXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XHJcblx0XHRpZiAoICh0d2VlbiA9IGNvbGxlY3Rpb25bIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBwcm9wLCB2YWx1ZSApKSApIHtcclxuXHJcblx0XHRcdC8vIHdlJ3JlIGRvbmUgd2l0aCB0aGlzIHByb3BlcnR5XHJcblx0XHRcdHJldHVybiB0d2VlbjtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRQcmVmaWx0ZXIoIGVsZW0sIHByb3BzLCBvcHRzICkge1xyXG5cdC8qIGpzaGludCB2YWxpZHRoaXM6IHRydWUgKi9cclxuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgdHdlZW4sIGhvb2tzLCBvbGRmaXJlLCBkaXNwbGF5LCBjaGVja0Rpc3BsYXksXHJcblx0XHRhbmltID0gdGhpcyxcclxuXHRcdG9yaWcgPSB7fSxcclxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcclxuXHRcdGhpZGRlbiA9IGVsZW0ubm9kZVR5cGUgJiYgaXNIaWRkZW4oIGVsZW0gKSxcclxuXHRcdGRhdGFTaG93ID0gZGF0YV9wcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xyXG5cclxuXHQvLyBoYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXHJcblx0aWYgKCAhb3B0cy5xdWV1ZSApIHtcclxuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcclxuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcclxuXHRcdFx0aG9va3MudW5xdWV1ZWQgPSAwO1xyXG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcclxuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmICggIWhvb2tzLnVucXVldWVkICkge1xyXG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHRcdGhvb2tzLnVucXVldWVkKys7XHJcblxyXG5cdFx0YW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XHJcblx0XHRcdC8vIGRvaW5nIHRoaXMgbWFrZXMgc3VyZSB0aGF0IHRoZSBjb21wbGV0ZSBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkXHJcblx0XHRcdC8vIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xyXG5cdFx0XHRhbmltLmFsd2F5cyhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xyXG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xyXG5cdFx0XHRcdFx0aG9va3MuZW1wdHkuZmlyZSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vIGhlaWdodC93aWR0aCBvdmVyZmxvdyBwYXNzXHJcblx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCJoZWlnaHRcIiBpbiBwcm9wcyB8fCBcIndpZHRoXCIgaW4gcHJvcHMgKSApIHtcclxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG5vdGhpbmcgc25lYWtzIG91dFxyXG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRTktMTAgZG8gbm90XHJcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcclxuXHRcdC8vIG92ZXJmbG93WSBhcmUgc2V0IHRvIHRoZSBzYW1lIHZhbHVlXHJcblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcclxuXHJcblx0XHQvLyBTZXQgZGlzcGxheSBwcm9wZXJ0eSB0byBpbmxpbmUtYmxvY2sgZm9yIGhlaWdodC93aWR0aFxyXG5cdFx0Ly8gYW5pbWF0aW9ucyBvbiBpbmxpbmUgZWxlbWVudHMgdGhhdCBhcmUgaGF2aW5nIHdpZHRoL2hlaWdodCBhbmltYXRlZFxyXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XHJcblxyXG5cdFx0Ly8gVGVzdCBkZWZhdWx0IGRpc3BsYXkgaWYgZGlzcGxheSBpcyBjdXJyZW50bHkgXCJub25lXCJcclxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cclxuXHRcdFx0ZGF0YV9wcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheTtcclxuXHJcblx0XHRpZiAoIGNoZWNrRGlzcGxheSA9PT0gXCJpbmxpbmVcIiAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XHJcblx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKCBvcHRzLm92ZXJmbG93ICkge1xyXG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xyXG5cdFx0YW5pbS5hbHdheXMoZnVuY3Rpb24oKSB7XHJcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xyXG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XHJcblx0XHRcdHN0eWxlLm92ZXJmbG93WSA9IG9wdHMub3ZlcmZsb3dbIDIgXTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Ly8gc2hvdy9oaWRlIHBhc3NcclxuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xyXG5cdFx0dmFsdWUgPSBwcm9wc1sgcHJvcCBdO1xyXG5cdFx0aWYgKCByZnh0eXBlcy5leGVjKCB2YWx1ZSApICkge1xyXG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcclxuXHRcdFx0dG9nZ2xlID0gdG9nZ2xlIHx8IHZhbHVlID09PSBcInRvZ2dsZVwiO1xyXG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gSWYgdGhlcmUgaXMgZGF0YVNob3cgbGVmdCBvdmVyIGZyb20gYSBzdG9wcGVkIGhpZGUgb3Igc2hvdyBhbmQgd2UgYXJlIGdvaW5nIHRvIHByb2NlZWQgd2l0aCBzaG93LCB3ZSBzaG91bGQgcHJldGVuZCB0byBiZSBoaWRkZW5cclxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcclxuXHJcblx0XHQvLyBBbnkgbm9uLWZ4IHZhbHVlIHN0b3BzIHVzIGZyb20gcmVzdG9yaW5nIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRkaXNwbGF5ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0aWYgKCAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIG9yaWcgKSApIHtcclxuXHRcdGlmICggZGF0YVNob3cgKSB7XHJcblx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcclxuXHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRhdGFTaG93ID0gZGF0YV9wcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwge30gKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBzdG9yZSBzdGF0ZSBpZiBpdHMgdG9nZ2xlIC0gZW5hYmxlcyAuc3RvcCgpLnRvZ2dsZSgpIHRvIFwicmV2ZXJzZVwiXHJcblx0XHRpZiAoIHRvZ2dsZSApIHtcclxuXHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcclxuXHRcdH1cclxuXHRcdGlmICggaGlkZGVuICkge1xyXG5cdFx0XHRqUXVlcnkoIGVsZW0gKS5zaG93KCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRhbmltLmRvbmUoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0alF1ZXJ5KCBlbGVtICkuaGlkZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHRcdGFuaW0uZG9uZShmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIHByb3A7XHJcblxyXG5cdFx0XHRkYXRhX3ByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XHJcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcclxuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcclxuXHRcdFx0dHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcclxuXHJcblx0XHRcdGlmICggISggcHJvcCBpbiBkYXRhU2hvdyApICkge1xyXG5cdFx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSB0d2Vlbi5zdGFydDtcclxuXHRcdFx0XHRpZiAoIGhpZGRlbiApIHtcclxuXHRcdFx0XHRcdHR3ZWVuLmVuZCA9IHR3ZWVuLnN0YXJ0O1xyXG5cdFx0XHRcdFx0dHdlZW4uc3RhcnQgPSBwcm9wID09PSBcIndpZHRoXCIgfHwgcHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHQvLyBJZiB0aGlzIGlzIGEgbm9vcCBsaWtlIC5oaWRlKCkuaGlkZSgpLCByZXN0b3JlIGFuIG92ZXJ3cml0dGVuIGRpc3BsYXkgdmFsdWVcclxuXHR9IGVsc2UgaWYgKCAoZGlzcGxheSA9PT0gXCJub25lXCIgPyBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheSkgPT09IFwiaW5saW5lXCIgKSB7XHJcblx0XHRzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xyXG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XHJcblxyXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xyXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xyXG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XHJcblx0XHRlYXNpbmcgPSBzcGVjaWFsRWFzaW5nWyBuYW1lIF07XHJcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xyXG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcclxuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcclxuXHRcdFx0dmFsdWUgPSBwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyAwIF07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBpbmRleCAhPT0gbmFtZSApIHtcclxuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xyXG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XHJcblx0XHR9XHJcblxyXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcclxuXHRcdGlmICggaG9va3MgJiYgXCJleHBhbmRcIiBpbiBob29rcyApIHtcclxuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XHJcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xyXG5cclxuXHRcdFx0Ly8gbm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbnQgb3ZlcndyaXRlIGtleXMgYWxyZWFkeSBwcmVzZW50LlxyXG5cdFx0XHQvLyBhbHNvIC0gcmV1c2luZyAnaW5kZXgnIGZyb20gYWJvdmUgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXHJcblx0XHRcdGZvciAoIGluZGV4IGluIHZhbHVlICkge1xyXG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcclxuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XHJcblx0XHRcdFx0XHRzcGVjaWFsRWFzaW5nWyBpbmRleCBdID0gZWFzaW5nO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gQW5pbWF0aW9uKCBlbGVtLCBwcm9wZXJ0aWVzLCBvcHRpb25zICkge1xyXG5cdHZhciByZXN1bHQsXHJcblx0XHRzdG9wcGVkLFxyXG5cdFx0aW5kZXggPSAwLFxyXG5cdFx0bGVuZ3RoID0gYW5pbWF0aW9uUHJlZmlsdGVycy5sZW5ndGgsXHJcblx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLmFsd2F5cyggZnVuY3Rpb24oKSB7XHJcblx0XHRcdC8vIGRvbid0IG1hdGNoIGVsZW0gaW4gdGhlIDphbmltYXRlZCBzZWxlY3RvclxyXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xyXG5cdFx0fSksXHJcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlmICggc3RvcHBlZCApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcclxuXHRcdFx0XHRyZW1haW5pbmcgPSBNYXRoLm1heCggMCwgYW5pbWF0aW9uLnN0YXJ0VGltZSArIGFuaW1hdGlvbi5kdXJhdGlvbiAtIGN1cnJlbnRUaW1lICksXHJcblx0XHRcdFx0Ly8gYXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIDEgLSAoIDAuNSB8fCAwICkgKCMxMjQ5NylcclxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXHJcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxyXG5cdFx0XHRcdGluZGV4ID0gMCxcclxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcclxuXHJcblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xyXG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSk7XHJcblxyXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcclxuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSh7XHJcblx0XHRcdGVsZW06IGVsZW0sXHJcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxyXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7IHNwZWNpYWxFYXNpbmc6IHt9IH0sIG9wdGlvbnMgKSxcclxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxyXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXHJcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcclxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXHJcblx0XHRcdHR3ZWVuczogW10sXHJcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xyXG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcclxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xyXG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcclxuXHRcdFx0XHRyZXR1cm4gdHdlZW47XHJcblx0XHRcdH0sXHJcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xyXG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXHJcblx0XHRcdFx0XHQvLyBpZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcclxuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxyXG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcclxuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XHJcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XHJcblx0XHRcdFx0XHRhbmltYXRpb24udHdlZW5zWyBpbmRleCBdLnJ1biggMSApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gcmVzb2x2ZSB3aGVuIHdlIHBsYXllZCB0aGUgbGFzdCBmcmFtZVxyXG5cdFx0XHRcdC8vIG90aGVyd2lzZSwgcmVqZWN0XHJcblx0XHRcdFx0aWYgKCBnb3RvRW5kICkge1xyXG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fVxyXG5cdFx0fSksXHJcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcclxuXHJcblx0cHJvcEZpbHRlciggcHJvcHMsIGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmcgKTtcclxuXHJcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XHJcblx0XHRyZXN1bHQgPSBhbmltYXRpb25QcmVmaWx0ZXJzWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgZWxlbSwgcHJvcHMsIGFuaW1hdGlvbi5vcHRzICk7XHJcblx0XHRpZiAoIHJlc3VsdCApIHtcclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XHJcblxyXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XHJcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcclxuXHR9XHJcblxyXG5cdGpRdWVyeS5meC50aW1lcihcclxuXHRcdGpRdWVyeS5leHRlbmQoIHRpY2ssIHtcclxuXHRcdFx0ZWxlbTogZWxlbSxcclxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxyXG5cdFx0XHRxdWV1ZTogYW5pbWF0aW9uLm9wdHMucXVldWVcclxuXHRcdH0pXHJcblx0KTtcclxuXHJcblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcclxuXHRyZXR1cm4gYW5pbWF0aW9uLnByb2dyZXNzKCBhbmltYXRpb24ub3B0cy5wcm9ncmVzcyApXHJcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxyXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxyXG5cdFx0LmFsd2F5cyggYW5pbWF0aW9uLm9wdHMuYWx3YXlzICk7XHJcbn1cclxuXHJcbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcclxuXHJcblx0dHdlZW5lcjogZnVuY3Rpb24oIHByb3BzLCBjYWxsYmFjayApIHtcclxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHByb3BzICkgKSB7XHJcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XHJcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cHJvcHMgPSBwcm9wcy5zcGxpdChcIiBcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHByb3AsXHJcblx0XHRcdGluZGV4ID0gMCxcclxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xyXG5cclxuXHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGggOyBpbmRleCsrICkge1xyXG5cdFx0XHRwcm9wID0gcHJvcHNbIGluZGV4IF07XHJcblx0XHRcdHR3ZWVuZXJzWyBwcm9wIF0gPSB0d2VlbmVyc1sgcHJvcCBdIHx8IFtdO1xyXG5cdFx0XHR0d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cHJlZmlsdGVyOiBmdW5jdGlvbiggY2FsbGJhY2ssIHByZXBlbmQgKSB7XHJcblx0XHRpZiAoIHByZXBlbmQgKSB7XHJcblx0XHRcdGFuaW1hdGlvblByZWZpbHRlcnMudW5zaGlmdCggY2FsbGJhY2sgKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGFuaW1hdGlvblByZWZpbHRlcnMucHVzaCggY2FsbGJhY2sgKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxualF1ZXJ5LnNwZWVkID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGZuICkge1xyXG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcclxuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XHJcblx0XHRcdGpRdWVyeS5pc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxyXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxyXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFqUXVlcnkuaXNGdW5jdGlvbiggZWFzaW5nICkgJiYgZWFzaW5nXHJcblx0fTtcclxuXHJcblx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4Lm9mZiA/IDAgOiB0eXBlb2Ygb3B0LmR1cmF0aW9uID09PSBcIm51bWJlclwiID8gb3B0LmR1cmF0aW9uIDpcclxuXHRcdG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzID8galF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xyXG5cclxuXHQvLyBub3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcclxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcclxuXHRcdG9wdC5xdWV1ZSA9IFwiZnhcIjtcclxuXHR9XHJcblxyXG5cdC8vIFF1ZXVlaW5nXHJcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcclxuXHJcblx0b3B0LmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHQub2xkICkgKSB7XHJcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xyXG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIG9wdDtcclxufTtcclxuXHJcbmpRdWVyeS5mbi5leHRlbmQoe1xyXG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcclxuXHJcblx0XHQvLyBzaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcclxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW4gKS5jc3MoIFwib3BhY2l0eVwiLCAwICkuc2hvdygpXHJcblxyXG5cdFx0XHQvLyBhbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcclxuXHRcdFx0LmVuZCgpLmFuaW1hdGUoeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xyXG5cdH0sXHJcblx0YW5pbWF0ZTogZnVuY3Rpb24oIHByb3AsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xyXG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcclxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxyXG5cdFx0XHRkb0FuaW1hdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdC8vIE9wZXJhdGUgb24gYSBjb3B5IG9mIHByb3Agc28gcGVyLXByb3BlcnR5IGVhc2luZyB3b24ndCBiZSBsb3N0XHJcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xyXG5cclxuXHRcdFx0XHQvLyBFbXB0eSBhbmltYXRpb25zLCBvciBmaW5pc2hpbmcgcmVzb2x2ZXMgaW1tZWRpYXRlbHlcclxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFfcHJpdi5nZXQoIHRoaXMsIFwiZmluaXNoXCIgKSApIHtcclxuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XHJcblxyXG5cdFx0cmV0dXJuIGVtcHR5IHx8IG9wdGFsbC5xdWV1ZSA9PT0gZmFsc2UgP1xyXG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxyXG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XHJcblx0fSxcclxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcclxuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XHJcblx0XHRcdHZhciBzdG9wID0gaG9va3Muc3RvcDtcclxuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XHJcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcclxuXHRcdFx0Z290b0VuZCA9IGNsZWFyUXVldWU7XHJcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xyXG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCBjbGVhclF1ZXVlICYmIHR5cGUgIT09IGZhbHNlICkge1xyXG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXHJcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxyXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXHJcblx0XHRcdFx0ZGF0YSA9IGRhdGFfcHJpdi5nZXQoIHRoaXMgKTtcclxuXHJcblx0XHRcdGlmICggaW5kZXggKSB7XHJcblx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCApIHtcclxuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xyXG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XHJcblx0XHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcclxuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmICh0eXBlID09IG51bGwgfHwgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlKSApIHtcclxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcclxuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcclxuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBzdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkXHJcblx0XHRcdC8vIHRpbWVycyBjdXJyZW50bHkgd2lsbCBjYWxsIHRoZWlyIGNvbXBsZXRlIGNhbGxiYWNrcywgd2hpY2ggd2lsbCBkZXF1ZXVlXHJcblx0XHRcdC8vIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kXHJcblx0XHRcdGlmICggZGVxdWV1ZSB8fCAhZ290b0VuZCApIHtcclxuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cdGZpbmlzaDogZnVuY3Rpb24oIHR5cGUgKSB7XHJcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xyXG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgaW5kZXgsXHJcblx0XHRcdFx0ZGF0YSA9IGRhdGFfcHJpdi5nZXQoIHRoaXMgKSxcclxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcclxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxyXG5cdFx0XHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnMsXHJcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xyXG5cclxuXHRcdFx0Ly8gZW5hYmxlIGZpbmlzaGluZyBmbGFnIG9uIHByaXZhdGUgZGF0YVxyXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XHJcblxyXG5cdFx0XHQvLyBlbXB0eSB0aGUgcXVldWUgZmlyc3RcclxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xyXG5cclxuXHRcdFx0aWYgKCBob29rcyAmJiBob29rcy5zdG9wICkge1xyXG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBsb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxyXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xyXG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiYgdGltZXJzWyBpbmRleCBdLnF1ZXVlID09PSB0eXBlICkge1xyXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xyXG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGxvb2sgZm9yIGFueSBhbmltYXRpb25zIGluIHRoZSBvbGQgcXVldWUgYW5kIGZpbmlzaCB0aGVtXHJcblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XHJcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XHJcblx0XHRcdFx0XHRxdWV1ZVsgaW5kZXggXS5maW5pc2guY2FsbCggdGhpcyApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdHVybiBvZmYgZmluaXNoaW5nIGZsYWdcclxuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcbmpRdWVyeS5lYWNoKFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xyXG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xyXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xyXG5cdFx0cmV0dXJuIHNwZWVkID09IG51bGwgfHwgdHlwZW9mIHNwZWVkID09PSBcImJvb2xlYW5cIiA/XHJcblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XHJcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcclxuXHR9O1xyXG59KTtcclxuXHJcbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcclxualF1ZXJ5LmVhY2goe1xyXG5cdHNsaWRlRG93bjogZ2VuRngoXCJzaG93XCIpLFxyXG5cdHNsaWRlVXA6IGdlbkZ4KFwiaGlkZVwiKSxcclxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoXCJ0b2dnbGVcIiksXHJcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXHJcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxyXG5cdGZhZGVUb2dnbGU6IHsgb3BhY2l0eTogXCJ0b2dnbGVcIiB9XHJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcclxuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcclxuXHRcdHJldHVybiB0aGlzLmFuaW1hdGUoIHByb3BzLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xyXG5cdH07XHJcbn0pO1xyXG5cclxualF1ZXJ5LnRpbWVycyA9IFtdO1xyXG5qUXVlcnkuZngudGljayA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciB0aW1lcixcclxuXHRcdGkgPSAwLFxyXG5cdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycztcclxuXHJcblx0ZnhOb3cgPSBqUXVlcnkubm93KCk7XHJcblxyXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcclxuXHRcdHRpbWVyID0gdGltZXJzWyBpIF07XHJcblx0XHQvLyBDaGVja3MgdGhlIHRpbWVyIGhhcyBub3QgYWxyZWFkeSBiZWVuIHJlbW92ZWRcclxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xyXG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XHJcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xyXG5cdH1cclxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcclxufTtcclxuXHJcbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcclxuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XHJcblx0aWYgKCB0aW1lcigpICkge1xyXG5cdFx0alF1ZXJ5LmZ4LnN0YXJ0KCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XHJcblx0fVxyXG59O1xyXG5cclxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XHJcblxyXG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcclxuXHRpZiAoICF0aW1lcklkICkge1xyXG5cdFx0dGltZXJJZCA9IHNldEludGVydmFsKCBqUXVlcnkuZngudGljaywgalF1ZXJ5LmZ4LmludGVydmFsICk7XHJcblx0fVxyXG59O1xyXG5cclxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcclxuXHRjbGVhckludGVydmFsKCB0aW1lcklkICk7XHJcblx0dGltZXJJZCA9IG51bGw7XHJcbn07XHJcblxyXG5qUXVlcnkuZnguc3BlZWRzID0ge1xyXG5cdHNsb3c6IDYwMCxcclxuXHRmYXN0OiAyMDAsXHJcblx0Ly8gRGVmYXVsdCBzcGVlZFxyXG5cdF9kZWZhdWx0OiA0MDBcclxufTtcclxuXHJcblxyXG4vLyBCYXNlZCBvZmYgb2YgdGhlIHBsdWdpbiBieSBDbGludCBIZWxmZXJzLCB3aXRoIHBlcm1pc3Npb24uXHJcbi8vIGh0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cclxualF1ZXJ5LmZuLmRlbGF5ID0gZnVuY3Rpb24oIHRpbWUsIHR5cGUgKSB7XHJcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcclxuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XHJcblxyXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XHJcblx0XHR2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoIG5leHQsIHRpbWUgKTtcclxuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0Y2xlYXJUaW1lb3V0KCB0aW1lb3V0ICk7XHJcblx0XHR9O1xyXG5cdH0pO1xyXG59O1xyXG5cclxuXHJcbihmdW5jdGlvbigpIHtcclxuXHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKSxcclxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcclxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XHJcblxyXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XHJcblxyXG5cdC8vIFN1cHBvcnQ6IGlPUyA1LjEsIEFuZHJvaWQgNC54LCBBbmRyb2lkIDIuM1xyXG5cdC8vIENoZWNrIHRoZSBkZWZhdWx0IGNoZWNrYm94L3JhZGlvIHZhbHVlIChcIlwiIG9uIG9sZCBXZWJLaXQ7IFwib25cIiBlbHNld2hlcmUpXHJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XHJcblxyXG5cdC8vIE11c3QgYWNjZXNzIHRoZSBwYXJlbnQgdG8gbWFrZSBhbiBvcHRpb24gc2VsZWN0IHByb3Blcmx5XHJcblx0Ly8gU3VwcG9ydDogSUU5LCBJRTEwXHJcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcclxuXHJcblx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIG9wdGlvbnMgaW5zaWRlIGRpc2FibGVkIHNlbGVjdHMgYXJlbid0IG1hcmtlZCBhcyBkaXNhYmxlZFxyXG5cdC8vIChXZWJLaXQgbWFya3MgdGhlbSBhcyBkaXNhYmxlZClcclxuXHRzZWxlY3QuZGlzYWJsZWQgPSB0cnVlO1xyXG5cdHN1cHBvcnQub3B0RGlzYWJsZWQgPSAhb3B0LmRpc2FibGVkO1xyXG5cclxuXHQvLyBDaGVjayBpZiBhbiBpbnB1dCBtYWludGFpbnMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cclxuXHQvLyBTdXBwb3J0OiBJRTksIElFMTBcclxuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xyXG5cdGlucHV0LnZhbHVlID0gXCJ0XCI7XHJcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcclxuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XHJcbn0pKCk7XHJcblxyXG5cclxudmFyIG5vZGVIb29rLCBib29sSG9vayxcclxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcclxuXHJcbmpRdWVyeS5mbi5leHRlbmQoe1xyXG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGpRdWVyeS5hdHRyLCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggbmFtZSApIHtcclxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCB0aGlzLCBuYW1lICk7XHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxualF1ZXJ5LmV4dGVuZCh7XHJcblx0YXR0cjogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xyXG5cdFx0dmFyIGhvb2tzLCByZXQsXHJcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcclxuXHJcblx0XHQvLyBkb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXHJcblx0XHRpZiAoICFlbGVtIHx8IG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRmFsbGJhY2sgdG8gcHJvcCB3aGVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBzdXBwb3J0ZWRcclxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBzdHJ1bmRlZmluZWQgKSB7XHJcblx0XHRcdHJldHVybiBqUXVlcnkucHJvcCggZWxlbSwgbmFtZSwgdmFsdWUgKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBBbGwgYXR0cmlidXRlcyBhcmUgbG93ZXJjYXNlXHJcblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXHJcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcclxuXHRcdFx0bmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcclxuXHRcdFx0aG9va3MgPSBqUXVlcnkuYXR0ckhvb2tzWyBuYW1lIF0gfHxcclxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiBub2RlSG9vayApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XHJcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiYgKHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSkgIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRyZXR1cm4gcmV0O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XHJcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkpICE9PSBudWxsICkge1xyXG5cdFx0XHRyZXR1cm4gcmV0O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcclxuXHJcblx0XHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXHJcblx0XHRcdHJldHVybiByZXQgPT0gbnVsbCA/XHJcblx0XHRcdFx0dW5kZWZpbmVkIDpcclxuXHRcdFx0XHRyZXQ7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xyXG5cdFx0dmFyIG5hbWUsIHByb3BOYW1lLFxyXG5cdFx0XHRpID0gMCxcclxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApO1xyXG5cclxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XHJcblx0XHRcdHdoaWxlICggKG5hbWUgPSBhdHRyTmFtZXNbaSsrXSkgKSB7XHJcblx0XHRcdFx0cHJvcE5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XHJcblxyXG5cdFx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcclxuXHRcdFx0XHRpZiAoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApICkge1xyXG5cdFx0XHRcdFx0Ly8gU2V0IGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdG8gZmFsc2VcclxuXHRcdFx0XHRcdGVsZW1bIHByb3BOYW1lIF0gPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhdHRySG9va3M6IHtcclxuXHRcdHR5cGU6IHtcclxuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XHJcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcclxuXHRcdFx0XHRcdGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJpbnB1dFwiICkgKSB7XHJcblx0XHRcdFx0XHQvLyBTZXR0aW5nIHRoZSB0eXBlIG9uIGEgcmFkaW8gYnV0dG9uIGFmdGVyIHRoZSB2YWx1ZSByZXNldHMgdGhlIHZhbHVlIGluIElFNi05XHJcblx0XHRcdFx0XHQvLyBSZXNldCB2YWx1ZSB0byBkZWZhdWx0IGluIGNhc2UgdHlwZSBpcyBzZXQgYWZ0ZXIgdmFsdWUgZHVyaW5nIGNyZWF0aW9uXHJcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcclxuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcclxuXHRcdFx0XHRcdGlmICggdmFsICkge1xyXG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXHJcbmJvb2xIb29rID0ge1xyXG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xyXG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XHJcblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2VcclxuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gbmFtZTtcclxuXHR9XHJcbn07XHJcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcclxuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XHJcblxyXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcclxuXHRcdHZhciByZXQsIGhhbmRsZTtcclxuXHRcdGlmICggIWlzWE1MICkge1xyXG5cdFx0XHQvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wIGJ5IHRlbXBvcmFyaWx5IHJlbW92aW5nIHRoaXMgZnVuY3Rpb24gZnJvbSB0aGUgZ2V0dGVyXHJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIG5hbWUgXTtcclxuXHRcdFx0YXR0ckhhbmRsZVsgbmFtZSBdID0gcmV0O1xyXG5cdFx0XHRyZXQgPSBnZXR0ZXIoIGVsZW0sIG5hbWUsIGlzWE1MICkgIT0gbnVsbCA/XHJcblx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcclxuXHRcdFx0XHRudWxsO1xyXG5cdFx0XHRhdHRySGFuZGxlWyBuYW1lIF0gPSBoYW5kbGU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmV0O1xyXG5cdH07XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pO1xyXG5cclxualF1ZXJ5LmZuLmV4dGVuZCh7XHJcblx0cHJvcDogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xyXG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LnByb3AsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZVByb3A6IGZ1bmN0aW9uKCBuYW1lICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXNbIGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZSBdO1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcbmpRdWVyeS5leHRlbmQoe1xyXG5cdHByb3BGaXg6IHtcclxuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxyXG5cdFx0XCJjbGFzc1wiOiBcImNsYXNzTmFtZVwiXHJcblx0fSxcclxuXHJcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xyXG5cdFx0dmFyIHJldCwgaG9va3MsIG5vdHhtbCxcclxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xyXG5cclxuXHRcdC8vIGRvbid0IGdldC9zZXQgcHJvcGVydGllcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcclxuXHRcdGlmICggIWVsZW0gfHwgblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRub3R4bWwgPSBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICk7XHJcblxyXG5cdFx0aWYgKCBub3R4bWwgKSB7XHJcblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3NcclxuXHRcdFx0bmFtZSA9IGpRdWVyeS5wcm9wRml4WyBuYW1lIF0gfHwgbmFtZTtcclxuXHRcdFx0aG9va3MgPSBqUXVlcnkucHJvcEhvb2tzWyBuYW1lIF07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRyZXR1cm4gaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApKSAhPT0gdW5kZWZpbmVkID9cclxuXHRcdFx0XHRyZXQgOlxyXG5cdFx0XHRcdCggZWxlbVsgbmFtZSBdID0gdmFsdWUgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkpICE9PSBudWxsID9cclxuXHRcdFx0XHRyZXQgOlxyXG5cdFx0XHRcdGVsZW1bIG5hbWUgXTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRwcm9wSG9va3M6IHtcclxuXHRcdHRhYkluZGV4OiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdFx0cmV0dXJuIGVsZW0uaGFzQXR0cmlidXRlKCBcInRhYmluZGV4XCIgKSB8fCByZm9jdXNhYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSB8fCBlbGVtLmhyZWYgP1xyXG5cdFx0XHRcdFx0ZWxlbS50YWJJbmRleCA6XHJcblx0XHRcdFx0XHQtMTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBTdXBwb3J0OiBJRTkrXHJcbi8vIFNlbGVjdGVkbmVzcyBmb3IgYW4gb3B0aW9uIGluIGFuIG9wdGdyb3VwIGNhbiBiZSBpbmFjY3VyYXRlXHJcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XHJcblx0alF1ZXJ5LnByb3BIb29rcy5zZWxlY3RlZCA9IHtcclxuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XHJcblx0XHRcdGlmICggcGFyZW50ICYmIHBhcmVudC5wYXJlbnROb2RlICkge1xyXG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxualF1ZXJ5LmVhY2goW1xyXG5cdFwidGFiSW5kZXhcIixcclxuXHRcInJlYWRPbmx5XCIsXHJcblx0XCJtYXhMZW5ndGhcIixcclxuXHRcImNlbGxTcGFjaW5nXCIsXHJcblx0XCJjZWxsUGFkZGluZ1wiLFxyXG5cdFwicm93U3BhblwiLFxyXG5cdFwiY29sU3BhblwiLFxyXG5cdFwidXNlTWFwXCIsXHJcblx0XCJmcmFtZUJvcmRlclwiLFxyXG5cdFwiY29udGVudEVkaXRhYmxlXCJcclxuXSwgZnVuY3Rpb24oKSB7XHJcblx0alF1ZXJ5LnByb3BGaXhbIHRoaXMudG9Mb3dlckNhc2UoKSBdID0gdGhpcztcclxufSk7XHJcblxyXG5cclxuXHJcblxyXG52YXIgcmNsYXNzID0gL1tcXHRcXHJcXG5cXGZdL2c7XHJcblxyXG5qUXVlcnkuZm4uZXh0ZW5kKHtcclxuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xyXG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY2xhenosIGosIGZpbmFsVmFsdWUsXHJcblx0XHRcdHByb2NlZWQgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUsXHJcblx0XHRcdGkgPSAwLFxyXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcclxuXHJcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xyXG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmFkZENsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSApICk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcHJvY2VlZCApIHtcclxuXHRcdFx0Ly8gVGhlIGRpc2p1bmN0aW9uIGhlcmUgaXMgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSByZW1vdmVDbGFzcylcclxuXHRcdFx0Y2xhc3NlcyA9ICggdmFsdWUgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcclxuXHJcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xyXG5cdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF07XHJcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIGVsZW0uY2xhc3NOYW1lID9cclxuXHRcdFx0XHRcdCggXCIgXCIgKyBlbGVtLmNsYXNzTmFtZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApIDpcclxuXHRcdFx0XHRcdFwiIFwiXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0aWYgKCBjdXIgKSB7XHJcblx0XHRcdFx0XHRqID0gMDtcclxuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcclxuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xyXG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gb25seSBhc3NpZ24gaWYgZGlmZmVyZW50IHRvIGF2b2lkIHVubmVlZGVkIHJlbmRlcmluZy5cclxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XHJcblx0XHRcdFx0XHRpZiAoIGVsZW0uY2xhc3NOYW1lICE9PSBmaW5hbFZhbHVlICkge1xyXG5cdFx0XHRcdFx0XHRlbGVtLmNsYXNzTmFtZSA9IGZpbmFsVmFsdWU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxyXG5cdFx0XHRwcm9jZWVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUsXHJcblx0XHRcdGkgPSAwLFxyXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcclxuXHJcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBqICkge1xyXG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCB0aGlzLmNsYXNzTmFtZSApICk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCBwcm9jZWVkICkge1xyXG5cdFx0XHRjbGFzc2VzID0gKCB2YWx1ZSB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XHJcblx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXTtcclxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxyXG5cdFx0XHRcdGN1ciA9IGVsZW0ubm9kZVR5cGUgPT09IDEgJiYgKCBlbGVtLmNsYXNzTmFtZSA/XHJcblx0XHRcdFx0XHQoIFwiIFwiICsgZWxlbS5jbGFzc05hbWUgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKSA6XHJcblx0XHRcdFx0XHRcIlwiXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdFx0aWYgKCBjdXIgKSB7XHJcblx0XHRcdFx0XHRqID0gMDtcclxuXHRcdFx0XHRcdHdoaWxlICggKGNsYXp6ID0gY2xhc3Nlc1tqKytdKSApIHtcclxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xyXG5cdFx0XHRcdFx0XHR3aGlsZSAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA+PSAwICkge1xyXG5cdFx0XHRcdFx0XHRcdGN1ciA9IGN1ci5yZXBsYWNlKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIsIFwiIFwiICk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyBvbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxyXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IHZhbHVlID8galF1ZXJ5LnRyaW0oIGN1ciApIDogXCJcIjtcclxuXHRcdFx0XHRcdGlmICggZWxlbS5jbGFzc05hbWUgIT09IGZpbmFsVmFsdWUgKSB7XHJcblx0XHRcdFx0XHRcdGVsZW0uY2xhc3NOYW1lID0gZmluYWxWYWx1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcclxuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xyXG5cclxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xyXG5cdFx0XHRyZXR1cm4gc3RhdGVWYWwgPyB0aGlzLmFkZENsYXNzKCB2YWx1ZSApIDogdGhpcy5yZW1vdmVDbGFzcyggdmFsdWUgKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xyXG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnRvZ2dsZUNsYXNzKCB2YWx1ZS5jYWxsKHRoaXMsIGksIHRoaXMuY2xhc3NOYW1lLCBzdGF0ZVZhbCksIHN0YXRlVmFsICk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlmICggdHlwZSA9PT0gXCJzdHJpbmdcIiApIHtcclxuXHRcdFx0XHQvLyB0b2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xyXG5cdFx0XHRcdHZhciBjbGFzc05hbWUsXHJcblx0XHRcdFx0XHRpID0gMCxcclxuXHRcdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKSxcclxuXHRcdFx0XHRcdGNsYXNzTmFtZXMgPSB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XHJcblxyXG5cdFx0XHRcdHdoaWxlICggKGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdKSApIHtcclxuXHRcdFx0XHRcdC8vIGNoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxyXG5cdFx0XHRcdFx0aWYgKCBzZWxmLmhhc0NsYXNzKCBjbGFzc05hbWUgKSApIHtcclxuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRzZWxmLmFkZENsYXNzKCBjbGFzc05hbWUgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBzdHJ1bmRlZmluZWQgfHwgdHlwZSA9PT0gXCJib29sZWFuXCIgKSB7XHJcblx0XHRcdFx0aWYgKCB0aGlzLmNsYXNzTmFtZSApIHtcclxuXHRcdFx0XHRcdC8vIHN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcclxuXHRcdFx0XHRcdGRhdGFfcHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCB0aGlzLmNsYXNzTmFtZSApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gSWYgdGhlIGVsZW1lbnQgaGFzIGEgY2xhc3MgbmFtZSBvciBpZiB3ZSdyZSBwYXNzZWQgXCJmYWxzZVwiLFxyXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXHJcblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGJyaW5nIGJhY2sgd2hhdGV2ZXIgd2FzIHByZXZpb3VzbHkgc2F2ZWQgKGlmIGFueXRoaW5nKSxcclxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXHJcblx0XHRcdFx0dGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgPyBcIlwiIDogZGF0YV9wcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIixcclxuXHRcdFx0aSA9IDAsXHJcblx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcclxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcclxuXHRcdFx0aWYgKCB0aGlzW2ldLm5vZGVUeXBlID09PSAxICYmIChcIiBcIiArIHRoaXNbaV0uY2xhc3NOYW1lICsgXCIgXCIpLnJlcGxhY2UocmNsYXNzLCBcIiBcIikuaW5kZXhPZiggY2xhc3NOYW1lICkgPj0gMCApIHtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxudmFyIHJyZXR1cm4gPSAvXFxyL2c7XHJcblxyXG5qUXVlcnkuZm4uZXh0ZW5kKHtcclxuXHR2YWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxyXG5cdFx0XHRlbGVtID0gdGhpc1swXTtcclxuXHJcblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xyXG5cdFx0XHRpZiAoIGVsZW0gKSB7XHJcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XHJcblxyXG5cdFx0XHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAocmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSkgIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRcdHJldHVybiByZXQ7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIHJldCA9PT0gXCJzdHJpbmdcIiA/XHJcblx0XHRcdFx0XHQvLyBoYW5kbGUgbW9zdCBjb21tb24gc3RyaW5nIGNhc2VzXHJcblx0XHRcdFx0XHRyZXQucmVwbGFjZShycmV0dXJuLCBcIlwiKSA6XHJcblx0XHRcdFx0XHQvLyBoYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xyXG5cdFx0XHR2YXIgdmFsO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uICkge1xyXG5cdFx0XHRcdHZhbCA9IHZhbHVlLmNhbGwoIHRoaXMsIGksIGpRdWVyeSggdGhpcyApLnZhbCgpICk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFsID0gdmFsdWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFRyZWF0IG51bGwvdW5kZWZpbmVkIGFzIFwiXCI7IGNvbnZlcnQgbnVtYmVycyB0byBzdHJpbmdcclxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcclxuXHRcdFx0XHR2YWwgPSBcIlwiO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiApIHtcclxuXHRcdFx0XHR2YWwgKz0gXCJcIjtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWwgKSApIHtcclxuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcclxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XHJcblxyXG5cdFx0XHQvLyBJZiBzZXQgcmV0dXJucyB1bmRlZmluZWQsIGZhbGwgYmFjayB0byBub3JtYWwgc2V0dGluZ1xyXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKFwic2V0XCIgaW4gaG9va3MpIHx8IGhvb2tzLnNldCggdGhpcywgdmFsLCBcInZhbHVlXCIgKSA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxufSk7XHJcblxyXG5qUXVlcnkuZXh0ZW5kKHtcclxuXHR2YWxIb29rczoge1xyXG5cdFx0b3B0aW9uOiB7XHJcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0XHRcdFx0dmFyIHZhbCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIFwidmFsdWVcIiApO1xyXG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XHJcblx0XHRcdFx0XHR2YWwgOlxyXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMC0xMStcclxuXHRcdFx0XHRcdC8vIG9wdGlvbi50ZXh0IHRocm93cyBleGNlcHRpb25zICgjMTQ2ODYsICMxNDg1OClcclxuXHRcdFx0XHRcdGpRdWVyeS50cmltKCBqUXVlcnkudGV4dCggZWxlbSApICk7XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblx0XHRzZWxlY3Q6IHtcclxuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcclxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXHJcblx0XHRcdFx0XHRpbmRleCA9IGVsZW0uc2VsZWN0ZWRJbmRleCxcclxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIgfHwgaW5kZXggPCAwLFxyXG5cdFx0XHRcdFx0dmFsdWVzID0gb25lID8gbnVsbCA6IFtdLFxyXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGgsXHJcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cclxuXHRcdFx0XHRcdFx0bWF4IDpcclxuXHRcdFx0XHRcdFx0b25lID8gaW5kZXggOiAwO1xyXG5cclxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXHJcblx0XHRcdFx0Zm9yICggOyBpIDwgbWF4OyBpKysgKSB7XHJcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gSUU2LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXHJcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcclxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXHJcblx0XHRcdFx0XHRcdFx0KCBzdXBwb3J0Lm9wdERpc2FibGVkID8gIW9wdGlvbi5kaXNhYmxlZCA6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09PSBudWxsICkgJiZcclxuXHRcdFx0XHRcdFx0XHQoICFvcHRpb24ucGFyZW50Tm9kZS5kaXNhYmxlZCB8fCAhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIEdldCB0aGUgc3BlY2lmaWMgdmFsdWUgZm9yIHRoZSBvcHRpb25cclxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gV2UgZG9uJ3QgbmVlZCBhbiBhcnJheSBmb3Igb25lIHNlbGVjdHNcclxuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBNdWx0aS1TZWxlY3RzIHJldHVybiBhbiBhcnJheVxyXG5cdFx0XHRcdFx0XHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcclxuXHRcdFx0XHR2YXIgb3B0aW9uU2V0LCBvcHRpb24sXHJcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxyXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcclxuXHRcdFx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XHJcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XHJcblx0XHRcdFx0XHRpZiAoIChvcHRpb24uc2VsZWN0ZWQgPSBqUXVlcnkuaW5BcnJheSggb3B0aW9uLnZhbHVlLCB2YWx1ZXMgKSA+PSAwKSApIHtcclxuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIGZvcmNlIGJyb3dzZXJzIHRvIGJlaGF2ZSBjb25zaXN0ZW50bHkgd2hlbiBub24tbWF0Y2hpbmcgdmFsdWUgaXMgc2V0XHJcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xyXG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcclxualF1ZXJ5LmVhY2goWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcclxuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcclxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xyXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCB2YWx1ZSApICkge1xyXG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoZWxlbSkudmFsKCksIHZhbHVlICkgPj0gMCApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XHJcblx0XHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXS5nZXQgPSBmdW5jdGlvbiggZWxlbSApIHtcclxuXHRcdFx0Ly8gU3VwcG9ydDogV2Via2l0XHJcblx0XHRcdC8vIFwiXCIgaXMgcmV0dXJuZWQgaW5zdGVhZCBvZiBcIm9uXCIgaWYgYSB2YWx1ZSBpc24ndCBzcGVjaWZpZWRcclxuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKFwidmFsdWVcIikgPT09IG51bGwgPyBcIm9uXCIgOiBlbGVtLnZhbHVlO1xyXG5cdFx0fTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxuLy8gUmV0dXJuIGpRdWVyeSBmb3IgYXR0cmlidXRlcy1vbmx5IGluY2x1c2lvblxyXG5cclxuXHJcbmpRdWVyeS5lYWNoKCAoXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXHJcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXHJcblx0XCJjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XCIpLnNwbGl0KFwiIFwiKSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XHJcblxyXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXHJcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggZGF0YSwgZm4gKSB7XHJcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xyXG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcclxuXHRcdFx0dGhpcy50cmlnZ2VyKCBuYW1lICk7XHJcblx0fTtcclxufSk7XHJcblxyXG5qUXVlcnkuZm4uZXh0ZW5kKHtcclxuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcclxuXHR9LFxyXG5cclxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xyXG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xyXG5cdH0sXHJcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xyXG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcclxuXHR9LFxyXG5cclxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xyXG5cdH0sXHJcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XHJcblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXHJcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/IHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOiB0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbnZhciBub25jZSA9IGpRdWVyeS5ub3coKTtcclxuXHJcbnZhciBycXVlcnkgPSAoL1xcPy8pO1xyXG5cclxuXHJcblxyXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xyXG4vLyBXb3JrYXJvdW5kIGZhaWx1cmUgdG8gc3RyaW5nLWNhc3QgbnVsbCBpbnB1dFxyXG5qUXVlcnkucGFyc2VKU09OID0gZnVuY3Rpb24oIGRhdGEgKSB7XHJcblx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKyBcIlwiICk7XHJcbn07XHJcblxyXG5cclxuLy8gQ3Jvc3MtYnJvd3NlciB4bWwgcGFyc2luZ1xyXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcclxuXHR2YXIgeG1sLCB0bXA7XHJcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHJcblx0Ly8gU3VwcG9ydDogSUU5XHJcblx0dHJ5IHtcclxuXHRcdHRtcCA9IG5ldyBET01QYXJzZXIoKTtcclxuXHRcdHhtbCA9IHRtcC5wYXJzZUZyb21TdHJpbmcoIGRhdGEsIFwidGV4dC94bWxcIiApO1xyXG5cdH0gY2F0Y2ggKCBlICkge1xyXG5cdFx0eG1sID0gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xyXG5cdFx0alF1ZXJ5LmVycm9yKCBcIkludmFsaWQgWE1MOiBcIiArIGRhdGEgKTtcclxuXHR9XHJcblx0cmV0dXJuIHhtbDtcclxufTtcclxuXHJcblxyXG52YXJcclxuXHQvLyBEb2N1bWVudCBsb2NhdGlvblxyXG5cdGFqYXhMb2NQYXJ0cyxcclxuXHRhamF4TG9jYXRpb24sXHJcblxyXG5cdHJoYXNoID0gLyMuKiQvLFxyXG5cdHJ0cyA9IC8oWz8mXSlfPVteJl0qLyxcclxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXHJcblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXHJcblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcclxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcclxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXHJcblx0cnVybCA9IC9eKFtcXHcuKy1dKzopKD86XFwvXFwvKD86W15cXC8/I10qQHwpKFteXFwvPyM6XSopKD86OihcXGQrKXwpfCkvLFxyXG5cclxuXHQvKiBQcmVmaWx0ZXJzXHJcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcclxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxyXG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcclxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXHJcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxyXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcclxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxyXG5cdCAqL1xyXG5cdHByZWZpbHRlcnMgPSB7fSxcclxuXHJcblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xyXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcclxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXHJcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXHJcblx0ICovXHJcblx0dHJhbnNwb3J0cyA9IHt9LFxyXG5cclxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cclxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoXCIqXCIpO1xyXG5cclxuLy8gIzgxMzgsIElFIG1heSB0aHJvdyBhbiBleGNlcHRpb24gd2hlbiBhY2Nlc3NpbmdcclxuLy8gYSBmaWVsZCBmcm9tIHdpbmRvdy5sb2NhdGlvbiBpZiBkb2N1bWVudC5kb21haW4gaGFzIGJlZW4gc2V0XHJcbnRyeSB7XHJcblx0YWpheExvY2F0aW9uID0gbG9jYXRpb24uaHJlZjtcclxufSBjYXRjaCggZSApIHtcclxuXHQvLyBVc2UgdGhlIGhyZWYgYXR0cmlidXRlIG9mIGFuIEEgZWxlbWVudFxyXG5cdC8vIHNpbmNlIElFIHdpbGwgbW9kaWZ5IGl0IGdpdmVuIGRvY3VtZW50LmxvY2F0aW9uXHJcblx0YWpheExvY2F0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcclxuXHRhamF4TG9jYXRpb24uaHJlZiA9IFwiXCI7XHJcblx0YWpheExvY2F0aW9uID0gYWpheExvY2F0aW9uLmhyZWY7XHJcbn1cclxuXHJcbi8vIFNlZ21lbnQgbG9jYXRpb24gaW50byBwYXJ0c1xyXG5hamF4TG9jUGFydHMgPSBydXJsLmV4ZWMoIGFqYXhMb2NhdGlvbi50b0xvd2VyQ2FzZSgpICkgfHwgW107XHJcblxyXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XHJcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xyXG5cclxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXHJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XHJcblxyXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xyXG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xyXG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YVR5cGUsXHJcblx0XHRcdGkgPSAwLFxyXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XHJcblxyXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggZnVuYyApICkge1xyXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXHJcblx0XHRcdHdoaWxlICggKGRhdGFUeXBlID0gZGF0YVR5cGVzW2krK10pICkge1xyXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXHJcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVswXSA9PT0gXCIrXCIgKSB7XHJcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XHJcblx0XHRcdFx0XHQoc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdKS51bnNoaWZ0KCBmdW5jICk7XHJcblxyXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0KHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSkucHVzaCggZnVuYyApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xyXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xyXG5cclxuXHR2YXIgaW5zcGVjdGVkID0ge30sXHJcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcclxuXHJcblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XHJcblx0XHR2YXIgc2VsZWN0ZWQ7XHJcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xyXG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcclxuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcclxuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJiAhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XHJcblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xyXG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XHJcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiBzZWxlY3RlZDtcclxuXHR9XHJcblxyXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xyXG59XHJcblxyXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcclxuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcclxuLy8gRml4ZXMgIzk4ODdcclxuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XHJcblx0dmFyIGtleSwgZGVlcCxcclxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcclxuXHJcblx0Zm9yICgga2V5IGluIHNyYyApIHtcclxuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoZGVlcCA9IHt9KSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKCBkZWVwICkge1xyXG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGFyZ2V0O1xyXG59XHJcblxyXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XHJcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXHJcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxyXG4gKi9cclxuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcclxuXHJcblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxyXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxyXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XHJcblxyXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXHJcblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XHJcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcclxuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXHJcblx0aWYgKCBjdCApIHtcclxuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XHJcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XHJcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXHJcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XHJcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcclxuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xyXG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1swXSBdICkge1xyXG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XHJcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxyXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcclxuXHR9XHJcblxyXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcclxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxyXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcclxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XHJcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xyXG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xyXG5cdH1cclxufVxyXG5cclxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxyXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcclxuICovXHJcbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcclxuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcclxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcclxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cclxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XHJcblxyXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xyXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XHJcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcclxuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcclxuXHJcblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcclxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XHJcblxyXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XHJcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXHJcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XHJcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHByZXYgPSBjdXJyZW50O1xyXG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xyXG5cclxuXHRcdGlmICggY3VycmVudCApIHtcclxuXHJcblx0XHQvLyBUaGVyZSdzIG9ubHkgd29yayB0byBkbyBpZiBjdXJyZW50IGRhdGFUeXBlIGlzIG5vbi1hdXRvXHJcblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XHJcblxyXG5cdFx0XHRcdGN1cnJlbnQgPSBwcmV2O1xyXG5cclxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxyXG5cdFx0XHR9IGVsc2UgaWYgKCBwcmV2ICE9PSBcIipcIiAmJiBwcmV2ICE9PSBjdXJyZW50ICkge1xyXG5cclxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxyXG5cdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBwcmV2ICsgXCIgXCIgKyBjdXJyZW50IF0gfHwgY29udmVydGVyc1sgXCIqIFwiICsgY3VycmVudCBdO1xyXG5cclxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxyXG5cdFx0XHRcdGlmICggIWNvbnYgKSB7XHJcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gSWYgY29udjIgb3V0cHV0cyBjdXJyZW50XHJcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xyXG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcclxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1sgXCIqIFwiICsgdG1wWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXHJcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGNvbnYgPSBjb252ZXJ0ZXJzWyBjb252MiBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcclxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnZlcnRlcnNbIGNvbnYyIF0gIT09IHRydWUgKSB7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxyXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXHJcblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgc1sgXCJ0aHJvd3NcIiBdICkge1xyXG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcclxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHsgc3RhdGU6IFwicGFyc2VyZXJyb3JcIiwgZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50IH07XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcclxufVxyXG5cclxualF1ZXJ5LmV4dGVuZCh7XHJcblxyXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xyXG5cdGFjdGl2ZTogMCxcclxuXHJcblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxyXG5cdGxhc3RNb2RpZmllZDoge30sXHJcblx0ZXRhZzoge30sXHJcblxyXG5cdGFqYXhTZXR0aW5nczoge1xyXG5cdFx0dXJsOiBhamF4TG9jYXRpb24sXHJcblx0XHR0eXBlOiBcIkdFVFwiLFxyXG5cdFx0aXNMb2NhbDogcmxvY2FsUHJvdG9jb2wudGVzdCggYWpheExvY1BhcnRzWyAxIF0gKSxcclxuXHRcdGdsb2JhbDogdHJ1ZSxcclxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxyXG5cdFx0YXN5bmM6IHRydWUsXHJcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcclxuXHRcdC8qXHJcblx0XHR0aW1lb3V0OiAwLFxyXG5cdFx0ZGF0YTogbnVsbCxcclxuXHRcdGRhdGFUeXBlOiBudWxsLFxyXG5cdFx0dXNlcm5hbWU6IG51bGwsXHJcblx0XHRwYXNzd29yZDogbnVsbCxcclxuXHRcdGNhY2hlOiBudWxsLFxyXG5cdFx0dGhyb3dzOiBmYWxzZSxcclxuXHRcdHRyYWRpdGlvbmFsOiBmYWxzZSxcclxuXHRcdGhlYWRlcnM6IHt9LFxyXG5cdFx0Ki9cclxuXHJcblx0XHRhY2NlcHRzOiB7XHJcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcclxuXHRcdFx0dGV4dDogXCJ0ZXh0L3BsYWluXCIsXHJcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXHJcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXHJcblx0XHRcdGpzb246IFwiYXBwbGljYXRpb24vanNvbiwgdGV4dC9qYXZhc2NyaXB0XCJcclxuXHRcdH0sXHJcblxyXG5cdFx0Y29udGVudHM6IHtcclxuXHRcdFx0eG1sOiAveG1sLyxcclxuXHRcdFx0aHRtbDogL2h0bWwvLFxyXG5cdFx0XHRqc29uOiAvanNvbi9cclxuXHRcdH0sXHJcblxyXG5cdFx0cmVzcG9uc2VGaWVsZHM6IHtcclxuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXHJcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXHJcblx0XHRcdGpzb246IFwicmVzcG9uc2VKU09OXCJcclxuXHRcdH0sXHJcblxyXG5cdFx0Ly8gRGF0YSBjb252ZXJ0ZXJzXHJcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXHJcblx0XHRjb252ZXJ0ZXJzOiB7XHJcblxyXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcclxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxyXG5cclxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXHJcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXHJcblxyXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXHJcblx0XHRcdFwidGV4dCBqc29uXCI6IGpRdWVyeS5wYXJzZUpTT04sXHJcblxyXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxyXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxyXG5cdFx0Ly8geW91IGNhbiBhZGQgeW91ciBvd24gY3VzdG9tIG9wdGlvbnMgaGVyZSBpZlxyXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcclxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxyXG5cdFx0ZmxhdE9wdGlvbnM6IHtcclxuXHRcdFx0dXJsOiB0cnVlLFxyXG5cdFx0XHRjb250ZXh0OiB0cnVlXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gQ3JlYXRlcyBhIGZ1bGwgZmxlZGdlZCBzZXR0aW5ncyBvYmplY3QgaW50byB0YXJnZXRcclxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXHJcblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cclxuXHRhamF4U2V0dXA6IGZ1bmN0aW9uKCB0YXJnZXQsIHNldHRpbmdzICkge1xyXG5cdFx0cmV0dXJuIHNldHRpbmdzID9cclxuXHJcblx0XHRcdC8vIEJ1aWxkaW5nIGEgc2V0dGluZ3Mgb2JqZWN0XHJcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcclxuXHJcblx0XHRcdC8vIEV4dGVuZGluZyBhamF4U2V0dGluZ3NcclxuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XHJcblx0fSxcclxuXHJcblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXHJcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXHJcblxyXG5cdC8vIE1haW4gbWV0aG9kXHJcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcclxuXHJcblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxyXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xyXG5cdFx0XHRvcHRpb25zID0gdXJsO1xyXG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3RcclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cclxuXHRcdHZhciB0cmFuc3BvcnQsXHJcblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cclxuXHRcdFx0Y2FjaGVVUkwsXHJcblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcclxuXHRcdFx0cmVzcG9uc2VIZWFkZXJzU3RyaW5nLFxyXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXHJcblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXHJcblx0XHRcdHRpbWVvdXRUaW1lcixcclxuXHRcdFx0Ly8gQ3Jvc3MtZG9tYWluIGRldGVjdGlvbiB2YXJzXHJcblx0XHRcdHBhcnRzLFxyXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcclxuXHRcdFx0ZmlyZUdsb2JhbHMsXHJcblx0XHRcdC8vIExvb3AgdmFyaWFibGVcclxuXHRcdFx0aSxcclxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxyXG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcclxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcclxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXHJcblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cclxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmICggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XHJcblx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XHJcblx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxyXG5cdFx0XHQvLyBEZWZlcnJlZHNcclxuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcclxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoXCJvbmNlIG1lbW9yeVwiKSxcclxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcclxuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcclxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcclxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcclxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxyXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcclxuXHRcdFx0c3RhdGUgPSAwLFxyXG5cdFx0XHQvLyBEZWZhdWx0IGFib3J0IG1lc3NhZ2VcclxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXHJcblx0XHRcdC8vIEZha2UgeGhyXHJcblx0XHRcdGpxWEhSID0ge1xyXG5cdFx0XHRcdHJlYWR5U3RhdGU6IDAsXHJcblxyXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcclxuXHRcdFx0XHRnZXRSZXNwb25zZUhlYWRlcjogZnVuY3Rpb24oIGtleSApIHtcclxuXHRcdFx0XHRcdHZhciBtYXRjaDtcclxuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XHJcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcclxuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcclxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApKSApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSBdID0gbWF0Y2hbIDIgXTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0bWF0Y2ggPSByZXNwb25zZUhlYWRlcnNbIGtleS50b0xvd2VyQ2FzZSgpIF07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaDtcclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXHJcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XHJcblx0XHRcdFx0XHR2YXIgbG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XHJcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcclxuXHRcdFx0XHRcdFx0bmFtZSA9IHJlcXVlc3RIZWFkZXJzTmFtZXNbIGxuYW1lIF0gPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdIHx8IG5hbWU7XHJcblx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzWyBuYW1lIF0gPSB2YWx1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0XHRcdH0sXHJcblxyXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXHJcblx0XHRcdFx0b3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24oIHR5cGUgKSB7XHJcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcclxuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0XHR9LFxyXG5cclxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xyXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XHJcblx0XHRcdFx0XHR2YXIgY29kZTtcclxuXHRcdFx0XHRcdGlmICggbWFwICkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcclxuXHRcdFx0XHRcdFx0XHRmb3IgKCBjb2RlIGluIG1hcCApIHtcclxuXHRcdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2sgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcclxuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3NcclxuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdFx0fSxcclxuXHJcblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XHJcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBzdGF0dXNUZXh0ICkge1xyXG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XHJcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcclxuXHRcdFx0XHRcdFx0dHJhbnNwb3J0LmFib3J0KCBmaW5hbFRleHQgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcclxuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcclxuXHRcdGpxWEhSLnN1Y2Nlc3MgPSBqcVhIUi5kb25lO1xyXG5cdFx0anFYSFIuZXJyb3IgPSBqcVhIUi5mYWlsO1xyXG5cclxuXHRcdC8vIFJlbW92ZSBoYXNoIGNoYXJhY3RlciAoIzc1MzE6IGFuZCBzdHJpbmcgcHJvbW90aW9uKVxyXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXHJcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxyXG5cdFx0Ly8gV2UgYWxzbyB1c2UgdGhlIHVybCBwYXJhbWV0ZXIgaWYgYXZhaWxhYmxlXHJcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgYWpheExvY2F0aW9uICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKVxyXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBhamF4TG9jUGFydHNbIDEgXSArIFwiLy9cIiApO1xyXG5cclxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxyXG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcclxuXHJcblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XHJcblx0XHRzLmRhdGFUeXBlcyA9IGpRdWVyeS50cmltKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgWyBcIlwiIF07XHJcblxyXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHdlIGhhdmUgYSBwcm90b2NvbDpob3N0OnBvcnQgbWlzbWF0Y2hcclxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xyXG5cdFx0XHRwYXJ0cyA9IHJ1cmwuZXhlYyggcy51cmwudG9Mb3dlckNhc2UoKSApO1xyXG5cdFx0XHRzLmNyb3NzRG9tYWluID0gISEoIHBhcnRzICYmXHJcblx0XHRcdFx0KCBwYXJ0c1sgMSBdICE9PSBhamF4TG9jUGFydHNbIDEgXSB8fCBwYXJ0c1sgMiBdICE9PSBhamF4TG9jUGFydHNbIDIgXSB8fFxyXG5cdFx0XHRcdFx0KCBwYXJ0c1sgMyBdIHx8ICggcGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgIT09XHJcblx0XHRcdFx0XHRcdCggYWpheExvY1BhcnRzWyAzIF0gfHwgKCBhamF4TG9jUGFydHNbIDEgXSA9PT0gXCJodHRwOlwiID8gXCI4MFwiIDogXCI0NDNcIiApICkgKVxyXG5cdFx0XHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xyXG5cdFx0aWYgKCBzLmRhdGEgJiYgcy5wcm9jZXNzRGF0YSAmJiB0eXBlb2Ygcy5kYXRhICE9PSBcInN0cmluZ1wiICkge1xyXG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcclxuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xyXG5cclxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXHJcblx0XHRpZiAoIHN0YXRlID09PSAyICkge1xyXG5cdFx0XHRyZXR1cm4ganFYSFI7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cclxuXHRcdGZpcmVHbG9iYWxzID0gcy5nbG9iYWw7XHJcblxyXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xyXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XHJcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKFwiYWpheFN0YXJ0XCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxyXG5cdFx0cy50eXBlID0gcy50eXBlLnRvVXBwZXJDYXNlKCk7XHJcblxyXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcclxuXHRcdHMuaGFzQ29udGVudCA9ICFybm9Db250ZW50LnRlc3QoIHMudHlwZSApO1xyXG5cclxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxyXG5cdFx0Ly8gYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyIGxhdGVyIG9uXHJcblx0XHRjYWNoZVVSTCA9IHMudXJsO1xyXG5cclxuXHRcdC8vIE1vcmUgb3B0aW9ucyBoYW5kbGluZyBmb3IgcmVxdWVzdHMgd2l0aCBubyBjb250ZW50XHJcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XHJcblxyXG5cdFx0XHQvLyBJZiBkYXRhIGlzIGF2YWlsYWJsZSwgYXBwZW5kIGRhdGEgdG8gdXJsXHJcblx0XHRcdGlmICggcy5kYXRhICkge1xyXG5cdFx0XHRcdGNhY2hlVVJMID0gKCBzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhICk7XHJcblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxyXG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFkZCBhbnRpLWNhY2hlIGluIHVybCBpZiBuZWVkZWRcclxuXHRcdFx0aWYgKCBzLmNhY2hlID09PSBmYWxzZSApIHtcclxuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cclxuXHJcblx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgJ18nIHBhcmFtZXRlciwgc2V0IGl0cyB2YWx1ZVxyXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XHJcblxyXG5cdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFkZCBvbmUgdG8gdGhlIGVuZFxyXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXHJcblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcclxuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xyXG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTW9kaWZpZWQtU2luY2VcIiwgalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XHJcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Ob25lLU1hdGNoXCIsIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcclxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xyXG5cdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiLCBzLmNvbnRlbnRUeXBlICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0IHRoZSBBY2NlcHRzIGhlYWRlciBmb3IgdGhlIHNlcnZlciwgZGVwZW5kaW5nIG9uIHRoZSBkYXRhVHlwZVxyXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcclxuXHRcdFx0XCJBY2NlcHRcIixcclxuXHRcdFx0cy5kYXRhVHlwZXNbIDAgXSAmJiBzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWzBdIF0gP1xyXG5cdFx0XHRcdHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbMF0gXSArICggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XHJcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXHJcblx0XHQpO1xyXG5cclxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxyXG5cdFx0Zm9yICggaSBpbiBzLmhlYWRlcnMgKSB7XHJcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxyXG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiYgKCBzLmJlZm9yZVNlbmQuY2FsbCggY2FsbGJhY2tDb250ZXh0LCBqcVhIUiwgcyApID09PSBmYWxzZSB8fCBzdGF0ZSA9PT0gMiApICkge1xyXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cclxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gYWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXHJcblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcclxuXHJcblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcclxuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcclxuXHRcdFx0anFYSFJbIGkgXSggc1sgaSBdICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gR2V0IHRyYW5zcG9ydFxyXG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XHJcblxyXG5cdFx0Ly8gSWYgbm8gdHJhbnNwb3J0LCB3ZSBhdXRvLWFib3J0XHJcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XHJcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcclxuXHJcblx0XHRcdC8vIFNlbmQgZ2xvYmFsIGV2ZW50XHJcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XHJcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gVGltZW91dFxyXG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcclxuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoXCJ0aW1lb3V0XCIpO1xyXG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdHN0YXRlID0gMTtcclxuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcclxuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XHJcblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxyXG5cdFx0XHRcdGlmICggc3RhdGUgPCAyICkge1xyXG5cdFx0XHRcdFx0ZG9uZSggLTEsIGUgKTtcclxuXHRcdFx0XHQvLyBTaW1wbHkgcmV0aHJvdyBvdGhlcndpc2VcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhyb3cgZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcclxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xyXG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxyXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xyXG5cclxuXHRcdFx0Ly8gQ2FsbGVkIG9uY2VcclxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFN0YXRlIGlzIFwiZG9uZVwiIG5vd1xyXG5cdFx0XHRzdGF0ZSA9IDI7XHJcblxyXG5cdFx0XHQvLyBDbGVhciB0aW1lb3V0IGlmIGl0IGV4aXN0c1xyXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQoIHRpbWVvdXRUaW1lciApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBEZXJlZmVyZW5jZSB0cmFuc3BvcnQgZm9yIGVhcmx5IGdhcmJhZ2UgY29sbGVjdGlvblxyXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxyXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXHJcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcclxuXHJcblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXHJcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XHJcblxyXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxyXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcclxuXHJcblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXHJcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xyXG5cdFx0XHRcdHJlc3BvbnNlID0gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBDb252ZXJ0IG5vIG1hdHRlciB3aGF0ICh0aGF0IHdheSByZXNwb25zZVhYWCBmaWVsZHMgYXJlIGFsd2F5cyBzZXQpXHJcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XHJcblxyXG5cdFx0XHQvLyBJZiBzdWNjZXNzZnVsLCBoYW5kbGUgdHlwZSBjaGFpbmluZ1xyXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcclxuXHJcblx0XHRcdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cclxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcclxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMYXN0LU1vZGlmaWVkXCIpO1xyXG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcclxuXHRcdFx0XHRcdFx0alF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlcihcImV0YWdcIik7XHJcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xyXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSA9IG1vZGlmaWVkO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxyXG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcclxuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vY29udGVudFwiO1xyXG5cclxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdGF0dXMgPT09IDMwNCApIHtcclxuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XHJcblxyXG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgZGF0YSwgbGV0J3MgY29udmVydCBpdFxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XHJcblx0XHRcdFx0XHRzdWNjZXNzID0gcmVzcG9uc2UuZGF0YTtcclxuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XHJcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8vIFdlIGV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0XHJcblx0XHRcdFx0Ly8gdGhlbiBub3JtYWxpemUgc3RhdHVzVGV4dCBhbmQgc3RhdHVzIGZvciBub24tYWJvcnRzXHJcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xyXG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xyXG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwiZXJyb3JcIjtcclxuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcclxuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XHJcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcclxuXHRcdFx0anFYSFIuc3RhdHVzVGV4dCA9ICggbmF0aXZlU3RhdHVzVGV4dCB8fCBzdGF0dXNUZXh0ICkgKyBcIlwiO1xyXG5cclxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxyXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcclxuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsganFYSFIsIHN0YXR1c1RleHQsIGVycm9yIF0gKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3NcclxuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xyXG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcclxuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcclxuXHRcdFx0XHRcdFsganFYSFIsIHMsIGlzU3VjY2VzcyA/IHN1Y2Nlc3MgOiBlcnJvciBdICk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIENvbXBsZXRlXHJcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XHJcblxyXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xyXG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcclxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xyXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoXCJhamF4U3RvcFwiKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ganFYSFI7XHJcblx0fSxcclxuXHJcblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XHJcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcclxuXHR9LFxyXG5cclxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xyXG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgdW5kZWZpbmVkLCBjYWxsYmFjaywgXCJzY3JpcHRcIiApO1xyXG5cdH1cclxufSk7XHJcblxyXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xyXG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcclxuXHRcdC8vIHNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXHJcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBkYXRhICkgKSB7XHJcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xyXG5cdFx0XHRjYWxsYmFjayA9IGRhdGE7XHJcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KHtcclxuXHRcdFx0dXJsOiB1cmwsXHJcblx0XHRcdHR5cGU6IG1ldGhvZCxcclxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXHJcblx0XHRcdGRhdGE6IGRhdGEsXHJcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXHJcblx0XHR9KTtcclxuXHR9O1xyXG59KTtcclxuXHJcbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXHJcbmpRdWVyeS5lYWNoKCBbIFwiYWpheFN0YXJ0XCIsIFwiYWpheFN0b3BcIiwgXCJhamF4Q29tcGxldGVcIiwgXCJhamF4RXJyb3JcIiwgXCJhamF4U3VjY2Vzc1wiLCBcImFqYXhTZW5kXCIgXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XHJcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcclxuXHR9O1xyXG59KTtcclxuXHJcblxyXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xyXG5cdHJldHVybiBqUXVlcnkuYWpheCh7XHJcblx0XHR1cmw6IHVybCxcclxuXHRcdHR5cGU6IFwiR0VUXCIsXHJcblx0XHRkYXRhVHlwZTogXCJzY3JpcHRcIixcclxuXHRcdGFzeW5jOiBmYWxzZSxcclxuXHRcdGdsb2JhbDogZmFsc2UsXHJcblx0XHRcInRocm93c1wiOiB0cnVlXHJcblx0fSk7XHJcbn07XHJcblxyXG5cclxualF1ZXJ5LmZuLmV4dGVuZCh7XHJcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XHJcblx0XHR2YXIgd3JhcDtcclxuXHJcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XHJcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKHRoaXMsIGkpICk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpc1sgMCBdICkge1xyXG5cclxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcclxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xyXG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0d3JhcC5tYXAoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xyXG5cclxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XHJcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJldHVybiBlbGVtO1xyXG5cdFx0XHR9KS5hcHBlbmQoIHRoaXMgKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xyXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCBpICkge1xyXG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKHRoaXMsIGkpICk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXHJcblx0XHRcdFx0Y29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCk7XHJcblxyXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcclxuXHRcdFx0XHRjb250ZW50cy53cmFwQWxsKCBodG1sICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHNlbGYuYXBwZW5kKCBodG1sICk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdHdyYXA6IGZ1bmN0aW9uKCBodG1sICkge1xyXG5cdFx0dmFyIGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XHJcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwodGhpcywgaSkgOiBodG1sICk7XHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHR1bndyYXA6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMucGFyZW50KCkuZWFjaChmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImJvZHlcIiApICkge1xyXG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcclxuXHRcdFx0fVxyXG5cdFx0fSkuZW5kKCk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG5qUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdC8vIFN1cHBvcnQ6IE9wZXJhIDw9IDEyLjEyXHJcblx0Ly8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xyXG5cdHJldHVybiBlbGVtLm9mZnNldFdpZHRoIDw9IDAgJiYgZWxlbS5vZmZzZXRIZWlnaHQgPD0gMDtcclxufTtcclxualF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XHJcblx0cmV0dXJuICFqUXVlcnkuZXhwci5maWx0ZXJzLmhpZGRlbiggZWxlbSApO1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxudmFyIHIyMCA9IC8lMjAvZyxcclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcclxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXHJcblx0cnN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pLFxyXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcclxuXHJcbmZ1bmN0aW9uIGJ1aWxkUGFyYW1zKCBwcmVmaXgsIG9iaiwgdHJhZGl0aW9uYWwsIGFkZCApIHtcclxuXHR2YXIgbmFtZTtcclxuXHJcblx0aWYgKCBqUXVlcnkuaXNBcnJheSggb2JqICkgKSB7XHJcblx0XHQvLyBTZXJpYWxpemUgYXJyYXkgaXRlbS5cclxuXHRcdGpRdWVyeS5lYWNoKCBvYmosIGZ1bmN0aW9uKCBpLCB2ICkge1xyXG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xyXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cclxuXHRcdFx0XHRhZGQoIHByZWZpeCwgdiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cclxuXHRcdFx0XHRidWlsZFBhcmFtcyggcHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiID8gaSA6IFwiXCIgKSArIFwiXVwiLCB2LCB0cmFkaXRpb25hbCwgYWRkICk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xyXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxyXG5cdFx0Zm9yICggbmFtZSBpbiBvYmogKSB7XHJcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cclxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcclxuXHR9XHJcbn1cclxuXHJcbi8vIFNlcmlhbGl6ZSBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzIG9yIGEgc2V0IG9mXHJcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xyXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XHJcblx0dmFyIHByZWZpeCxcclxuXHRcdHMgPSBbXSxcclxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xyXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcclxuXHRcdFx0dmFsdWUgPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSA/IHZhbHVlKCkgOiAoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcclxuXHRcdFx0c1sgcy5sZW5ndGggXSA9IGVuY29kZVVSSUNvbXBvbmVudCgga2V5ICkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudCggdmFsdWUgKTtcclxuXHRcdH07XHJcblxyXG5cdC8vIFNldCB0cmFkaXRpb25hbCB0byB0cnVlIGZvciBqUXVlcnkgPD0gMS4zLjIgYmVoYXZpb3IuXHJcblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0dHJhZGl0aW9uYWwgPSBqUXVlcnkuYWpheFNldHRpbmdzICYmIGpRdWVyeS5hamF4U2V0dGluZ3MudHJhZGl0aW9uYWw7XHJcblx0fVxyXG5cclxuXHQvLyBJZiBhbiBhcnJheSB3YXMgcGFzc2VkIGluLCBhc3N1bWUgdGhhdCBpdCBpcyBhbiBhcnJheSBvZiBmb3JtIGVsZW1lbnRzLlxyXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIGEgKSB8fCAoIGEuanF1ZXJ5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggYSApICkgKSB7XHJcblx0XHQvLyBTZXJpYWxpemUgdGhlIGZvcm0gZWxlbWVudHNcclxuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcclxuXHRcdH0pO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cdFx0Ly8gSWYgdHJhZGl0aW9uYWwsIGVuY29kZSB0aGUgXCJvbGRcIiB3YXkgKHRoZSB3YXkgMS4zLjIgb3Igb2xkZXJcclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxyXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XHJcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXgsIGFbIHByZWZpeCBdLCB0cmFkaXRpb25hbCwgYWRkICk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXHJcblx0cmV0dXJuIHMuam9pbiggXCImXCIgKS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XHJcbn07XHJcblxyXG5qUXVlcnkuZm4uZXh0ZW5kKHtcclxuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIGpRdWVyeS5wYXJhbSggdGhpcy5zZXJpYWxpemVBcnJheSgpICk7XHJcblx0fSxcclxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oKSB7XHJcblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcclxuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xyXG5cdFx0XHRyZXR1cm4gZWxlbWVudHMgPyBqUXVlcnkubWFrZUFycmF5KCBlbGVtZW50cyApIDogdGhpcztcclxuXHRcdH0pXHJcblx0XHQuZmlsdGVyKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcclxuXHJcblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXHJcblx0XHRcdFx0cnN1Ym1pdHRhYmxlLnRlc3QoIHRoaXMubm9kZU5hbWUgKSAmJiAhcnN1Ym1pdHRlclR5cGVzLnRlc3QoIHR5cGUgKSAmJlxyXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcclxuXHRcdH0pXHJcblx0XHQubWFwKGZ1bmN0aW9uKCBpLCBlbGVtICkge1xyXG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xyXG5cdFx0XHRcdG51bGwgOlxyXG5cdFx0XHRcdGpRdWVyeS5pc0FycmF5KCB2YWwgKSA/XHJcblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XHJcblx0XHRcdFx0XHR9KSA6XHJcblx0XHRcdFx0XHR7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XHJcblx0XHR9KS5nZXQoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XHJcblx0dHJ5IHtcclxuXHRcdHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHR9IGNhdGNoKCBlICkge31cclxufTtcclxuXHJcbnZhciB4aHJJZCA9IDAsXHJcblx0eGhyQ2FsbGJhY2tzID0ge30sXHJcblx0eGhyU3VjY2Vzc1N0YXR1cyA9IHtcclxuXHRcdC8vIGZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXHJcblx0XHQwOiAyMDAsXHJcblx0XHQvLyBTdXBwb3J0OiBJRTlcclxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxyXG5cdFx0MTIyMzogMjA0XHJcblx0fSxcclxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xyXG5cclxuLy8gU3VwcG9ydDogSUU5XHJcbi8vIE9wZW4gcmVxdWVzdHMgbXVzdCBiZSBtYW51YWxseSBhYm9ydGVkIG9uIHVubG9hZCAoIzUyODApXHJcbmlmICggd2luZG93LkFjdGl2ZVhPYmplY3QgKSB7XHJcblx0alF1ZXJ5KCB3aW5kb3cgKS5vbiggXCJ1bmxvYWRcIiwgZnVuY3Rpb24oKSB7XHJcblx0XHRmb3IgKCB2YXIga2V5IGluIHhockNhbGxiYWNrcyApIHtcclxuXHRcdFx0eGhyQ2FsbGJhY2tzWyBrZXkgXSgpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcblxyXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XHJcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xyXG5cclxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24oIG9wdGlvbnMgKSB7XHJcblx0dmFyIGNhbGxiYWNrO1xyXG5cclxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XHJcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xyXG5cdFx0XHRcdHZhciBpLFxyXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKSxcclxuXHRcdFx0XHRcdGlkID0gKyt4aHJJZDtcclxuXHJcblx0XHRcdFx0eGhyLm9wZW4oIG9wdGlvbnMudHlwZSwgb3B0aW9ucy51cmwsIG9wdGlvbnMuYXN5bmMsIG9wdGlvbnMudXNlcm5hbWUsIG9wdGlvbnMucGFzc3dvcmQgKTtcclxuXHJcblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxyXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XHJcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xyXG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXHJcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xyXG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXHJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxyXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXHJcblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXHJcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXHJcblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1tcIlgtUmVxdWVzdGVkLVdpdGhcIl0gKSB7XHJcblx0XHRcdFx0XHRoZWFkZXJzW1wiWC1SZXF1ZXN0ZWQtV2l0aFwiXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXHJcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xyXG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gQ2FsbGJhY2tcclxuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xyXG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSB4aHJDYWxsYmFja3NbIGlkIF07XHJcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSB4aHIub25sb2FkID0geGhyLm9uZXJyb3IgPSBudWxsO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcclxuXHRcdFx0XHRcdFx0XHRcdHhoci5hYm9ydCgpO1xyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcclxuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBmaWxlOiBwcm90b2NvbCBhbHdheXMgeWllbGRzIHN0YXR1cyAwOyBzZWUgIzg2MDUsICMxNDIwN1xyXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dFxyXG5cdFx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXHJcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5XHJcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEFjY2Vzc2luZyBiaW5hcnktZGF0YSByZXNwb25zZVRleHQgdGhyb3dzIGFuIGV4Y2VwdGlvblxyXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyAoIzExNDI2KVxyXG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCA9PT0gXCJzdHJpbmdcIiA/IHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ZXh0OiB4aHIucmVzcG9uc2VUZXh0XHJcblx0XHRcdFx0XHRcdFx0XHRcdH0gOiB1bmRlZmluZWQsXHJcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxyXG5cdFx0XHRcdFx0XHRcdFx0KTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH07XHJcblx0XHRcdFx0fTtcclxuXHJcblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xyXG5cdFx0XHRcdHhoci5vbmxvYWQgPSBjYWxsYmFjaygpO1xyXG5cdFx0XHRcdHhoci5vbmVycm9yID0gY2FsbGJhY2soXCJlcnJvclwiKTtcclxuXHJcblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xyXG5cdFx0XHRcdGNhbGxiYWNrID0geGhyQ2FsbGJhY2tzWyBpZCBdID0gY2FsbGJhY2soXCJhYm9ydFwiKTtcclxuXHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdC8vIERvIHNlbmQgdGhlIHJlcXVlc3QgKHRoaXMgbWF5IHJhaXNlIGFuIGV4Y2VwdGlvbilcclxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcclxuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcclxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XHJcblx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG5cclxuXHJcbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXHJcbmpRdWVyeS5hamF4U2V0dXAoe1xyXG5cdGFjY2VwdHM6IHtcclxuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXHJcblx0fSxcclxuXHRjb250ZW50czoge1xyXG5cdFx0c2NyaXB0OiAvKD86amF2YXxlY21hKXNjcmlwdC9cclxuXHR9LFxyXG5cdGNvbnZlcnRlcnM6IHtcclxuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XHJcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XHJcblx0XHRcdHJldHVybiB0ZXh0O1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG4vLyBIYW5kbGUgY2FjaGUncyBzcGVjaWFsIGNhc2UgYW5kIGNyb3NzRG9tYWluXHJcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcclxuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHRcdHMuY2FjaGUgPSBmYWxzZTtcclxuXHR9XHJcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xyXG5cdFx0cy50eXBlID0gXCJHRVRcIjtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XHJcbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcclxuXHQvLyBUaGlzIHRyYW5zcG9ydCBvbmx5IGRlYWxzIHdpdGggY3Jvc3MgZG9tYWluIHJlcXVlc3RzXHJcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xyXG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XHJcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KFwiPHNjcmlwdD5cIikucHJvcCh7XHJcblx0XHRcdFx0XHRhc3luYzogdHJ1ZSxcclxuXHRcdFx0XHRcdGNoYXJzZXQ6IHMuc2NyaXB0Q2hhcnNldCxcclxuXHRcdFx0XHRcdHNyYzogcy51cmxcclxuXHRcdFx0XHR9KS5vbihcclxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxyXG5cdFx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xyXG5cdFx0XHRcdFx0XHRzY3JpcHQucmVtb3ZlKCk7XHJcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcclxuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XHJcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIGV2dC50eXBlID09PSBcImVycm9yXCIgPyA0MDQgOiAyMDAsIGV2dC50eXBlICk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHQpO1xyXG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XHJcblx0XHRcdH0sXHJcblx0XHRcdGFib3J0OiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG5cclxuXHJcbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcclxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xyXG5cclxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xyXG5qUXVlcnkuYWpheFNldHVwKHtcclxuXHRqc29ucDogXCJjYWxsYmFja1wiLFxyXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGNhbGxiYWNrID0gb2xkQ2FsbGJhY2tzLnBvcCgpIHx8ICggalF1ZXJ5LmV4cGFuZG8gKyBcIl9cIiArICggbm9uY2UrKyApICk7XHJcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcclxuXHRcdHJldHVybiBjYWxsYmFjaztcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXHJcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcImpzb24ganNvbnBcIiwgZnVuY3Rpb24oIHMsIG9yaWdpbmFsU2V0dGluZ3MsIGpxWEhSICkge1xyXG5cclxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXHJcblx0XHRqc29uUHJvcCA9IHMuanNvbnAgIT09IGZhbHNlICYmICggcmpzb25wLnRlc3QoIHMudXJsICkgP1xyXG5cdFx0XHRcInVybFwiIDpcclxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiAhKCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKS5pbmRleE9mKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpICYmIHJqc29ucC50ZXN0KCBzLmRhdGEgKSAmJiBcImRhdGFcIlxyXG5cdFx0KTtcclxuXHJcblx0Ly8gSGFuZGxlIGlmZiB0aGUgZXhwZWN0ZWQgZGF0YSB0eXBlIGlzIFwianNvbnBcIiBvciB3ZSBoYXZlIGEgcGFyYW1ldGVyIHRvIHNldFxyXG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xyXG5cclxuXHRcdC8vIEdldCBjYWxsYmFjayBuYW1lLCByZW1lbWJlcmluZyBwcmVleGlzdGluZyB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggaXRcclxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBzLmpzb25wQ2FsbGJhY2sgKSA/XHJcblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcclxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xyXG5cclxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcclxuXHRcdGlmICgganNvblByb3AgKSB7XHJcblx0XHRcdHNbIGpzb25Qcm9wIF0gPSBzWyBqc29uUHJvcCBdLnJlcGxhY2UoIHJqc29ucCwgXCIkMVwiICsgY2FsbGJhY2tOYW1lICk7XHJcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcclxuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXHJcblx0XHRzLmNvbnZlcnRlcnNbXCJzY3JpcHQganNvblwiXSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRpZiAoICFyZXNwb25zZUNvbnRhaW5lciApIHtcclxuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VDb250YWluZXJbIDAgXTtcclxuXHRcdH07XHJcblxyXG5cdFx0Ly8gZm9yY2UganNvbiBkYXRhVHlwZVxyXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xyXG5cclxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tcclxuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcclxuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBhcmd1bWVudHM7XHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIENsZWFuLXVwIGZ1bmN0aW9uIChmaXJlcyBhZnRlciBjb252ZXJ0ZXJzKVxyXG5cdFx0anFYSFIuYWx3YXlzKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHQvLyBSZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXHJcblx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcclxuXHJcblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXHJcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XHJcblx0XHRcdFx0Ly8gbWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXHJcblx0XHRcdFx0cy5qc29ucENhbGxiYWNrID0gb3JpZ2luYWxTZXR0aW5ncy5qc29ucENhbGxiYWNrO1xyXG5cclxuXHRcdFx0XHQvLyBzYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXHJcblx0XHRcdFx0b2xkQ2FsbGJhY2tzLnB1c2goIGNhbGxiYWNrTmFtZSApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBDYWxsIGlmIGl0IHdhcyBhIGZ1bmN0aW9uIGFuZCB3ZSBoYXZlIGEgcmVzcG9uc2VcclxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcclxuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XHJcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcblxyXG5cclxuLy8gZGF0YTogc3RyaW5nIG9mIGh0bWxcclxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LCBkZWZhdWx0cyB0byBkb2N1bWVudFxyXG4vLyBrZWVwU2NyaXB0cyAob3B0aW9uYWwpOiBJZiB0cnVlLCB3aWxsIGluY2x1ZGUgc2NyaXB0cyBwYXNzZWQgaW4gdGhlIGh0bWwgc3RyaW5nXHJcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XHJcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcclxuXHRcdHJldHVybiBudWxsO1xyXG5cdH1cclxuXHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcImJvb2xlYW5cIiApIHtcclxuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcclxuXHRcdGNvbnRleHQgPSBmYWxzZTtcclxuXHR9XHJcblx0Y29udGV4dCA9IGNvbnRleHQgfHwgZG9jdW1lbnQ7XHJcblxyXG5cdHZhciBwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKSxcclxuXHRcdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XHJcblxyXG5cdC8vIFNpbmdsZSB0YWdcclxuXHRpZiAoIHBhcnNlZCApIHtcclxuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWzFdICkgXTtcclxuXHR9XHJcblxyXG5cdHBhcnNlZCA9IGpRdWVyeS5idWlsZEZyYWdtZW50KCBbIGRhdGEgXSwgY29udGV4dCwgc2NyaXB0cyApO1xyXG5cclxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XHJcblx0XHRqUXVlcnkoIHNjcmlwdHMgKS5yZW1vdmUoKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBqUXVlcnkubWVyZ2UoIFtdLCBwYXJzZWQuY2hpbGROb2RlcyApO1xyXG59O1xyXG5cclxuXHJcbi8vIEtlZXAgYSBjb3B5IG9mIHRoZSBvbGQgbG9hZCBtZXRob2RcclxudmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7XHJcblxyXG4vKipcclxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxyXG4gKi9cclxualF1ZXJ5LmZuLmxvYWQgPSBmdW5jdGlvbiggdXJsLCBwYXJhbXMsIGNhbGxiYWNrICkge1xyXG5cdGlmICggdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCApIHtcclxuXHRcdHJldHVybiBfbG9hZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XHJcblx0fVxyXG5cclxuXHR2YXIgc2VsZWN0b3IsIHR5cGUsIHJlc3BvbnNlLFxyXG5cdFx0c2VsZiA9IHRoaXMsXHJcblx0XHRvZmYgPSB1cmwuaW5kZXhPZihcIiBcIik7XHJcblxyXG5cdGlmICggb2ZmID49IDAgKSB7XHJcblx0XHRzZWxlY3RvciA9IGpRdWVyeS50cmltKCB1cmwuc2xpY2UoIG9mZiApICk7XHJcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xyXG5cdH1cclxuXHJcblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXHJcblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XHJcblxyXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcclxuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xyXG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xyXG5cclxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXHJcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XHJcblx0XHR0eXBlID0gXCJQT1NUXCI7XHJcblx0fVxyXG5cclxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxyXG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xyXG5cdFx0alF1ZXJ5LmFqYXgoe1xyXG5cdFx0XHR1cmw6IHVybCxcclxuXHJcblx0XHRcdC8vIGlmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWRcclxuXHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxyXG5cdFx0XHRkYXRhOiBwYXJhbXNcclxuXHRcdH0pLmRvbmUoZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcclxuXHJcblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xyXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcclxuXHJcblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xyXG5cclxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcclxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcclxuXHRcdFx0XHRqUXVlcnkoXCI8ZGl2PlwiKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XHJcblxyXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XHJcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XHJcblxyXG5cdFx0fSkuY29tcGxldGUoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xyXG5cdFx0XHRzZWxmLmVhY2goIGNhbGxiYWNrLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxualF1ZXJ5LmV4cHIuZmlsdGVycy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xyXG5cdHJldHVybiBqUXVlcnkuZ3JlcChqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XHJcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcclxuXHR9KS5sZW5ndGg7XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG52YXIgZG9jRWxlbSA9IHdpbmRvdy5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG4vKipcclxuICogR2V0cyBhIHdpbmRvdyBmcm9tIGFuIGVsZW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcclxuXHRyZXR1cm4galF1ZXJ5LmlzV2luZG93KCBlbGVtICkgPyBlbGVtIDogZWxlbS5ub2RlVHlwZSA9PT0gOSAmJiBlbGVtLmRlZmF1bHRWaWV3O1xyXG59XHJcblxyXG5qUXVlcnkub2Zmc2V0ID0ge1xyXG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XHJcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxyXG5cdFx0XHRwb3NpdGlvbiA9IGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApLFxyXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXHJcblx0XHRcdHByb3BzID0ge307XHJcblxyXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxyXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcclxuXHRcdFx0ZWxlbS5zdHlsZS5wb3NpdGlvbiA9IFwicmVsYXRpdmVcIjtcclxuXHRcdH1cclxuXHJcblx0XHRjdXJPZmZzZXQgPSBjdXJFbGVtLm9mZnNldCgpO1xyXG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xyXG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XHJcblx0XHRjYWxjdWxhdGVQb3NpdGlvbiA9ICggcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIiB8fCBwb3NpdGlvbiA9PT0gXCJmaXhlZFwiICkgJiZcclxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZihcImF1dG9cIikgPiAtMTtcclxuXHJcblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlciB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcclxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XHJcblx0XHRcdGN1clBvc2l0aW9uID0gY3VyRWxlbS5wb3NpdGlvbigpO1xyXG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XHJcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XHJcblx0XHRcdGN1ckxlZnQgPSBwYXJzZUZsb2F0KCBjdXJDU1NMZWZ0ICkgfHwgMDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XHJcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGN1ck9mZnNldCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcclxuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcclxuXHRcdH1cclxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XHJcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XHJcblx0XHRcdG9wdGlvbnMudXNpbmcuY2FsbCggZWxlbSwgcHJvcHMgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjdXJFbGVtLmNzcyggcHJvcHMgKTtcclxuXHRcdH1cclxuXHR9XHJcbn07XHJcblxyXG5qUXVlcnkuZm4uZXh0ZW5kKHtcclxuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xyXG5cdFx0XHRyZXR1cm4gb3B0aW9ucyA9PT0gdW5kZWZpbmVkID9cclxuXHRcdFx0XHR0aGlzIDpcclxuXHRcdFx0XHR0aGlzLmVhY2goZnVuY3Rpb24oIGkgKSB7XHJcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBkb2NFbGVtLCB3aW4sXHJcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXHJcblx0XHRcdGJveCA9IHsgdG9wOiAwLCBsZWZ0OiAwIH0sXHJcblx0XHRcdGRvYyA9IGVsZW0gJiYgZWxlbS5vd25lckRvY3VtZW50O1xyXG5cclxuXHRcdGlmICggIWRvYyApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSBpdCdzIG5vdCBhIGRpc2Nvbm5lY3RlZCBET00gbm9kZVxyXG5cdFx0aWYgKCAhalF1ZXJ5LmNvbnRhaW5zKCBkb2NFbGVtLCBlbGVtICkgKSB7XHJcblx0XHRcdHJldHVybiBib3g7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgd2UgZG9uJ3QgaGF2ZSBnQkNSLCBqdXN0IHVzZSAwLDAgcmF0aGVyIHRoYW4gZXJyb3JcclxuXHRcdC8vIEJsYWNrQmVycnkgNSwgaU9TIDMgKG9yaWdpbmFsIGlQaG9uZSlcclxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSBzdHJ1bmRlZmluZWQgKSB7XHJcblx0XHRcdGJveCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblx0XHR9XHJcblx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0dG9wOiBib3gudG9wICsgd2luLnBhZ2VZT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRUb3AsXHJcblx0XHRcdGxlZnQ6IGJveC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcclxuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcclxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcclxuXHRcdFx0cGFyZW50T2Zmc2V0ID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcclxuXHJcblx0XHQvLyBGaXhlZCBlbGVtZW50cyBhcmUgb2Zmc2V0IGZyb20gd2luZG93IChwYXJlbnRPZmZzZXQgPSB7dG9wOjAsIGxlZnQ6IDB9LCBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcclxuXHRcdGlmICggalF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIiApIHtcclxuXHRcdFx0Ly8gV2UgYXNzdW1lIHRoYXQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGlzIGF2YWlsYWJsZSB3aGVuIGNvbXB1dGVkIHBvc2l0aW9uIGlzIGZpeGVkXHJcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Ly8gR2V0ICpyZWFsKiBvZmZzZXRQYXJlbnRcclxuXHRcdFx0b2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQoKTtcclxuXHJcblx0XHRcdC8vIEdldCBjb3JyZWN0IG9mZnNldHNcclxuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcclxuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcclxuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0KCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFkZCBvZmZzZXRQYXJlbnQgYm9yZGVyc1xyXG5cdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKTtcclxuXHRcdFx0cGFyZW50T2Zmc2V0LmxlZnQgKz0galF1ZXJ5LmNzcyggb2Zmc2V0UGFyZW50WyAwIF0sIFwiYm9yZGVyTGVmdFdpZHRoXCIsIHRydWUgKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTdWJ0cmFjdCBwYXJlbnQgb2Zmc2V0cyBhbmQgZWxlbWVudCBtYXJnaW5zXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0b3A6IG9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wIC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5Ub3BcIiwgdHJ1ZSApLFxyXG5cdFx0XHRsZWZ0OiBvZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0IC0galF1ZXJ5LmNzcyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIsIHRydWUgKVxyXG5cdFx0fTtcclxuXHR9LFxyXG5cclxuXHRvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR2YXIgb2Zmc2V0UGFyZW50ID0gdGhpcy5vZmZzZXRQYXJlbnQgfHwgZG9jRWxlbTtcclxuXHJcblx0XHRcdHdoaWxlICggb2Zmc2V0UGFyZW50ICYmICggIWpRdWVyeS5ub2RlTmFtZSggb2Zmc2V0UGFyZW50LCBcImh0bWxcIiApICYmIGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSApIHtcclxuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY0VsZW07XHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXHJcbmpRdWVyeS5lYWNoKCB7IHNjcm9sbExlZnQ6IFwicGFnZVhPZmZzZXRcIiwgc2Nyb2xsVG9wOiBcInBhZ2VZT2Zmc2V0XCIgfSwgZnVuY3Rpb24oIG1ldGhvZCwgcHJvcCApIHtcclxuXHR2YXIgdG9wID0gXCJwYWdlWU9mZnNldFwiID09PSBwcm9wO1xyXG5cclxuXHRqUXVlcnkuZm5bIG1ldGhvZCBdID0gZnVuY3Rpb24oIHZhbCApIHtcclxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBtZXRob2QsIHZhbCApIHtcclxuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xyXG5cclxuXHRcdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB3aW4gKSB7XHJcblx0XHRcdFx0d2luLnNjcm9sbFRvKFxyXG5cdFx0XHRcdFx0IXRvcCA/IHZhbCA6IHdpbmRvdy5wYWdlWE9mZnNldCxcclxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbmRvdy5wYWdlWU9mZnNldFxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGVsZW1bIG1ldGhvZCBdID0gdmFsO1xyXG5cdFx0XHR9XHJcblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCwgbnVsbCApO1xyXG5cdH07XHJcbn0pO1xyXG5cclxuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cclxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XHJcbi8vIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBwZXJjZW50IHdoZW4gc3BlY2lmaWVkIGZvciB0b3AvbGVmdC9ib3R0b20vcmlnaHRcclxuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIHdlIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcclxualF1ZXJ5LmVhY2goIFsgXCJ0b3BcIiwgXCJsZWZ0XCIgXSwgZnVuY3Rpb24oIGksIHByb3AgKSB7XHJcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcclxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcclxuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcclxuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xyXG5cdFx0XHRcdC8vIGlmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxyXG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XHJcblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxyXG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHQpO1xyXG59KTtcclxuXHJcblxyXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcclxualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xyXG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSwgZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XHJcblx0XHQvLyBtYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcclxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xyXG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxyXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcclxuXHJcblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcclxuXHRcdFx0XHR2YXIgZG9jO1xyXG5cclxuXHRcdFx0XHRpZiAoIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApICkge1xyXG5cdFx0XHRcdFx0Ly8gQXMgb2YgNS84LzIwMTIgdGhpcyB3aWxsIHlpZWxkIGluY29ycmVjdCByZXN1bHRzIGZvciBNb2JpbGUgU2FmYXJpLCBidXQgdGhlcmVcclxuXHRcdFx0XHRcdC8vIGlzbid0IGEgd2hvbGUgbG90IHdlIGNhbiBkby4gU2VlIHB1bGwgcmVxdWVzdCBhdCB0aGlzIFVSTCBmb3IgZGlzY3Vzc2lvbjpcclxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XHJcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XHJcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xyXG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxyXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XHJcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXHJcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxyXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcclxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXHJcblx0XHRcdFx0XHQpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xyXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxyXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XHJcblxyXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxyXG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcclxuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUsIG51bGwgKTtcclxuXHRcdH07XHJcblx0fSk7XHJcbn0pO1xyXG5cclxuXHJcbi8vIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgY29udGFpbmVkIGluIHRoZSBtYXRjaGVkIGVsZW1lbnQgc2V0XHJcbmpRdWVyeS5mbi5zaXplID0gZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXMubGVuZ3RoO1xyXG59O1xyXG5cclxualF1ZXJ5LmZuLmFuZFNlbGYgPSBqUXVlcnkuZm4uYWRkQmFjaztcclxuXHJcblxyXG5cclxuXHJcbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XHJcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxyXG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXHJcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxyXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcclxuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxyXG5cclxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcclxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxyXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxyXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXHJcblxyXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xyXG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIGpRdWVyeTtcclxuXHR9KTtcclxufVxyXG5cclxuXHJcblxyXG5cclxudmFyXHJcblx0Ly8gTWFwIG92ZXIgalF1ZXJ5IGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXHJcblxyXG5cdC8vIE1hcCBvdmVyIHRoZSAkIGluIGNhc2Ugb2Ygb3ZlcndyaXRlXHJcblx0XyQgPSB3aW5kb3cuJDtcclxuXHJcbmpRdWVyeS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oIGRlZXAgKSB7XHJcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xyXG5cdFx0d2luZG93LiQgPSBfJDtcclxuXHR9XHJcblxyXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XHJcblx0XHR3aW5kb3cualF1ZXJ5ID0gX2pRdWVyeTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBqUXVlcnk7XHJcbn07XHJcblxyXG4vLyBFeHBvc2UgalF1ZXJ5IGFuZCAkIGlkZW50aWZpZXJzLCBldmVuIGluXHJcbi8vIEFNRCAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXHJcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcclxuaWYgKCB0eXBlb2Ygbm9HbG9iYWwgPT09IHN0cnVuZGVmaW5lZCApIHtcclxuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbnJldHVybiBqUXVlcnk7XHJcblxyXG59KSk7XHJcbiIsIi8vISBtb21lbnQuanNcclxuLy8hIHZlcnNpb24gOiAyLjguNFxyXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xyXG4vLyEgbGljZW5zZSA6IE1JVFxyXG4vLyEgbW9tZW50anMuY29tXHJcblxyXG4oZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgICAgIENvbnN0YW50c1xyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuICAgIHZhciBtb21lbnQsXHJcbiAgICAgICAgVkVSU0lPTiA9ICcyLjguNCcsXHJcbiAgICAgICAgLy8gdGhlIGdsb2JhbC1zY29wZSB0aGlzIGlzIE5PVCB0aGUgZ2xvYmFsIG9iamVjdCBpbiBOb2RlLmpzXHJcbiAgICAgICAgZ2xvYmFsU2NvcGUgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHRoaXMsXHJcbiAgICAgICAgb2xkR2xvYmFsTW9tZW50LFxyXG4gICAgICAgIHJvdW5kID0gTWF0aC5yb3VuZCxcclxuICAgICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXHJcbiAgICAgICAgaSxcclxuXHJcbiAgICAgICAgWUVBUiA9IDAsXHJcbiAgICAgICAgTU9OVEggPSAxLFxyXG4gICAgICAgIERBVEUgPSAyLFxyXG4gICAgICAgIEhPVVIgPSAzLFxyXG4gICAgICAgIE1JTlVURSA9IDQsXHJcbiAgICAgICAgU0VDT05EID0gNSxcclxuICAgICAgICBNSUxMSVNFQ09ORCA9IDYsXHJcblxyXG4gICAgICAgIC8vIGludGVybmFsIHN0b3JhZ2UgZm9yIGxvY2FsZSBjb25maWcgZmlsZXNcclxuICAgICAgICBsb2NhbGVzID0ge30sXHJcblxyXG4gICAgICAgIC8vIGV4dHJhIG1vbWVudCBpbnRlcm5hbCBwcm9wZXJ0aWVzIChwbHVnaW5zIHJlZ2lzdGVyIHByb3BzIGhlcmUpXHJcbiAgICAgICAgbW9tZW50UHJvcGVydGllcyA9IFtdLFxyXG5cclxuICAgICAgICAvLyBjaGVjayBmb3Igbm9kZUpTXHJcbiAgICAgICAgaGFzTW9kdWxlID0gKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyksXHJcblxyXG4gICAgICAgIC8vIEFTUC5ORVQganNvbiBkYXRlIGZvcm1hdCByZWdleFxyXG4gICAgICAgIGFzcE5ldEpzb25SZWdleCA9IC9eXFwvP0RhdGVcXCgoXFwtP1xcZCspL2ksXHJcbiAgICAgICAgYXNwTmV0VGltZVNwYW5Kc29uUmVnZXggPSAvKFxcLSk/KD86KFxcZCopXFwuKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKylcXC4/KFxcZHszfSk/KT8vLFxyXG5cclxuICAgICAgICAvLyBmcm9tIGh0dHA6Ly9kb2NzLmNsb3N1cmUtbGlicmFyeS5nb29nbGVjb2RlLmNvbS9naXQvY2xvc3VyZV9nb29nX2RhdGVfZGF0ZS5qcy5zb3VyY2UuaHRtbFxyXG4gICAgICAgIC8vIHNvbWV3aGF0IG1vcmUgaW4gbGluZSB3aXRoIDQuNC4zLjIgMjAwNCBzcGVjLCBidXQgYWxsb3dzIGRlY2ltYWwgYW55d2hlcmVcclxuICAgICAgICBpc29EdXJhdGlvblJlZ2V4ID0gL14oLSk/UCg/Oig/OihbMC05LC5dKilZKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKUQpPyg/OlQoPzooWzAtOSwuXSopSCk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilTKT8pP3woWzAtOSwuXSopVykkLyxcclxuXHJcbiAgICAgICAgLy8gZm9ybWF0IHRva2Vuc1xyXG4gICAgICAgIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oTW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UXxZWVlZWVl8WVlZWVl8WVlZWXxZWXxnZyhnZ2c/KT98R0coR0dHPyk/fGV8RXxhfEF8aGg/fEhIP3xtbT98c3M/fFN7MSw0fXx4fFh8eno/fFpaP3wuKS9nLFxyXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2csXHJcblxyXG4gICAgICAgIC8vIHBhcnNpbmcgdG9rZW4gcmVnZXhlc1xyXG4gICAgICAgIHBhcnNlVG9rZW5PbmVPclR3b0RpZ2l0cyA9IC9cXGRcXGQ/LywgLy8gMCAtIDk5XHJcbiAgICAgICAgcGFyc2VUb2tlbk9uZVRvVGhyZWVEaWdpdHMgPSAvXFxkezEsM30vLCAvLyAwIC0gOTk5XHJcbiAgICAgICAgcGFyc2VUb2tlbk9uZVRvRm91ckRpZ2l0cyA9IC9cXGR7MSw0fS8sIC8vIDAgLSA5OTk5XHJcbiAgICAgICAgcGFyc2VUb2tlbk9uZVRvU2l4RGlnaXRzID0gL1srXFwtXT9cXGR7MSw2fS8sIC8vIC05OTksOTk5IC0gOTk5LDk5OVxyXG4gICAgICAgIHBhcnNlVG9rZW5EaWdpdHMgPSAvXFxkKy8sIC8vIG5vbnplcm8gbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICAgIHBhcnNlVG9rZW5Xb3JkID0gL1swLTldKlsnYS16XFx1MDBBMC1cXHUwNUZGXFx1MDcwMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSt8W1xcdTA2MDAtXFx1MDZGRlxcL10rKFxccyo/W1xcdTA2MDAtXFx1MDZGRl0rKXsxLDJ9L2ksIC8vIGFueSB3b3JkIChvciB0d28pIGNoYXJhY3RlcnMgb3IgbnVtYmVycyBpbmNsdWRpbmcgdHdvL3RocmVlIHdvcmQgbW9udGggaW4gYXJhYmljLlxyXG4gICAgICAgIHBhcnNlVG9rZW5UaW1lem9uZSA9IC9afFtcXCtcXC1dXFxkXFxkOj9cXGRcXGQvZ2ksIC8vICswMDowMCAtMDA6MDAgKzAwMDAgLTAwMDAgb3IgWlxyXG4gICAgICAgIHBhcnNlVG9rZW5UID0gL1QvaSwgLy8gVCAoSVNPIHNlcGFyYXRvcilcclxuICAgICAgICBwYXJzZVRva2VuT2Zmc2V0TXMgPSAvW1xcK1xcLV0/XFxkKy8sIC8vIDEyMzQ1Njc4OTAxMjNcclxuICAgICAgICBwYXJzZVRva2VuVGltZXN0YW1wTXMgPSAvW1xcK1xcLV0/XFxkKyhcXC5cXGR7MSwzfSk/LywgLy8gMTIzNDU2Nzg5IDEyMzQ1Njc4OS4xMjNcclxuXHJcbiAgICAgICAgLy9zdHJpY3QgcGFyc2luZyByZWdleGVzXHJcbiAgICAgICAgcGFyc2VUb2tlbk9uZURpZ2l0ID0gL1xcZC8sIC8vIDAgLSA5XHJcbiAgICAgICAgcGFyc2VUb2tlblR3b0RpZ2l0cyA9IC9cXGRcXGQvLCAvLyAwMCAtIDk5XHJcbiAgICAgICAgcGFyc2VUb2tlblRocmVlRGlnaXRzID0gL1xcZHszfS8sIC8vIDAwMCAtIDk5OVxyXG4gICAgICAgIHBhcnNlVG9rZW5Gb3VyRGlnaXRzID0gL1xcZHs0fS8sIC8vIDAwMDAgLSA5OTk5XHJcbiAgICAgICAgcGFyc2VUb2tlblNpeERpZ2l0cyA9IC9bKy1dP1xcZHs2fS8sIC8vIC05OTksOTk5IC0gOTk5LDk5OVxyXG4gICAgICAgIHBhcnNlVG9rZW5TaWduZWROdW1iZXIgPSAvWystXT9cXGQrLywgLy8gLWluZiAtIGluZlxyXG5cclxuICAgICAgICAvLyBpc28gODYwMSByZWdleFxyXG4gICAgICAgIC8vIDAwMDAtMDAtMDAgMDAwMC1XMDAgb3IgMDAwMC1XMDAtMCArIFQgKyAwMCBvciAwMDowMCBvciAwMDowMDowMCBvciAwMDowMDowMC4wMDAgKyArMDA6MDAgb3IgKzAwMDAgb3IgKzAwKVxyXG4gICAgICAgIGlzb1JlZ2V4ID0gL15cXHMqKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OihcXGRcXGQtXFxkXFxkKXwoV1xcZFxcZCQpfChXXFxkXFxkLVxcZCl8KFxcZFxcZFxcZCkpKChUfCApKFxcZFxcZCg6XFxkXFxkKDpcXGRcXGQoXFwuXFxkKyk/KT8pPyk/KFtcXCtcXC1dXFxkXFxkKD86Oj9cXGRcXGQpP3xcXHMqWik/KT8kLyxcclxuXHJcbiAgICAgICAgaXNvRm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJyxcclxuXHJcbiAgICAgICAgaXNvRGF0ZXMgPSBbXHJcbiAgICAgICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkezJ9LVxcZHsyfS9dLFxyXG4gICAgICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZHsyfS1cXGR7Mn0vXSxcclxuICAgICAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGR7Mn0tXFxkL10sXHJcbiAgICAgICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZHsyfS9dLFxyXG4gICAgICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXVxyXG4gICAgICAgIF0sXHJcblxyXG4gICAgICAgIC8vIGlzbyB0aW1lIGZvcm1hdHMgYW5kIHJlZ2V4ZXNcclxuICAgICAgICBpc29UaW1lcyA9IFtcclxuICAgICAgICAgICAgWydISDptbTpzcy5TU1NTJywgLyhUfCApXFxkXFxkOlxcZFxcZDpcXGRcXGRcXC5cXGQrL10sXHJcbiAgICAgICAgICAgIFsnSEg6bW06c3MnLCAvKFR8IClcXGRcXGQ6XFxkXFxkOlxcZFxcZC9dLFxyXG4gICAgICAgICAgICBbJ0hIOm1tJywgLyhUfCApXFxkXFxkOlxcZFxcZC9dLFxyXG4gICAgICAgICAgICBbJ0hIJywgLyhUfCApXFxkXFxkL11cclxuICAgICAgICBdLFxyXG5cclxuICAgICAgICAvLyB0aW1lem9uZSBjaHVua2VyICcrMTA6MDAnID4gWycxMCcsICcwMCddIG9yICctMTUzMCcgPiBbJy0xNScsICczMCddXHJcbiAgICAgICAgcGFyc2VUaW1lem9uZUNodW5rZXIgPSAvKFtcXCtcXC1dfFxcZFxcZCkvZ2ksXHJcblxyXG4gICAgICAgIC8vIGdldHRlciBhbmQgc2V0dGVyIG5hbWVzXHJcbiAgICAgICAgcHJveHlHZXR0ZXJzQW5kU2V0dGVycyA9ICdEYXRlfEhvdXJzfE1pbnV0ZXN8U2Vjb25kc3xNaWxsaXNlY29uZHMnLnNwbGl0KCd8JyksXHJcbiAgICAgICAgdW5pdE1pbGxpc2Vjb25kRmFjdG9ycyA9IHtcclxuICAgICAgICAgICAgJ01pbGxpc2Vjb25kcycgOiAxLFxyXG4gICAgICAgICAgICAnU2Vjb25kcycgOiAxZTMsXHJcbiAgICAgICAgICAgICdNaW51dGVzJyA6IDZlNCxcclxuICAgICAgICAgICAgJ0hvdXJzJyA6IDM2ZTUsXHJcbiAgICAgICAgICAgICdEYXlzJyA6IDg2NGU1LFxyXG4gICAgICAgICAgICAnTW9udGhzJyA6IDI1OTJlNixcclxuICAgICAgICAgICAgJ1llYXJzJyA6IDMxNTM2ZTZcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB1bml0QWxpYXNlcyA9IHtcclxuICAgICAgICAgICAgbXMgOiAnbWlsbGlzZWNvbmQnLFxyXG4gICAgICAgICAgICBzIDogJ3NlY29uZCcsXHJcbiAgICAgICAgICAgIG0gOiAnbWludXRlJyxcclxuICAgICAgICAgICAgaCA6ICdob3VyJyxcclxuICAgICAgICAgICAgZCA6ICdkYXknLFxyXG4gICAgICAgICAgICBEIDogJ2RhdGUnLFxyXG4gICAgICAgICAgICB3IDogJ3dlZWsnLFxyXG4gICAgICAgICAgICBXIDogJ2lzb1dlZWsnLFxyXG4gICAgICAgICAgICBNIDogJ21vbnRoJyxcclxuICAgICAgICAgICAgUSA6ICdxdWFydGVyJyxcclxuICAgICAgICAgICAgeSA6ICd5ZWFyJyxcclxuICAgICAgICAgICAgREREIDogJ2RheU9mWWVhcicsXHJcbiAgICAgICAgICAgIGUgOiAnd2Vla2RheScsXHJcbiAgICAgICAgICAgIEUgOiAnaXNvV2Vla2RheScsXHJcbiAgICAgICAgICAgIGdnOiAnd2Vla1llYXInLFxyXG4gICAgICAgICAgICBHRzogJ2lzb1dlZWtZZWFyJ1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNhbWVsRnVuY3Rpb25zID0ge1xyXG4gICAgICAgICAgICBkYXlvZnllYXIgOiAnZGF5T2ZZZWFyJyxcclxuICAgICAgICAgICAgaXNvd2Vla2RheSA6ICdpc29XZWVrZGF5JyxcclxuICAgICAgICAgICAgaXNvd2VlayA6ICdpc29XZWVrJyxcclxuICAgICAgICAgICAgd2Vla3llYXIgOiAnd2Vla1llYXInLFxyXG4gICAgICAgICAgICBpc293ZWVreWVhciA6ICdpc29XZWVrWWVhcidcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyBmb3JtYXQgZnVuY3Rpb24gc3RyaW5nc1xyXG4gICAgICAgIGZvcm1hdEZ1bmN0aW9ucyA9IHt9LFxyXG5cclxuICAgICAgICAvLyBkZWZhdWx0IHJlbGF0aXZlIHRpbWUgdGhyZXNob2xkc1xyXG4gICAgICAgIHJlbGF0aXZlVGltZVRocmVzaG9sZHMgPSB7XHJcbiAgICAgICAgICAgIHM6IDQ1LCAgLy8gc2Vjb25kcyB0byBtaW51dGVcclxuICAgICAgICAgICAgbTogNDUsICAvLyBtaW51dGVzIHRvIGhvdXJcclxuICAgICAgICAgICAgaDogMjIsICAvLyBob3VycyB0byBkYXlcclxuICAgICAgICAgICAgZDogMjYsICAvLyBkYXlzIHRvIG1vbnRoXHJcbiAgICAgICAgICAgIE06IDExICAgLy8gbW9udGhzIHRvIHllYXJcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICAvLyB0b2tlbnMgdG8gb3JkaW5hbGl6ZSBhbmQgcGFkXHJcbiAgICAgICAgb3JkaW5hbGl6ZVRva2VucyA9ICdEREQgdyBXIE0gRCBkJy5zcGxpdCgnICcpLFxyXG4gICAgICAgIHBhZGRlZFRva2VucyA9ICdNIEQgSCBoIG0gcyB3IFcnLnNwbGl0KCcgJyksXHJcblxyXG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zID0ge1xyXG4gICAgICAgICAgICBNICAgIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9udGgoKSArIDE7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIE1NTSAgOiBmdW5jdGlvbiAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubW9udGhzU2hvcnQodGhpcywgZm9ybWF0KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgTU1NTSA6IGZ1bmN0aW9uIChmb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgRCAgICA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgREREICA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRheU9mWWVhcigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkICAgIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF5KCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRkICAgOiBmdW5jdGlvbiAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNNaW4odGhpcywgZm9ybWF0KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZGRkICA6IGZ1bmN0aW9uIChmb3JtYXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c1Nob3J0KHRoaXMsIGZvcm1hdCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRkZGQgOiBmdW5jdGlvbiAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdyAgICA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWsoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgVyAgICA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWsoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgWVkgICA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy55ZWFyKCkgJSAxMDAsIDIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBZWVlZIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLnllYXIoKSwgNCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFlZWVlZIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLnllYXIoKSwgNSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFlZWVlZWSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCksIHNpZ24gPSB5ID49IDAgPyAnKycgOiAnLSc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbiArIGxlZnRaZXJvRmlsbChNYXRoLmFicyh5KSwgNik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdnICAgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMud2Vla1llYXIoKSAlIDEwMCwgMik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdnZ2cgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMud2Vla1llYXIoKSwgNCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdnZ2dnIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLndlZWtZZWFyKCksIDUpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBHRyAgIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDAsIDIpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBHR0dHIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0aGlzLmlzb1dlZWtZZWFyKCksIDQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBHR0dHRyA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5pc29XZWVrWWVhcigpLCA1KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLndlZWtkYXkoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgRSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtkYXkoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYSAgICA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCB0cnVlKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgQSAgICA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tZXJpZGllbSh0aGlzLmhvdXJzKCksIHRoaXMubWludXRlcygpLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIEggICAgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoICAgIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaG91cnMoKSAlIDEyIHx8IDEyO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtICAgIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWludXRlcygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzICAgIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2Vjb25kcygpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBTICAgIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvSW50KHRoaXMubWlsbGlzZWNvbmRzKCkgLyAxMDApO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBTUyAgIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnRaZXJvRmlsbCh0b0ludCh0aGlzLm1pbGxpc2Vjb25kcygpIC8gMTApLCAyKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgU1NTICA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0WmVyb0ZpbGwodGhpcy5taWxsaXNlY29uZHMoKSwgMyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFNTU1MgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKHRoaXMubWlsbGlzZWNvbmRzKCksIDMpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBaICAgIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGEgPSAtdGhpcy56b25lKCksXHJcbiAgICAgICAgICAgICAgICAgICAgYiA9ICcrJztcclxuICAgICAgICAgICAgICAgIGlmIChhIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgICAgICAgICAgICBiID0gJy0nO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGIgKyBsZWZ0WmVyb0ZpbGwodG9JbnQoYSAvIDYwKSwgMikgKyAnOicgKyBsZWZ0WmVyb0ZpbGwodG9JbnQoYSkgJSA2MCwgMik7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFpaICAgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgYSA9IC10aGlzLnpvbmUoKSxcclxuICAgICAgICAgICAgICAgICAgICBiID0gJysnO1xyXG4gICAgICAgICAgICAgICAgaWYgKGEgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgICAgICAgICAgIGIgPSAnLSc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYiArIGxlZnRaZXJvRmlsbCh0b0ludChhIC8gNjApLCAyKSArIGxlZnRaZXJvRmlsbCh0b0ludChhKSAlIDYwLCAyKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgeiA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnpvbmVBYmJyKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHp6IDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuem9uZU5hbWUoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgeCAgICA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgWCAgICA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnVuaXgoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgUSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnF1YXJ0ZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRlcHJlY2F0aW9ucyA9IHt9LFxyXG5cclxuICAgICAgICBsaXN0cyA9IFsnbW9udGhzJywgJ21vbnRoc1Nob3J0JywgJ3dlZWtkYXlzJywgJ3dlZWtkYXlzU2hvcnQnLCAnd2Vla2RheXNNaW4nXTtcclxuXHJcbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuIGRmbCBjb21lcyBmcm9tXHJcbiAgICAvLyBkZWZhdWx0LlxyXG4gICAgZnVuY3Rpb24gZGZsKGEsIGIsIGMpIHtcclxuICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gYSAhPSBudWxsID8gYSA6IGI7XHJcbiAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIGEgIT0gbnVsbCA/IGEgOiBiICE9IG51bGwgPyBiIDogYztcclxuICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdJbXBsZW1lbnQgbWUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaGFzT3duUHJvcChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoYSwgYik7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcclxuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QsIGFuZCBlczUgc3RhbmRhcmQgaXMgbm90IHZlcnlcclxuICAgICAgICAvLyBoZWxwZnVsLlxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGVtcHR5IDogZmFsc2UsXHJcbiAgICAgICAgICAgIHVudXNlZFRva2VucyA6IFtdLFxyXG4gICAgICAgICAgICB1bnVzZWRJbnB1dCA6IFtdLFxyXG4gICAgICAgICAgICBvdmVyZmxvdyA6IC0yLFxyXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyIDogMCxcclxuICAgICAgICAgICAgbnVsbElucHV0IDogZmFsc2UsXHJcbiAgICAgICAgICAgIGludmFsaWRNb250aCA6IG51bGwsXHJcbiAgICAgICAgICAgIGludmFsaWRGb3JtYXQgOiBmYWxzZSxcclxuICAgICAgICAgICAgdXNlckludmFsaWRhdGVkIDogZmFsc2UsXHJcbiAgICAgICAgICAgIGlzbzogZmFsc2VcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHByaW50TXNnKG1zZykge1xyXG4gICAgICAgIGlmIChtb21lbnQuc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmdzID09PSBmYWxzZSAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmIGNvbnNvbGUud2Fybikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlcHJlY2F0aW9uIHdhcm5pbmc6ICcgKyBtc2cpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xyXG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBwcmludE1zZyhtc2cpO1xyXG4gICAgICAgICAgICAgICAgZmlyc3RUaW1lID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfSwgZm4pO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCBtc2cpIHtcclxuICAgICAgICBpZiAoIWRlcHJlY2F0aW9uc1tuYW1lXSkge1xyXG4gICAgICAgICAgICBwcmludE1zZyhtc2cpO1xyXG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYWRUb2tlbihmdW5jLCBjb3VudCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbGVmdFplcm9GaWxsKGZ1bmMuY2FsbCh0aGlzLCBhKSwgY291bnQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBvcmRpbmFsaXplVG9rZW4oZnVuYywgcGVyaW9kKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuY2FsbCh0aGlzLCBhKSwgcGVyaW9kKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHdoaWxlIChvcmRpbmFsaXplVG9rZW5zLmxlbmd0aCkge1xyXG4gICAgICAgIGkgPSBvcmRpbmFsaXplVG9rZW5zLnBvcCgpO1xyXG4gICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW2kgKyAnbyddID0gb3JkaW5hbGl6ZVRva2VuKGZvcm1hdFRva2VuRnVuY3Rpb25zW2ldLCBpKTtcclxuICAgIH1cclxuICAgIHdoaWxlIChwYWRkZWRUb2tlbnMubGVuZ3RoKSB7XHJcbiAgICAgICAgaSA9IHBhZGRlZFRva2Vucy5wb3AoKTtcclxuICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1tpICsgaV0gPSBwYWRUb2tlbihmb3JtYXRUb2tlbkZ1bmN0aW9uc1tpXSwgMik7XHJcbiAgICB9XHJcbiAgICBmb3JtYXRUb2tlbkZ1bmN0aW9ucy5EREREID0gcGFkVG9rZW4oZm9ybWF0VG9rZW5GdW5jdGlvbnMuRERELCAzKTtcclxuXHJcblxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgICAgIENvbnN0cnVjdG9yc1xyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuICAgIGZ1bmN0aW9uIExvY2FsZSgpIHtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNb21lbnQgcHJvdG90eXBlIG9iamVjdFxyXG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZywgc2tpcE92ZXJmbG93KSB7XHJcbiAgICAgICAgaWYgKHNraXBPdmVyZmxvdyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgY2hlY2tPdmVyZmxvdyhjb25maWcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fZCA9IG5ldyBEYXRlKCtjb25maWcuX2QpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIER1cmF0aW9uIENvbnN0cnVjdG9yXHJcbiAgICBmdW5jdGlvbiBEdXJhdGlvbihkdXJhdGlvbikge1xyXG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhkdXJhdGlvbiksXHJcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcclxuICAgICAgICAgICAgcXVhcnRlcnMgPSBub3JtYWxpemVkSW5wdXQucXVhcnRlciB8fCAwLFxyXG4gICAgICAgICAgICBtb250aHMgPSBub3JtYWxpemVkSW5wdXQubW9udGggfHwgMCxcclxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxyXG4gICAgICAgICAgICBkYXlzID0gbm9ybWFsaXplZElucHV0LmRheSB8fCAwLFxyXG4gICAgICAgICAgICBob3VycyA9IG5vcm1hbGl6ZWRJbnB1dC5ob3VyIHx8IDAsXHJcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXHJcbiAgICAgICAgICAgIHNlY29uZHMgPSBub3JtYWxpemVkSW5wdXQuc2Vjb25kIHx8IDAsXHJcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZCB8fCAwO1xyXG5cclxuICAgICAgICAvLyByZXByZXNlbnRhdGlvbiBmb3IgZGF0ZUFkZFJlbW92ZVxyXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xyXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxyXG4gICAgICAgICAgICBtaW51dGVzICogNmU0ICsgLy8gMTAwMCAqIDYwXHJcbiAgICAgICAgICAgIGhvdXJzICogMzZlNTsgLy8gMTAwMCAqIDYwICogNjBcclxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcclxuICAgICAgICAvLyBkYXkgd2hlbiB3b3JraW5nIGFyb3VuZCBEU1QsIHdlIG5lZWQgdG8gc3RvcmUgdGhlbSBzZXBhcmF0ZWx5XHJcbiAgICAgICAgdGhpcy5fZGF5cyA9ICtkYXlzICtcclxuICAgICAgICAgICAgd2Vla3MgKiA3O1xyXG4gICAgICAgIC8vIEl0IGlzIGltcG9zc2libGUgdHJhbnNsYXRlIG1vbnRocyBpbnRvIGRheXMgd2l0aG91dCBrbm93aW5nXHJcbiAgICAgICAgLy8gd2hpY2ggbW9udGhzIHlvdSBhcmUgYXJlIHRhbGtpbmcgYWJvdXQsIHNvIHdlIGhhdmUgdG8gc3RvcmVcclxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxyXG4gICAgICAgIHRoaXMuX21vbnRocyA9ICttb250aHMgK1xyXG4gICAgICAgICAgICBxdWFydGVycyAqIDMgK1xyXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xyXG5cclxuICAgICAgICB0aGlzLl9kYXRhID0ge307XHJcblxyXG4gICAgICAgIHRoaXMuX2xvY2FsZSA9IG1vbWVudC5sb2NhbGVEYXRhKCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2J1YmJsZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgICAgICBIZWxwZXJzXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XHJcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGhhc093blByb3AoYiwgJ3RvU3RyaW5nJykpIHtcclxuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XHJcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcclxuICAgICAgICB2YXIgaSwgcHJvcCwgdmFsO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2lzQU1vbWVudE9iamVjdCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdG8uX2lzQU1vbWVudE9iamVjdCA9IGZyb20uX2lzQU1vbWVudE9iamVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0by5faSA9IGZyb20uX2k7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fZiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdG8uX2YgPSBmcm9tLl9mO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2wgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRvLl9sID0gZnJvbS5fbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9zdHJpY3QgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRvLl9zdHJpY3QgPSBmcm9tLl9zdHJpY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fdHptICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0by5fdHptID0gZnJvbS5fdHptO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2lzVVRDICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICB0by5faXNVVEMgPSBmcm9tLl9pc1VUQztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9vZmZzZXQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRvLl9vZmZzZXQgPSBmcm9tLl9vZmZzZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fcGYgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHRvLl9wZiA9IGZyb20uX3BmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2xvY2FsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdG8uX2xvY2FsZSA9IGZyb20uX2xvY2FsZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtb21lbnRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgZm9yIChpIGluIG1vbWVudFByb3BlcnRpZXMpIHtcclxuICAgICAgICAgICAgICAgIHByb3AgPSBtb21lbnRQcm9wZXJ0aWVzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFsID0gZnJvbVtwcm9wXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRvW3Byb3BdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWJzUm91bmQobnVtYmVyKSB7XHJcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGxlZnQgemVybyBmaWxsIGEgbnVtYmVyXHJcbiAgICAvLyBzZWUgaHR0cDovL2pzcGVyZi5jb20vbGVmdC16ZXJvLWZpbGxpbmcgZm9yIHBlcmZvcm1hbmNlIGNvbXBhcmlzb25cclxuICAgIGZ1bmN0aW9uIGxlZnRaZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XHJcbiAgICAgICAgdmFyIG91dHB1dCA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcclxuICAgICAgICAgICAgc2lnbiA9IG51bWJlciA+PSAwO1xyXG5cclxuICAgICAgICB3aGlsZSAob3V0cHV0Lmxlbmd0aCA8IHRhcmdldExlbmd0aCkge1xyXG4gICAgICAgICAgICBvdXRwdXQgPSAnMCcgKyBvdXRwdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoc2lnbiA/IChmb3JjZVNpZ24gPyAnKycgOiAnJykgOiAnLScpICsgb3V0cHV0O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcclxuICAgICAgICB2YXIgcmVzID0ge21pbGxpc2Vjb25kczogMCwgbW9udGhzOiAwfTtcclxuXHJcbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xyXG4gICAgICAgICAgICAob3RoZXIueWVhcigpIC0gYmFzZS55ZWFyKCkpICogMTI7XHJcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xyXG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xyXG5cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XHJcbiAgICAgICAgdmFyIHJlcztcclxuICAgICAgICBvdGhlciA9IG1ha2VBcyhvdGhlciwgYmFzZSk7XHJcbiAgICAgICAgaWYgKGJhc2UuaXNCZWZvcmUob3RoZXIpKSB7XHJcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2Uob3RoZXIsIGJhc2UpO1xyXG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XHJcbiAgICAgICAgICAgIHJlcy5tb250aHMgPSAtcmVzLm1vbnRocztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETzogcmVtb3ZlICduYW1lJyBhcmcgYWZ0ZXIgZGVwcmVjYXRpb24gaXMgcmVtb3ZlZFxyXG4gICAgZnVuY3Rpb24gY3JlYXRlQWRkZXIoZGlyZWN0aW9uLCBuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xyXG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XHJcbiAgICAgICAgICAgIC8vaW52ZXJ0IHRoZSBhcmd1bWVudHMsIGJ1dCBjb21wbGFpbiBhYm91dCBpdFxyXG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xyXG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuJyk7XHJcbiAgICAgICAgICAgICAgICB0bXAgPSB2YWw7IHZhbCA9IHBlcmlvZDsgcGVyaW9kID0gdG1wO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YWwgPSB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyA/ICt2YWwgOiB2YWw7XHJcbiAgICAgICAgICAgIGR1ciA9IG1vbWVudC5kdXJhdGlvbih2YWwsIHBlcmlvZCk7XHJcbiAgICAgICAgICAgIGFkZE9yU3VidHJhY3REdXJhdGlvbkZyb21Nb21lbnQodGhpcywgZHVyLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGFkZE9yU3VidHJhY3REdXJhdGlvbkZyb21Nb21lbnQobW9tLCBkdXJhdGlvbiwgaXNBZGRpbmcsIHVwZGF0ZU9mZnNldCkge1xyXG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxyXG4gICAgICAgICAgICBkYXlzID0gZHVyYXRpb24uX2RheXMsXHJcbiAgICAgICAgICAgIG1vbnRocyA9IGR1cmF0aW9uLl9tb250aHM7XHJcbiAgICAgICAgdXBkYXRlT2Zmc2V0ID0gdXBkYXRlT2Zmc2V0ID09IG51bGwgPyB0cnVlIDogdXBkYXRlT2Zmc2V0O1xyXG5cclxuICAgICAgICBpZiAobWlsbGlzZWNvbmRzKSB7XHJcbiAgICAgICAgICAgIG1vbS5fZC5zZXRUaW1lKCttb20uX2QgKyBtaWxsaXNlY29uZHMgKiBpc0FkZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChkYXlzKSB7XHJcbiAgICAgICAgICAgIHJhd1NldHRlcihtb20sICdEYXRlJywgcmF3R2V0dGVyKG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtb250aHMpIHtcclxuICAgICAgICAgICAgcmF3TW9udGhTZXR0ZXIobW9tLCByYXdHZXR0ZXIobW9tLCAnTW9udGgnKSArIG1vbnRocyAqIGlzQWRkaW5nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHVwZGF0ZU9mZnNldCkge1xyXG4gICAgICAgICAgICBtb21lbnQudXBkYXRlT2Zmc2V0KG1vbSwgZGF5cyB8fCBtb250aHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBjaGVjayBpZiBpcyBhbiBhcnJheVxyXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBBcnJheV0nO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzRGF0ZShpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBEYXRlXScgfHxcclxuICAgICAgICAgICAgaW5wdXQgaW5zdGFuY2VvZiBEYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGNvbXBhcmUgdHdvIGFycmF5cywgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGlmZmVyZW5jZXNcclxuICAgIGZ1bmN0aW9uIGNvbXBhcmVBcnJheXMoYXJyYXkxLCBhcnJheTIsIGRvbnRDb252ZXJ0KSB7XHJcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxyXG4gICAgICAgICAgICBsZW5ndGhEaWZmID0gTWF0aC5hYnMoYXJyYXkxLmxlbmd0aCAtIGFycmF5Mi5sZW5ndGgpLFxyXG4gICAgICAgICAgICBkaWZmcyA9IDAsXHJcbiAgICAgICAgICAgIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICgoZG9udENvbnZlcnQgJiYgYXJyYXkxW2ldICE9PSBhcnJheTJbaV0pIHx8XHJcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmcysrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaWZmcyArIGxlbmd0aERpZmY7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcclxuICAgICAgICBpZiAodW5pdHMpIHtcclxuICAgICAgICAgICAgdmFyIGxvd2VyZWQgPSB1bml0cy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyguKXMkLywgJyQxJyk7XHJcbiAgICAgICAgICAgIHVuaXRzID0gdW5pdEFsaWFzZXNbdW5pdHNdIHx8IGNhbWVsRnVuY3Rpb25zW2xvd2VyZWRdIHx8IGxvd2VyZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1bml0cztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpemVPYmplY3RVbml0cyhpbnB1dE9iamVjdCkge1xyXG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcclxuICAgICAgICAgICAgbm9ybWFsaXplZFByb3AsXHJcbiAgICAgICAgICAgIHByb3A7XHJcblxyXG4gICAgICAgIGZvciAocHJvcCBpbiBpbnB1dE9iamVjdCkge1xyXG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcChpbnB1dE9iamVjdCwgcHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9ybWFsaXplZFByb3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkSW5wdXRbbm9ybWFsaXplZFByb3BdID0gaW5wdXRPYmplY3RbcHJvcF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBub3JtYWxpemVkSW5wdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZUxpc3QoZmllbGQpIHtcclxuICAgICAgICB2YXIgY291bnQsIHNldHRlcjtcclxuXHJcbiAgICAgICAgaWYgKGZpZWxkLmluZGV4T2YoJ3dlZWsnKSA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb3VudCA9IDc7XHJcbiAgICAgICAgICAgIHNldHRlciA9ICdkYXknO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmaWVsZC5pbmRleE9mKCdtb250aCcpID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvdW50ID0gMTI7XHJcbiAgICAgICAgICAgIHNldHRlciA9ICdtb250aCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBtb21lbnRbZmllbGRdID0gZnVuY3Rpb24gKGZvcm1hdCwgaW5kZXgpIHtcclxuICAgICAgICAgICAgdmFyIGksIGdldHRlcixcclxuICAgICAgICAgICAgICAgIG1ldGhvZCA9IG1vbWVudC5fbG9jYWxlW2ZpZWxkXSxcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XHJcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGdldHRlciA9IGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbSA9IG1vbWVudCgpLnV0YygpLnNldChzZXR0ZXIsIGkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5jYWxsKG1vbWVudC5fbG9jYWxlLCBtLCBmb3JtYXQgfHwgJycpO1xyXG4gICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBnZXR0ZXIoaW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0dGVyKGkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB0b0ludChhcmd1bWVudEZvckNvZXJjaW9uKSB7XHJcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcclxuICAgICAgICAgICAgdmFsdWUgPSAwO1xyXG5cclxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xyXG4gICAgICAgICAgICBpZiAoY29lcmNlZE51bWJlciA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IoY29lcmNlZE51bWJlcik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGguY2VpbChjb2VyY2VkTnVtYmVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoICsgMSwgMCkpLmdldFVUQ0RhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiB3ZWVrc0luWWVhcih5ZWFyLCBkb3csIGRveSkge1xyXG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbWVudChbeWVhciwgMTEsIDMxICsgZG93IC0gZG95XSksIGRvdywgZG95KS53ZWVrO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xyXG4gICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHllYXIpID8gMzY2IDogMzY1O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcikge1xyXG4gICAgICAgIHJldHVybiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCkgfHwgeWVhciAlIDQwMCA9PT0gMDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93KG0pIHtcclxuICAgICAgICB2YXIgb3ZlcmZsb3c7XHJcbiAgICAgICAgaWYgKG0uX2EgJiYgbS5fcGYub3ZlcmZsb3cgPT09IC0yKSB7XHJcbiAgICAgICAgICAgIG92ZXJmbG93ID1cclxuICAgICAgICAgICAgICAgIG0uX2FbTU9OVEhdIDwgMCB8fCBtLl9hW01PTlRIXSA+IDExID8gTU9OVEggOlxyXG4gICAgICAgICAgICAgICAgbS5fYVtEQVRFXSA8IDEgfHwgbS5fYVtEQVRFXSA+IGRheXNJbk1vbnRoKG0uX2FbWUVBUl0sIG0uX2FbTU9OVEhdKSA/IERBVEUgOlxyXG4gICAgICAgICAgICAgICAgbS5fYVtIT1VSXSA8IDAgfHwgbS5fYVtIT1VSXSA+IDI0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKG0uX2FbSE9VUl0gPT09IDI0ICYmIChtLl9hW01JTlVURV0gIT09IDAgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0uX2FbU0VDT05EXSAhPT0gMCB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbS5fYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxyXG4gICAgICAgICAgICAgICAgbS5fYVtNSU5VVEVdIDwgMCB8fCBtLl9hW01JTlVURV0gPiA1OSA/IE1JTlVURSA6XHJcbiAgICAgICAgICAgICAgICBtLl9hW1NFQ09ORF0gPCAwIHx8IG0uX2FbU0VDT05EXSA+IDU5ID8gU0VDT05EIDpcclxuICAgICAgICAgICAgICAgIG0uX2FbTUlMTElTRUNPTkRdIDwgMCB8fCBtLl9hW01JTExJU0VDT05EXSA+IDk5OSA/IE1JTExJU0VDT05EIDpcclxuICAgICAgICAgICAgICAgIC0xO1xyXG5cclxuICAgICAgICAgICAgaWYgKG0uX3BmLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gREFURTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbS5fcGYub3ZlcmZsb3cgPSBvdmVyZmxvdztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaXNWYWxpZChtKSB7XHJcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBtLl9pc1ZhbGlkID0gIWlzTmFOKG0uX2QuZ2V0VGltZSgpKSAmJlxyXG4gICAgICAgICAgICAgICAgbS5fcGYub3ZlcmZsb3cgPCAwICYmXHJcbiAgICAgICAgICAgICAgICAhbS5fcGYuZW1wdHkgJiZcclxuICAgICAgICAgICAgICAgICFtLl9wZi5pbnZhbGlkTW9udGggJiZcclxuICAgICAgICAgICAgICAgICFtLl9wZi5udWxsSW5wdXQgJiZcclxuICAgICAgICAgICAgICAgICFtLl9wZi5pbnZhbGlkRm9ybWF0ICYmXHJcbiAgICAgICAgICAgICAgICAhbS5fcGYudXNlckludmFsaWRhdGVkO1xyXG5cclxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xyXG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IG0uX2lzVmFsaWQgJiZcclxuICAgICAgICAgICAgICAgICAgICBtLl9wZi5jaGFyc0xlZnRPdmVyID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICAgICAgbS5fcGYudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG0uX3BmLmJpZ0hvdXIgPT09IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIGtleSA/IGtleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJ18nLCAnLScpIDoga2V5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHBpY2sgdGhlIGxvY2FsZSBmcm9tIHRoZSBhcnJheVxyXG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcclxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcclxuICAgIGZ1bmN0aW9uIGNob29zZUxvY2FsZShuYW1lcykge1xyXG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcclxuXHJcbiAgICAgICAgd2hpbGUgKGkgPCBuYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XHJcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XHJcbiAgICAgICAgICAgIG5leHQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaSArIDFdKTtcclxuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xyXG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoc3BsaXQuc2xpY2UoMCwgaikuam9pbignLScpKTtcclxuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGotLTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGxvYWRMb2NhbGUobmFtZSkge1xyXG4gICAgICAgIHZhciBvbGRMb2NhbGUgPSBudWxsO1xyXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiBoYXNNb2R1bGUpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IG1vbWVudC5sb2NhbGUoKTtcclxuICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vbG9jYWxlLycgKyBuYW1lKTtcclxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZGVmaW5lTG9jYWxlIGN1cnJlbnRseSBhbHNvIHNldHMgdGhlIGdsb2JhbCBsb2NhbGUsIHdlIHdhbnQgdG8gdW5kbyB0aGF0IGZvciBsYXp5IGxvYWRlZCBsb2NhbGVzXHJcbiAgICAgICAgICAgICAgICBtb21lbnQubG9jYWxlKG9sZExvY2FsZSk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXR1cm4gYSBtb21lbnQgZnJvbSBpbnB1dCwgdGhhdCBpcyBsb2NhbC91dGMvem9uZSBlcXVpdmFsZW50IHRvIG1vZGVsLlxyXG4gICAgZnVuY3Rpb24gbWFrZUFzKGlucHV0LCBtb2RlbCkge1xyXG4gICAgICAgIHZhciByZXMsIGRpZmY7XHJcbiAgICAgICAgaWYgKG1vZGVsLl9pc1VUQykge1xyXG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBkaWZmID0gKG1vbWVudC5pc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/XHJcbiAgICAgICAgICAgICAgICAgICAgK2lucHV0IDogK21vbWVudChpbnB1dCkpIC0gKCtyZXMpO1xyXG4gICAgICAgICAgICAvLyBVc2UgbG93LWxldmVsIGFwaSwgYmVjYXVzZSB0aGlzIGZuIGlzIGxvdy1sZXZlbCBhcGkuXHJcbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKCtyZXMuX2QgKyBkaWZmKTtcclxuICAgICAgICAgICAgbW9tZW50LnVwZGF0ZU9mZnNldChyZXMsIGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50KGlucHV0KS5sb2NhbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICAgICAgTG9jYWxlXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuICAgIGV4dGVuZChMb2NhbGUucHJvdG90eXBlLCB7XHJcblxyXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgICAgICAgdmFyIHByb3AsIGk7XHJcbiAgICAgICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcclxuICAgICAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXHJcbiAgICAgICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX29yZGluYWxQYXJzZUxlbmllbnQuXHJcbiAgICAgICAgICAgIHRoaXMuX29yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UgKyAnfCcgKyAvXFxkezEsMn0vLnNvdXJjZSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX21vbnRocyA6ICdKYW51YXJ5X0ZlYnJ1YXJ5X01hcmNoX0FwcmlsX01heV9KdW5lX0p1bHlfQXVndXN0X1NlcHRlbWJlcl9PY3RvYmVyX05vdmVtYmVyX0RlY2VtYmVyJy5zcGxpdCgnXycpLFxyXG4gICAgICAgIG1vbnRocyA6IGZ1bmN0aW9uIChtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNbbS5tb250aCgpXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfbW9udGhzU2hvcnQgOiAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyksXHJcbiAgICAgICAgbW9udGhzU2hvcnQgOiBmdW5jdGlvbiAobSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzU2hvcnRbbS5tb250aCgpXTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtb250aHNQYXJzZSA6IGZ1bmN0aW9uIChtb250aE5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xyXG5cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XHJcbiAgICAgICAgICAgICAgICBtb20gPSBtb21lbnQudXRjKFsyMDAwLCBpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcclxuICAgICAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3dlZWtkYXlzIDogJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpLFxyXG4gICAgICAgIHdlZWtkYXlzIDogZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzW20uZGF5KCldO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF93ZWVrZGF5c1Nob3J0IDogJ1N1bl9Nb25fVHVlX1dlZF9UaHVfRnJpX1NhdCcuc3BsaXQoJ18nKSxcclxuICAgICAgICB3ZWVrZGF5c1Nob3J0IDogZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3dlZWtkYXlzTWluIDogJ1N1X01vX1R1X1dlX1RoX0ZyX1NhJy5zcGxpdCgnXycpLFxyXG4gICAgICAgIHdlZWtkYXlzTWluIDogZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHdlZWtkYXlzUGFyc2UgOiBmdW5jdGlvbiAod2Vla2RheU5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2UpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2UgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3dlZWtkYXlzUGFyc2VbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBtb20gPSBtb21lbnQoWzIwMDAsIDFdKS5kYXkoaSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLndlZWtkYXlzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzTWluKG1vbSwgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9sb25nRGF0ZUZvcm1hdCA6IHtcclxuICAgICAgICAgICAgTFRTIDogJ2g6bW06c3MgQScsXHJcbiAgICAgICAgICAgIExUIDogJ2g6bW0gQScsXHJcbiAgICAgICAgICAgIEwgOiAnTU0vREQvWVlZWScsXHJcbiAgICAgICAgICAgIExMIDogJ01NTU0gRCwgWVlZWScsXHJcbiAgICAgICAgICAgIExMTCA6ICdNTU1NIEQsIFlZWVkgTFQnLFxyXG4gICAgICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBMVCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0IDogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcclxuICAgICAgICAgICAgaWYgKCFvdXRwdXQgJiYgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldKSB7XHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV0ucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gb3V0cHV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNQTSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXHJcbiAgICAgICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxyXG4gICAgICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfbWVyaWRpZW1QYXJzZSA6IC9bYXBdXFwuP20/XFwuPy9pLFxyXG4gICAgICAgIG1lcmlkaWVtIDogZnVuY3Rpb24gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XHJcbiAgICAgICAgICAgIGlmIChob3VycyA+IDExKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIF9jYWxlbmRhciA6IHtcclxuICAgICAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcclxuICAgICAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcclxuICAgICAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcclxuICAgICAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXHJcbiAgICAgICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxyXG4gICAgICAgICAgICBzYW1lRWxzZSA6ICdMJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2FsZW5kYXIgOiBmdW5jdGlvbiAoa2V5LCBtb20sIG5vdykge1xyXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XTtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicgPyBvdXRwdXQuYXBwbHkobW9tLCBbbm93XSkgOiBvdXRwdXQ7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3JlbGF0aXZlVGltZSA6IHtcclxuICAgICAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcclxuICAgICAgICAgICAgcGFzdCA6ICclcyBhZ28nLFxyXG4gICAgICAgICAgICBzIDogJ2EgZmV3IHNlY29uZHMnLFxyXG4gICAgICAgICAgICBtIDogJ2EgbWludXRlJyxcclxuICAgICAgICAgICAgbW0gOiAnJWQgbWludXRlcycsXHJcbiAgICAgICAgICAgIGggOiAnYW4gaG91cicsXHJcbiAgICAgICAgICAgIGhoIDogJyVkIGhvdXJzJyxcclxuICAgICAgICAgICAgZCA6ICdhIGRheScsXHJcbiAgICAgICAgICAgIGRkIDogJyVkIGRheXMnLFxyXG4gICAgICAgICAgICBNIDogJ2EgbW9udGgnLFxyXG4gICAgICAgICAgICBNTSA6ICclZCBtb250aHMnLFxyXG4gICAgICAgICAgICB5IDogJ2EgeWVhcicsXHJcbiAgICAgICAgICAgIHl5IDogJyVkIHllYXJzJ1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHJlbGF0aXZlVGltZSA6IGZ1bmN0aW9uIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcclxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xyXG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicpID9cclxuICAgICAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcclxuICAgICAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBhc3RGdXR1cmUgOiBmdW5jdGlvbiAoZGlmZiwgb3V0cHV0KSB7XHJcbiAgICAgICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLl9yZWxhdGl2ZVRpbWVbZGlmZiA+IDAgPyAnZnV0dXJlJyA6ICdwYXN0J107XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09PSAnZnVuY3Rpb24nID8gZm9ybWF0KG91dHB1dCkgOiBmb3JtYXQucmVwbGFjZSgvJXMvaSwgb3V0cHV0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBvcmRpbmFsIDogZnVuY3Rpb24gKG51bWJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fb3JkaW5hbC5yZXBsYWNlKCclZCcsIG51bWJlcik7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBfb3JkaW5hbCA6ICclZCcsXHJcbiAgICAgICAgX29yZGluYWxQYXJzZSA6IC9cXGR7MSwyfS8sXHJcblxyXG4gICAgICAgIHByZXBhcnNlIDogZnVuY3Rpb24gKHN0cmluZykge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBvc3Rmb3JtYXQgOiBmdW5jdGlvbiAoc3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgd2VlayA6IGZ1bmN0aW9uIChtb20pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobW9tLCB0aGlzLl93ZWVrLmRvdywgdGhpcy5fd2Vlay5kb3kpLndlZWs7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX3dlZWsgOiB7XHJcbiAgICAgICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxyXG4gICAgICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiAxc3QgaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgX2ludmFsaWREYXRlOiAnSW52YWxpZCBkYXRlJyxcclxuICAgICAgICBpbnZhbGlkRGF0ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgICAgIEZvcm1hdHRpbmdcclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xyXG4gICAgICAgIGlmIChpbnB1dC5tYXRjaCgvXFxbW1xcc1xcU10vKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1xcXFwvZywgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VGb3JtYXRGdW5jdGlvbihmb3JtYXQpIHtcclxuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcclxuXHJcbiAgICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xyXG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xyXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gJyc7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGFycmF5W2ldIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcclxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcclxuICAgICAgICBpZiAoIW0uaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xyXG5cclxuICAgICAgICBpZiAoIWZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XHJcbiAgICAgICAgdmFyIGkgPSA1O1xyXG5cclxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5sb25nRGF0ZUZvcm1hdChpbnB1dCkgfHwgaW5wdXQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcclxuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcclxuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xyXG4gICAgICAgICAgICBsb2NhbEZvcm1hdHRpbmdUb2tlbnMubGFzdEluZGV4ID0gMDtcclxuICAgICAgICAgICAgaSAtPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgICAgIFBhcnNpbmdcclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG4gICAgLy8gZ2V0IHRoZSByZWdleCB0byBmaW5kIHRoZSBuZXh0IHRva2VuXHJcbiAgICBmdW5jdGlvbiBnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykge1xyXG4gICAgICAgIHZhciBhLCBzdHJpY3QgPSBjb25maWcuX3N0cmljdDtcclxuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XHJcbiAgICAgICAgY2FzZSAnUSc6XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuT25lRGlnaXQ7XHJcbiAgICAgICAgY2FzZSAnRERERCc6XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVGhyZWVEaWdpdHM7XHJcbiAgICAgICAgY2FzZSAnWVlZWSc6XHJcbiAgICAgICAgY2FzZSAnR0dHRyc6XHJcbiAgICAgICAgY2FzZSAnZ2dnZyc6XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3QgPyBwYXJzZVRva2VuRm91ckRpZ2l0cyA6IHBhcnNlVG9rZW5PbmVUb0ZvdXJEaWdpdHM7XHJcbiAgICAgICAgY2FzZSAnWSc6XHJcbiAgICAgICAgY2FzZSAnRyc6XHJcbiAgICAgICAgY2FzZSAnZyc6XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuU2lnbmVkTnVtYmVyO1xyXG4gICAgICAgIGNhc2UgJ1lZWVlZWSc6XHJcbiAgICAgICAgY2FzZSAnWVlZWVknOlxyXG4gICAgICAgIGNhc2UgJ0dHR0dHJzpcclxuICAgICAgICBjYXNlICdnZ2dnZyc6XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3QgPyBwYXJzZVRva2VuU2l4RGlnaXRzIDogcGFyc2VUb2tlbk9uZVRvU2l4RGlnaXRzO1xyXG4gICAgICAgIGNhc2UgJ1MnOlxyXG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbk9uZURpZ2l0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICBjYXNlICdTUyc6XHJcbiAgICAgICAgICAgIGlmIChzdHJpY3QpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVHdvRGlnaXRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICBjYXNlICdTU1MnOlxyXG4gICAgICAgICAgICBpZiAoc3RyaWN0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblRocmVlRGlnaXRzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICBjYXNlICdEREQnOlxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbk9uZVRvVGhyZWVEaWdpdHM7XHJcbiAgICAgICAgY2FzZSAnTU1NJzpcclxuICAgICAgICBjYXNlICdNTU1NJzpcclxuICAgICAgICBjYXNlICdkZCc6XHJcbiAgICAgICAgY2FzZSAnZGRkJzpcclxuICAgICAgICBjYXNlICdkZGRkJzpcclxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVG9rZW5Xb3JkO1xyXG4gICAgICAgIGNhc2UgJ2EnOlxyXG4gICAgICAgIGNhc2UgJ0EnOlxyXG4gICAgICAgICAgICByZXR1cm4gY29uZmlnLl9sb2NhbGUuX21lcmlkaWVtUGFyc2U7XHJcbiAgICAgICAgY2FzZSAneCc6XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuT2Zmc2V0TXM7XHJcbiAgICAgICAgY2FzZSAnWCc6XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuVGltZXN0YW1wTXM7XHJcbiAgICAgICAgY2FzZSAnWic6XHJcbiAgICAgICAgY2FzZSAnWlonOlxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblRpbWV6b25lO1xyXG4gICAgICAgIGNhc2UgJ1QnOlxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlblQ7XHJcbiAgICAgICAgY2FzZSAnU1NTUyc6XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVRva2VuRGlnaXRzO1xyXG4gICAgICAgIGNhc2UgJ01NJzpcclxuICAgICAgICBjYXNlICdERCc6XHJcbiAgICAgICAgY2FzZSAnWVknOlxyXG4gICAgICAgIGNhc2UgJ0dHJzpcclxuICAgICAgICBjYXNlICdnZyc6XHJcbiAgICAgICAgY2FzZSAnSEgnOlxyXG4gICAgICAgIGNhc2UgJ2hoJzpcclxuICAgICAgICBjYXNlICdtbSc6XHJcbiAgICAgICAgY2FzZSAnc3MnOlxyXG4gICAgICAgIGNhc2UgJ3d3JzpcclxuICAgICAgICBjYXNlICdXVyc6XHJcbiAgICAgICAgICAgIHJldHVybiBzdHJpY3QgPyBwYXJzZVRva2VuVHdvRGlnaXRzIDogcGFyc2VUb2tlbk9uZU9yVHdvRGlnaXRzO1xyXG4gICAgICAgIGNhc2UgJ00nOlxyXG4gICAgICAgIGNhc2UgJ0QnOlxyXG4gICAgICAgIGNhc2UgJ2QnOlxyXG4gICAgICAgIGNhc2UgJ0gnOlxyXG4gICAgICAgIGNhc2UgJ2gnOlxyXG4gICAgICAgIGNhc2UgJ20nOlxyXG4gICAgICAgIGNhc2UgJ3MnOlxyXG4gICAgICAgIGNhc2UgJ3cnOlxyXG4gICAgICAgIGNhc2UgJ1cnOlxyXG4gICAgICAgIGNhc2UgJ2UnOlxyXG4gICAgICAgIGNhc2UgJ0UnOlxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VUb2tlbk9uZU9yVHdvRGlnaXRzO1xyXG4gICAgICAgIGNhc2UgJ0RvJzpcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmljdCA/IGNvbmZpZy5fbG9jYWxlLl9vcmRpbmFsUGFyc2UgOiBjb25maWcuX2xvY2FsZS5fb3JkaW5hbFBhcnNlTGVuaWVudDtcclxuICAgICAgICBkZWZhdWx0IDpcclxuICAgICAgICAgICAgYSA9IG5ldyBSZWdFeHAocmVnZXhwRXNjYXBlKHVuZXNjYXBlRm9ybWF0KHRva2VuLnJlcGxhY2UoJ1xcXFwnLCAnJykpLCAnaScpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHRpbWV6b25lTWludXRlc0Zyb21TdHJpbmcoc3RyaW5nKSB7XHJcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nIHx8ICcnO1xyXG4gICAgICAgIHZhciBwb3NzaWJsZVR6TWF0Y2hlcyA9IChzdHJpbmcubWF0Y2gocGFyc2VUb2tlblRpbWV6b25lKSB8fCBbXSksXHJcbiAgICAgICAgICAgIHR6Q2h1bmsgPSBwb3NzaWJsZVR6TWF0Y2hlc1twb3NzaWJsZVR6TWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXSxcclxuICAgICAgICAgICAgcGFydHMgPSAodHpDaHVuayArICcnKS5tYXRjaChwYXJzZVRpbWV6b25lQ2h1bmtlcikgfHwgWyctJywgMCwgMF0sXHJcbiAgICAgICAgICAgIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xyXG5cclxuICAgICAgICByZXR1cm4gcGFydHNbMF0gPT09ICcrJyA/IC1taW51dGVzIDogbWludXRlcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBmdW5jdGlvbiB0byBjb252ZXJ0IHN0cmluZyBpbnB1dCB0byBkYXRlXHJcbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xyXG4gICAgICAgIHZhciBhLCBkYXRlUGFydEFycmF5ID0gY29uZmlnLl9hO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XHJcbiAgICAgICAgLy8gUVVBUlRFUlxyXG4gICAgICAgIGNhc2UgJ1EnOlxyXG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIE1PTlRIXHJcbiAgICAgICAgY2FzZSAnTScgOiAvLyBmYWxsIHRocm91Z2ggdG8gTU1cclxuICAgICAgICBjYXNlICdNTScgOlxyXG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ01NTScgOiAvLyBmYWxsIHRocm91Z2ggdG8gTU1NTVxyXG4gICAgICAgIGNhc2UgJ01NTU0nIDpcclxuICAgICAgICAgICAgYSA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cclxuICAgICAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtNT05USF0gPSBhO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi5pbnZhbGlkTW9udGggPSBpbnB1dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBEQVkgT0YgTU9OVEhcclxuICAgICAgICBjYXNlICdEJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBERFxyXG4gICAgICAgIGNhc2UgJ0REJyA6XHJcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlUGFydEFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ0RvJyA6XHJcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlUGFydEFycmF5W0RBVEVdID0gdG9JbnQocGFyc2VJbnQoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5tYXRjaCgvXFxkezEsMn0vKVswXSwgMTApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBEQVkgT0YgWUVBUlxyXG4gICAgICAgIGNhc2UgJ0RERCcgOiAvLyBmYWxsIHRocm91Z2ggdG8gRERERFxyXG4gICAgICAgIGNhc2UgJ0REREQnIDpcclxuICAgICAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBZRUFSXHJcbiAgICAgICAgY2FzZSAnWVknIDpcclxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtZRUFSXSA9IG1vbWVudC5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ1lZWVknIDpcclxuICAgICAgICBjYXNlICdZWVlZWScgOlxyXG4gICAgICAgIGNhc2UgJ1lZWVlZWScgOlxyXG4gICAgICAgICAgICBkYXRlUGFydEFycmF5W1lFQVJdID0gdG9JbnQoaW5wdXQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBBTSAvIFBNXHJcbiAgICAgICAgY2FzZSAnYScgOiAvLyBmYWxsIHRocm91Z2ggdG8gQVxyXG4gICAgICAgIGNhc2UgJ0EnIDpcclxuICAgICAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIEhPVVJcclxuICAgICAgICBjYXNlICdoJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBoaFxyXG4gICAgICAgIGNhc2UgJ2hoJyA6XHJcbiAgICAgICAgICAgIGNvbmZpZy5fcGYuYmlnSG91ciA9IHRydWU7XHJcbiAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICBjYXNlICdIJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBISFxyXG4gICAgICAgIGNhc2UgJ0hIJyA6XHJcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIE1JTlVURVxyXG4gICAgICAgIGNhc2UgJ20nIDogLy8gZmFsbCB0aHJvdWdoIHRvIG1tXHJcbiAgICAgICAgY2FzZSAnbW0nIDpcclxuICAgICAgICAgICAgZGF0ZVBhcnRBcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBTRUNPTkRcclxuICAgICAgICBjYXNlICdzJyA6IC8vIGZhbGwgdGhyb3VnaCB0byBzc1xyXG4gICAgICAgIGNhc2UgJ3NzJyA6XHJcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gTUlMTElTRUNPTkRcclxuICAgICAgICBjYXNlICdTJyA6XHJcbiAgICAgICAgY2FzZSAnU1MnIDpcclxuICAgICAgICBjYXNlICdTU1MnIDpcclxuICAgICAgICBjYXNlICdTU1NTJyA6XHJcbiAgICAgICAgICAgIGRhdGVQYXJ0QXJyYXlbTUlMTElTRUNPTkRdID0gdG9JbnQoKCcwLicgKyBpbnB1dCkgKiAxMDAwKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gVU5JWCBPRkZTRVQgKE1JTExJU0VDT05EUylcclxuICAgICAgICBjYXNlICd4JzpcclxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gVU5JWCBUSU1FU1RBTVAgV0lUSCBNU1xyXG4gICAgICAgIGNhc2UgJ1gnOlxyXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShwYXJzZUZsb2F0KGlucHV0KSAqIDEwMDApO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBUSU1FWk9ORVxyXG4gICAgICAgIGNhc2UgJ1onIDogLy8gZmFsbCB0aHJvdWdoIHRvIFpaXHJcbiAgICAgICAgY2FzZSAnWlonIDpcclxuICAgICAgICAgICAgY29uZmlnLl91c2VVVEMgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25maWcuX3R6bSA9IHRpbWV6b25lTWludXRlc0Zyb21TdHJpbmcoaW5wdXQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAvLyBXRUVLREFZIC0gaHVtYW5cclxuICAgICAgICBjYXNlICdkZCc6XHJcbiAgICAgICAgY2FzZSAnZGRkJzpcclxuICAgICAgICBjYXNlICdkZGRkJzpcclxuICAgICAgICAgICAgYSA9IGNvbmZpZy5fbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpO1xyXG4gICAgICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZ2V0IGEgd2Vla2RheSBuYW1lLCBtYXJrIHRoZSBkYXRlIGFzIGludmFsaWRcclxuICAgICAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLl93ID0gY29uZmlnLl93IHx8IHt9O1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLl93WydkJ10gPSBhO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIC8vIFdFRUssIFdFRUsgREFZIC0gbnVtZXJpY1xyXG4gICAgICAgIGNhc2UgJ3cnOlxyXG4gICAgICAgIGNhc2UgJ3d3JzpcclxuICAgICAgICBjYXNlICdXJzpcclxuICAgICAgICBjYXNlICdXVyc6XHJcbiAgICAgICAgY2FzZSAnZCc6XHJcbiAgICAgICAgY2FzZSAnZSc6XHJcbiAgICAgICAgY2FzZSAnRSc6XHJcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW4uc3Vic3RyKDAsIDEpO1xyXG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgY2FzZSAnZ2dnZyc6XHJcbiAgICAgICAgY2FzZSAnR0dHRyc6XHJcbiAgICAgICAgY2FzZSAnR0dHR0cnOlxyXG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnN1YnN0cigwLCAyKTtcclxuICAgICAgICAgICAgaWYgKGlucHV0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XHJcbiAgICAgICAgICAgICAgICBjb25maWcuX3dbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2dnJzpcclxuICAgICAgICBjYXNlICdHRyc6XHJcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcclxuICAgICAgICAgICAgY29uZmlnLl93W3Rva2VuXSA9IG1vbWVudC5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpIHtcclxuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wO1xyXG5cclxuICAgICAgICB3ID0gY29uZmlnLl93O1xyXG4gICAgICAgIGlmICh3LkdHICE9IG51bGwgfHwgdy5XICE9IG51bGwgfHwgdy5FICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZG93ID0gMTtcclxuICAgICAgICAgICAgZG95ID0gNDtcclxuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxyXG4gICAgICAgICAgICAvLyBob3cgd2UgaW50ZXJwcmV0IG5vdyAobG9jYWwsIHV0YywgZml4ZWQgb2Zmc2V0KS4gU28gY3JlYXRlXHJcbiAgICAgICAgICAgIC8vIGEgbm93IHZlcnNpb24gb2YgY3VycmVudCBjb25maWcgKHRha2UgbG9jYWwvdXRjL29mZnNldCBmbGFncywgYW5kXHJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxyXG4gICAgICAgICAgICB3ZWVrWWVhciA9IGRmbCh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobW9tZW50KCksIDEsIDQpLnllYXIpO1xyXG4gICAgICAgICAgICB3ZWVrID0gZGZsKHcuVywgMSk7XHJcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZmwody5FLCAxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkb3cgPSBjb25maWcuX2xvY2FsZS5fd2Vlay5kb3c7XHJcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcclxuXHJcbiAgICAgICAgICAgIHdlZWtZZWFyID0gZGZsKHcuZ2csIGNvbmZpZy5fYVtZRUFSXSwgd2Vla09mWWVhcihtb21lbnQoKSwgZG93LCBkb3kpLnllYXIpO1xyXG4gICAgICAgICAgICB3ZWVrID0gZGZsKHcudywgMSk7XHJcblxyXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIC8vIHdlZWtkYXkgLS0gbG93IGRheSBudW1iZXJzIGFyZSBjb25zaWRlcmVkIG5leHQgd2Vla1xyXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcclxuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgZG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgKyt3ZWVrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBsb2NhbCB3ZWVrZGF5IC0tIGNvdW50aW5nIHN0YXJ0cyBmcm9tIGJlZ2luaW5nIG9mIHdlZWtcclxuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IHRvIGJlZ2luaW5nIG9mIHdlZWtcclxuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG95LCBkb3cpO1xyXG5cclxuICAgICAgICBjb25maWcuX2FbWUVBUl0gPSB0ZW1wLnllYXI7XHJcbiAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBjb252ZXJ0IGFuIGFycmF5IHRvIGEgZGF0ZS5cclxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XHJcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cclxuICAgIC8vIFt5ZWFyLCBtb250aCwgZGF5ICwgaG91ciwgbWludXRlLCBzZWNvbmQsIG1pbGxpc2Vjb25kXVxyXG4gICAgZnVuY3Rpb24gZGF0ZUZyb21Db25maWcoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCB5ZWFyVG9Vc2U7XHJcblxyXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XHJcblxyXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcclxuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vaWYgdGhlIGRheSBvZiB0aGUgeWVhciBpcyBzZXQsIGZpZ3VyZSBvdXQgd2hhdCBpdCBpc1xyXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhcikge1xyXG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZmwoY29uZmlnLl9hW1lFQVJdLCBjdXJyZW50RGF0ZVtZRUFSXSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoY29uZmlnLl9kYXlPZlllYXIgPiBkYXlzSW5ZZWFyKHllYXJUb1VzZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZGF0ZSA9IG1ha2VVVENEYXRlKHllYXJUb1VzZSwgMCwgY29uZmlnLl9kYXlPZlllYXIpO1xyXG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xyXG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxyXG4gICAgICAgIC8vICogaWYgbm8geWVhciwgbW9udGgsIGRheSBvZiBtb250aCBhcmUgZ2l2ZW4sIGRlZmF1bHQgdG8gdG9kYXlcclxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXHJcbiAgICAgICAgLy8gKiBpZiB5ZWFyIGlzIGdpdmVuLCBkb24ndCBkZWZhdWx0IGFueXRoaW5nXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xyXG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXHJcbiAgICAgICAgZm9yICg7IGkgPCA3OyBpKyspIHtcclxuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXHJcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSU5VVEVdID09PSAwICYmXHJcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBjb25maWcuX25leHREYXkgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gbWFrZVVUQ0RhdGUgOiBtYWtlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xyXG4gICAgICAgIC8vIEFwcGx5IHRpbWV6b25lIG9mZnNldCBmcm9tIGlucHV0LiBUaGUgYWN0dWFsIHpvbmUgY2FuIGJlIGNoYW5nZWRcclxuICAgICAgICAvLyB3aXRoIHBhcnNlWm9uZS5cclxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpICsgY29uZmlnLl90em0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xyXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAyNDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZGF0ZUZyb21PYmplY3QoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dDtcclxuXHJcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBub3JtYWxpemVkSW5wdXQgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xyXG4gICAgICAgIGNvbmZpZy5fYSA9IFtcclxuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0LnllYXIsXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5tb250aCxcclxuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0LmRheSB8fCBub3JtYWxpemVkSW5wdXQuZGF0ZSxcclxuICAgICAgICAgICAgbm9ybWFsaXplZElucHV0LmhvdXIsXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5taW51dGUsXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5zZWNvbmQsXHJcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dC5taWxsaXNlY29uZFxyXG4gICAgICAgIF07XHJcblxyXG4gICAgICAgIGRhdGVGcm9tQ29uZmlnKGNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcclxuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcclxuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIG5vdy5nZXRVVENGdWxsWWVhcigpLFxyXG4gICAgICAgICAgICAgICAgbm93LmdldFVUQ01vbnRoKCksXHJcbiAgICAgICAgICAgICAgICBub3cuZ2V0VVRDRGF0ZSgpXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBkYXRlIGZyb20gc3RyaW5nIGFuZCBmb3JtYXQgc3RyaW5nXHJcbiAgICBmdW5jdGlvbiBtYWtlRGF0ZUZyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XHJcbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gbW9tZW50LklTT184NjAxKSB7XHJcbiAgICAgICAgICAgIHBhcnNlSVNPKGNvbmZpZyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbmZpZy5fYSA9IFtdO1xyXG4gICAgICAgIGNvbmZpZy5fcGYuZW1wdHkgPSB0cnVlO1xyXG5cclxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxyXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcclxuICAgICAgICAgICAgaSwgcGFyc2VkSW5wdXQsIHRva2VucywgdG9rZW4sIHNraXBwZWQsXHJcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXHJcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xyXG5cclxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XHJcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcclxuICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxyXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLmVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb25maWcuX3N0cmljdCAmJiAhcGFyc2VkSW5wdXQpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5fcGYudW51c2VkVG9rZW5zLnB1c2godG9rZW4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXHJcbiAgICAgICAgY29uZmlnLl9wZi5jaGFyc0xlZnRPdmVyID0gc3RyaW5nTGVuZ3RoIC0gdG90YWxQYXJzZWRJbnB1dExlbmd0aDtcclxuICAgICAgICBpZiAoc3RyaW5nLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgY29uZmlnLl9wZi51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxyXG4gICAgICAgIGlmIChjb25maWcuX3BmLmJpZ0hvdXIgPT09IHRydWUgJiYgY29uZmlnLl9hW0hPVVJdIDw9IDEyKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fcGYuYmlnSG91ciA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaGFuZGxlIGFtIHBtXHJcbiAgICAgICAgaWYgKGNvbmZpZy5faXNQbSAmJiBjb25maWcuX2FbSE9VUl0gPCAxMikge1xyXG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gKz0gMTI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIGlzIDEyIGFtLCBjaGFuZ2UgaG91cnMgdG8gMFxyXG4gICAgICAgIGlmIChjb25maWcuX2lzUG0gPT09IGZhbHNlICYmIGNvbmZpZy5fYVtIT1VSXSA9PT0gMTIpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0ZUZyb21Db25maWcoY29uZmlnKTtcclxuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xyXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwMSB8fCBwMiB8fCBwMyB8fCBwNDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XHJcbiAgICBmdW5jdGlvbiByZWdleHBFc2NhcGUocykge1xyXG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXHJcbiAgICBmdW5jdGlvbiBtYWtlRGF0ZUZyb21TdHJpbmdBbmRBcnJheShjb25maWcpIHtcclxuICAgICAgICB2YXIgdGVtcENvbmZpZyxcclxuICAgICAgICAgICAgYmVzdE1vbWVudCxcclxuXHJcbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxyXG4gICAgICAgICAgICBpLFxyXG4gICAgICAgICAgICBjdXJyZW50U2NvcmU7XHJcblxyXG4gICAgICAgIGlmIChjb25maWcuX2YubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fcGYuaW52YWxpZEZvcm1hdCA9IHRydWU7XHJcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25maWcuX2YubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcclxuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XHJcbiAgICAgICAgICAgIGlmIChjb25maWcuX3VzZVVUQyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcclxuICAgICAgICAgICAgdGVtcENvbmZpZy5fZiA9IGNvbmZpZy5fZltpXTtcclxuICAgICAgICAgICAgbWFrZURhdGVGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKHRlbXBDb25maWcpKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcclxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IHRlbXBDb25maWcuX3BmLmNoYXJzTGVmdE92ZXI7XHJcblxyXG4gICAgICAgICAgICAvL29yIHRva2Vuc1xyXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gdGVtcENvbmZpZy5fcGYudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xyXG5cclxuICAgICAgICAgICAgdGVtcENvbmZpZy5fcGYuc2NvcmUgPSBjdXJyZW50U2NvcmU7XHJcblxyXG4gICAgICAgICAgICBpZiAoc2NvcmVUb0JlYXQgPT0gbnVsbCB8fCBjdXJyZW50U2NvcmUgPCBzY29yZVRvQmVhdCkge1xyXG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XHJcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXh0ZW5kKGNvbmZpZywgYmVzdE1vbWVudCB8fCB0ZW1wQ29uZmlnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBkYXRlIGZyb20gaXNvIGZvcm1hdFxyXG4gICAgZnVuY3Rpb24gcGFyc2VJU08oY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGksIGwsXHJcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcclxuICAgICAgICAgICAgbWF0Y2ggPSBpc29SZWdleC5leGVjKHN0cmluZyk7XHJcblxyXG4gICAgICAgIGlmIChtYXRjaCkge1xyXG4gICAgICAgICAgICBjb25maWcuX3BmLmlzbyA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29EYXRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKHN0cmluZykpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFs1XSBzaG91bGQgYmUgJ1QnIG9yIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fZiA9IGlzb0RhdGVzW2ldWzBdICsgKG1hdGNoWzZdIHx8ICcgJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb1RpbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMoc3RyaW5nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5fZiArPSBpc29UaW1lc1tpXVswXTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoc3RyaW5nLm1hdGNoKHBhcnNlVG9rZW5UaW1lem9uZSkpIHtcclxuICAgICAgICAgICAgICAgIGNvbmZpZy5fZiArPSAnWic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWFrZURhdGVGcm9tU3RyaW5nQW5kRm9ybWF0KGNvbmZpZyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXHJcbiAgICBmdW5jdGlvbiBtYWtlRGF0ZUZyb21TdHJpbmcoY29uZmlnKSB7XHJcbiAgICAgICAgcGFyc2VJU08oY29uZmlnKTtcclxuICAgICAgICBpZiAoY29uZmlnLl9pc1ZhbGlkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xyXG4gICAgICAgICAgICBtb21lbnQuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcclxuICAgICAgICB2YXIgcmVzID0gW10sIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xyXG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBtYWtlRGF0ZUZyb21JbnB1dChjb25maWcpIHtcclxuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksIG1hdGNoZWQ7XHJcbiAgICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGlzRGF0ZShpbnB1dCkpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK2lucHV0KTtcclxuICAgICAgICB9IGVsc2UgaWYgKChtYXRjaGVkID0gYXNwTmV0SnNvblJlZ2V4LmV4ZWMoaW5wdXQpKSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG1ha2VEYXRlRnJvbVN0cmluZyhjb25maWcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9hID0gbWFwKGlucHV0LnNsaWNlKDApLCBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQob2JqLCAxMCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBkYXRlRnJvbUNvbmZpZyhjb25maWcpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgZGF0ZUZyb21PYmplY3QoY29uZmlnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZihpbnB1dCkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIC8vIGZyb20gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBtb21lbnQuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZURhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpIHtcclxuICAgICAgICAvL2Nhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxyXG4gICAgICAgIC8vaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODEzNDgvaW5zdGFudGlhdGluZy1hLWphdmFzY3JpcHQtb2JqZWN0LWJ5LWNhbGxpbmctcHJvdG90eXBlLWNvbnN0cnVjdG9yLWFwcGx5XHJcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh5LCBtLCBkLCBoLCBNLCBzLCBtcyk7XHJcblxyXG4gICAgICAgIC8vdGhlIGRhdGUgY29uc3RydWN0b3IgZG9lc24ndCBhY2NlcHQgeWVhcnMgPCAxOTcwXHJcbiAgICAgICAgaWYgKHkgPCAxOTcwKSB7XHJcbiAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VVVENEYXRlKHkpIHtcclxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xyXG4gICAgICAgIGlmICh5IDwgMTk3MCkge1xyXG4gICAgICAgICAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBwYXJzZVdlZWtkYXkoaW5wdXQsIGxvY2FsZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dCA9IHBhcnNlSW50KGlucHV0LCAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgICAgICBSZWxhdGl2ZSBUaW1lXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXHJcbiAgICBmdW5jdGlvbiBzdWJzdGl0dXRlVGltZUFnbyhzdHJpbmcsIG51bWJlciwgd2l0aG91dFN1ZmZpeCwgaXNGdXR1cmUsIGxvY2FsZSkge1xyXG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHJlbGF0aXZlVGltZShwb3NOZWdEdXJhdGlvbiwgd2l0aG91dFN1ZmZpeCwgbG9jYWxlKSB7XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKHBvc05lZ0R1cmF0aW9uKS5hYnMoKSxcclxuICAgICAgICAgICAgc2Vjb25kcyA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpLFxyXG4gICAgICAgICAgICBtaW51dGVzID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSksXHJcbiAgICAgICAgICAgIGhvdXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSksXHJcbiAgICAgICAgICAgIGRheXMgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKSxcclxuICAgICAgICAgICAgbW9udGhzID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSksXHJcbiAgICAgICAgICAgIHllYXJzID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSksXHJcblxyXG4gICAgICAgICAgICBhcmdzID0gc2Vjb25kcyA8IHJlbGF0aXZlVGltZVRocmVzaG9sZHMucyAmJiBbJ3MnLCBzZWNvbmRzXSB8fFxyXG4gICAgICAgICAgICAgICAgbWludXRlcyA9PT0gMSAmJiBbJ20nXSB8fFxyXG4gICAgICAgICAgICAgICAgbWludXRlcyA8IHJlbGF0aXZlVGltZVRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10gfHxcclxuICAgICAgICAgICAgICAgIGhvdXJzID09PSAxICYmIFsnaCddIHx8XHJcbiAgICAgICAgICAgICAgICBob3VycyA8IHJlbGF0aXZlVGltZVRocmVzaG9sZHMuaCAmJiBbJ2hoJywgaG91cnNdIHx8XHJcbiAgICAgICAgICAgICAgICBkYXlzID09PSAxICYmIFsnZCddIHx8XHJcbiAgICAgICAgICAgICAgICBkYXlzIDwgcmVsYXRpdmVUaW1lVGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSB8fFxyXG4gICAgICAgICAgICAgICAgbW9udGhzID09PSAxICYmIFsnTSddIHx8XHJcbiAgICAgICAgICAgICAgICBtb250aHMgPCByZWxhdGl2ZVRpbWVUaHJlc2hvbGRzLk0gJiYgWydNTScsIG1vbnRoc10gfHxcclxuICAgICAgICAgICAgICAgIHllYXJzID09PSAxICYmIFsneSddIHx8IFsneXknLCB5ZWFyc107XHJcblxyXG4gICAgICAgIGFyZ3NbMl0gPSB3aXRob3V0U3VmZml4O1xyXG4gICAgICAgIGFyZ3NbM10gPSArcG9zTmVnRHVyYXRpb24gPiAwO1xyXG4gICAgICAgIGFyZ3NbNF0gPSBsb2NhbGU7XHJcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KHt9LCBhcmdzKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgICAgIFdlZWsgb2YgWWVhclxyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcbiAgICAvLyBmaXJzdERheU9mV2VlayAgICAgICAwID0gc3VuLCA2ID0gc2F0XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICB0aGUgZGF5IG9mIHRoZSB3ZWVrIHRoYXQgc3RhcnRzIHRoZSB3ZWVrXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAodXN1YWxseSBzdW5kYXkgb3IgbW9uZGF5KVxyXG4gICAgLy8gZmlyc3REYXlPZldlZWtPZlllYXIgMCA9IHN1biwgNiA9IHNhdFxyXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGhlIGZpcnN0IHdlZWsgaXMgdGhlIHdlZWsgdGhhdCBjb250YWlucyB0aGUgZmlyc3RcclxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIG9mIHRoaXMgZGF5IG9mIHRoZSB3ZWVrXHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAoZWcuIElTTyB3ZWVrcyB1c2UgdGh1cnNkYXkgKDQpKVxyXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGZpcnN0RGF5T2ZXZWVrLCBmaXJzdERheU9mV2Vla09mWWVhcikge1xyXG4gICAgICAgIHZhciBlbmQgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIGZpcnN0RGF5T2ZXZWVrLFxyXG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgPSBmaXJzdERheU9mV2Vla09mWWVhciAtIG1vbS5kYXkoKSxcclxuICAgICAgICAgICAgYWRqdXN0ZWRNb21lbnQ7XHJcblxyXG5cclxuICAgICAgICBpZiAoZGF5c1RvRGF5T2ZXZWVrID4gZW5kKSB7XHJcbiAgICAgICAgICAgIGRheXNUb0RheU9mV2VlayAtPSA3O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGRheXNUb0RheU9mV2VlayA8IGVuZCAtIDcpIHtcclxuICAgICAgICAgICAgZGF5c1RvRGF5T2ZXZWVrICs9IDc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhZGp1c3RlZE1vbWVudCA9IG1vbWVudChtb20pLmFkZChkYXlzVG9EYXlPZldlZWssICdkJyk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgd2VlazogTWF0aC5jZWlsKGFkanVzdGVkTW9tZW50LmRheU9mWWVhcigpIC8gNyksXHJcbiAgICAgICAgICAgIHllYXI6IGFkanVzdGVkTW9tZW50LnllYXIoKVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XHJcbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla3MoeWVhciwgd2Vlaywgd2Vla2RheSwgZmlyc3REYXlPZldlZWtPZlllYXIsIGZpcnN0RGF5T2ZXZWVrKSB7XHJcbiAgICAgICAgdmFyIGQgPSBtYWtlVVRDRGF0ZSh5ZWFyLCAwLCAxKS5nZXRVVENEYXkoKSwgZGF5c1RvQWRkLCBkYXlPZlllYXI7XHJcblxyXG4gICAgICAgIGQgPSBkID09PSAwID8gNyA6IGQ7XHJcbiAgICAgICAgd2Vla2RheSA9IHdlZWtkYXkgIT0gbnVsbCA/IHdlZWtkYXkgOiBmaXJzdERheU9mV2VlaztcclxuICAgICAgICBkYXlzVG9BZGQgPSBmaXJzdERheU9mV2VlayAtIGQgKyAoZCA+IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyID8gNyA6IDApIC0gKGQgPCBmaXJzdERheU9mV2VlayA/IDcgOiAwKTtcclxuICAgICAgICBkYXlPZlllYXIgPSA3ICogKHdlZWsgLSAxKSArICh3ZWVrZGF5IC0gZmlyc3REYXlPZldlZWspICsgZGF5c1RvQWRkICsgMTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgeWVhcjogZGF5T2ZZZWFyID4gMCA/IHllYXIgOiB5ZWFyIC0gMSxcclxuICAgICAgICAgICAgZGF5T2ZZZWFyOiBkYXlPZlllYXIgPiAwID8gIGRheU9mWWVhciA6IGRheXNJblllYXIoeWVhciAtIDEpICsgZGF5T2ZZZWFyXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICAgICAgVG9wIExldmVsIEZ1bmN0aW9uc1xyXG4gICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VNb21lbnQoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxyXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2YsXHJcbiAgICAgICAgICAgIHJlcztcclxuXHJcbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBtb21lbnQubG9jYWxlRGF0YShjb25maWcuX2wpO1xyXG5cclxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC5pbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGNvbmZpZy5faSA9IGlucHV0ID0gY29uZmlnLl9sb2NhbGUucHJlcGFyc2UoaW5wdXQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1vbWVudC5pc01vbWVudChpbnB1dCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb21lbnQoaW5wdXQsIHRydWUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0KSB7XHJcbiAgICAgICAgICAgIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcclxuICAgICAgICAgICAgICAgIG1ha2VEYXRlRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtYWtlRGF0ZUZyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIG1ha2VEYXRlRnJvbUlucHV0KGNvbmZpZyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXMgPSBuZXcgTW9tZW50KGNvbmZpZyk7XHJcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xyXG4gICAgICAgICAgICAvLyBBZGRpbmcgaXMgc21hcnQgZW5vdWdoIGFyb3VuZCBEU1RcclxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xyXG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmVzO1xyXG4gICAgfVxyXG5cclxuICAgIG1vbWVudCA9IGZ1bmN0aW9uIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xyXG4gICAgICAgIHZhciBjO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mKGxvY2FsZSkgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XHJcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcclxuICAgICAgICBjID0ge307XHJcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcclxuICAgICAgICBjLl9pID0gaW5wdXQ7XHJcbiAgICAgICAgYy5fZiA9IGZvcm1hdDtcclxuICAgICAgICBjLl9sID0gbG9jYWxlO1xyXG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcclxuICAgICAgICBjLl9pc1VUQyA9IGZhbHNlO1xyXG4gICAgICAgIGMuX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xyXG5cclxuICAgICAgICByZXR1cm4gbWFrZU1vbWVudChjKTtcclxuICAgIH07XHJcblxyXG4gICAgbW9tZW50LnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xyXG5cclxuICAgIG1vbWVudC5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcclxuICAgICAgICAnbW9tZW50IGNvbnN0cnVjdGlvbiBmYWxscyBiYWNrIHRvIGpzIERhdGUuIFRoaXMgaXMgJyArXHJcbiAgICAgICAgJ2Rpc2NvdXJhZ2VkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdXBjb21pbmcgbWFqb3IgJyArXHJcbiAgICAgICAgJ3JlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcclxuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MDcgZm9yIG1vcmUgaW5mby4nLFxyXG4gICAgICAgIGZ1bmN0aW9uIChjb25maWcpIHtcclxuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXHJcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXHJcbiAgICAvL1xyXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxyXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cclxuICAgIGZ1bmN0aW9uIHBpY2tCeShmbiwgbW9tZW50cykge1xyXG4gICAgICAgIHZhciByZXMsIGk7XHJcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcclxuICAgICAgICAgICAgbW9tZW50cyA9IG1vbWVudHNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xyXG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBtb21lbnRzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgICAgICAgIGlmIChtb21lbnRzW2ldW2ZuXShyZXMpKSB7XHJcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcblxyXG4gICAgbW9tZW50Lm1pbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcclxuICAgIH07XHJcblxyXG4gICAgbW9tZW50Lm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNBZnRlcicsIGFyZ3MpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBjcmVhdGluZyB3aXRoIHV0Y1xyXG4gICAgbW9tZW50LnV0YyA9IGZ1bmN0aW9uIChpbnB1dCwgZm9ybWF0LCBsb2NhbGUsIHN0cmljdCkge1xyXG4gICAgICAgIHZhciBjO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mKGxvY2FsZSkgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICBzdHJpY3QgPSBsb2NhbGU7XHJcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gb2JqZWN0IGNvbnN0cnVjdGlvbiBtdXN0IGJlIGRvbmUgdGhpcyB3YXkuXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcclxuICAgICAgICBjID0ge307XHJcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcclxuICAgICAgICBjLl91c2VVVEMgPSB0cnVlO1xyXG4gICAgICAgIGMuX2lzVVRDID0gdHJ1ZTtcclxuICAgICAgICBjLl9sID0gbG9jYWxlO1xyXG4gICAgICAgIGMuX2kgPSBpbnB1dDtcclxuICAgICAgICBjLl9mID0gZm9ybWF0O1xyXG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcclxuICAgICAgICBjLl9wZiA9IGRlZmF1bHRQYXJzaW5nRmxhZ3MoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIG1ha2VNb21lbnQoYykudXRjKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIGNyZWF0aW5nIHdpdGggdW5peCB0aW1lc3RhbXAgKGluIHNlY29uZHMpXHJcbiAgICBtb21lbnQudW5peCA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQoaW5wdXQgKiAxMDAwKTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gZHVyYXRpb25cclxuICAgIG1vbWVudC5kdXJhdGlvbiA9IGZ1bmN0aW9uIChpbnB1dCwga2V5KSB7XHJcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXHJcbiAgICAgICAgICAgIC8vIG1hdGNoaW5nIGFnYWluc3QgcmVnZXhwIGlzIGV4cGVuc2l2ZSwgZG8gaXQgb24gZGVtYW5kXHJcbiAgICAgICAgICAgIG1hdGNoID0gbnVsbCxcclxuICAgICAgICAgICAgc2lnbixcclxuICAgICAgICAgICAgcmV0LFxyXG4gICAgICAgICAgICBwYXJzZUlzbyxcclxuICAgICAgICAgICAgZGlmZlJlcztcclxuXHJcbiAgICAgICAgaWYgKG1vbWVudC5pc0R1cmF0aW9uKGlucHV0KSkge1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIG1zOiBpbnB1dC5fbWlsbGlzZWNvbmRzLFxyXG4gICAgICAgICAgICAgICAgZDogaW5wdXQuX2RheXMsXHJcbiAgICAgICAgICAgICAgICBNOiBpbnB1dC5fbW9udGhzXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XHJcbiAgICAgICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGFzcE5ldFRpbWVTcGFuSnNvblJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xyXG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIHk6IDAsXHJcbiAgICAgICAgICAgICAgICBkOiB0b0ludChtYXRjaFtEQVRFXSkgKiBzaWduLFxyXG4gICAgICAgICAgICAgICAgaDogdG9JbnQobWF0Y2hbSE9VUl0pICogc2lnbixcclxuICAgICAgICAgICAgICAgIG06IHRvSW50KG1hdGNoW01JTlVURV0pICogc2lnbixcclxuICAgICAgICAgICAgICAgIHM6IHRvSW50KG1hdGNoW1NFQ09ORF0pICogc2lnbixcclxuICAgICAgICAgICAgICAgIG1zOiB0b0ludChtYXRjaFtNSUxMSVNFQ09ORF0pICogc2lnblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29EdXJhdGlvblJlZ2V4LmV4ZWMoaW5wdXQpKSkge1xyXG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xyXG4gICAgICAgICAgICBwYXJzZUlzbyA9IGZ1bmN0aW9uIChpbnApIHtcclxuICAgICAgICAgICAgICAgIC8vIFdlJ2Qgbm9ybWFsbHkgdXNlIH5+aW5wIGZvciB0aGlzLCBidXQgdW5mb3J0dW5hdGVseSBpdCBhbHNvXHJcbiAgICAgICAgICAgICAgICAvLyBjb252ZXJ0cyBmbG9hdHMgdG8gaW50cy5cclxuICAgICAgICAgICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cclxuICAgICAgICAgICAgICAgIHZhciByZXMgPSBpbnAgJiYgcGFyc2VGbG9hdChpbnAucmVwbGFjZSgnLCcsICcuJykpO1xyXG4gICAgICAgICAgICAgICAgLy8gYXBwbHkgc2lnbiB3aGlsZSB3ZSdyZSBhdCBpdFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIHk6IHBhcnNlSXNvKG1hdGNoWzJdKSxcclxuICAgICAgICAgICAgICAgIE06IHBhcnNlSXNvKG1hdGNoWzNdKSxcclxuICAgICAgICAgICAgICAgIGQ6IHBhcnNlSXNvKG1hdGNoWzRdKSxcclxuICAgICAgICAgICAgICAgIGg6IHBhcnNlSXNvKG1hdGNoWzVdKSxcclxuICAgICAgICAgICAgICAgIG06IHBhcnNlSXNvKG1hdGNoWzZdKSxcclxuICAgICAgICAgICAgICAgIHM6IHBhcnNlSXNvKG1hdGNoWzddKSxcclxuICAgICAgICAgICAgICAgIHc6IHBhcnNlSXNvKG1hdGNoWzhdKVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGR1cmF0aW9uID09PSAnb2JqZWN0JyAmJlxyXG4gICAgICAgICAgICAgICAgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xyXG4gICAgICAgICAgICBkaWZmUmVzID0gbW9tZW50c0RpZmZlcmVuY2UobW9tZW50KGR1cmF0aW9uLmZyb20pLCBtb21lbnQoZHVyYXRpb24udG8pKTtcclxuXHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0ge307XHJcbiAgICAgICAgICAgIGR1cmF0aW9uLm1zID0gZGlmZlJlcy5taWxsaXNlY29uZHM7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XHJcblxyXG4gICAgICAgIGlmIChtb21lbnQuaXNEdXJhdGlvbihpbnB1dCkgJiYgaGFzT3duUHJvcChpbnB1dCwgJ19sb2NhbGUnKSkge1xyXG4gICAgICAgICAgICByZXQuX2xvY2FsZSA9IGlucHV0Ll9sb2NhbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyB2ZXJzaW9uIG51bWJlclxyXG4gICAgbW9tZW50LnZlcnNpb24gPSBWRVJTSU9OO1xyXG5cclxuICAgIC8vIGRlZmF1bHQgZm9ybWF0XHJcbiAgICBtb21lbnQuZGVmYXVsdEZvcm1hdCA9IGlzb0Zvcm1hdDtcclxuXHJcbiAgICAvLyBjb25zdGFudCB0aGF0IHJlZmVycyB0byB0aGUgSVNPIHN0YW5kYXJkXHJcbiAgICBtb21lbnQuSVNPXzg2MDEgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXHJcbiAgICAvLyBzbyB3ZSBjYW4gcHJvcGVybHkgY2xvbmUgb3Vyc2VsdmVzLlxyXG4gICAgbW9tZW50Lm1vbWVudFByb3BlcnRpZXMgPSBtb21lbnRQcm9wZXJ0aWVzO1xyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBtb21lbnQgaXMgbXV0YXRlZC5cclxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxyXG4gICAgbW9tZW50LnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xyXG4gICAgbW9tZW50LnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGZ1bmN0aW9uICh0aHJlc2hvbGQsIGxpbWl0KSB7XHJcbiAgICAgICAgaWYgKHJlbGF0aXZlVGltZVRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlVGltZVRocmVzaG9sZHNbdGhyZXNob2xkXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVsYXRpdmVUaW1lVGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vbWVudC5sYW5nID0gZGVwcmVjYXRlKFxyXG4gICAgICAgICdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsXHJcbiAgICAgICAgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1vbWVudC5sb2NhbGUoa2V5LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcclxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXHJcbiAgICAvLyBsb2NhbGUga2V5LlxyXG4gICAgbW9tZW50LmxvY2FsZSA9IGZ1bmN0aW9uIChrZXksIHZhbHVlcykge1xyXG4gICAgICAgIHZhciBkYXRhO1xyXG4gICAgICAgIGlmIChrZXkpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZih2YWx1ZXMpICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IG1vbWVudC5kZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF0YSA9IG1vbWVudC5sb2NhbGVEYXRhKGtleSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC5fbG9jYWxlLl9hYmJyO1xyXG4gICAgfTtcclxuXHJcbiAgICBtb21lbnQuZGVmaW5lTG9jYWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlcykge1xyXG4gICAgICAgIGlmICh2YWx1ZXMgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgdmFsdWVzLmFiYnIgPSBuYW1lO1xyXG4gICAgICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXS5zZXQodmFsdWVzKTtcclxuXHJcbiAgICAgICAgICAgIC8vIGJhY2t3YXJkcyBjb21wYXQgZm9yIG5vdzogYWxzbyBzZXQgdGhlIGxvY2FsZVxyXG4gICAgICAgICAgICBtb21lbnQubG9jYWxlKG5hbWUpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdXNlZnVsIGZvciB0ZXN0aW5nXHJcbiAgICAgICAgICAgIGRlbGV0ZSBsb2NhbGVzW25hbWVdO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIG1vbWVudC5sYW5nRGF0YSA9IGRlcHJlY2F0ZShcclxuICAgICAgICAnbW9tZW50LmxhbmdEYXRhIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlRGF0YSBpbnN0ZWFkLicsXHJcbiAgICAgICAgZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmxvY2FsZURhdGEoa2V5KTtcclxuICAgICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIC8vIHJldHVybnMgbG9jYWxlIGRhdGFcclxuICAgIG1vbWVudC5sb2NhbGVEYXRhID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBsb2NhbGU7XHJcblxyXG4gICAgICAgIGlmIChrZXkgJiYga2V5Ll9sb2NhbGUgJiYga2V5Ll9sb2NhbGUuX2FiYnIpIHtcclxuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWtleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50Ll9sb2NhbGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoIWlzQXJyYXkoa2V5KSkge1xyXG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXHJcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcclxuICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBrZXkgPSBba2V5XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBjaG9vc2VMb2NhbGUoa2V5KTtcclxuICAgIH07XHJcblxyXG4gICAgLy8gY29tcGFyZSBtb21lbnQgb2JqZWN0XHJcbiAgICBtb21lbnQuaXNNb21lbnQgPSBmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fFxyXG4gICAgICAgICAgICAob2JqICE9IG51bGwgJiYgaGFzT3duUHJvcChvYmosICdfaXNBTW9tZW50T2JqZWN0JykpO1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBmb3IgdHlwZWNoZWNraW5nIER1cmF0aW9uIG9iamVjdHNcclxuICAgIG1vbWVudC5pc0R1cmF0aW9uID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcclxuICAgIH07XHJcblxyXG4gICAgZm9yIChpID0gbGlzdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcclxuICAgICAgICBtYWtlTGlzdChsaXN0c1tpXSk7XHJcbiAgICB9XHJcblxyXG4gICAgbW9tZW50Lm5vcm1hbGl6ZVVuaXRzID0gZnVuY3Rpb24gKHVuaXRzKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuICAgIH07XHJcblxyXG4gICAgbW9tZW50LmludmFsaWQgPSBmdW5jdGlvbiAoZmxhZ3MpIHtcclxuICAgICAgICB2YXIgbSA9IG1vbWVudC51dGMoTmFOKTtcclxuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBleHRlbmQobS5fcGYsIGZsYWdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG0uX3BmLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH07XHJcblxyXG4gICAgbW9tZW50LnBhcnNlWm9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50LmFwcGx5KG51bGwsIGFyZ3VtZW50cykucGFyc2Vab25lKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIG1vbWVudC5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgIHJldHVybiB0b0ludChpbnB1dCkgKyAodG9JbnQoaW5wdXQpID4gNjggPyAxOTAwIDogMjAwMCk7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgICAgICBNb21lbnQgUHJvdG90eXBlXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuICAgIGV4dGVuZChtb21lbnQuZm4gPSBNb21lbnQucHJvdG90eXBlLCB7XHJcblxyXG4gICAgICAgIGNsb25lIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50KHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHZhbHVlT2YgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiArdGhpcy5fZCArICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHVuaXggOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKCt0aGlzIC8gMTAwMCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdG9TdHJpbmcgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB0b0RhdGUgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXQgPyBuZXcgRGF0ZSgrdGhpcykgOiB0aGlzLl9kO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRvSVNPU3RyaW5nIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgbSA9IG1vbWVudCh0aGlzKS51dGMoKTtcclxuICAgICAgICAgICAgaWYgKDAgPCBtLnllYXIoKSAmJiBtLnllYXIoKSA8PSA5OTk5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIERhdGUucHJvdG90eXBlLnRvSVNPU3RyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmF0aXZlIGltcGxlbWVudGF0aW9uIGlzIH41MHggZmFzdGVyLCB1c2UgaXQgd2hlbiB3ZSBjYW5cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0RhdGUoKS50b0lTT1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHRvQXJyYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIG0ueWVhcigpLFxyXG4gICAgICAgICAgICAgICAgbS5tb250aCgpLFxyXG4gICAgICAgICAgICAgICAgbS5kYXRlKCksXHJcbiAgICAgICAgICAgICAgICBtLmhvdXJzKCksXHJcbiAgICAgICAgICAgICAgICBtLm1pbnV0ZXMoKSxcclxuICAgICAgICAgICAgICAgIG0uc2Vjb25kcygpLFxyXG4gICAgICAgICAgICAgICAgbS5taWxsaXNlY29uZHMoKVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzVmFsaWQgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkKHRoaXMpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzRFNUU2hpZnRlZCA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2EpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSAmJiBjb21wYXJlQXJyYXlzKHRoaXMuX2EsICh0aGlzLl9pc1VUQyA/IG1vbWVudC51dGModGhpcy5fYSkgOiBtb21lbnQodGhpcy5fYSkpLnRvQXJyYXkoKSkgPiAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcGFyc2luZ0ZsYWdzIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5kKHt9LCB0aGlzLl9wZik7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaW52YWxpZEF0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wZi5vdmVyZmxvdztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB1dGMgOiBmdW5jdGlvbiAoa2VlcExvY2FsVGltZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy56b25lKDAsIGtlZXBMb2NhbFRpbWUpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGxvY2FsIDogZnVuY3Rpb24gKGtlZXBMb2NhbFRpbWUpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUoMCwga2VlcExvY2FsVGltZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1VUQyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGQodGhpcy5fZGF0ZVR6T2Zmc2V0KCksICdtJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZm9ybWF0IDogZnVuY3Rpb24gKGlucHV0U3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBmb3JtYXRNb21lbnQodGhpcywgaW5wdXRTdHJpbmcgfHwgbW9tZW50LmRlZmF1bHRGb3JtYXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkucG9zdGZvcm1hdChvdXRwdXQpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGFkZCA6IGNyZWF0ZUFkZGVyKDEsICdhZGQnKSxcclxuXHJcbiAgICAgICAgc3VidHJhY3QgOiBjcmVhdGVBZGRlcigtMSwgJ3N1YnRyYWN0JyksXHJcblxyXG4gICAgICAgIGRpZmYgOiBmdW5jdGlvbiAoaW5wdXQsIHVuaXRzLCBhc0Zsb2F0KSB7XHJcbiAgICAgICAgICAgIHZhciB0aGF0ID0gbWFrZUFzKGlucHV0LCB0aGlzKSxcclxuICAgICAgICAgICAgICAgIHpvbmVEaWZmID0gKHRoaXMuem9uZSgpIC0gdGhhdC56b25lKCkpICogNmU0LFxyXG4gICAgICAgICAgICAgICAgZGlmZiwgb3V0cHV0LCBkYXlzQWRqdXN0O1xyXG5cclxuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XHJcblxyXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICd5ZWFyJyB8fCB1bml0cyA9PT0gJ21vbnRoJykge1xyXG4gICAgICAgICAgICAgICAgLy8gYXZlcmFnZSBudW1iZXIgb2YgZGF5cyBpbiB0aGUgbW9udGhzIGluIHRoZSBnaXZlbiBkYXRlc1xyXG4gICAgICAgICAgICAgICAgZGlmZiA9ICh0aGlzLmRheXNJbk1vbnRoKCkgKyB0aGF0LmRheXNJbk1vbnRoKCkpICogNDMyZTU7IC8vIDI0ICogNjAgKiA2MCAqIDEwMDAgLyAyXHJcbiAgICAgICAgICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gKCh0aGlzLnllYXIoKSAtIHRoYXQueWVhcigpKSAqIDEyKSArICh0aGlzLm1vbnRoKCkgLSB0aGF0Lm1vbnRoKCkpO1xyXG4gICAgICAgICAgICAgICAgLy8gYWRqdXN0IGJ5IHRha2luZyBkaWZmZXJlbmNlIGluIGRheXMsIGF2ZXJhZ2UgbnVtYmVyIG9mIGRheXNcclxuICAgICAgICAgICAgICAgIC8vIGFuZCBkc3QgaW4gdGhlIGdpdmVuIG1vbnRocy5cclxuICAgICAgICAgICAgICAgIGRheXNBZGp1c3QgPSAodGhpcyAtIG1vbWVudCh0aGlzKS5zdGFydE9mKCdtb250aCcpKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoYXQgLSBtb21lbnQodGhhdCkuc3RhcnRPZignbW9udGgnKSk7XHJcbiAgICAgICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aXRoIHpvbmVzLCB0byBuZWdhdGUgYWxsIGRzdFxyXG4gICAgICAgICAgICAgICAgZGF5c0FkanVzdCAtPSAoKHRoaXMuem9uZSgpIC0gbW9tZW50KHRoaXMpLnN0YXJ0T2YoJ21vbnRoJykuem9uZSgpKSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGF0LnpvbmUoKSAtIG1vbWVudCh0aGF0KS5zdGFydE9mKCdtb250aCcpLnpvbmUoKSkpICogNmU0O1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGRheXNBZGp1c3QgLyBkaWZmO1xyXG4gICAgICAgICAgICAgICAgaWYgKHVuaXRzID09PSAneWVhcicpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAxMjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRpZmYgPSAodGhpcyAtIHRoYXQpO1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdW5pdHMgPT09ICdzZWNvbmQnID8gZGlmZiAvIDFlMyA6IC8vIDEwMDBcclxuICAgICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ21pbnV0ZScgPyBkaWZmIC8gNmU0IDogLy8gMTAwMCAqIDYwXHJcbiAgICAgICAgICAgICAgICAgICAgdW5pdHMgPT09ICdob3VyJyA/IGRpZmYgLyAzNmU1IDogLy8gMTAwMCAqIDYwICogNjBcclxuICAgICAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2RheScgPyAoZGlmZiAtIHpvbmVEaWZmKSAvIDg2NGU1IDogLy8gMTAwMCAqIDYwICogNjAgKiAyNCwgbmVnYXRlIGRzdFxyXG4gICAgICAgICAgICAgICAgICAgIHVuaXRzID09PSAnd2VlaycgPyAoZGlmZiAtIHpvbmVEaWZmKSAvIDYwNDhlNSA6IC8vIDEwMDAgKiA2MCAqIDYwICogMjQgKiA3LCBuZWdhdGUgZHN0XHJcbiAgICAgICAgICAgICAgICAgICAgZGlmZjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYXNGbG9hdCA/IG91dHB1dCA6IGFic1JvdW5kKG91dHB1dCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZnJvbSA6IGZ1bmN0aW9uICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBmcm9tTm93IDogZnVuY3Rpb24gKHdpdGhvdXRTdWZmaXgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbShtb21lbnQoKSwgd2l0aG91dFN1ZmZpeCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgY2FsZW5kYXIgOiBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgICAgICAgICAvLyBXZSB3YW50IHRvIGNvbXBhcmUgdGhlIHN0YXJ0IG9mIHRvZGF5LCB2cyB0aGlzLlxyXG4gICAgICAgICAgICAvLyBHZXR0aW5nIHN0YXJ0LW9mLXRvZGF5IGRlcGVuZHMgb24gd2hldGhlciB3ZSdyZSB6b25lJ2Qgb3Igbm90LlxyXG4gICAgICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBtb21lbnQoKSxcclxuICAgICAgICAgICAgICAgIHNvZCA9IG1ha2VBcyhub3csIHRoaXMpLnN0YXJ0T2YoJ2RheScpLFxyXG4gICAgICAgICAgICAgICAgZGlmZiA9IHRoaXMuZGlmZihzb2QsICdkYXlzJywgdHJ1ZSksXHJcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSBkaWZmIDwgLTYgPyAnc2FtZUVsc2UnIDpcclxuICAgICAgICAgICAgICAgICAgICBkaWZmIDwgLTEgPyAnbGFzdFdlZWsnIDpcclxuICAgICAgICAgICAgICAgICAgICBkaWZmIDwgMCA/ICdsYXN0RGF5JyA6XHJcbiAgICAgICAgICAgICAgICAgICAgZGlmZiA8IDEgPyAnc2FtZURheScgOlxyXG4gICAgICAgICAgICAgICAgICAgIGRpZmYgPCAyID8gJ25leHREYXknIDpcclxuICAgICAgICAgICAgICAgICAgICBkaWZmIDwgNyA/ICduZXh0V2VlaycgOiAnc2FtZUVsc2UnO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQodGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBtb21lbnQobm93KSkpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzTGVhcFllYXIgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpc0xlYXBZZWFyKHRoaXMueWVhcigpKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc0RTVCA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnpvbmUoKSA8IHRoaXMuY2xvbmUoKS5tb250aCgwKS56b25lKCkgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuem9uZSgpIDwgdGhpcy5jbG9uZSgpLm1vbnRoKDUpLnpvbmUoKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGF5IDogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xyXG4gICAgICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkYXk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtb250aCA6IG1ha2VBY2Nlc3NvcignTW9udGgnLCB0cnVlKSxcclxuXHJcbiAgICAgICAgc3RhcnRPZiA6IGZ1bmN0aW9uICh1bml0cykge1xyXG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBzd2l0Y2ggaW50ZW50aW9uYWxseSBvbWl0cyBicmVhayBrZXl3b3Jkc1xyXG4gICAgICAgICAgICAvLyB0byB1dGlsaXplIGZhbGxpbmcgdGhyb3VnaCB0aGUgY2FzZXMuXHJcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcclxuICAgICAgICAgICAgY2FzZSAneWVhcic6XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vbnRoKDApO1xyXG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcclxuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRlKDEpO1xyXG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcclxuICAgICAgICAgICAgY2FzZSAnaXNvV2Vlayc6XHJcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhvdXJzKDApO1xyXG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgICAgICBjYXNlICdob3VyJzpcclxuICAgICAgICAgICAgICAgIHRoaXMubWludXRlcygwKTtcclxuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICAgICAgY2FzZSAnbWludXRlJzpcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Vjb25kcygwKTtcclxuICAgICAgICAgICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cclxuICAgICAgICAgICAgY2FzZSAnc2Vjb25kJzpcclxuICAgICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRzKDApO1xyXG4gICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyB3ZWVrcyBhcmUgYSBzcGVjaWFsIGNhc2VcclxuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMud2Vla2RheSgwKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ2lzb1dlZWsnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmlzb1dlZWtkYXkoMSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIHF1YXJ0ZXJzIGFyZSBhbHNvIHNwZWNpYWxcclxuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubW9udGgoTWF0aC5mbG9vcih0aGlzLm1vbnRoKCkgLyAzKSAqIDMpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBlbmRPZjogZnVuY3Rpb24gKHVuaXRzKSB7XHJcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xyXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09IHVuZGVmaW5lZCB8fCB1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZih1bml0cykuYWRkKDEsICh1bml0cyA9PT0gJ2lzb1dlZWsnID8gJ3dlZWsnIDogdW5pdHMpKS5zdWJ0cmFjdCgxLCAnbXMnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc0FmdGVyOiBmdW5jdGlvbiAoaW5wdXQsIHVuaXRzKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnB1dE1zO1xyXG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xyXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0ID0gbW9tZW50LmlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbW9tZW50KGlucHV0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiArdGhpcyA+ICtpbnB1dDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlucHV0TXMgPSBtb21lbnQuaXNNb21lbnQoaW5wdXQpID8gK2lucHV0IDogK21vbWVudChpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5wdXRNcyA8ICt0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc0JlZm9yZTogZnVuY3Rpb24gKGlucHV0LCB1bml0cykge1xyXG4gICAgICAgICAgICB2YXIgaW5wdXRNcztcclxuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh0eXBlb2YgdW5pdHMgIT09ICd1bmRlZmluZWQnID8gdW5pdHMgOiAnbWlsbGlzZWNvbmQnKTtcclxuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG1vbWVudC5pc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IG1vbWVudChpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gK3RoaXMgPCAraW5wdXQ7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dE1zID0gbW9tZW50LmlzTW9tZW50KGlucHV0KSA/ICtpbnB1dCA6ICttb21lbnQoaW5wdXQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICt0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpIDwgaW5wdXRNcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGlzU2FtZTogZnVuY3Rpb24gKGlucHV0LCB1bml0cykge1xyXG4gICAgICAgICAgICB2YXIgaW5wdXRNcztcclxuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcclxuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XHJcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG1vbWVudC5pc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IG1vbWVudChpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gK3RoaXMgPT09ICtpbnB1dDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlucHV0TXMgPSArbW9tZW50KGlucHV0KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiArKHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKSkgPD0gaW5wdXRNcyAmJiBpbnB1dE1zIDw9ICsodGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBtaW46IGRlcHJlY2F0ZShcclxuICAgICAgICAgICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWluIGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNTQ4JyxcclxuICAgICAgICAgICAgICAgICBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgb3RoZXIgPSBtb21lbnQuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcclxuICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICksXHJcblxyXG4gICAgICAgIG1heDogZGVwcmVjYXRlKFxyXG4gICAgICAgICAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1heCBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OCcsXHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAob3RoZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdGhlciA9IG1vbWVudC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuXHJcbiAgICAgICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XHJcbiAgICAgICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3pvbmUoMiwgdHJ1ZSldLS0+XHJcbiAgICAgICAgLy8gNTozMToyNiArMDIwMCBJdCBpcyBwb3NzaWJsZSB0aGF0IDU6MzE6MjYgZG9lc24ndCBleGlzdCBpbnQgem9uZVxyXG4gICAgICAgIC8vICswMjAwLCBzbyB3ZSBhZGp1c3QgdGhlIHRpbWUgYXMgbmVlZGVkLCB0byBiZSB2YWxpZC5cclxuICAgICAgICAvL1xyXG4gICAgICAgIC8vIEtlZXBpbmcgdGhlIHRpbWUgYWN0dWFsbHkgYWRkcy9zdWJ0cmFjdHMgKG9uZSBob3VyKVxyXG4gICAgICAgIC8vIGZyb20gdGhlIGFjdHVhbCByZXByZXNlbnRlZCB0aW1lLiBUaGF0IGlzIHdoeSB3ZSBjYWxsIHVwZGF0ZU9mZnNldFxyXG4gICAgICAgIC8vIGEgc2Vjb25kIHRpbWUuIEluIGNhc2UgaXQgd2FudHMgdXMgdG8gY2hhbmdlIHRoZSBvZmZzZXQgYWdhaW5cclxuICAgICAgICAvLyBfY2hhbmdlSW5Qcm9ncmVzcyA9PSB0cnVlIGNhc2UsIHRoZW4gd2UgaGF2ZSB0byBhZGp1c3QsIGJlY2F1c2VcclxuICAgICAgICAvLyB0aGVyZSBpcyBubyBzdWNoIHRpbWUgaW4gdGhlIGdpdmVuIHRpbWV6b25lLlxyXG4gICAgICAgIHpvbmUgOiBmdW5jdGlvbiAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcclxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxyXG4gICAgICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0ID0gdGltZXpvbmVNaW51dGVzRnJvbVN0cmluZyhpbnB1dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoaW5wdXQpIDwgMTYpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0ICogNjA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzVVRDICYmIGtlZXBMb2NhbFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2NhbEFkanVzdCA9IHRoaXMuX2RhdGVUek9mZnNldCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fb2Zmc2V0ID0gaW5wdXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1VUQyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAobG9jYWxBZGp1c3QgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3VidHJhY3QobG9jYWxBZGp1c3QsICdtJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICE9PSBpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgha2VlcExvY2FsVGltZSB8fCB0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9yU3VidHJhY3REdXJhdGlvbkZyb21Nb21lbnQodGhpcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb21lbnQuZHVyYXRpb24ob2Zmc2V0IC0gaW5wdXQsICdtJyksIDEsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb21lbnQudXBkYXRlT2Zmc2V0KHRoaXMsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiB0aGlzLl9kYXRlVHpPZmZzZXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB6b25lQWJiciA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB6b25lTmFtZSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIHBhcnNlWm9uZSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3R6bSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b25lKHRoaXMuX3R6bSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2kgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvbmUodGhpcy5faSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaGFzQWxpZ25lZEhvdXJPZmZzZXQgOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgaWYgKCFpbnB1dCkge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQgPSBtb21lbnQoaW5wdXQpLnpvbmUoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnpvbmUoKSAtIGlucHV0KSAlIDYwID09PSAwO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGRheXNJbk1vbnRoIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGF5c0luTW9udGgodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZGF5T2ZZZWFyIDogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgICAgIHZhciBkYXlPZlllYXIgPSByb3VuZCgobW9tZW50KHRoaXMpLnN0YXJ0T2YoJ2RheScpIC0gbW9tZW50KHRoaXMpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgcXVhcnRlciA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgd2Vla1llYXIgOiBmdW5jdGlvbiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgdmFyIHllYXIgPSB3ZWVrT2ZZZWFyKHRoaXMsIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdywgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG95KS55ZWFyO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHllYXIgOiB0aGlzLmFkZCgoaW5wdXQgLSB5ZWFyKSwgJ3knKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc29XZWVrWWVhciA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkueWVhcjtcclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB5ZWFyIDogdGhpcy5hZGQoKGlucHV0IC0geWVhciksICd5Jyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgd2VlayA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgICAgICB2YXIgd2VlayA9IHRoaXMubG9jYWxlRGF0YSgpLndlZWsodGhpcyk7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc29XZWVrIDogZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgd2Vla2RheSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xyXG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgaXNvV2Vla2RheSA6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG4gICAgICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XHJcbiAgICAgICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXHJcbiAgICAgICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cclxuICAgICAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB0aGlzLmRheSgpIHx8IDcgOiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IGlucHV0IDogaW5wdXQgLSA3KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBpc29XZWVrc0luWWVhciA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHdlZWtzSW5ZZWFyKHRoaXMueWVhcigpLCAxLCA0KTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB3ZWVrc0luWWVhciA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XHJcbiAgICAgICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGdldCA6IGZ1bmN0aW9uICh1bml0cykge1xyXG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc2V0IDogZnVuY3Rpb24gKHVuaXRzLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW3VuaXRzXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgdGhpc1t1bml0c10odmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8vIElmIHBhc3NlZCBhIGxvY2FsZSBrZXksIGl0IHdpbGwgc2V0IHRoZSBsb2NhbGUgZm9yIHRoaXNcclxuICAgICAgICAvLyBpbnN0YW5jZS4gIE90aGVyd2lzZSwgaXQgd2lsbCByZXR1cm4gdGhlIGxvY2FsZSBjb25maWd1cmF0aW9uXHJcbiAgICAgICAgLy8gdmFyaWFibGVzIGZvciB0aGlzIGluc3RhbmNlLlxyXG4gICAgICAgIGxvY2FsZSA6IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIG5ld0xvY2FsZURhdGE7XHJcblxyXG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gbW9tZW50LmxvY2FsZURhdGEoa2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdMb2NhbGVEYXRhICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sb2NhbGUgPSBuZXdMb2NhbGVEYXRhO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBsYW5nIDogZGVwcmVjYXRlKFxyXG4gICAgICAgICAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxyXG4gICAgICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgKSxcclxuXHJcbiAgICAgICAgbG9jYWxlRGF0YSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBfZGF0ZVR6T2Zmc2V0IDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxyXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodGhpcy5fZC5nZXRUaW1lem9uZU9mZnNldCgpIC8gMTUpICogMTU7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgZnVuY3Rpb24gcmF3TW9udGhTZXR0ZXIobW9tLCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBkYXlPZk1vbnRoO1xyXG5cclxuICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgb3V0IG9mIGhlcmUhXHJcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcclxuICAgICAgICAgICAgLy8gVE9ETzogQW5vdGhlciBzaWxlbnQgZmFpbHVyZT9cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBtb207XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGRheU9mTW9udGggPSBNYXRoLm1pbihtb20uZGF0ZSgpLFxyXG4gICAgICAgICAgICAgICAgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcclxuICAgICAgICBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgJ01vbnRoJ10odmFsdWUsIGRheU9mTW9udGgpO1xyXG4gICAgICAgIHJldHVybiBtb207XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcmF3R2V0dGVyKG1vbSwgdW5pdCkge1xyXG4gICAgICAgIHJldHVybiBtb20uX2RbJ2dldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0oKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiByYXdTZXR0ZXIobW9tLCB1bml0LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmICh1bml0ID09PSAnTW9udGgnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByYXdNb250aFNldHRlcihtb20sIHZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZUFjY2Vzc29yKHVuaXQsIGtlZXBUaW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmF3U2V0dGVyKHRoaXMsIHVuaXQsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIG1vbWVudC51cGRhdGVPZmZzZXQodGhpcywga2VlcFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF3R2V0dGVyKHRoaXMsIHVuaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBtb21lbnQuZm4ubWlsbGlzZWNvbmQgPSBtb21lbnQuZm4ubWlsbGlzZWNvbmRzID0gbWFrZUFjY2Vzc29yKCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XHJcbiAgICBtb21lbnQuZm4uc2Vjb25kID0gbW9tZW50LmZuLnNlY29uZHMgPSBtYWtlQWNjZXNzb3IoJ1NlY29uZHMnLCBmYWxzZSk7XHJcbiAgICBtb21lbnQuZm4ubWludXRlID0gbW9tZW50LmZuLm1pbnV0ZXMgPSBtYWtlQWNjZXNzb3IoJ01pbnV0ZXMnLCBmYWxzZSk7XHJcbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcclxuICAgIC8vIHNwZWNpZmllZCB3aGljaCBob3VyIGhlIHdhbnRzLiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cclxuICAgIC8vIGEgbmV3IHRpbWV6b25lKSBtYWtlcyBzZW5zZS4gQWRkaW5nL3N1YnRyYWN0aW5nIGhvdXJzIGRvZXMgbm90IGZvbGxvd1xyXG4gICAgLy8gdGhpcyBydWxlLlxyXG4gICAgbW9tZW50LmZuLmhvdXIgPSBtb21lbnQuZm4uaG91cnMgPSBtYWtlQWNjZXNzb3IoJ0hvdXJzJywgdHJ1ZSk7XHJcbiAgICAvLyBtb21lbnQuZm4ubW9udGggaXMgZGVmaW5lZCBzZXBhcmF0ZWx5XHJcbiAgICBtb21lbnQuZm4uZGF0ZSA9IG1ha2VBY2Nlc3NvcignRGF0ZScsIHRydWUpO1xyXG4gICAgbW9tZW50LmZuLmRhdGVzID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIG1ha2VBY2Nlc3NvcignRGF0ZScsIHRydWUpKTtcclxuICAgIG1vbWVudC5mbi55ZWFyID0gbWFrZUFjY2Vzc29yKCdGdWxsWWVhcicsIHRydWUpO1xyXG4gICAgbW9tZW50LmZuLnllYXJzID0gZGVwcmVjYXRlKCd5ZWFycyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgeWVhciBpbnN0ZWFkLicsIG1ha2VBY2Nlc3NvcignRnVsbFllYXInLCB0cnVlKSk7XHJcblxyXG4gICAgLy8gYWRkIHBsdXJhbCBtZXRob2RzXHJcbiAgICBtb21lbnQuZm4uZGF5cyA9IG1vbWVudC5mbi5kYXk7XHJcbiAgICBtb21lbnQuZm4ubW9udGhzID0gbW9tZW50LmZuLm1vbnRoO1xyXG4gICAgbW9tZW50LmZuLndlZWtzID0gbW9tZW50LmZuLndlZWs7XHJcbiAgICBtb21lbnQuZm4uaXNvV2Vla3MgPSBtb21lbnQuZm4uaXNvV2VlaztcclxuICAgIG1vbWVudC5mbi5xdWFydGVycyA9IG1vbWVudC5mbi5xdWFydGVyO1xyXG5cclxuICAgIC8vIGFkZCBhbGlhc2VkIGZvcm1hdCBtZXRob2RzXHJcbiAgICBtb21lbnQuZm4udG9KU09OID0gbW9tZW50LmZuLnRvSVNPU3RyaW5nO1xyXG5cclxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgICAgICBEdXJhdGlvbiBQcm90b3R5cGVcclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gZGF5c1RvWWVhcnMgKGRheXMpIHtcclxuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXHJcbiAgICAgICAgcmV0dXJuIGRheXMgKiA0MDAgLyAxNDYwOTc7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24geWVhcnNUb0RheXMgKHllYXJzKSB7XHJcbiAgICAgICAgLy8geWVhcnMgKiAzNjUgKyBhYnNSb3VuZCh5ZWFycyAvIDQpIC1cclxuICAgICAgICAvLyAgICAgYWJzUm91bmQoeWVhcnMgLyAxMDApICsgYWJzUm91bmQoeWVhcnMgLyA0MDApO1xyXG4gICAgICAgIHJldHVybiB5ZWFycyAqIDE0NjA5NyAvIDQwMDtcclxuICAgIH1cclxuXHJcbiAgICBleHRlbmQobW9tZW50LmR1cmF0aW9uLmZuID0gRHVyYXRpb24ucHJvdG90eXBlLCB7XHJcblxyXG4gICAgICAgIF9idWJibGUgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSB0aGlzLl9taWxsaXNlY29uZHMsXHJcbiAgICAgICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyxcclxuICAgICAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyxcclxuICAgICAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kYXRhLFxyXG4gICAgICAgICAgICAgICAgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY29kZSBidWJibGVzIHVwIHZhbHVlcywgc2VlIHRoZSB0ZXN0cyBmb3JcclxuICAgICAgICAgICAgLy8gZXhhbXBsZXMgb2Ygd2hhdCB0aGF0IG1lYW5zLlxyXG4gICAgICAgICAgICBkYXRhLm1pbGxpc2Vjb25kcyA9IG1pbGxpc2Vjb25kcyAlIDEwMDA7XHJcblxyXG4gICAgICAgICAgICBzZWNvbmRzID0gYWJzUm91bmQobWlsbGlzZWNvbmRzIC8gMTAwMCk7XHJcbiAgICAgICAgICAgIGRhdGEuc2Vjb25kcyA9IHNlY29uZHMgJSA2MDtcclxuXHJcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBhYnNSb3VuZChzZWNvbmRzIC8gNjApO1xyXG4gICAgICAgICAgICBkYXRhLm1pbnV0ZXMgPSBtaW51dGVzICUgNjA7XHJcblxyXG4gICAgICAgICAgICBob3VycyA9IGFic1JvdW5kKG1pbnV0ZXMgLyA2MCk7XHJcbiAgICAgICAgICAgIGRhdGEuaG91cnMgPSBob3VycyAlIDI0O1xyXG5cclxuICAgICAgICAgICAgZGF5cyArPSBhYnNSb3VuZChob3VycyAvIDI0KTtcclxuXHJcbiAgICAgICAgICAgIC8vIEFjY3VyYXRlbHkgY29udmVydCBkYXlzIHRvIHllYXJzLCBhc3N1bWUgc3RhcnQgZnJvbSB5ZWFyIDAuXHJcbiAgICAgICAgICAgIHllYXJzID0gYWJzUm91bmQoZGF5c1RvWWVhcnMoZGF5cykpO1xyXG4gICAgICAgICAgICBkYXlzIC09IGFic1JvdW5kKHllYXJzVG9EYXlzKHllYXJzKSk7XHJcblxyXG4gICAgICAgICAgICAvLyAzMCBkYXlzIHRvIGEgbW9udGhcclxuICAgICAgICAgICAgLy8gVE9ETyAoaXNrcmVuKTogVXNlIGFuY2hvciBkYXRlIChsaWtlIDFzdCBKYW4pIHRvIGNvbXB1dGUgdGhpcy5cclxuICAgICAgICAgICAgbW9udGhzICs9IGFic1JvdW5kKGRheXMgLyAzMCk7XHJcbiAgICAgICAgICAgIGRheXMgJT0gMzA7XHJcblxyXG4gICAgICAgICAgICAvLyAxMiBtb250aHMgLT4gMSB5ZWFyXHJcbiAgICAgICAgICAgIHllYXJzICs9IGFic1JvdW5kKG1vbnRocyAvIDEyKTtcclxuICAgICAgICAgICAgbW9udGhzICU9IDEyO1xyXG5cclxuICAgICAgICAgICAgZGF0YS5kYXlzID0gZGF5cztcclxuICAgICAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XHJcbiAgICAgICAgICAgIGRhdGEueWVhcnMgPSB5ZWFycztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBhYnMgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IE1hdGguYWJzKHRoaXMuX21pbGxpc2Vjb25kcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RheXMgPSBNYXRoLmFicyh0aGlzLl9kYXlzKTtcclxuICAgICAgICAgICAgdGhpcy5fbW9udGhzID0gTWF0aC5hYnModGhpcy5fbW9udGhzKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEubWlsbGlzZWNvbmRzID0gTWF0aC5hYnModGhpcy5fZGF0YS5taWxsaXNlY29uZHMpO1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhLnNlY29uZHMgPSBNYXRoLmFicyh0aGlzLl9kYXRhLnNlY29uZHMpO1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhLm1pbnV0ZXMgPSBNYXRoLmFicyh0aGlzLl9kYXRhLm1pbnV0ZXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhLmhvdXJzID0gTWF0aC5hYnModGhpcy5fZGF0YS5ob3Vycyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RhdGEubW9udGhzID0gTWF0aC5hYnModGhpcy5fZGF0YS5tb250aHMpO1xyXG4gICAgICAgICAgICB0aGlzLl9kYXRhLnllYXJzID0gTWF0aC5hYnModGhpcy5fZGF0YS55ZWFycyk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICB3ZWVrcyA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFic1JvdW5kKHRoaXMuZGF5cygpIC8gNyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgdmFsdWVPZiA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21pbGxpc2Vjb25kcyArXHJcbiAgICAgICAgICAgICAgdGhpcy5fZGF5cyAqIDg2NGU1ICtcclxuICAgICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcclxuICAgICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGh1bWFuaXplIDogZnVuY3Rpb24gKHdpdGhTdWZmaXgpIHtcclxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IHJlbGF0aXZlVGltZSh0aGlzLCAhd2l0aFN1ZmZpeCwgdGhpcy5sb2NhbGVEYXRhKCkpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcclxuICAgICAgICAgICAgICAgIG91dHB1dCA9IHRoaXMubG9jYWxlRGF0YSgpLnBhc3RGdXR1cmUoK3RoaXMsIG91dHB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKGlucHV0LCB2YWwpIHtcclxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgYWRkKDEsICdzJykgb3IgYWRkKG1vbWVudClcclxuICAgICAgICAgICAgdmFyIGR1ciA9IG1vbWVudC5kdXJhdGlvbihpbnB1dCwgdmFsKTtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArPSBkdXIuX21pbGxpc2Vjb25kcztcclxuICAgICAgICAgICAgdGhpcy5fZGF5cyArPSBkdXIuX2RheXM7XHJcbiAgICAgICAgICAgIHRoaXMuX21vbnRocyArPSBkdXIuX21vbnRocztcclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2J1YmJsZSgpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgc3VidHJhY3QgOiBmdW5jdGlvbiAoaW5wdXQsIHZhbCkge1xyXG4gICAgICAgICAgICB2YXIgZHVyID0gbW9tZW50LmR1cmF0aW9uKGlucHV0LCB2YWwpO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzIC09IGR1ci5fbWlsbGlzZWNvbmRzO1xyXG4gICAgICAgICAgICB0aGlzLl9kYXlzIC09IGR1ci5fZGF5cztcclxuICAgICAgICAgICAgdGhpcy5fbW9udGhzIC09IGR1ci5fbW9udGhzO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fYnViYmxlKCk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBnZXQgOiBmdW5jdGlvbiAodW5pdHMpIHtcclxuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzW3VuaXRzLnRvTG93ZXJDYXNlKCkgKyAncyddKCk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgYXMgOiBmdW5jdGlvbiAodW5pdHMpIHtcclxuICAgICAgICAgICAgdmFyIGRheXMsIG1vbnRocztcclxuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XHJcblxyXG4gICAgICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xyXG4gICAgICAgICAgICAgICAgZGF5cyA9IHRoaXMuX2RheXMgKyB0aGlzLl9taWxsaXNlY29uZHMgLyA4NjRlNTtcclxuICAgICAgICAgICAgICAgIG1vbnRocyA9IHRoaXMuX21vbnRocyArIGRheXNUb1llYXJzKGRheXMpICogMTI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5pdHMgPT09ICdtb250aCcgPyBtb250aHMgOiBtb250aHMgLyAxMjtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBtaWxsaXNlY29uZHMgc2VwYXJhdGVseSBiZWNhdXNlIG9mIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIChpc3N1ZSAjMTg2NylcclxuICAgICAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgTWF0aC5yb3VuZCh5ZWFyc1RvRGF5cyh0aGlzLl9tb250aHMgLyAxMikpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnOiByZXR1cm4gZGF5cyAvIDcgKyB0aGlzLl9taWxsaXNlY29uZHMgLyA2MDQ4ZTU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGF5JzogcmV0dXJuIGRheXMgKyB0aGlzLl9taWxsaXNlY29uZHMgLyA4NjRlNTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdob3VyJzogcmV0dXJuIGRheXMgKiAyNCArIHRoaXMuX21pbGxpc2Vjb25kcyAvIDM2ZTU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWludXRlJzogcmV0dXJuIGRheXMgKiAyNCAqIDYwICsgdGhpcy5fbWlsbGlzZWNvbmRzIC8gNmU0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCc6IHJldHVybiBkYXlzICogMjQgKiA2MCAqIDYwICsgdGhpcy5fbWlsbGlzZWNvbmRzIC8gMTAwMDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKSArIHRoaXMuX21pbGxpc2Vjb25kcztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbGFuZyA6IG1vbWVudC5mbi5sYW5nLFxyXG4gICAgICAgIGxvY2FsZSA6IG1vbWVudC5mbi5sb2NhbGUsXHJcblxyXG4gICAgICAgIHRvSXNvU3RyaW5nIDogZGVwcmVjYXRlKFxyXG4gICAgICAgICAgICAndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAnICtcclxuICAgICAgICAgICAgJyhub3RpY2UgdGhlIGNhcGl0YWxzKScsXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSVNPU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApLFxyXG5cclxuICAgICAgICB0b0lTT1N0cmluZyA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gaW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2RvcmRpbGxlL21vbWVudC1pc29kdXJhdGlvbi9ibG9iL21hc3Rlci9tb21lbnQuaXNvZHVyYXRpb24uanNcclxuICAgICAgICAgICAgdmFyIHllYXJzID0gTWF0aC5hYnModGhpcy55ZWFycygpKSxcclxuICAgICAgICAgICAgICAgIG1vbnRocyA9IE1hdGguYWJzKHRoaXMubW9udGhzKCkpLFxyXG4gICAgICAgICAgICAgICAgZGF5cyA9IE1hdGguYWJzKHRoaXMuZGF5cygpKSxcclxuICAgICAgICAgICAgICAgIGhvdXJzID0gTWF0aC5hYnModGhpcy5ob3VycygpKSxcclxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBNYXRoLmFicyh0aGlzLm1pbnV0ZXMoKSksXHJcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gTWF0aC5hYnModGhpcy5zZWNvbmRzKCkgKyB0aGlzLm1pbGxpc2Vjb25kcygpIC8gMTAwMCk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuYXNTZWNvbmRzKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIHNhbWUgYXMgQyMncyAoTm9kYSkgYW5kIHB5dGhvbiAoaXNvZGF0ZSkuLi5cclxuICAgICAgICAgICAgICAgIC8vIGJ1dCBub3Qgb3RoZXIgSlMgKGdvb2cuZGF0ZSlcclxuICAgICAgICAgICAgICAgIHJldHVybiAnUDBEJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmFzU2Vjb25kcygpIDwgMCA/ICctJyA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAnUCcgK1xyXG4gICAgICAgICAgICAgICAgKHllYXJzID8geWVhcnMgKyAnWScgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgKG1vbnRocyA/IG1vbnRocyArICdNJyA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAoZGF5cyA/IGRheXMgKyAnRCcgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgKChob3VycyB8fCBtaW51dGVzIHx8IHNlY29uZHMpID8gJ1QnIDogJycpICtcclxuICAgICAgICAgICAgICAgIChob3VycyA/IGhvdXJzICsgJ0gnIDogJycpICtcclxuICAgICAgICAgICAgICAgIChtaW51dGVzID8gbWludXRlcyArICdNJyA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAoc2Vjb25kcyA/IHNlY29uZHMgKyAnUycgOiAnJyk7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgbG9jYWxlRGF0YSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsZTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBtb21lbnQuZHVyYXRpb24uZm4udG9TdHJpbmcgPSBtb21lbnQuZHVyYXRpb24uZm4udG9JU09TdHJpbmc7XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZUR1cmF0aW9uR2V0dGVyKG5hbWUpIHtcclxuICAgICAgICBtb21lbnQuZHVyYXRpb24uZm5bbmFtZV0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZm9yIChpIGluIHVuaXRNaWxsaXNlY29uZEZhY3RvcnMpIHtcclxuICAgICAgICBpZiAoaGFzT3duUHJvcCh1bml0TWlsbGlzZWNvbmRGYWN0b3JzLCBpKSkge1xyXG4gICAgICAgICAgICBtYWtlRHVyYXRpb25HZXR0ZXIoaS50b0xvd2VyQ2FzZSgpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbW9tZW50LmR1cmF0aW9uLmZuLmFzTWlsbGlzZWNvbmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFzKCdtcycpO1xyXG4gICAgfTtcclxuICAgIG1vbWVudC5kdXJhdGlvbi5mbi5hc1NlY29uZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoJ3MnKTtcclxuICAgIH07XHJcbiAgICBtb21lbnQuZHVyYXRpb24uZm4uYXNNaW51dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFzKCdtJyk7XHJcbiAgICB9O1xyXG4gICAgbW9tZW50LmR1cmF0aW9uLmZuLmFzSG91cnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoJ2gnKTtcclxuICAgIH07XHJcbiAgICBtb21lbnQuZHVyYXRpb24uZm4uYXNEYXlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFzKCdkJyk7XHJcbiAgICB9O1xyXG4gICAgbW9tZW50LmR1cmF0aW9uLmZuLmFzV2Vla3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoJ3dlZWtzJyk7XHJcbiAgICB9O1xyXG4gICAgbW9tZW50LmR1cmF0aW9uLmZuLmFzTW9udGhzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFzKCdNJyk7XHJcbiAgICB9O1xyXG4gICAgbW9tZW50LmR1cmF0aW9uLmZuLmFzWWVhcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMoJ3knKTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gICAgICAgIERlZmF1bHQgTG9jYWxlXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuICAgIC8vIFNldCBkZWZhdWx0IGxvY2FsZSwgb3RoZXIgbG9jYWxlIHdpbGwgaW5oZXJpdCBmcm9tIEVuZ2xpc2guXHJcbiAgICBtb21lbnQubG9jYWxlKCdlbicsIHtcclxuICAgICAgICBvcmRpbmFsUGFyc2U6IC9cXGR7MSwyfSh0aHxzdHxuZHxyZCkvLFxyXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XHJcbiAgICAgICAgICAgIHZhciBiID0gbnVtYmVyICUgMTAsXHJcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSAodG9JbnQobnVtYmVyICUgMTAwIC8gMTApID09PSAxKSA/ICd0aCcgOlxyXG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XHJcbiAgICAgICAgICAgICAgICAoYiA9PT0gMikgPyAnbmQnIDpcclxuICAgICAgICAgICAgICAgIChiID09PSAzKSA/ICdyZCcgOiAndGgnO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8qIEVNQkVEX0xPQ0FMRVMgKi9cclxuXHJcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICAgICAgRXhwb3NpbmcgTW9tZW50XHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZUdsb2JhbChzaG91bGREZXByZWNhdGUpIHtcclxuICAgICAgICAvKmdsb2JhbCBlbmRlcjpmYWxzZSAqL1xyXG4gICAgICAgIGlmICh0eXBlb2YgZW5kZXIgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgb2xkR2xvYmFsTW9tZW50ID0gZ2xvYmFsU2NvcGUubW9tZW50O1xyXG4gICAgICAgIGlmIChzaG91bGREZXByZWNhdGUpIHtcclxuICAgICAgICAgICAgZ2xvYmFsU2NvcGUubW9tZW50ID0gZGVwcmVjYXRlKFxyXG4gICAgICAgICAgICAgICAgICAgICdBY2Nlc3NpbmcgTW9tZW50IHRocm91Z2ggdGhlIGdsb2JhbCBzY29wZSBpcyAnICtcclxuICAgICAgICAgICAgICAgICAgICAnZGVwcmVjYXRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhbiB1cGNvbWluZyAnICtcclxuICAgICAgICAgICAgICAgICAgICAncmVsZWFzZS4nLFxyXG4gICAgICAgICAgICAgICAgICAgIG1vbWVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2xvYmFsU2NvcGUubW9tZW50ID0gbW9tZW50O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBDb21tb25KUyBtb2R1bGUgaXMgZGVmaW5lZFxyXG4gICAgaWYgKGhhc01vZHVsZSkge1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gbW9tZW50O1xyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgICAgICBkZWZpbmUoJ21vbWVudCcsIGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcclxuICAgICAgICAgICAgaWYgKG1vZHVsZS5jb25maWcgJiYgbW9kdWxlLmNvbmZpZygpICYmIG1vZHVsZS5jb25maWcoKS5ub0dsb2JhbCA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVsZWFzZSB0aGUgZ2xvYmFsIHZhcmlhYmxlXHJcbiAgICAgICAgICAgICAgICBnbG9iYWxTY29wZS5tb21lbnQgPSBvbGRHbG9iYWxNb21lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbWFrZUdsb2JhbCh0cnVlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWFrZUdsb2JhbCgpO1xyXG4gICAgfVxyXG59KS5jYWxsKHRoaXMpO1xyXG4iLCIvKipcclxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cclxuICovXHJcblxyXG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2VtaXR0ZXInKTtcclxudmFyIHJlZHVjZSA9IHJlcXVpcmUoJ3JlZHVjZScpO1xyXG5cclxuLyoqXHJcbiAqIFJvb3QgcmVmZXJlbmNlIGZvciBpZnJhbWVzLlxyXG4gKi9cclxuXHJcbnZhciByb290ID0gJ3VuZGVmaW5lZCcgPT0gdHlwZW9mIHdpbmRvd1xyXG4gID8gdGhpc1xyXG4gIDogd2luZG93O1xyXG5cclxuLyoqXHJcbiAqIE5vb3AuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbm9vcCgpe307XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgYG9iamAgaXMgYSBob3N0IG9iamVjdCxcclxuICogd2UgZG9uJ3Qgd2FudCB0byBzZXJpYWxpemUgdGhlc2UgOilcclxuICpcclxuICogVE9ETzogZnV0dXJlIHByb29mLCBtb3ZlIHRvIGNvbXBvZW50IGxhbmRcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBpc0hvc3Qob2JqKSB7XHJcbiAgdmFyIHN0ciA9IHt9LnRvU3RyaW5nLmNhbGwob2JqKTtcclxuXHJcbiAgc3dpdGNoIChzdHIpIHtcclxuICAgIGNhc2UgJ1tvYmplY3QgRmlsZV0nOlxyXG4gICAgY2FzZSAnW29iamVjdCBCbG9iXSc6XHJcbiAgICBjYXNlICdbb2JqZWN0IEZvcm1EYXRhXSc6XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSBYSFIuXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZ2V0WEhSKCkge1xyXG4gIGlmIChyb290LlhNTEh0dHBSZXF1ZXN0XHJcbiAgICAmJiAoJ2ZpbGU6JyAhPSByb290LmxvY2F0aW9uLnByb3RvY29sIHx8ICFyb290LkFjdGl2ZVhPYmplY3QpKSB7XHJcbiAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7IH0gY2F0Y2goZSkge31cclxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuNi4wJyk7IH0gY2F0Y2goZSkge31cclxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuMy4wJyk7IH0gY2F0Y2goZSkge31cclxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGFkZGVkIHRvIHN1cHBvcnQgSUUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXHJcbiAqIEByZXR1cm4ge1N0cmluZ31cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxudmFyIHRyaW0gPSAnJy50cmltXHJcbiAgPyBmdW5jdGlvbihzKSB7IHJldHVybiBzLnRyaW0oKTsgfVxyXG4gIDogZnVuY3Rpb24ocykgeyByZXR1cm4gcy5yZXBsYWNlKC8oXlxccyp8XFxzKiQpL2csICcnKTsgfTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBhbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gaXNPYmplY3Qob2JqKSB7XHJcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTZXJpYWxpemUgdGhlIGdpdmVuIGBvYmpgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge1N0cmluZ31cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gc2VyaWFsaXplKG9iaikge1xyXG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcclxuICB2YXIgcGFpcnMgPSBbXTtcclxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICBpZiAobnVsbCAhPSBvYmpba2V5XSkge1xyXG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpXHJcbiAgICAgICAgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2tleV0pKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEV4cG9zZSBzZXJpYWxpemF0aW9uIG1ldGhvZC5cclxuICovXHJcblxyXG4gcmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XHJcblxyXG4gLyoqXHJcbiAgKiBQYXJzZSB0aGUgZ2l2ZW4geC13d3ctZm9ybS11cmxlbmNvZGVkIGBzdHJgLlxyXG4gICpcclxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICAqIEByZXR1cm4ge09iamVjdH1cclxuICAqIEBhcGkgcHJpdmF0ZVxyXG4gICovXHJcblxyXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIpIHtcclxuICB2YXIgb2JqID0ge307XHJcbiAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KCcmJyk7XHJcbiAgdmFyIHBhcnRzO1xyXG4gIHZhciBwYWlyO1xyXG5cclxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFpcnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgIHBhaXIgPSBwYWlyc1tpXTtcclxuICAgIHBhcnRzID0gcGFpci5zcGxpdCgnPScpO1xyXG4gICAgb2JqW2RlY29kZVVSSUNvbXBvbmVudChwYXJ0c1swXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRzWzFdKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBFeHBvc2UgcGFyc2VyLlxyXG4gKi9cclxuXHJcbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IE1JTUUgdHlwZSBtYXAuXHJcbiAqXHJcbiAqICAgICBzdXBlcmFnZW50LnR5cGVzLnhtbCA9ICdhcHBsaWNhdGlvbi94bWwnO1xyXG4gKlxyXG4gKi9cclxuXHJcbnJlcXVlc3QudHlwZXMgPSB7XHJcbiAgaHRtbDogJ3RleHQvaHRtbCcsXHJcbiAganNvbjogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gIHhtbDogJ2FwcGxpY2F0aW9uL3htbCcsXHJcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXHJcbiAgJ2Zvcm0nOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcclxuICAnZm9ybS1kYXRhJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcclxufTtcclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxyXG4gKlxyXG4gKiAgICAgc3VwZXJhZ2VudC5zZXJpYWxpemVbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24ob2JqKXtcclxuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xyXG4gKiAgICAgfTtcclxuICpcclxuICovXHJcblxyXG4gcmVxdWVzdC5zZXJpYWxpemUgPSB7XHJcbiAgICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnOiBzZXJpYWxpemUsXHJcbiAgICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5zdHJpbmdpZnlcclxuIH07XHJcblxyXG4gLyoqXHJcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXHJcbiAgKlxyXG4gICogICAgIHN1cGVyYWdlbnQucGFyc2VbJ2FwcGxpY2F0aW9uL3htbCddID0gZnVuY3Rpb24oc3RyKXtcclxuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcclxuICAqICAgICB9O1xyXG4gICpcclxuICAqL1xyXG5cclxucmVxdWVzdC5wYXJzZSA9IHtcclxuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXHJcbiAgJ2FwcGxpY2F0aW9uL2pzb24nOiBKU09OLnBhcnNlXHJcbn07XHJcblxyXG4vKipcclxuICogUGFyc2UgdGhlIGdpdmVuIGhlYWRlciBgc3RyYCBpbnRvXHJcbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gcGFyc2VIZWFkZXIoc3RyKSB7XHJcbiAgdmFyIGxpbmVzID0gc3RyLnNwbGl0KC9cXHI/XFxuLyk7XHJcbiAgdmFyIGZpZWxkcyA9IHt9O1xyXG4gIHZhciBpbmRleDtcclxuICB2YXIgbGluZTtcclxuICB2YXIgZmllbGQ7XHJcbiAgdmFyIHZhbDtcclxuXHJcbiAgbGluZXMucG9wKCk7IC8vIHRyYWlsaW5nIENSTEZcclxuXHJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICBsaW5lID0gbGluZXNbaV07XHJcbiAgICBpbmRleCA9IGxpbmUuaW5kZXhPZignOicpO1xyXG4gICAgZmllbGQgPSBsaW5lLnNsaWNlKDAsIGluZGV4KS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgdmFsID0gdHJpbShsaW5lLnNsaWNlKGluZGV4ICsgMSkpO1xyXG4gICAgZmllbGRzW2ZpZWxkXSA9IHZhbDtcclxuICB9XHJcblxyXG4gIHJldHVybiBmaWVsZHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIG1pbWUgdHlwZSBmb3IgdGhlIGdpdmVuIGBzdHJgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXHJcbiAqIEByZXR1cm4ge1N0cmluZ31cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gdHlwZShzdHIpe1xyXG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykuc2hpZnQoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gaGVhZGVyIGZpZWxkIHBhcmFtZXRlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBwYXJhbXMoc3RyKXtcclxuICByZXR1cm4gcmVkdWNlKHN0ci5zcGxpdCgvICo7ICovKSwgZnVuY3Rpb24ob2JqLCBzdHIpe1xyXG4gICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KC8gKj0gKi8pXHJcbiAgICAgICwga2V5ID0gcGFydHMuc2hpZnQoKVxyXG4gICAgICAsIHZhbCA9IHBhcnRzLnNoaWZ0KCk7XHJcblxyXG4gICAgaWYgKGtleSAmJiB2YWwpIG9ialtrZXldID0gdmFsO1xyXG4gICAgcmV0dXJuIG9iajtcclxuICB9LCB7fSk7XHJcbn07XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VgIHdpdGggdGhlIGdpdmVuIGB4aHJgLlxyXG4gKlxyXG4gKiAgLSBzZXQgZmxhZ3MgKC5vaywgLmVycm9yLCBldGMpXHJcbiAqICAtIHBhcnNlIGhlYWRlclxyXG4gKlxyXG4gKiBFeGFtcGxlczpcclxuICpcclxuICogIEFsaWFzaW5nIGBzdXBlcmFnZW50YCBhcyBgcmVxdWVzdGAgaXMgbmljZTpcclxuICpcclxuICogICAgICByZXF1ZXN0ID0gc3VwZXJhZ2VudDtcclxuICpcclxuICogIFdlIGNhbiB1c2UgdGhlIHByb21pc2UtbGlrZSBBUEksIG9yIHBhc3MgY2FsbGJhY2tzOlxyXG4gKlxyXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvJykuZW5kKGZ1bmN0aW9uKHJlcyl7fSk7XHJcbiAqICAgICAgcmVxdWVzdC5nZXQoJy8nLCBmdW5jdGlvbihyZXMpe30pO1xyXG4gKlxyXG4gKiAgU2VuZGluZyBkYXRhIGNhbiBiZSBjaGFpbmVkOlxyXG4gKlxyXG4gKiAgICAgIHJlcXVlc3RcclxuICogICAgICAgIC5wb3N0KCcvdXNlcicpXHJcbiAqICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcclxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcclxuICpcclxuICogIE9yIHBhc3NlZCB0byBgLnNlbmQoKWA6XHJcbiAqXHJcbiAqICAgICAgcmVxdWVzdFxyXG4gKiAgICAgICAgLnBvc3QoJy91c2VyJylcclxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xyXG4gKlxyXG4gKiAgT3IgcGFzc2VkIHRvIGAucG9zdCgpYDpcclxuICpcclxuICogICAgICByZXF1ZXN0XHJcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSlcclxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcclxuICpcclxuICogT3IgZnVydGhlciByZWR1Y2VkIHRvIGEgc2luZ2xlIGNhbGwgZm9yIHNpbXBsZSBjYXNlczpcclxuICpcclxuICogICAgICByZXF1ZXN0XHJcbiAqICAgICAgICAucG9zdCgnL3VzZXInLCB7IG5hbWU6ICd0aicgfSwgZnVuY3Rpb24ocmVzKXt9KTtcclxuICpcclxuICogQHBhcmFtIHtYTUxIVFRQUmVxdWVzdH0geGhyXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcSwgb3B0aW9ucykge1xyXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG4gIHRoaXMucmVxID0gcmVxO1xyXG4gIHRoaXMueGhyID0gdGhpcy5yZXEueGhyO1xyXG4gIHRoaXMudGV4dCA9IHRoaXMucmVxLm1ldGhvZCAhPSdIRUFEJyBcclxuICAgICA/IHRoaXMueGhyLnJlc3BvbnNlVGV4dCBcclxuICAgICA6IG51bGw7XHJcbiAgdGhpcy5zZXRTdGF0dXNQcm9wZXJ0aWVzKHRoaXMueGhyLnN0YXR1cyk7XHJcbiAgdGhpcy5oZWFkZXIgPSB0aGlzLmhlYWRlcnMgPSBwYXJzZUhlYWRlcih0aGlzLnhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XHJcbiAgLy8gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzIHNvbWV0aW1lcyBmYWxzZWx5IHJldHVybnMgXCJcIiBmb3IgQ09SUyByZXF1ZXN0cywgYnV0XHJcbiAgLy8gZ2V0UmVzcG9uc2VIZWFkZXIgc3RpbGwgd29ya3MuIHNvIHdlIGdldCBjb250ZW50LXR5cGUgZXZlbiBpZiBnZXR0aW5nXHJcbiAgLy8gb3RoZXIgaGVhZGVycyBmYWlscy5cclxuICB0aGlzLmhlYWRlclsnY29udGVudC10eXBlJ10gPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XHJcbiAgdGhpcy5zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcclxuICB0aGlzLmJvZHkgPSB0aGlzLnJlcS5tZXRob2QgIT0gJ0hFQUQnXHJcbiAgICA/IHRoaXMucGFyc2VCb2R5KHRoaXMudGV4dClcclxuICAgIDogbnVsbDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGBmaWVsZGAgdmFsdWUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuUmVzcG9uc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKXtcclxuICByZXR1cm4gdGhpcy5oZWFkZXJbZmllbGQudG9Mb3dlckNhc2UoKV07XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IGhlYWRlciByZWxhdGVkIHByb3BlcnRpZXM6XHJcbiAqXHJcbiAqICAgLSBgLnR5cGVgIHRoZSBjb250ZW50IHR5cGUgd2l0aG91dCBwYXJhbXNcclxuICpcclxuICogQSByZXNwb25zZSBvZiBcIkNvbnRlbnQtVHlwZTogdGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXHJcbiAqIHdpbGwgcHJvdmlkZSB5b3Ugd2l0aCBhIGAudHlwZWAgb2YgXCJ0ZXh0L3BsYWluXCIuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBoZWFkZXJcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuUmVzcG9uc2UucHJvdG90eXBlLnNldEhlYWRlclByb3BlcnRpZXMgPSBmdW5jdGlvbihoZWFkZXIpe1xyXG4gIC8vIGNvbnRlbnQtdHlwZVxyXG4gIHZhciBjdCA9IHRoaXMuaGVhZGVyWydjb250ZW50LXR5cGUnXSB8fCAnJztcclxuICB0aGlzLnR5cGUgPSB0eXBlKGN0KTtcclxuXHJcbiAgLy8gcGFyYW1zXHJcbiAgdmFyIG9iaiA9IHBhcmFtcyhjdCk7XHJcbiAgZm9yICh2YXIga2V5IGluIG9iaikgdGhpc1trZXldID0gb2JqW2tleV07XHJcbn07XHJcblxyXG4vKipcclxuICogUGFyc2UgdGhlIGdpdmVuIGJvZHkgYHN0cmAuXHJcbiAqXHJcbiAqIFVzZWQgZm9yIGF1dG8tcGFyc2luZyBvZiBib2RpZXMuIFBhcnNlcnNcclxuICogYXJlIGRlZmluZWQgb24gdGhlIGBzdXBlcmFnZW50LnBhcnNlYCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcclxuICogQHJldHVybiB7TWl4ZWR9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcblJlc3BvbnNlLnByb3RvdHlwZS5wYXJzZUJvZHkgPSBmdW5jdGlvbihzdHIpe1xyXG4gIHZhciBwYXJzZSA9IHJlcXVlc3QucGFyc2VbdGhpcy50eXBlXTtcclxuICByZXR1cm4gcGFyc2UgJiYgc3RyICYmIHN0ci5sZW5ndGhcclxuICAgID8gcGFyc2Uoc3RyKVxyXG4gICAgOiBudWxsO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCBmbGFncyBzdWNoIGFzIGAub2tgIGJhc2VkIG9uIGBzdGF0dXNgLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSBhIDJ4eCByZXNwb25zZSB3aWxsIGdpdmUgeW91IGEgYC5va2Agb2YgX190cnVlX19cclxuICogd2hlcmVhcyA1eHggd2lsbCBiZSBfX2ZhbHNlX18gYW5kIGAuZXJyb3JgIHdpbGwgYmUgX190cnVlX18uIFRoZVxyXG4gKiBgLmNsaWVudEVycm9yYCBhbmQgYC5zZXJ2ZXJFcnJvcmAgYXJlIGFsc28gYXZhaWxhYmxlIHRvIGJlIG1vcmVcclxuICogc3BlY2lmaWMsIGFuZCBgLnN0YXR1c1R5cGVgIGlzIHRoZSBjbGFzcyBvZiBlcnJvciByYW5naW5nIGZyb20gMS4uNVxyXG4gKiBzb21ldGltZXMgdXNlZnVsIGZvciBtYXBwaW5nIHJlc3BvbmQgY29sb3JzIGV0Yy5cclxuICpcclxuICogXCJzdWdhclwiIHByb3BlcnRpZXMgYXJlIGFsc28gZGVmaW5lZCBmb3IgY29tbW9uIGNhc2VzLiBDdXJyZW50bHkgcHJvdmlkaW5nOlxyXG4gKlxyXG4gKiAgIC0gLm5vQ29udGVudFxyXG4gKiAgIC0gLmJhZFJlcXVlc3RcclxuICogICAtIC51bmF1dGhvcml6ZWRcclxuICogICAtIC5ub3RBY2NlcHRhYmxlXHJcbiAqICAgLSAubm90Rm91bmRcclxuICpcclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c1xyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5SZXNwb25zZS5wcm90b3R5cGUuc2V0U3RhdHVzUHJvcGVydGllcyA9IGZ1bmN0aW9uKHN0YXR1cyl7XHJcbiAgdmFyIHR5cGUgPSBzdGF0dXMgLyAxMDAgfCAwO1xyXG5cclxuICAvLyBzdGF0dXMgLyBjbGFzc1xyXG4gIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xyXG4gIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7XHJcblxyXG4gIC8vIGJhc2ljc1xyXG4gIHRoaXMuaW5mbyA9IDEgPT0gdHlwZTtcclxuICB0aGlzLm9rID0gMiA9PSB0eXBlO1xyXG4gIHRoaXMuY2xpZW50RXJyb3IgPSA0ID09IHR5cGU7XHJcbiAgdGhpcy5zZXJ2ZXJFcnJvciA9IDUgPT0gdHlwZTtcclxuICB0aGlzLmVycm9yID0gKDQgPT0gdHlwZSB8fCA1ID09IHR5cGUpXHJcbiAgICA/IHRoaXMudG9FcnJvcigpXHJcbiAgICA6IGZhbHNlO1xyXG5cclxuICAvLyBzdWdhclxyXG4gIHRoaXMuYWNjZXB0ZWQgPSAyMDIgPT0gc3RhdHVzO1xyXG4gIHRoaXMubm9Db250ZW50ID0gMjA0ID09IHN0YXR1cyB8fCAxMjIzID09IHN0YXR1cztcclxuICB0aGlzLmJhZFJlcXVlc3QgPSA0MDAgPT0gc3RhdHVzO1xyXG4gIHRoaXMudW5hdXRob3JpemVkID0gNDAxID09IHN0YXR1cztcclxuICB0aGlzLm5vdEFjY2VwdGFibGUgPSA0MDYgPT0gc3RhdHVzO1xyXG4gIHRoaXMubm90Rm91bmQgPSA0MDQgPT0gc3RhdHVzO1xyXG4gIHRoaXMuZm9yYmlkZGVuID0gNDAzID09IHN0YXR1cztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtFcnJvcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5SZXNwb25zZS5wcm90b3R5cGUudG9FcnJvciA9IGZ1bmN0aW9uKCl7XHJcbiAgdmFyIHJlcSA9IHRoaXMucmVxO1xyXG4gIHZhciBtZXRob2QgPSByZXEubWV0aG9kO1xyXG4gIHZhciB1cmwgPSByZXEudXJsO1xyXG5cclxuICB2YXIgbXNnID0gJ2Nhbm5vdCAnICsgbWV0aG9kICsgJyAnICsgdXJsICsgJyAoJyArIHRoaXMuc3RhdHVzICsgJyknO1xyXG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcclxuICBlcnIuc3RhdHVzID0gdGhpcy5zdGF0dXM7XHJcbiAgZXJyLm1ldGhvZCA9IG1ldGhvZDtcclxuICBlcnIudXJsID0gdXJsO1xyXG5cclxuICByZXR1cm4gZXJyO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4cG9zZSBgUmVzcG9uc2VgLlxyXG4gKi9cclxuXHJcbnJlcXVlc3QuUmVzcG9uc2UgPSBSZXNwb25zZTtcclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0YCB3aXRoIHRoZSBnaXZlbiBgbWV0aG9kYCBhbmQgYHVybGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcclxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIFJlcXVlc3QobWV0aG9kLCB1cmwpIHtcclxuICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgRW1pdHRlci5jYWxsKHRoaXMpO1xyXG4gIHRoaXMuX3F1ZXJ5ID0gdGhpcy5fcXVlcnkgfHwgW107XHJcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XHJcbiAgdGhpcy51cmwgPSB1cmw7XHJcbiAgdGhpcy5oZWFkZXIgPSB7fTtcclxuICB0aGlzLl9oZWFkZXIgPSB7fTtcclxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbigpe1xyXG4gICAgdmFyIGVyciA9IG51bGw7XHJcbiAgICB2YXIgcmVzID0gbnVsbDtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICByZXMgPSBuZXcgUmVzcG9uc2Uoc2VsZik7IFxyXG4gICAgfSBjYXRjaChlKSB7XHJcbiAgICAgIGVyciA9IG5ldyBFcnJvcignUGFyc2VyIGlzIHVuYWJsZSB0byBwYXJzZSB0aGUgcmVzcG9uc2UnKTtcclxuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcclxuICAgICAgZXJyLm9yaWdpbmFsID0gZTtcclxuICAgIH1cclxuXHJcbiAgICBzZWxmLmNhbGxiYWNrKGVyciwgcmVzKTtcclxuICB9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1peGluIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcclxuXHJcbi8qKlxyXG4gKiBBbGxvdyBmb3IgZXh0ZW5zaW9uXHJcbiAqL1xyXG5cclxuUmVxdWVzdC5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24oZm4pIHtcclxuICBmbih0aGlzKTtcclxuICByZXR1cm4gdGhpcztcclxufVxyXG5cclxuLyoqXHJcbiAqIFNldCB0aW1lb3V0IHRvIGBtc2AuXHJcbiAqXHJcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xyXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5SZXF1ZXN0LnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24obXMpe1xyXG4gIHRoaXMuX3RpbWVvdXQgPSBtcztcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDbGVhciBwcmV2aW91cyB0aW1lb3V0LlxyXG4gKlxyXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbigpe1xyXG4gIHRoaXMuX3RpbWVvdXQgPSAwO1xyXG4gIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWJvcnQgdGhlIHJlcXVlc3QsIGFuZCBjbGVhciBwb3RlbnRpYWwgdGltZW91dC5cclxuICpcclxuICogQHJldHVybiB7UmVxdWVzdH1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XHJcbiAgaWYgKHRoaXMuYWJvcnRlZCkgcmV0dXJuO1xyXG4gIHRoaXMuYWJvcnRlZCA9IHRydWU7XHJcbiAgdGhpcy54aHIuYWJvcnQoKTtcclxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xyXG4gIHRoaXMuZW1pdCgnYWJvcnQnKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgaGVhZGVyIGBmaWVsZGAgdG8gYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3QuXHJcbiAqXHJcbiAqIEV4YW1wbGVzOlxyXG4gKlxyXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxyXG4gKiAgICAgICAgLnNldCgnQWNjZXB0JywgJ2FwcGxpY2F0aW9uL2pzb24nKVxyXG4gKiAgICAgICAgLnNldCgnWC1BUEktS2V5JywgJ2Zvb2JhcicpXHJcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcclxuICpcclxuICogICAgICByZXEuZ2V0KCcvJylcclxuICogICAgICAgIC5zZXQoeyBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJywgJ1gtQVBJLUtleSc6ICdmb29iYXInIH0pXHJcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBmaWVsZFxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXHJcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcblJlcXVlc3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKGZpZWxkLCB2YWwpe1xyXG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBmaWVsZCkge1xyXG4gICAgICB0aGlzLnNldChrZXksIGZpZWxkW2tleV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcclxuICB0aGlzLmhlYWRlcltmaWVsZF0gPSB2YWw7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxyXG4gKlxyXG4gKiBFeGFtcGxlOlxyXG4gKlxyXG4gKiAgICAgIHJlcS5nZXQoJy8nKVxyXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcclxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcclxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuUmVxdWVzdC5wcm90b3R5cGUudW5zZXQgPSBmdW5jdGlvbihmaWVsZCl7XHJcbiAgZGVsZXRlIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcclxuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEdldCBjYXNlLWluc2Vuc2l0aXZlIGhlYWRlciBgZmllbGRgIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcclxuICogQHJldHVybiB7U3RyaW5nfVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5SZXF1ZXN0LnByb3RvdHlwZS5nZXRIZWFkZXIgPSBmdW5jdGlvbihmaWVsZCl7XHJcbiAgcmV0dXJuIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgQ29udGVudC1UeXBlIHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXHJcbiAqXHJcbiAqIEV4YW1wbGVzOlxyXG4gKlxyXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XHJcbiAqXHJcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcclxuICogICAgICAgIC50eXBlKCd4bWwnKVxyXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxyXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XHJcbiAqXHJcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvJylcclxuICogICAgICAgIC50eXBlKCdhcHBsaWNhdGlvbi94bWwnKVxyXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxyXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXHJcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcblJlcXVlc3QucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbih0eXBlKXtcclxuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZXQgQWNjZXB0IHRvIGB0eXBlYCwgbWFwcGluZyB2YWx1ZXMgZnJvbSBgcmVxdWVzdC50eXBlc2AuXHJcbiAqXHJcbiAqIEV4YW1wbGVzOlxyXG4gKlxyXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcclxuICpcclxuICogICAgICByZXF1ZXN0LmdldCgnL2FnZW50JylcclxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxyXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XHJcbiAqXHJcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXHJcbiAqICAgICAgICAuYWNjZXB0KCdhcHBsaWNhdGlvbi9qc29uJylcclxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjZXB0XHJcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xyXG4gIHRoaXMuc2V0KCdBY2NlcHQnLCByZXF1ZXN0LnR5cGVzW3R5cGVdIHx8IHR5cGUpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzXHJcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcblJlcXVlc3QucHJvdG90eXBlLmF1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzKXtcclxuICB2YXIgc3RyID0gYnRvYSh1c2VyICsgJzonICsgcGFzcyk7XHJcbiAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIHN0cik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuKiBBZGQgcXVlcnktc3RyaW5nIGB2YWxgLlxyXG4qXHJcbiogRXhhbXBsZXM6XHJcbipcclxuKiAgIHJlcXVlc3QuZ2V0KCcvc2hvZXMnKVxyXG4qICAgICAucXVlcnkoJ3NpemU9MTAnKVxyXG4qICAgICAucXVlcnkoeyBjb2xvcjogJ2JsdWUnIH0pXHJcbipcclxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHZhbFxyXG4qIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xyXG4qIEBhcGkgcHVibGljXHJcbiovXHJcblxyXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XHJcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiB2YWwpIHZhbCA9IHNlcmlhbGl6ZSh2YWwpO1xyXG4gIGlmICh2YWwpIHRoaXMuX3F1ZXJ5LnB1c2godmFsKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBXcml0ZSB0aGUgZmllbGQgYG5hbWVgIGFuZCBgdmFsYCBmb3IgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCJcclxuICogcmVxdWVzdCBib2RpZXMuXHJcbiAqXHJcbiAqIGBgYCBqc1xyXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxyXG4gKiAgIC5maWVsZCgnZm9vJywgJ2JhcicpXHJcbiAqICAgLmVuZChjYWxsYmFjayk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxyXG4gKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEZpbGV9IHZhbFxyXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5SZXF1ZXN0LnByb3RvdHlwZS5maWVsZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbCl7XHJcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkgdGhpcy5fZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuICB0aGlzLl9mb3JtRGF0YS5hcHBlbmQobmFtZSwgdmFsKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBRdWV1ZSB0aGUgZ2l2ZW4gYGZpbGVgIGFzIGFuIGF0dGFjaG1lbnQgdG8gdGhlIHNwZWNpZmllZCBgZmllbGRgLFxyXG4gKiB3aXRoIG9wdGlvbmFsIGBmaWxlbmFtZWAuXHJcbiAqXHJcbiAqIGBgYCBqc1xyXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxyXG4gKiAgIC5hdHRhY2gobmV3IEJsb2IoWyc8YSBpZD1cImFcIj48YiBpZD1cImJcIj5oZXkhPC9iPjwvYT4nXSwgeyB0eXBlOiBcInRleHQvaHRtbFwifSkpXHJcbiAqICAgLmVuZChjYWxsYmFjayk7XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcclxuICogQHBhcmFtIHtCbG9ifEZpbGV9IGZpbGVcclxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVuYW1lXHJcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcblJlcXVlc3QucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKGZpZWxkLCBmaWxlLCBmaWxlbmFtZSl7XHJcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkgdGhpcy5fZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcclxuICB0aGlzLl9mb3JtRGF0YS5hcHBlbmQoZmllbGQsIGZpbGUsIGZpbGVuYW1lKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTZW5kIGBkYXRhYCwgZGVmYXVsdGluZyB0aGUgYC50eXBlKClgIHRvIFwianNvblwiIHdoZW5cclxuICogYW4gb2JqZWN0IGlzIGdpdmVuLlxyXG4gKlxyXG4gKiBFeGFtcGxlczpcclxuICpcclxuICogICAgICAgLy8gcXVlcnlzdHJpbmdcclxuICogICAgICAgcmVxdWVzdC5nZXQoJy9zZWFyY2gnKVxyXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXHJcbiAqXHJcbiAqICAgICAgIC8vIG11bHRpcGxlIGRhdGEgXCJ3cml0ZXNcIlxyXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3NlYXJjaCcpXHJcbiAqICAgICAgICAgLnNlbmQoeyBzZWFyY2g6ICdxdWVyeScgfSlcclxuICogICAgICAgICAuc2VuZCh7IHJhbmdlOiAnMS4uNScgfSlcclxuICogICAgICAgICAuc2VuZCh7IG9yZGVyOiAnZGVzYycgfSlcclxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxyXG4gKlxyXG4gKiAgICAgICAvLyBtYW51YWwganNvblxyXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcclxuICogICAgICAgICAudHlwZSgnanNvbicpXHJcbiAqICAgICAgICAgLnNlbmQoJ3tcIm5hbWVcIjpcInRqXCJ9KVxyXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXHJcbiAqXHJcbiAqICAgICAgIC8vIGF1dG8ganNvblxyXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcclxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcclxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxyXG4gKlxyXG4gKiAgICAgICAvLyBtYW51YWwgeC13d3ctZm9ybS11cmxlbmNvZGVkXHJcbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxyXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcclxuICogICAgICAgICAuc2VuZCgnbmFtZT10aicpXHJcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcclxuICpcclxuICogICAgICAgLy8gYXV0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcclxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXHJcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxyXG4gKiAgICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxyXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXHJcbiAqXHJcbiAqICAgICAgIC8vIGRlZmF1bHRzIHRvIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxyXG4gICogICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcclxuICAqICAgICAgICAuc2VuZCgnbmFtZT10b2JpJylcclxuICAqICAgICAgICAuc2VuZCgnc3BlY2llcz1mZXJyZXQnKVxyXG4gICogICAgICAgIC5lbmQoY2FsbGJhY2spXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGF0YVxyXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5SZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XHJcbiAgdmFyIG9iaiA9IGlzT2JqZWN0KGRhdGEpO1xyXG4gIHZhciB0eXBlID0gdGhpcy5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpO1xyXG5cclxuICAvLyBtZXJnZVxyXG4gIGlmIChvYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcclxuICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XHJcbiAgICAgIHRoaXMuX2RhdGFba2V5XSA9IGRhdGFba2V5XTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBkYXRhKSB7XHJcbiAgICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnZm9ybScpO1xyXG4gICAgdHlwZSA9IHRoaXMuZ2V0SGVhZGVyKCdDb250ZW50LVR5cGUnKTtcclxuICAgIGlmICgnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyA9PSB0eXBlKSB7XHJcbiAgICAgIHRoaXMuX2RhdGEgPSB0aGlzLl9kYXRhXHJcbiAgICAgICAgPyB0aGlzLl9kYXRhICsgJyYnICsgZGF0YVxyXG4gICAgICAgIDogZGF0YTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcclxuICB9XHJcblxyXG4gIGlmICghb2JqKSByZXR1cm4gdGhpcztcclxuICBpZiAoIXR5cGUpIHRoaXMudHlwZSgnanNvbicpO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBgZXJyYCBhbmQgYHJlc2BcclxuICogYW5kIGhhbmRsZSBhcml0eSBjaGVjay5cclxuICpcclxuICogQHBhcmFtIHtFcnJvcn0gZXJyXHJcbiAqIEBwYXJhbSB7UmVzcG9uc2V9IHJlc1xyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5SZXF1ZXN0LnByb3RvdHlwZS5jYWxsYmFjayA9IGZ1bmN0aW9uKGVyciwgcmVzKXtcclxuICB2YXIgZm4gPSB0aGlzLl9jYWxsYmFjaztcclxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xyXG4gIGlmICgyID09IGZuLmxlbmd0aCkgcmV0dXJuIGZuKGVyciwgcmVzKTtcclxuICBpZiAoZXJyKSByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XHJcbiAgZm4ocmVzKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBJbnZva2UgY2FsbGJhY2sgd2l0aCB4LWRvbWFpbiBlcnJvci5cclxuICpcclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuUmVxdWVzdC5wcm90b3R5cGUuY3Jvc3NEb21haW5FcnJvciA9IGZ1bmN0aW9uKCl7XHJcbiAgdmFyIGVyciA9IG5ldyBFcnJvcignT3JpZ2luIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbicpO1xyXG4gIGVyci5jcm9zc0RvbWFpbiA9IHRydWU7XHJcbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHRpbWVvdXQgZXJyb3IuXHJcbiAqXHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcblJlcXVlc3QucHJvdG90eXBlLnRpbWVvdXRFcnJvciA9IGZ1bmN0aW9uKCl7XHJcbiAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xyXG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3RpbWVvdXQgb2YgJyArIHRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnKTtcclxuICBlcnIudGltZW91dCA9IHRpbWVvdXQ7XHJcbiAgdGhpcy5jYWxsYmFjayhlcnIpO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVuYWJsZSB0cmFuc21pc3Npb24gb2YgY29va2llcyB3aXRoIHgtZG9tYWluIHJlcXVlc3RzLlxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgZm9yIHRoaXMgdG8gd29yayB0aGUgb3JpZ2luIG11c3Qgbm90IGJlXHJcbiAqIHVzaW5nIFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIgd2l0aCBhIHdpbGRjYXJkLFxyXG4gKiBhbmQgYWxzbyBtdXN0IHNldCBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCJcclxuICogdG8gXCJ0cnVlXCIuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuUmVxdWVzdC5wcm90b3R5cGUud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24oKXtcclxuICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYXRlIHJlcXVlc3QsIGludm9raW5nIGNhbGxiYWNrIGBmbihyZXMpYFxyXG4gKiB3aXRoIGFuIGluc3RhbmNlb2YgYFJlc3BvbnNlYC5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oZm4pe1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBnZXRYSFIoKTtcclxuICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeS5qb2luKCcmJyk7XHJcbiAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xyXG4gIHZhciBkYXRhID0gdGhpcy5fZm9ybURhdGEgfHwgdGhpcy5fZGF0YTtcclxuXHJcbiAgLy8gc3RvcmUgY2FsbGJhY2tcclxuICB0aGlzLl9jYWxsYmFjayA9IGZuIHx8IG5vb3A7XHJcblxyXG4gIC8vIHN0YXRlIGNoYW5nZVxyXG4gIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xyXG4gICAgaWYgKDQgIT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcclxuICAgIGlmICgwID09IHhoci5zdGF0dXMpIHtcclxuICAgICAgaWYgKHNlbGYuYWJvcnRlZCkgcmV0dXJuIHNlbGYudGltZW91dEVycm9yKCk7XHJcbiAgICAgIHJldHVybiBzZWxmLmNyb3NzRG9tYWluRXJyb3IoKTtcclxuICAgIH1cclxuICAgIHNlbGYuZW1pdCgnZW5kJyk7XHJcbiAgfTtcclxuXHJcbiAgLy8gcHJvZ3Jlc3NcclxuICBpZiAoeGhyLnVwbG9hZCkge1xyXG4gICAgeGhyLnVwbG9hZC5vbnByb2dyZXNzID0gZnVuY3Rpb24oZSl7XHJcbiAgICAgIGUucGVyY2VudCA9IGUubG9hZGVkIC8gZS50b3RhbCAqIDEwMDtcclxuICAgICAgc2VsZi5lbWl0KCdwcm9ncmVzcycsIGUpO1xyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIHRpbWVvdXRcclxuICBpZiAodGltZW91dCAmJiAhdGhpcy5fdGltZXIpIHtcclxuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICBzZWxmLmFib3J0KCk7XHJcbiAgICB9LCB0aW1lb3V0KTtcclxuICB9XHJcblxyXG4gIC8vIHF1ZXJ5c3RyaW5nXHJcbiAgaWYgKHF1ZXJ5KSB7XHJcbiAgICBxdWVyeSA9IHJlcXVlc3Quc2VyaWFsaXplT2JqZWN0KHF1ZXJ5KTtcclxuICAgIHRoaXMudXJsICs9IH50aGlzLnVybC5pbmRleE9mKCc/JylcclxuICAgICAgPyAnJicgKyBxdWVyeVxyXG4gICAgICA6ICc/JyArIHF1ZXJ5O1xyXG4gIH1cclxuXHJcbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxyXG4gIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSk7XHJcblxyXG4gIC8vIENPUlNcclxuICBpZiAodGhpcy5fd2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcclxuXHJcbiAgLy8gYm9keVxyXG4gIGlmICgnR0VUJyAhPSB0aGlzLm1ldGhvZCAmJiAnSEVBRCcgIT0gdGhpcy5tZXRob2QgJiYgJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgJiYgIWlzSG9zdChkYXRhKSkge1xyXG4gICAgLy8gc2VyaWFsaXplIHN0dWZmXHJcbiAgICB2YXIgc2VyaWFsaXplID0gcmVxdWVzdC5zZXJpYWxpemVbdGhpcy5nZXRIZWFkZXIoJ0NvbnRlbnQtVHlwZScpXTtcclxuICAgIGlmIChzZXJpYWxpemUpIGRhdGEgPSBzZXJpYWxpemUoZGF0YSk7XHJcbiAgfVxyXG5cclxuICAvLyBzZXQgaGVhZGVyIGZpZWxkc1xyXG4gIGZvciAodmFyIGZpZWxkIGluIHRoaXMuaGVhZGVyKSB7XHJcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xyXG4gICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoZmllbGQsIHRoaXMuaGVhZGVyW2ZpZWxkXSk7XHJcbiAgfVxyXG5cclxuICAvLyBzZW5kIHN0dWZmXHJcbiAgdGhpcy5lbWl0KCdyZXF1ZXN0JywgdGhpcyk7XHJcbiAgeGhyLnNlbmQoZGF0YSk7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRXhwb3NlIGBSZXF1ZXN0YC5cclxuICovXHJcblxyXG5yZXF1ZXN0LlJlcXVlc3QgPSBSZXF1ZXN0O1xyXG5cclxuLyoqXHJcbiAqIElzc3VlIGEgcmVxdWVzdDpcclxuICpcclxuICogRXhhbXBsZXM6XHJcbiAqXHJcbiAqICAgIHJlcXVlc3QoJ0dFVCcsICcvdXNlcnMnKS5lbmQoY2FsbGJhY2spXHJcbiAqICAgIHJlcXVlc3QoJy91c2VycycpLmVuZChjYWxsYmFjaylcclxuICogICAgcmVxdWVzdCgnL3VzZXJzJywgY2FsbGJhY2spXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcclxuICogQHBhcmFtIHtTdHJpbmd8RnVuY3Rpb259IHVybCBvciBjYWxsYmFja1xyXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIHJlcXVlc3QobWV0aG9kLCB1cmwpIHtcclxuICAvLyBjYWxsYmFja1xyXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1cmwpIHtcclxuICAgIHJldHVybiBuZXcgUmVxdWVzdCgnR0VUJywgbWV0aG9kKS5lbmQodXJsKTtcclxuICB9XHJcblxyXG4gIC8vIHVybCBmaXJzdFxyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHJldHVybiBuZXcgUmVxdWVzdCgnR0VUJywgbWV0aG9kKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBuZXcgUmVxdWVzdChtZXRob2QsIHVybCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHRVQgYHVybGAgd2l0aCBvcHRpb25hbCBjYWxsYmFjayBgZm4ocmVzKWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcclxuICogQHBhcmFtIHtNaXhlZHxGdW5jdGlvbn0gZGF0YSBvciBmblxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbnJlcXVlc3QuZ2V0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XHJcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0dFVCcsIHVybCk7XHJcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XHJcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcclxuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xyXG4gIHJldHVybiByZXE7XHJcbn07XHJcblxyXG4vKipcclxuICogSEVBRCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxyXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBkYXRhIG9yIGZuXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge1JlcXVlc3R9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxucmVxdWVzdC5oZWFkID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbil7XHJcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ0hFQUQnLCB1cmwpO1xyXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xyXG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcclxuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xyXG4gIHJldHVybiByZXE7XHJcbn07XHJcblxyXG4vKipcclxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge1JlcXVlc3R9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxucmVxdWVzdC5kZWwgPSBmdW5jdGlvbih1cmwsIGZuKXtcclxuICB2YXIgcmVxID0gcmVxdWVzdCgnREVMRVRFJywgdXJsKTtcclxuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xyXG4gIHJldHVybiByZXE7XHJcbn07XHJcblxyXG4vKipcclxuICogUEFUQ0ggYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxyXG4gKiBAcGFyYW0ge01peGVkfSBkYXRhXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge1JlcXVlc3R9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxucmVxdWVzdC5wYXRjaCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xyXG4gIHZhciByZXEgPSByZXF1ZXN0KCdQQVRDSCcsIHVybCk7XHJcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIGZuID0gZGF0YSwgZGF0YSA9IG51bGw7XHJcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xyXG4gIGlmIChmbikgcmVxLmVuZChmbik7XHJcbiAgcmV0dXJuIHJlcTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQT1NUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcclxuICogQHBhcmFtIHtNaXhlZH0gZGF0YVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbnJlcXVlc3QucG9zdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xyXG4gIHZhciByZXEgPSByZXF1ZXN0KCdQT1NUJywgdXJsKTtcclxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgZm4gPSBkYXRhLCBkYXRhID0gbnVsbDtcclxuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XHJcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcclxuICByZXR1cm4gcmVxO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFBVVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXHJcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IGRhdGEgb3IgZm5cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7UmVxdWVzdH1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5yZXF1ZXN0LnB1dCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pe1xyXG4gIHZhciByZXEgPSByZXF1ZXN0KCdQVVQnLCB1cmwpO1xyXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSBmbiA9IGRhdGEsIGRhdGEgPSBudWxsO1xyXG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcclxuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xyXG4gIHJldHVybiByZXE7XHJcbn07XHJcblxyXG4vKipcclxuICogRXhwb3NlIGByZXF1ZXN0YC5cclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVlc3Q7XHJcbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcblxyXG4vKipcclxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXHJcbiAqXHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcclxuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXHJcbiAqIEByZXR1cm4ge09iamVjdH1cclxuICogQGFwaSBwcml2YXRlXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XHJcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XHJcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XHJcbiAgfVxyXG4gIHJldHVybiBvYmo7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXHJcbiAgICAucHVzaChmbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXHJcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHZhciBzZWxmID0gdGhpcztcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIGZ1bmN0aW9uIG9uKCkge1xyXG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcclxuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgfVxyXG5cclxuICBvbi5mbiA9IGZuO1xyXG4gIHRoaXMub24oZXZlbnQsIG9uKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxyXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIC8vIGFsbFxyXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyBzcGVjaWZpYyBldmVudFxyXG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xyXG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcclxuXHJcbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xyXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcclxuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxyXG4gIHZhciBjYjtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgY2IgPSBjYWxsYmFja3NbaV07XHJcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xyXG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge01peGVkfSAuLi5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG4iLCJcclxuLyoqXHJcbiAqIFJlZHVjZSBgYXJyYCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcGFyYW0ge01peGVkfSBpbml0aWFsXHJcbiAqXHJcbiAqIFRPRE86IGNvbWJhdGlibGUgZXJyb3IgaGFuZGxpbmc/XHJcbiAqL1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIGZuLCBpbml0aWFsKXsgIFxyXG4gIHZhciBpZHggPSAwO1xyXG4gIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xyXG4gIHZhciBjdXJyID0gYXJndW1lbnRzLmxlbmd0aCA9PSAzXHJcbiAgICA/IGluaXRpYWxcclxuICAgIDogYXJyW2lkeCsrXTtcclxuXHJcbiAgd2hpbGUgKGlkeCA8IGxlbikge1xyXG4gICAgY3VyciA9IGZuLmNhbGwobnVsbCwgY3VyciwgYXJyW2lkeF0sICsraWR4LCBhcnIpO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gY3VycjtcclxufTsiLCJ2YXIgQmFja2JvbmUgPSByZXF1aXJlKCdiYWNrYm9uZScpXHJcbiAgLCBCYWNrZ3JpZCA9IHJlcXVpcmUoJ2JhY2tncmlkJylcclxuICAsIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpXHJcbiAgLCBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpXHJcbiAgLCBtb2RlbHMgPSByZXF1aXJlKCcuL21vZGVscy9pbmRleC5qcycpXHJcbiAgLCB2aWV3cyA9IHJlcXVpcmUoJy4vdmlld3MuanMnKVxyXG4gICwgTm90aWZ5ID0gcmVxdWlyZSgnLi9sb2NhbF9tb2R1bGVzL25vdGlmeS9ub3RpZnkuanMnKTtcclxuXHJcbnZhciBtZW51RGF0YSA9IFtcclxuICB7XHJcbiAgICBuYW1lOiAnRGFzaGJvYXJkJyxcclxuICAgIGlkOiAnZGFzaGJvYXJkJyxcclxuICAgIGljb246ICd0YXNrcycsXHJcbiAgICB1cmw6ICcvJ1xyXG4gIH0sXHJcbiAge1xyXG4gICAgbmFtZTogJ1N1YmplY3RzJyxcclxuICAgIGlkOiAnc3ViamVjdHMnLFxyXG4gICAgaWNvbjogJ3RhZ3MnLFxyXG4gICAgdXJsOiAnL3N1YmplY3RzJ1xyXG4gIH1cclxuXVxyXG5cclxudmFyIFJvdXRlciA9IEJhY2tib25lLlJvdXRlci5leHRlbmQoe1xyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5vbihcImFsbFwiLCB0aGlzLnN0b3JlUm91dGUpXHJcbiAgICB0aGlzLmhpc3RvcnkgPSBbXVxyXG4gICAgdGhpcy5sYXlvdXQgPSAnJ1xyXG4gICAgdGhpcy5ub3RpY2UgPSB7fVxyXG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlXHJcbiAgICB0aGlzLmJ1aWxkTWVudSgpXHJcbiAgICB0aGlzLmNvbnRleHRNZW51ID0gbmV3IG1vZGVscy5jb250ZXh0SXRlbXMoKVxyXG5cdH0sXHJcblx0cm91dGVzOiB7XHJcbiAgICAnJzogJ2Rhc2hib2FyZCcsXHJcbiAgICAnc3ViamVjdHMnOiAnc3ViamVjdHMnLFxyXG4gICAgJ3N1YmplY3RzL2FkZCc6ICdzdWJqZWN0QWRkJyxcclxuICAgICdzdWJqZWN0cy86aWQnOiAnc3ViamVjdEVkaXQnXHJcblx0fSxcclxuICBkYXNoYm9hcmQ6IGZ1bmN0aW9uKGNhbGxiYWNrLCBpZCkge1xyXG4gICAgdmFyIGRhc2hib2FyZEdyaWQgPSBbXHJcbiAgICAgIHtcclxuICAgICAgICBuYW1lOiAnbm9kZXMuZG9jdW1lbnQudGl0bGUnLFxyXG4gICAgICAgIGxhYmVsOiAnc29ydCBieSB0aXRsZScsXHJcbiAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgIGNlbGw6IHZpZXdzLmRvY3VtZW50Q2VsbFxyXG4gICAgICB9XHJcbiAgICBdO1xyXG4gICAgdGhpcy5ncmlkKGRhc2hib2FyZEdyaWQsICdkb2N1bWVudHMnLCAnZG9jdW1lbnRzR3JpZCcsIGNhbGxiYWNrLCBpZCk7XHJcbiAgfSxcclxuXHJcbiAgc3ViamVjdHM6IGZ1bmN0aW9uKGNhbGxiYWNrLCBpZCkge1xyXG4gICAgTm90aWZ5LnNwaW5uZXIoJ3Nob3cnKTtcclxuXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgXHJcbiAgICBzZWxmLnN1YmplY3RzID0gbmV3IG1vZGVscy5zdWJqZWN0cygpXHJcblxyXG4gICAgc2VsZi5zdWJqZWN0cy5mZXRjaCgpLmRvbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBzdWJqZWN0c1ZpZXcgPSBuZXcgdmlld3Muc3ViamVjdHNUcmVlVmlldyh7IGNvbGxlY3Rpb246IHNlbGYuc3ViamVjdHMsIGNvbnRleHRNZW51OiBzZWxmLmNvbnRleHRNZW51IH0pO1xyXG4gICAgICBzZWxmLmNoYW5nZUxheW91dChzdWJqZWN0c1ZpZXcsIGNhbGxiYWNrLCBpZCk7XHJcbiAgICAgIE5vdGlmeS5zcGlubmVyKCdoaWRlJyk7XHJcbiAgICAgIE5vdGlmeS5pbmZvKCAnRGF0YSBoYXMgYmVlbiBsb2FkZWQnICk7XHJcbiAgICB9KTtcclxuICB9LFxyXG5cclxuICBzdWJqZWN0UGFnZTogZnVuY3Rpb24oaWQpIHtcclxuICAgICAgTm90aWZ5LnNwaW5uZXIoJ3Nob3cnKTtcclxuXHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgIG1vZGVsID0gbW9kZWxzLnN1YmplY3QuY3JlYXRlKHtfaWQ6aWR9KSxcclxuICAgICAgICAgIHRlcm1zID0gbmV3IG1vZGVscy50ZXJtcyhbXSx7IHF1ZXJ5UGFyYW1zOiB7cXVlcnk6IHtkaWN0aW9uYXJ5OiBpZH19LCBzdGF0ZToge3BhZ2VTaXplOiA1MDB9fSlcclxuXHJcbiAgICAgIG1vZGVsLmZldGNoKCkuZG9uZShmdW5jdGlvbigpIHtcclxuICAgICAgICB0ZXJtcy5mZXRjaCgpLmRvbmUoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICB2YXIgdmlldyA9IG5ldyB2aWV3cy5jYXRlZ29yeVZpZXcoeyBtb2RlbDogbW9kZWwsIGNvbGxlY3Rpb246IHNlbGYuZGljdGlvbmFyaWVzLCBjb250ZXh0TWVudTogc2VsZi5jb250ZXh0TWVudSwgbGF5b3V0OiBzZWxmLmxheW91dCwgdGVybXM6IHRlcm1zIH0pOyAgIFxyXG4gICAgICAgICAgc2VsZi5sYXlvdXQuc3RhY2tWaWV3LnB1c2godmlldyk7XHJcbiAgICAgICAgICBOb3RpZnkuc3Bpbm5lcignaGlkZScpO1xyXG4gICAgICAgICAgTm90aWZ5LmluZm8oICdEYXRhIGhhcyBiZWVuIGxvYWRlZCcgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgfSxcclxuXHJcbiAgZ3JpZDogZnVuY3Rpb24oZ3JpZCwgY29sTmFtZSwgdmlld05hbWUsIGNhbGxiYWNrLCBpZCkge1xyXG4gICAgTm90aWZ5LnNwaW5uZXIoJ3Nob3cnKTtcclxuXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgICAgXHJcbiAgICBzZWxmW2NvbE5hbWVdID0gbmV3IG1vZGVsc1tjb2xOYW1lXSgpXHJcblxyXG4gICAgc2VsZltjb2xOYW1lXS5mZXRjaCgpLmRvbmUoZnVuY3Rpb24oKXtcclxuICAgICAgdmFyIGdyaWRWaWV3ID0gbmV3IHZpZXdzW3ZpZXdOYW1lXSh7IGNvbGxlY3Rpb246IHNlbGZbY29sTmFtZV0sIGNvbHVtbnM6IGdyaWQsIGNvbnRleHRNZW51OiBzZWxmLmNvbnRleHRNZW51IH0pO1xyXG4gICAgICBzZWxmLmNoYW5nZUxheW91dChncmlkVmlldywgY2FsbGJhY2ssIGlkKTtcclxuICAgICAgTm90aWZ5LnNwaW5uZXIoJ2hpZGUnKTtcclxuICAgICAgTm90aWZ5LmluZm8oICdEYXRhIGhhcyBiZWVuIGxvYWRlZCcgKTtcclxuICAgIH0pO1xyXG4gIH0sXHJcblxyXG4gIGVkaXQ6IGZ1bmN0aW9uKGlkLCBwYXJlbnROYW1lLCBuYW1lLCBtb2RlbE5hbWUsIGNvbE5hbWUpIHtcclxuICAgIGlmKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgIHRoaXNbcGFyZW50TmFtZV0obmFtZSwgaWQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgTm90aWZ5LnNwaW5uZXIoJ3Nob3cnKTtcclxuXHJcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcclxuICAgICAgICAgIG1vZGVsID0gbW9kZWxzW21vZGVsTmFtZV0uY3JlYXRlKHtfaWQ6aWR9KTtcclxuXHJcbiAgICAgIG1vZGVsLmZldGNoKCkuZG9uZShmdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgdmlldyA9IG5ldyB2aWV3cy5lZGl0UGFnZSh7IG1vZGVsOiBtb2RlbCwgY29sbGVjdGlvbjogc2VsZltjb2xOYW1lXSwgYWRkOiBmYWxzZSwgY29udGV4dE1lbnU6IHNlbGYuY29udGV4dE1lbnUsIGxheW91dDogc2VsZi5sYXlvdXQsIHNpZGViYXJJdGVtczogcmVsYXRpb25zIH0pOyAgIFxyXG4gICAgICAgIHNlbGYubGF5b3V0LnN0YWNrVmlldy5wdXNoKHZpZXcpO1xyXG4gICAgICAgIE5vdGlmeS5zcGlubmVyKCdoaWRlJyk7XHJcbiAgICAgICAgTm90aWZ5LmluZm8oICdEYXRhIGhhcyBiZWVuIGxvYWRlZCcgKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgYWRkOiBmdW5jdGlvbihwYXJlbnROYW1lLCBuYW1lLCBtb2RlbE5hbWUsIGNvbE5hbWUpIHtcclxuICAgIGlmKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgIHRoaXNbcGFyZW50TmFtZV0obmFtZSk7XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgICAgbW9kZWwgPSBtb2RlbHNbbW9kZWxOYW1lXS5jcmVhdGUoKTtcclxuXHJcbiAgICAgIHZhciB2aWV3ID0gbmV3IHZpZXdzLmVkaXRQYWdlKHsgbW9kZWw6IG1vZGVsLCBjb2xsZWN0aW9uOiBzZWxmW2NvbE5hbWVdLCBhZGQ6IHRydWUsIGNvbnRleHRNZW51OiBzZWxmLmNvbnRleHRNZW51LCBsYXlvdXQ6IHNlbGYubGF5b3V0IH0pOyAgIFxyXG4gICAgICBzZWxmLmxheW91dC5zdGFja1ZpZXcucHVzaCh2aWV3KVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIHN0b3JlUm91dGU6IGZ1bmN0aW9uKGUpIHtcclxuICAgIGlmKGUgIT0gJ3JvdXRlJykge1xyXG4gICAgICB0aGlzLmhpc3RvcnkucHVzaChCYWNrYm9uZS5oaXN0b3J5LmZyYWdtZW50KVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgXHJcbiAgcHJldmlvdXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgaWYgKHRoaXMuaGlzdG9yeS5sZW5ndGggPiAxKSB7XHJcbiAgICAgIHRoaXMubmF2aWdhdGUodGhpcy5oaXN0b3J5W3RoaXMuaGlzdG9yeS5sZW5ndGggLSAyXSwgZmFsc2UpXHJcbiAgICAgIHRoaXMuaGlzdG9yeS5wb3AoKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5uYXZpZ2F0ZSgnLycsIHRydWUpXHJcbiAgICB9XHJcbiAgfSxcclxuXHJcbiAgY2hhbmdlTGF5b3V0OiBmdW5jdGlvbih2LCBjYWxsYmFjaywgaWQpIHtcclxuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xyXG4gICAgICB0aGlzLmxheW91dCA9IG5ldyB2aWV3cy5tYWluTGF5b3V0KHtyb290VmlldzogdiwgY29udGV4dE1lbnU6IHRoaXMuY29udGV4dE1lbnV9KS5yZW5kZXIoKVxyXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5idWlsZENvbnRleHRNZW51KClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubGF5b3V0LmNoYW5nZUxheW91dCh2KTtcclxuICAgICAgdGhpcy5idWlsZENvbnRleHRNZW51KClcclxuICAgIH1cclxuICAgIGlmIChjYWxsYmFjaykgdGhpc1tjYWxsYmFja10oaWQpO1xyXG4gIH0sXHJcblxyXG4gIGJ1aWxkTWVudTogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgbWVudUl0ZW1zID0gbmV3IG1vZGVscy5tZW51SXRlbXMoKTtcclxuICAgIG1lbnVJdGVtcy5zZXQobWVudURhdGEpO1xyXG4gICAgdmFyIG1lbnUgPSBuZXcgdmlld3MubWFpbk1lbnUoeyBjb2xsZWN0aW9uOiBtZW51SXRlbXMsIGVsOiAkKCdkaXYudG9vbGJveCcpIH0pO1xyXG4gIH0sXHJcblxyXG4gIGJ1aWxkQ29udGV4dE1lbnU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIGNvbnRleHRNZW51ID0gbmV3IHZpZXdzLmNvbnRleHRNZW51KHsgY29sbGVjdGlvbjogdGhpcy5jb250ZXh0TWVudSwgbGF5b3V0OiB0aGlzLmxheW91dCB9KTtcclxuICAgIHRoaXMubGF5b3V0LmFkZENvbnRleHQoY29udGV4dE1lbnUpO1xyXG4gIH1cclxufSlcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUm91dGVyIiwidmFyIEJhY2tib25lID0gcmVxdWlyZSgnYmFja2JvbmUnKSxcclxuICAgIEJhY2tncmlkID0gcmVxdWlyZSgnYmFja2dyaWQnKSxcclxuICAgIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpLFxyXG4gICAgUGFnaW5hdG9yID0gcmVxdWlyZSgnYmFja2JvbmUucGFnaW5hdG9yJyksXHJcbiAgICBQYWdlYWJsZSA9IHJlcXVpcmUoJy4vbG9jYWxfbW9kdWxlcy9iYWNrZ3JpZC1wYWdpbmF0b3IvYmFja2dyaWQtcGFnaW5hdG9yLmpzJyksXHJcbiAgICBsYXlvdXRtYW5hZ2VyID0gcmVxdWlyZSgnYmFja2JvbmUubGF5b3V0bWFuYWdlcicpLFxyXG4gICAgZm9ybXMgPSByZXF1aXJlKCdiYWNrYm9uZS1mb3JtcycpLFxyXG4gICAgcGFyZW50ID0gcmVxdWlyZSgnLi9sb2NhbF9tb2R1bGVzL3BhcmVudC1mb3JtL3BhcmVudC5qcycpLFxyXG4gICAgYm9vdHN0cmFwRm9ybXMgPSByZXF1aXJlKCcuL2xvY2FsX21vZHVsZXMvYm9vdHN0cmFwLWZvcm0vYm9vdHN0cmFwMy5qcycpLFxyXG4gICAgYm9vdHN0cmFwID0gcmVxdWlyZSgnLi9sb2NhbF9tb2R1bGVzL2Jvb3RzdHJhcC1tb2RhbC9ib290c3RyYXAuanMnKSxcclxuICAgIG1vZGFsID0gcmVxdWlyZSgnLi9sb2NhbF9tb2R1bGVzL2JhY2tib25lLmJvb3RzdHJhcC1tb2RhbCcpLFxyXG4gICAgZmlsdGVycyA9IHJlcXVpcmUoJ2JhY2tncmlkLWZpbHRlcicpLFxyXG4gICAgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKSxcclxuICAgICQgPSByZXF1aXJlKCdqcXVlcnknKSxcclxuICAgIGpzdHJlZSA9IHJlcXVpcmUoJy4vbG9jYWxfbW9kdWxlcy9qc3RyZWUvZGlzdC9qc3RyZWUuanMnKSxcclxuICAgIHJlcXVlc3QgPSByZXF1aXJlKCdzdXBlcmFnZW50JyksXHJcbiAgICBPYmplY3RJZCA9IHJlcXVpcmUoJy4vbG9jYWxfbW9kdWxlcy9vYmplY3RpZC9PYmplY3RpZC5qcycpLFxyXG5cdFx0Tm90aWZ5ID0gcmVxdWlyZSgnLi9sb2NhbF9tb2R1bGVzL25vdGlmeS9ub3RpZnkuanMnKVxyXG5cclxudmFyIE1haW5HcmlkID0gQmFja2JvbmUuTGF5b3V0LmV4dGVuZCh7XHJcbiAgaWNvbjogJycsXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmdyaWQgPSBuZXcgQmFja2dyaWQuR3JpZCh7XHJcbiAgICAgIHJvdzogQ2xpY2thYmxlUm93LFxyXG4gICAgICBjb2x1bW5zOiB0aGlzLm9wdGlvbnMuY29sdW1ucyxcclxuICAgICAgY29sbGVjdGlvbjogdGhpcy5vcHRpb25zLmNvbGxlY3Rpb25cclxuICAgIH0pO1xyXG4gICAgJCh0aGlzLiRlbCkuYXBwZW5kKHRoaXMuZ3JpZC5yZW5kZXIoKS4kZWwpO1xyXG4gICAgdGhpcy5wYWdpbmF0b3IgPSBuZXcgQmFja2dyaWQuRXh0ZW5zaW9uLlBhZ2luYXRvcih7XHJcbiAgXHRcdGNvbHVtbnM6IHRoaXMub3B0aW9ucy5jb2x1bW5zLFxyXG4gIFx0XHRjb2xsZWN0aW9uOiB0aGlzLm9wdGlvbnMuY29sbGVjdGlvblxyXG5cdCAgfSk7XHJcblx0ICAkKHRoaXMuJGVsKS5hcHBlbmQodGhpcy5wYWdpbmF0b3IucmVuZGVyKCkuJGVsKTtcclxuICAgIHRoaXMuY3JlYXRlQ29udGV4dFBhbmVsKCk7XHJcbiAgICB0aGlzLmNvbnRleHRNZW51LnJlc2V0KHRoaXMucGFuZWwpO1xyXG4gIH0sXHJcbiAgYWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgJCgnIycgKyB0aGlzLmljb24pLmFkZENsYXNzKCdhY3RpdmUnKTtcclxuICAgIHRoaXMuJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5jbGFzcyk7XHJcbiAgICB0aGlzLmZpbHRlcnMoKTtcclxuICB9LFxyXG4gIGZpbHRlcnM6IGZ1bmN0aW9uKCkge30sXHJcbiAgY3JlYXRlQ29udGV4dFBhbmVsOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBjb250ZXh0UGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xyXG4gICAgY29udGV4dFBhbmVsLmlkID0gXCJjb250ZXh0LXBhbmVsXCI7XHJcbiAgICBjb250ZXh0UGFuZWwuY2xhc3NOYW1lID0gXCJjb250ZXh0LXBhbmVsXCI7XHJcbiAgICBjb250ZXh0UGFuZWwuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJjb250ZXh0LWZpbHRlcnNcIj48L2Rpdj4nO1xyXG4gICAgdGhpcy4kZWwucHJlcGVuZChjb250ZXh0UGFuZWwpO1xyXG4gIH0sXHJcbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xyXG4gICAgJCgnIycgKyB0aGlzLmljb24pLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgIHRoaXMuZ3JpZC5yZW1vdmUoKTtcclxuICAgIHRoaXMucmVtb3ZlKCk7XHJcbiAgICB0aGlzLnVuYmluZCgpO1xyXG4gIH0sXHJcbiAgcGFuZWw6IFtdXHJcbn0pXHJcbmV4cG9ydHMubWFpbkdyaWQgPSBNYWluR3JpZFxyXG5cclxudmFyIEVkaXRQYWdlID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG4gIG1hbmFnZTogdHJ1ZSxcclxuICB0ZW1wbGF0ZTogJyNwYWdlJyxcclxuICBvcHRpb25zX2RlZjoge1xyXG4gICAgY2xhc3M6ICdzdGFjay1pdGVtJ1xyXG4gIH0sXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICBpZihzZWxmLmFkZCkge1xyXG4gICAgICBzZWxmLmNvbnRleHRNZW51LnJlc2V0KHNlbGYucGFuZWxBZGQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2VsZi5jb250ZXh0TWVudS5yZXNldChzZWxmLnBhbmVsRWRpdCk7XHJcbiAgICAgIHNlbGYudGVtcGxhdGUgPSAnI2VkaXRwYWdlJztcclxuICAgIH1cclxuICB9LFxyXG4gIGJlZm9yZVJlbmRlcjogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmZvcm0gPSBuZXcgQmFja2JvbmUuRm9ybSh7XHJcbiAgICAgIG1vZGVsOiB0aGlzLm1vZGVsXHJcbiAgICB9KS5yZW5kZXIoKTtcclxuICB9LFxyXG4gIGFmdGVyUmVuZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHRoaXMuJGVsLmFkZENsYXNzKHRoaXMub3B0aW9uc19kZWYuY2xhc3MpO1xyXG4gICAgdGhpcy4kZWwuY3NzKCdiYWNrZ3JvdW5kLWNvbG9yJywgJ3JnYmEoMCwwLDAsMC44KScpO1xyXG4gICAgdGhpcy4kZWwuZmluZCgnLmZvcm0nKS5hcHBlbmQodGhpcy5mb3JtLmVsKTtcclxuICB9LFxyXG4gIHNlcmlhbGl6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4geyBtb2RlbDogdGhpcy5tb2RlbC5hdHRyaWJ1dGVzIH07XHJcbiAgfSxcclxuICBjbG9zZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnJlbW92ZSgpO1xyXG4gICAgdGhpcy51bmJpbmQoKTtcclxuICB9LFxyXG4gIF9kZWxldGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgYm9vdGJveC5jb25maXJtKFwi0JLRiyDRgdC+0LHQuNGA0LDQtdGC0LXRgdGMINGD0LTQsNC70LjRgtGMINC30LDQv9C40YHRjCDQuNC3INCx0LDQt9GLINC00LDQvdC90YvRhS4g0JLRiyDRg9Cy0LXRgNC10L3Riz9cIiwgZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgIGlmKHJlc3VsdCkge1xyXG4gICAgICAgIE5vdGlmeS5zcGlubmVyKCdzaG93Jyk7XHJcbiAgICAgICAgc2VsZi5jb2xsZWN0aW9uLnJlbW92ZShzZWxmLm1vZGVsKTtcclxuICAgICAgICBzZWxmLm1vZGVsLmRlc3Ryb3koe1xyXG4gICAgICAgICAgd2FpdDogdHJ1ZSxcclxuICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKG1vZGVsLHJlc3ApIHtcclxuICAgICAgICAgICAgTm90aWZ5LnNwaW5uZXIoJ2hpZGUnKTtcclxuICAgICAgICAgICAgTm90aWZ5LmluZm8oJ9CX0LDQv9C40YHRjCDRg9C00LDQu9C10L3QsCcpO1xyXG4gICAgICAgICAgICBzZWxmLmxheW91dC5yZW1vdmVGcm9tU3RhY2soKTtcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24obW9kZWwsZXJyKSB7IFxyXG4gICAgICAgICAgICBOb3RpZnkuc3Bpbm5lcignaGlkZScpO1xyXG4gICAgICAgICAgICBOb3RpZnkuaW5mbygn0JfQsNC/0LjRgdGMINC90LUg0YPQtNCw0LvQtdC90LAuINCf0YDQvtC40LfQvtGI0LvQsCDQvtGI0LjQsdC60LAuJyk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgX3NhdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgdmFyIGVycm9ycyA9IHNlbGYuZm9ybS5jb21taXQoKTtcclxuICAgIGlmKCFlcnJvcnMpIHtcclxuICAgICAgTm90aWZ5LnNwaW5uZXIoJ3Nob3cnKTtcclxuICAgICAgc2VsZi5tb2RlbC5zYXZlKHt9LCB7XHJcbiAgICAgICAgd2FpdDogdHJ1ZSxcclxuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihtb2RlbCxyZXNwKSB7IFxyXG4gICAgICAgICAgTm90aWZ5LnNwaW5uZXIoJ2hpZGUnKTtcclxuICAgICAgICAgIHZhciBub3RpY2UgPSBOb3RpZnkuaW5mbygn0JfQsNC/0LjRgdGMINGB0L7RhdGA0LDQvdC10L3QsCcpO1xyXG4gICAgICAgICAgc2VsZi5sYXlvdXQucmVtb3ZlRnJvbVN0YWNrKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlcnJvcjogZnVuY3Rpb24obW9kZWwsZXJyKSB7IFxyXG4gICAgICAgICAgTm90aWZ5LnNwaW5uZXIoJ2hpZGUnKTtcclxuICAgICAgICAgIHZhciBub3RpY2UgPSBOb3RpZnkuaW5mbygn0JfQsNC/0LjRgdGMINC90LUg0YHQvtGF0YDQsNC90LjQu9Cw0YHRjC4g0J/RgNC+0LjQt9C+0YjQu9CwINC+0YjQuNCx0LrQsC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgX2NyZWF0ZTogZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgZXJyb3JzID0gc2VsZi5mb3JtLmNvbW1pdCgpO1xyXG4gICAgaWYoIWVycm9ycykge1xyXG4gICAgICBOb3RpZnkuc3Bpbm5lcignc2hvdycpO1xyXG4gICAgICBzZWxmLmNvbGxlY3Rpb24uY3JlYXRlKHNlbGYubW9kZWwsIHtcclxuICAgICAgICB3YWl0OiB0cnVlLFxyXG4gICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKG1vZGVsLHJlc3ApIHsgXHJcbiAgICAgICAgICBOb3RpZnkuc3Bpbm5lcignaGlkZScpO1xyXG4gICAgICAgICAgdmFyIG5vdGljZSA9IE5vdGlmeS5pbmZvKCfQl9Cw0L/QuNGB0Ywg0YHQvtC30LTQsNC90LAnKTtcclxuICAgICAgICAgIHNlbGYubGF5b3V0LnJlbW92ZUZyb21TdGFjaygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1vZGVsLGVycikgeyBcclxuICAgICAgICAgIE5vdGlmeS5zcGlubmVyKCdoaWRlJyk7XHJcbiAgICAgICAgICB2YXIgbm90aWNlID0gTm90aWZ5LmluZm8oJ9CX0LDQv9C40YHRjCDQvdC1INGB0L7Qt9C00LDQvdCwLiDQn9GA0L7QuNC30L7RiNC70LAg0L7RiNC40LHQutCwLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBwYW5lbEFkZDogW1xyXG4gICAge1xyXG4gICAgICBuYW1lOiBcImNyZWF0ZVwiLFxyXG4gICAgICBpY29uOiBcInNhdmVcIixcclxuICAgICAgZm46IFwiX2NyZWF0ZVwiXHJcbiAgICB9XHJcbiAgXSxcclxuICBwYW5lbEVkaXQ6IFtcclxuICAgIHtcclxuICAgICAgbmFtZTogXCJzYXZlXCIsXHJcbiAgICAgIGljb246IFwic2F2ZVwiLFxyXG4gICAgICBmbjogXCJfc2F2ZVwiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiBcInJlbW92ZVwiLFxyXG4gICAgICBpY29uOiBcInJlbW92ZVwiLFxyXG4gICAgICBmbjogXCJfZGVsZXRlXCJcclxuICAgIH1cclxuICBdXHJcbn0pO1xyXG5leHBvcnRzLmVkaXRQYWdlID0gRWRpdFBhZ2VcclxuXHJcbi8vIFJPT1QgVklFV1xyXG52YXIgTWFpbkxheW91dCA9IEJhY2tib25lLkxheW91dC5leHRlbmQoe1xyXG4gIGVsOiAnYm9keScsXHJcblxyXG4gIGV2ZW50czoge1xyXG4gICAgJ2NsaWNrICNnb2JhY2ssIGNsaWNrIC5jbG9zZS1zdGFjaywgZXhpdCc6ICdyZW1vdmVGcm9tU3RhY2snLFxyXG4gICAgJ2tleXVwJyA6ICdrZXl1cCcsXHJcbiAgfSxcclxuICBcclxuICBjaGFuZ2VMYXlvdXQ6IGZ1bmN0aW9uKHYpIHtcclxuICBcdHRoaXMuc3RhY2tWaWV3LmNsb3NlU3RhY2soKTtcclxuICAgIHRoaXMuc3RhY2tWaWV3ID0gbmV3IFN0YWNrVmlldygpO1xyXG4gICAgdGhpcy5zdGFja1ZpZXcuc2V0Um9vdFZpZXcodik7XHJcbiAgICB0aGlzLnNldFZpZXcoJyNzdGFja1ZpZXcnLCB0aGlzLnN0YWNrVmlldykucmVuZGVyKCk7XHJcbiAgfSxcclxuXHJcbiAgYWRkQ29udGV4dDogZnVuY3Rpb24odikge1xyXG4gICAgdGhpcy5zdGFja1ZpZXcuaW5zZXJ0VmlldygnI2NvbnRleHQtcGFuZWwnLCB2KS5yZW5kZXIoKTtcclxuICB9LFxyXG5cdFxyXG5cdGtleXVwOiBmdW5jdGlvbihlKXtcclxuXHRcdGlmIChlLndoaWNoID09IDI3ICYmICQoZS50YXJnZXQpLmlzKCdib2R5JykgJiYgISQoZS50YXJnZXQpLmhhc0NsYXNzKCdtb2RhbC1vcGVuJykpIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVGcm9tU3RhY2soKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuICBnZXRSb290OiBmdW5jdGlvbigpIHtcclxuICAgIHJldHVybiB0aGlzLnN0YWNrVmlldy5nZXRGaXJzdCgpO1xyXG4gIH0sXHJcblxyXG4gIGdldFRvcDogZnVuY3Rpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zdGFja1ZpZXcuZ2V0TGFzdCgpO1xyXG4gIH0sXHJcblx0XHJcbiAgYWRkVG9TdGFjazogZnVuY3Rpb24odikge1xyXG4gICAgdGhpcy5zdGFja1ZpZXcucHVzaCh2KTtcclxuICB9LFxyXG5cclxuICByZW1vdmVGcm9tU3RhY2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5zdGFja1ZpZXcucG9wKCk7XHJcbiAgICB0aGlzLmNvbnRleHRNZW51LnRyaWdnZXIoXCJyZXN0b3JlXCIpO1xyXG4gIH0sXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gQ3JlYXRlIGEgbmV3IFN0YWNrVmlldyBhbmQgdGhlIHJvb3Qgdmlldy5cclxuICAgIHRoaXMuc3RhY2tWaWV3ID0gbmV3IFN0YWNrVmlldygpO1xyXG4gICAgdGhpcy5zdGFja1ZpZXcuc2V0Um9vdFZpZXcodGhpcy5vcHRpb25zLnJvb3RWaWV3KTtcclxuICAgIHRoaXMuc2V0VmlldygnI3N0YWNrVmlldycsIHRoaXMuc3RhY2tWaWV3KTtcclxuICB9XHJcbn0pO1xyXG5leHBvcnRzLm1haW5MYXlvdXQgPSBNYWluTGF5b3V0XHJcblxyXG4vLyBTVEFDSyBNQU5BR0VSXHJcbnZhciBTdGFja1ZpZXcgPSBCYWNrYm9uZS5MYXlvdXQuZXh0ZW5kKHtcclxuICBoYXNSb290VmlldzogZmFsc2UsXHJcblxyXG4gIC8vIERlZmluZSBvcHRpb25zIGZvciB0cmFuc2l0aW9uaW5nIHZpZXdzIGluIGFuZCBvdXQuXHJcbiAgb3B0aW9uc19kZWY6IHtcclxuICAgIGluVHJhbnNpdGlvbkNsYXNzOiAnYW5pbWF0ZWQgZmFkZUluTGVmdCcsXHJcbiAgICBvdXRUcmFuc2l0aW9uQ2xhc3M6ICdhbmltYXRlZCBmYWRlT3V0UmlnaHQnLFxyXG4gICAgdHJhbnNpdGlvbkRlbGF5OiAxMDAwLFxyXG4gICAgY2xhc3M6ICdzdGFja3MnXHJcbiAgfSxcclxuXHJcbiAgYWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy4kZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zX2RlZi5jbGFzcyk7XHJcbiAgfSxcclxuXHJcbiAgLy8gUG9wIHRoZSB0b3AtbW9zdCB2aWV3IG9mZiBvZiB0aGUgc3RhY2suXHJcbiAgcG9wOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB2aWV3cyA9IHRoaXMuZ2V0Vmlld3MoKS52YWx1ZSgpO1xyXG5cclxuICAgIGlmICh2aWV3cy5sZW5ndGggPiAodGhpcy5oYXNSb290VmlldyA/IDEgOiAwKSkge1xyXG4gICAgICB2YXIgdmlldyA9IHZpZXdzLnBvcCgpO1xyXG4gICAgICB0aGlzLnRyYW5zaXRpb25WaWV3T3V0KHZpZXcpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGdldEZpcnN0OiBmdW5jdGlvbigpIHtcclxuICAgIHZhciB2aWV3cyA9IHRoaXMuZ2V0Vmlld3MoKS52YWx1ZSgpO1xyXG4gICAgcmV0dXJuIHZpZXdzWzBdO1xyXG4gIH0sXHJcblxyXG4gIGdldExhc3Q6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZpZXdzID0gdGhpcy5nZXRWaWV3cygpLnZhbHVlKCk7XHJcbiAgICByZXR1cm4gdmlld3Nbdmlld3MubGVuZ3RoIC0gMV07XHJcbiAgfSxcclxuXHJcbiAgLy8gUHVzaCBhIG5ldyB2aWV3IG9udG8gdGhlIHN0YWNrLlxyXG4gIC8vIFRoZSBpdGVtQ2xhc3Mgd2lsbCBiZSBhdXRvLWFkZGVkIHRvIHRoZSBwYXJlbnQgZWxlbWVudC5cclxuICBwdXNoOiBmdW5jdGlvbih2aWV3KSB7XHJcbiAgICB0aGlzLmluc2VydFZpZXcodmlldyk7XHJcbiAgICB0aGlzLnRyYW5zaXRpb25WaWV3SW4odmlldyk7XHJcbiAgfSxcclxuXHJcbiAgLy8gVHJhc3RpdGlvbiB0aGUgbmV3IHZpZXcgaW4uICBUaGlzIGlzIGJyb2tlbiBvdXQgYXMgYSBtZXRob2QgZm9yIGNvbnZlbmllbnRcclxuICAvLyBvdmVycmlkaW5nIG9mIHRoZSBkZWZhdWx0IHRyYW5zaXRpb24gYmVoYXZpb3IuICBJZiB5b3Ugb25seSB3YW50IHRvIGNoYW5nZVxyXG4gIC8vIHRoZSBhbmltYXRpb24gdXNlIHRoZSB0cmFzaXRpb24gY2xhc3Mgb3B0aW9ucyBpbnN0ZWFkLlxyXG4gIHRyYW5zaXRpb25WaWV3SW46IGZ1bmN0aW9uKHZpZXcpIHtcclxuICAgIHRoaXMudHJpZ2dlcignYmVmb3JlOnRyYW5zaXRpb25JbicsIHRoaXMsIHZpZXcpO1xyXG4gICAgdmlldy4kZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zX2RlZi5pblRyYW5zaXRpb25DbGFzcyk7XHJcblx0XHRcclxuICAgIHZpZXcucmVuZGVyKCk7XHJcblxyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgdGhpcy50cmlnZ2VyKCd0cmFuc2l0aW9uSW4nLCB0aGlzLCB2aWV3KTtcclxuICAgIH0uYmluZCh0aGlzKSwgdGhpcy5vcHRpb25zX2RlZi50cmFuc2l0aW9uRGVsYXkpO1xyXG4gIH0sXHJcbiAgXHJcbiAgLy8gVHJhc3RpdGlvbiBhIHZpZXcgb3V0LiAgVGhpcyBpcyBicm9rZW4gb3V0IGFzIGEgbWV0aG9kIGZvciBjb252ZW5pZW50XHJcbiAgLy8gb3ZlcnJpZGluZyBvZiB0aGUgZGVmYXVsdCB0cmFuc2l0aW9uIGJlaGF2aW9yLiAgSWYgeW91IG9ubHkgd2FudCB0byBjaGFuZ2VcclxuICAvLyB0aGUgYW5pbWF0aW9uIHVzZSB0aGUgdHJhc2l0aW9uIGNsYXNzIG9wdGlvbnMgaW5zdGVhZC5cclxuICB0cmFuc2l0aW9uVmlld091dDogZnVuY3Rpb24odmlldykge1xyXG4gICAgdGhpcy50cmlnZ2VyKCdiZWZvcmU6dHJhbnNpdGlvbk91dCcsIHRoaXMsIHZpZXcpO1xyXG4gICAgdmlldy4kZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zX2RlZi5vdXRUcmFuc2l0aW9uQ2xhc3MpO1xyXG4gICAgQmFja2JvbmUubWlkZGxlLnRyaWdnZXIoXCJnb1RvUHJldmlvdXNcIik7XHJcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICB2aWV3LmNsb3NlKCk7XHJcbiAgICAgIHRoaXMudHJpZ2dlcigndHJhbnNpdGlvbk91dCcsIHRoaXMsIHZpZXcpO1xyXG4gICAgfS5iaW5kKHRoaXMpLCB0aGlzLm9wdGlvbnNfZGVmLnRyYW5zaXRpb25EZWxheSk7XHJcbiAgfSxcclxuXHJcbiAgc2V0Um9vdFZpZXc6IGZ1bmN0aW9uKHZpZXcpIHtcclxuICAgIHRoaXMuaGFzUm9vdFZpZXcgPSB0cnVlO1xyXG4gIFx0dGhpcy5zZXRWaWV3KHZpZXcpO1xyXG4gIH0sXHJcblxyXG4gIGNsb3NlU3RhY2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHZpZXdzID0gdGhpcy5nZXRWaWV3cygpLnZhbHVlKCk7XHJcbiAgICBfLmVhY2godmlld3MsIGZ1bmN0aW9uKHZpZXcpe1xyXG4gICAgICB2aWV3LmNsb3NlKCk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMucmVtb3ZlKCk7XHJcbiAgICB0aGlzLnVuYmluZCgpO1xyXG4gIH1cclxufSk7XHJcbmV4cG9ydHMuc3RhY2tWaWV3ID0gU3RhY2tWaWV3XHJcblxyXG52YXIgRG9jdW1lbnRzR3JpZCA9IE1haW5HcmlkLmV4dGVuZCh7XHJcbiAgaWNvbjogJ2Rhc2hib2FyZCcsXHJcbiAgY2xhc3NOYW1lOiAnZGFzaGJvYXJkJyxcclxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuZ3JpZCA9IG5ldyBCYWNrZ3JpZC5HcmlkKHtcclxuICAgICAgcm93OiBEb2N1bWVudFJvdyxcclxuICAgICAgY29sdW1uczogdGhpcy5vcHRpb25zLmNvbHVtbnMsXHJcbiAgICAgIGNvbGxlY3Rpb246IHRoaXMub3B0aW9ucy5jb2xsZWN0aW9uXHJcbiAgICB9KTtcclxuICAgICQodGhpcy4kZWwpLmFwcGVuZCh0aGlzLmdyaWQucmVuZGVyKCkuJGVsKTtcclxuICAgIHRoaXMucGFnaW5hdG9yID0gbmV3IEJhY2tncmlkLkV4dGVuc2lvbi5QYWdpbmF0b3Ioe1xyXG4gICAgICBjb2x1bW5zOiB0aGlzLm9wdGlvbnMuY29sdW1ucyxcclxuICAgICAgY29sbGVjdGlvbjogdGhpcy5vcHRpb25zLmNvbGxlY3Rpb25cclxuICAgIH0pO1xyXG4gICAgJCh0aGlzLiRlbCkuYXBwZW5kKHRoaXMucGFnaW5hdG9yLnJlbmRlcigpLiRlbCk7XHJcbiAgICB0aGlzLmNyZWF0ZUNvbnRleHRQYW5lbCgpO1xyXG4gICAgdGhpcy5jb250ZXh0TWVudS5yZXNldCh0aGlzLnBhbmVsKTtcclxuICB9LFxyXG5cdGZpbHRlcnM6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy50aXRsZUZpbHRlciA9IG5ldyBGaWx0ZXIoe1xyXG4gICAgICBjb2xsZWN0aW9uOiB0aGlzLm9wdGlvbnMuY29sbGVjdGlvbixcclxuICAgICAgcGxhY2Vob2xkZXI6IFwiRW50ZXIgYSB0aXRsZSB0byBzZWFyY2hcIixcclxuICAgICAgbmFtZTogXCJub2Rlcy5kb2N1bWVudC50aXRsZVwiLFxyXG4gICAgfSk7XHJcbiAgICB0aGlzLiRlbC5maW5kKCcuY29udGV4dC1maWx0ZXJzJykucHJlcGVuZCh0aGlzLnRpdGxlRmlsdGVyLnJlbmRlcigpLmVsKTtcclxuXHR9LFxyXG4gIF9hZGQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgQmFja2JvbmUubWlkZGxlLnRyaWdnZXIoXCJnb1RvRXh0XCIsICdlZGl0b3IvbmV3JylcclxuICB9LFxyXG4gIHBhbmVsOiBbXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6IFwiQWRkIG5ldyBkb2N1bWVudFwiLFxyXG4gICAgICBpY29uOiBcInBsdXNcIixcclxuICAgICAgZm46IFwiX2FkZFwiXHJcbiAgICB9XHJcbiAgXVxyXG59KVxyXG5leHBvcnRzLmRvY3VtZW50c0dyaWQgPSBEb2N1bWVudHNHcmlkXHJcblxyXG5cclxudmFyIExpc3RWaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xyXG4gIHRhZ05hbWU6IFwiZGl2XCIsXHJcbiAgY2xhc3NOYW1lOiBcImxpc3RcIixcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgIHZhciBsaXN0SXRlbXMgPSB0aGlzLmxpc3RJdGVtcyA9IG9wdGlvbnMuaXRlbXM7XHJcblxyXG4gICAgLy8gYWRkIG5ldyBpdGVtIHRvIHRoZSBsaXN0XHJcbiAgICB0aGlzLmxpc3RlblRvKGxpc3RJdGVtcywgXCJhZGRcIiwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgdGhpcy5hZGRJdGVtKGl0ZW0pO1xyXG4gICAgfSlcclxuXHJcbiAgICB0aGlzLmxpc3RlblRvKGxpc3RJdGVtcywgXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgdGhpcy51cGRhdGVJdGVtKGl0ZW0pO1xyXG4gICAgfSlcclxuXHJcbiAgICAvLyByZW1vdmUgaXRlbSBmcm9tIGxpc3RcclxuICAgIHRoaXMubGlzdGVuVG8obGlzdEl0ZW1zLCBcInJlbW92ZVwiLCBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICB0aGlzLnJlbW92ZUl0ZW0oaXRlbSk7XHJcbiAgICB9KVxyXG5cclxuICAgIHRoaXMubGlzdGVuVG8obGlzdEl0ZW1zLCBcImNoYW5nZVBhcmVudFwiLCBmdW5jdGlvbiAoaXRlbUlkLCBwYXJlbnRJZCkge1xyXG4gICAgICB0aGlzLmNoYW5nZVBhcmVudChpdGVtSWQsIHBhcmVudElkKTtcclxuICAgIH0pXHJcblxyXG4gICAgdGhpcy5vbihcInBhcmVudDpjaG9vc2VcIiwgZnVuY3Rpb24oY2hpbGQpIHtcclxuICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKHRoaXMubGlzdEl0ZW1zLCBcImxpc3Q6Z2V0aXRlbVwiKTtcclxuICAgICAgbGlzdEl0ZW1zLm9uY2UoXCJsaXN0OmdldGl0ZW1cIiwgZnVuY3Rpb24ocGFyZW50KSB7XHJcbiAgICAgICAgY2hpbGQuc2V0KCdwYXJlbnQnLCBwYXJlbnQuZ2V0KCdpZCcpKTtcclxuICAgICAgICB0aGlzLnJlZ2lzdGVySXRlbUxpc3RuZXIoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhpZXJhcmNoeSgpO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH0pXHJcblxyXG4gICAgdGhpcy5vbihcInBhcmVudDptZXJnZVwiLCBmdW5jdGlvbihjaGlsZCkge1xyXG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcodGhpcy5saXN0SXRlbXMsIFwibGlzdDpnZXRpdGVtXCIpO1xyXG4gICAgICBsaXN0SXRlbXMub25jZShcImxpc3Q6Z2V0aXRlbVwiLCBmdW5jdGlvbihwYXJlbnQpIHtcclxuICAgICAgICByZXF1ZXN0XHJcbiAgICAgICAgICAuZ2V0KCcvYXBpL3N1YmplY3RzL21lcmdlJylcclxuICAgICAgICAgIC5xdWVyeSh7IG9uZTogY2hpbGQuaWQsIGludG86IHBhcmVudC5pZCB9KVxyXG4gICAgICAgICAgLmVuZChmdW5jdGlvbihyZXMpe1xyXG4gICAgICAgICAgICBpZihyZXMub2spIGNvbnNvbGUubG9nKFwiTWVyZ2VkOiBcIiArIGNoaWxkLmlkICsgXCIgaW50byBcIiArIHBhcmVudC5pZCk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgfSwgdGhpcyk7XHJcbiAgICB9KVxyXG5cclxuICAgIHRoaXMucmVnaXN0ZXJJdGVtTGlzdG5lcigpO1xyXG4gIH0sXHJcblxyXG4gIHJlZ2lzdGVySXRlbUxpc3RuZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5saXN0ZW5Ubyh0aGlzLmxpc3RJdGVtcywgXCJsaXN0OmdldGl0ZW1cIiwgZnVuY3Rpb24gKGl0ZW0sIGVsKSB7XHJcbiAgICAgICQoJ2Rpdi5saXN0IGxpLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgICAgZWwuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgICBpdGVtLnRyaWdnZXIoXCJsaXN0OmVkaXRcIiwgaXRlbSlcclxuICAgIH0pXHJcbiAgfSxcclxuXHJcbiAgcHJlcGFyZVZpZXdzOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuaXRlbVZpZXdzID0ge307XHJcbiAgICB0aGlzLmxpc3RJdGVtcy5lYWNoKGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgdGhpcy5pdGVtVmlld3NbaXRlbS5pZF0gPSBuZXcgSXRlbVZpZXcoe21vZGVsOiBpdGVtfSkucmVuZGVyKCk7XHJcbiAgICB9LCB0aGlzKTtcclxuICB9LFxyXG5cclxuICBhZGRJdGVtOiBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICAvLyBtb2RlbCBjcmVhdGlvblxyXG4gICAgdGhpcy5pdGVtVmlld3NbaXRlbS5pZF0gPSBuZXcgSXRlbVZpZXcoe21vZGVsOiBpdGVtfSkucmVuZGVyKCk7XHJcbiAgICB0aGlzLnVwZGF0ZUhpZXJhcmNoeSgpO1xyXG4gIH0sXHJcbiBcclxuICAvLyBkb2VzbnQgYWZmZWN0IGhpZXJhcmNoeVxyXG4gIHVwZGF0ZUl0ZW06IGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgIHZhciBpc1BhcmVudCA9IHRoaXMubGlzdEl0ZW1zLmZpbmRXaGVyZSh7cGFyZW50OiBpdGVtLmlkfSkgPyB0cnVlIDogZmFsc2U7XHJcbiAgICB0aGlzLml0ZW1WaWV3c1tpdGVtLmlkXS5yZW5kZXIoaXNQYXJlbnQpIC8vIHJlLXJlbmRlclxyXG4gICAgdGhpcy51cGRhdGVIaWVyYXJjaHkoaXRlbSk7XHJcbiAgfSxcclxuXHJcbiAgcmVtb3ZlSXRlbTogZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgdGhpcy5pdGVtVmlld3NbaXRlbS5pZF0ucmVtb3ZlKClcclxuICAgIHRoaXMudXBkYXRlSGllcmFyY2h5KCk7XHJcbiAgfSxcclxuXHJcbiAgY2hhbmdlUGFyZW50OiBmdW5jdGlvbihpdGVtSWQsIHBhcmVudElkKSB7XHJcbiAgICB2YXIgbW9kZWwgPSB0aGlzLmxpc3RJdGVtcy5nZXQoaXRlbUlkKSxcclxuICAgICAgICBpc1BhcmVudCA9IHRoaXMubGlzdEl0ZW1zLmZpbmRXaGVyZSh7cGFyZW50OiBpdGVtSWR9KSA/IHRydWUgOiBmYWxzZTtcclxuICAgIG1vZGVsLnNldCgncGFyZW50JywgcGFyZW50SWQpO1xyXG4gICAgdGhpcy51cGRhdGVIaWVyYXJjaHkoKTtcclxuICB9LFxyXG5cclxuICB1cGRhdGVIaWVyYXJjaHk6IGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuIFxyXG4gICAgLy8gQnVpbGQgYSBtYXAgb2YgcGFyZW50cyByZWZlcmVuY2luZyB0aGVpciBraWRzXHJcbiAgICB2YXIgbWFwID0ge307XHJcbiAgICBfLmVhY2goc2VsZi5pdGVtVmlld3MsIGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgdmFyIHBhcmVudCA9IGl0ZW0ubW9kZWwuZ2V0KCdwYXJlbnQnKSB8fCBcInJvb3RcIjtcclxuICAgICAgaWYgKCFtYXBbcGFyZW50XSkge1xyXG4gICAgICAgIG1hcFtwYXJlbnRdID0gWyBpdGVtIF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWFwW3BhcmVudF0ucHVzaChpdGVtKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy9kZWJ1Z2dlcjtcclxuXHJcbiAgICBmdW5jdGlvbiByZW5kZXJDaGlsZHJlbihwYXJlbnQpIHtcclxuICAgICAgdmFyIGxpc3RFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ29sJyk7XHJcbiBcclxuICAgICAgdmFyIGl0ZW1zID0gbWFwW3BhcmVudF07XHJcbiAgICAgIGlmICghaXRlbXMpIHJldHVybiBsaXN0RWw7IC8vIGV4aXQgY29uZGl0aW9uICAgICAgXHJcbiAgICAgIFxyXG4gICAgICBfLmVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcclxuICAgICAgICB2YXIgaXNQYXJlbnQgPSBtYXAuaGFzT3duUHJvcGVydHkoaXRlbS5tb2RlbC5pZCk7XHJcbiAgICAgICAgdmFyIGxpc3RJdGVtRWwgPSBzZWxmLml0ZW1WaWV3c1tpdGVtLm1vZGVsLmlkXS5yZW5kZXIoaXNQYXJlbnQpLmVsO1xyXG5cclxuICAgICAgICB2YXIgY2hpbGRMaXN0ID0gcmVuZGVyQ2hpbGRyZW4oaXRlbS5tb2RlbC5pZCk7XHJcbiAgICAgICAgbGlzdEl0ZW1FbC5hcHBlbmRDaGlsZChjaGlsZExpc3QpO1xyXG4gICAgICAgIGxpc3RFbC5hcHBlbmRDaGlsZChsaXN0SXRlbUVsKTtcclxuICAgICAgICBpZiAoaXNQYXJlbnQpIGl0ZW0uX2NvbGxhcHNlSXRlbShpdGVtLiRlbCk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIGxpc3RFbDtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbGlzdEVsID0gaXRlbSA/IHJlbmRlckNoaWxkcmVuKGl0ZW0uaWQpIDogcmVuZGVyQ2hpbGRyZW4oXCJyb290XCIpO1xyXG4gICAgaWYgKGl0ZW0pIHtcclxuICAgICAgdGhpcy5pdGVtVmlld3NbaXRlbS5pZF0uJGVsLmFwcGVuZChsaXN0RWwpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2VsZi4kZWwuYXBwZW5kKGxpc3RFbCk7XHJcbiAgICB9XHJcbiAgICBcclxuICB9LFxyXG5cclxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5wcmVwYXJlVmlld3MoKTtcclxuICAgIHRoaXMudXBkYXRlSGllcmFyY2h5KCk7XHJcbiAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG5cclxuICB9XHJcblxyXG59KTtcclxuXHJcblxyXG52YXIgSXRlbVZpZXcgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgdGFnTmFtZTogXCJsaVwiLFxyXG5cclxuICBldmVudHM6IHtcclxuICAgICdjbGljayc6ICdjaG9vc2VJdGVtJyxcclxuICAgICdjbGljayAuY29sbGFwc2UnOiAnX29uQ29sbGFwc2VJdGVtJyxcclxuICAgICdjbGljayAuZXhwYW5kJzogJ19vbkV4cGFuZEl0ZW0nLFxyXG4gICAgJ2NsaWNrIC5kcmFnLWhhbmRsZSc6ICdfZHJhZ0hhbmRsZUNsaWNrJyxcclxuICAgICdkcmFnc3RhcnQnOiAnX29uRHJhZ1N0YXJ0JyxcclxuICAgICdkcmFnZW50ZXInOiAnX29uRHJhZ0VudGVyJyxcclxuICAgICdkcmFnbGVhdmUnOiAnX29uRHJhZ0xlYXZlJyxcclxuICAgICdkcmFnb3Zlcic6ICdfb25EcmFnT3ZlcicsXHJcbiAgICAnZHJvcCc6ICdfb25Ecm9wJyxcclxuICAgICdkcmFnZW5kJzogJ19vbkRyYWdFbmQnXHJcbiAgfSxcclxuXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG1vZGVsID0gdGhpcy5tb2RlbDtcclxuXHJcbiAgICBtb2RlbC5vbihcImNoYW5nZVwiLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHRoaXMucmVuZGVyKCk7XHJcbiAgICB9LCB0aGlzKTtcclxuICB9LFxyXG5cclxuICByZW5kZXI6IGZ1bmN0aW9uIChwYXJlbnQpIHtcclxuICAgIHRoaXMuJGVsLmVtcHR5KCk7XHJcblxyXG4gICAgdmFyIGRyYWdIYW5kbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcclxuICAgIGRyYWdIYW5kbGUuY2xhc3NMaXN0LmFkZChcImRyYWctaGFuZGxlXCIpO1xyXG4gICAgZHJhZ0hhbmRsZS5pbm5lckhUTUwgPSAnPGkgY2xhc3M9XCJmYSBmYS1iYXJzXCI+PC9pPic7XHJcbiAgICBkcmFnSGFuZGxlLnNldEF0dHJpYnV0ZShcImRyYWdnYWJsZVwiLCB0cnVlKTtcclxuICAgIHRoaXMuJGVsLmFwcGVuZChkcmFnSGFuZGxlKTtcclxuXHJcbiAgICB2YXIgY29sbGFwc2VCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcclxuICAgIGNvbGxhcHNlQnRuLmNsYXNzTGlzdC5hZGQoXCJjb2xsYXBzZVwiKTtcclxuICAgIGNvbGxhcHNlQnRuLmlubmVySFRNTCA9ICc8aSBjbGFzcz1cImZhIGZhLW1pbnVzLXNxdWFyZS1vXCI+PC9pPic7XHJcbiAgICBjb2xsYXBzZUJ0bi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgdGhpcy4kZWwuYXBwZW5kKGNvbGxhcHNlQnRuKTtcclxuXHJcbiAgICB2YXIgZXhwYW5kQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAgICBleHBhbmRCdG4uY2xhc3NMaXN0LmFkZChcImV4cGFuZFwiKTtcclxuICAgIGV4cGFuZEJ0bi5pbm5lckhUTUwgPSAnPGkgY2xhc3M9XCJmYSBmYS1wbHVzLXNxdWFyZS1vXCI+PC9pPic7XHJcbiAgICBpZighcGFyZW50KSBleHBhbmRCdG4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIHRoaXMuJGVsLmFwcGVuZChleHBhbmRCdG4pO1xyXG5cclxuICAgIHZhciBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xyXG4gICAgY29udGVudC50ZXh0Q29udGVudCA9IHRoaXMubW9kZWwuZ2V0KCduYW1lJyk7XHJcbiAgICB0aGlzLiRlbC5hcHBlbmQoY29udGVudCk7XHJcbiAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG5cclxuICBjaG9vc2VJdGVtOiBmdW5jdGlvbihlKSB7XHJcbiAgICB2YXIgbW9kZWwgPSB0aGlzLm1vZGVsO1xyXG4gICAgbW9kZWwudHJpZ2dlcihcImxpc3Q6Z2V0aXRlbVwiLCBtb2RlbCwgdGhpcy4kZWwpO1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICB9LFxyXG5cclxuICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgfSxcclxuXHJcbiAgX2RyYWdIYW5kbGVDbGljazogZnVuY3Rpb24oZSkge1xyXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICB9LFxyXG5cclxuICBfY29sbGFwc2VJdGVtOiBmdW5jdGlvbihpdGVtKSB7XHJcbiAgICB2YXIgbGlzdHMgPSBpdGVtLmNoaWxkcmVuKCdvbCcpO1xyXG4gICAgaWYgKGxpc3RzLmxlbmd0aCkge1xyXG4gICAgICBpdGVtLmFkZENsYXNzKCdjb2xsYXBzZWQnKTtcclxuICAgICAgaXRlbS5jaGlsZHJlbignLmNvbGxhcHNlJykuaGlkZSgpO1xyXG4gICAgICBpdGVtLmNoaWxkcmVuKCcuZXhwYW5kJykuc2hvdygpO1xyXG4gICAgICBpdGVtLmNoaWxkcmVuKCdvbCcpLmhpZGUoKTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfb25Db2xsYXBzZUl0ZW06IGZ1bmN0aW9uKGUpIHtcclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICB2YXIgaXRlbSA9ICQoZS5jdXJyZW50VGFyZ2V0KS5wYXJlbnQoKTtcclxuICAgIHRoaXMuX2NvbGxhcHNlSXRlbShpdGVtKTtcclxuICB9LFxyXG5cclxuICBfZXhwYW5kSXRlbTogZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgaXRlbS5yZW1vdmVDbGFzcygnY29sbGFwc2VkJyk7XHJcbiAgICBpdGVtLmNoaWxkcmVuKCcuZXhwYW5kJykuaGlkZSgpO1xyXG4gICAgaXRlbS5jaGlsZHJlbignLmNvbGxhcHNlJykuc2hvdygpO1xyXG4gICAgaXRlbS5jaGlsZHJlbignb2wnKS5zaG93KCk7XHJcbiAgfSxcclxuXHJcbiAgX29uRXhwYW5kSXRlbTogZnVuY3Rpb24oZSkge1xyXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIHZhciBpdGVtID0gJChlLmN1cnJlbnRUYXJnZXQpLnBhcmVudCgpO1xyXG4gICAgdGhpcy5fZXhwYW5kSXRlbShpdGVtKTtcclxuICB9LFxyXG5cclxuICBfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uKGUpIHtcclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgdmFyIGlkID0gdGhpcy5tb2RlbC5nZXQoJ19pZCcpO1xyXG5cclxuICAgIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnRcclxuICAgIGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcIm1vdmVcIjtcclxuICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIGlkKTtcclxuICAgIGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShlLnRhcmdldC5wYXJlbnROb2RlLDAsMCk7XHJcbiAgICBlLnRhcmdldC5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XHJcbiAgICBlLnRhcmdldC5wYXJlbnROb2RlLmNsYXNzTmFtZSA9ICdkcmFnZ2luZyc7XHJcbiAgICAvL2UudGFyZ2V0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9LFxyXG5cclxuICBfb25EcmFnRW5kOiBmdW5jdGlvbihlKSB7XHJcbiAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50XHJcbiAgICBlLnRhcmdldC5zdHlsZS5vcGFjaXR5ID0gJzEnO1xyXG4gICAgZS50YXJnZXQucGFyZW50Tm9kZS5jbGFzc05hbWUgPSAnJztcclxuICB9LFxyXG5cclxuICBfb25EcmFnRW50ZXI6IGZ1bmN0aW9uKGUpIHtcclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50O1xyXG4gICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgPT0gJ1NQQU4nICYmICEkKGUudGFyZ2V0KS5wYXJlbnRzKCcuZHJhZ2dpbmcnKS5sZW5ndGgpIHtcclxuICAgICAgdGhpcy5faW5zZXJ0RHJhZ1BsYWNlaG9sZGVyKGUudGFyZ2V0KTtcclxuICAgIH1cclxuICB9LFxyXG5cclxuICBfb25EcmFnTGVhdmU6IGZ1bmN0aW9uKGUpIHtcclxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSBlID0gZS5vcmlnaW5hbEV2ZW50O1xyXG4gICAgaWYgKGUudGFyZ2V0LnRhZ05hbWUgPT0gJ1NQQU4nKSB7XHJcbiAgICAgIHRoaXMuX3JlbW92ZURyYWdQbGFjZWhvbGRlcigpO1xyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIF9vbkRyYWdPdmVyOiBmdW5jdGlvbihlKSB7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfSxcclxuXHJcbiAgX29uRHJvcDogZnVuY3Rpb24oZSkge1xyXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIGlmIChlLm9yaWdpbmFsRXZlbnQpIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XHJcbiAgICB2YXIgaWQgPSBlLmRhdGFUcmFuc2Zlci5nZXREYXRhKFwidGV4dC9wbGFpblwiKTtcclxuICAgIGlmKGlkICE9IHRoaXMubW9kZWwuaWQgJiYgISQoZS50YXJnZXQpLnBhcmVudHMoJy5kcmFnZ2luZycpLmxlbmd0aCkgdGhpcy5tb2RlbC50cmlnZ2VyKCdjaGFuZ2VQYXJlbnQnLCBpZCwgdGhpcy5tb2RlbC5pZCk7XHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH0sXHJcblxyXG4gIF9pbnNlcnREcmFnUGxhY2Vob2xkZXI6IGZ1bmN0aW9uKHRhcmdldCkge1xyXG4gICAgdGhpcy5fcmVtb3ZlRHJhZ1BsYWNlaG9sZGVyKCk7XHJcbiAgICB2YXIgZHJvcHpvbmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICBkcm9wem9uZS5zZXRBdHRyaWJ1dGUoJ2lkJywnZHJvcHpvbmUnKTtcclxuICAgIHRhcmdldC5uZXh0U2libGluZy5pbnNlcnRCZWZvcmUoZHJvcHpvbmUsIHRhcmdldC5uZXh0U2libGluZy5maXJzdENoaWxkKTtcclxuICB9LFxyXG5cclxuICBfcmVtb3ZlRHJhZ1BsYWNlaG9sZGVyOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBkcm9wem9uZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZHJvcHpvbmVcIik7XHJcbiAgICBpZiAoZHJvcHpvbmUpIGRyb3B6b25lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZHJvcHpvbmUpO1xyXG4gIH1cclxuXHJcbn0pO1xyXG5cclxuLy8gU1VCSkVDVCBQQUdFU1xyXG5cclxudmFyIFN1YmplY3RzVmlldyA9IEJhY2tib25lLkxheW91dC5leHRlbmQoe1xyXG4gIGljb246ICdzdWJqZWN0cycsXHJcbiAgY2xhc3NOYW1lOiAnc3ViamVjdHMnLFxyXG4gIHRlbXBsYXRlOiAnI3N1YmplY3RzTGF5b3V0JyxcclxuXHJcbiAgZXZlbnRzOiB7XHJcbiAgICBcImNsaWNrIC5pbXBvcnRcIjogXCJfcnVuSW1wb3J0XCIsXHJcbiAgICBcImNsaWNrIC5jYW5jZWxcIjogXCJfY2FuY2VsSW1wb3J0XCJcclxuICB9LFxyXG5cclxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHRoaXMuY29sbGVjdGlvbi5vbignbGlzdDplZGl0JywgZnVuY3Rpb24obW9kZWwpIHtcclxuICAgICAgdGhpcy5lZGl0U3ViamVjdChtb2RlbCk7XHJcbiAgICB9LCB0aGlzKTtcclxuICB9LFxyXG4gIGJlZm9yZVJlbmRlcjogZnVuY3Rpb24oKSB7XHJcblxyXG4gIH0sXHJcbiAgYWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgJCgnIycgKyB0aGlzLmljb24pLmFkZENsYXNzKCdhY3RpdmUnKTtcclxuICAgIHRoaXMuY29udGV4dE1lbnUucmVzZXQodGhpcy5wYW5lbCk7XHJcbiAgICB0aGlzLmxpc3QgPSBuZXcgTGlzdFZpZXcoe2l0ZW1zOiBzZWxmLmNvbGxlY3Rpb259KS5yZW5kZXIoKTtcclxuICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLmxpc3QuZWwpO1xyXG4gIH0sXHJcbiAgZWRpdFN1YmplY3Q6IGZ1bmN0aW9uKG1vZGVsKSB7XHJcbiAgICB2YXIgc2VsZiA9IHRoaXMsXHJcbiAgICAgICAgc2lkZWJhciA9IHRoaXMuJGVsLmZpbmQoJy5zaWRlYmFyJyk7XHJcbiAgICBzaWRlYmFyLmVtcHR5KCk7XHJcbiAgICB0aGlzLmZvcm0gPSBuZXcgQmFja2JvbmUuRm9ybSh7XHJcbiAgICAgIG1vZGVsOiBtb2RlbFxyXG4gICAgfSkucmVuZGVyKCk7XHJcbiAgICB0aGlzLmZvcm0ub24oJ2NoYW5nZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLmNvbW1pdCgpO1xyXG4gICAgfSk7XHJcbiAgICB0aGlzLmZvcm0ub24oJ3BhcmVudDplZGl0JywgZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICBzZWxmLmxpc3QudHJpZ2dlcigncGFyZW50OmNob29zZScsIGl0ZW0ubW9kZWwpO1xyXG4gICAgfSlcclxuICAgIHRoaXMuZm9ybS5vbigncGFyZW50Om1lcmdlJywgZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICBzZWxmLmxpc3QudHJpZ2dlcigncGFyZW50Om1lcmdlJywgaXRlbS5tb2RlbCk7XHJcbiAgICB9KVxyXG4gICAgdGhpcy5mb3JtLm9uKCdwYXJlbnQ6YWRkJywgZnVuY3Rpb24oaXRlbSkge1xyXG4gICAgICBzZWxmLl9hZGQoaXRlbS5tb2RlbC5pZCk7XHJcbiAgICB9KVxyXG4gICAgdGhpcy5jb2xsZWN0aW9uLm9uY2UoJ2xpc3Q6aXRlbXBhcmVudCcsIGZ1bmN0aW9uKGl0ZW0pe1xyXG4gICAgICB0aGlzLmZvcm0udHJpZ2dlcihcInBhcmVudDpjaG9vc2VkXCIsIGl0ZW0pO1xyXG4gICAgfSwgdGhpcyk7XHJcbiAgICBzaWRlYmFyLmh0bWwodGhpcy5mb3JtLmVsKTtcclxuICAgIHRoaXMuZm9ybS4kZWwuZmluZCgnaW5wdXQnKVswXS5mb2N1cygpO1xyXG4gICAgLy90aGlzLmluc2VydFZpZXcoJy5zaWRlYmFyJywgdGhpcy5mb3JtKS5yZW5kZXIoKTtcclxuICAgIC8vdGhpcy4kZWwuaHRtbCh0aGlzLmZvcm0uZWwpO1xyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgICAvL2NvbnNvbGUubG9nKGUpXHJcbiAgICAvLyB2YXIgc3ViamVjdElkID0gZS50YXJnZXQucGFyZW50RWxlbWVudC5kYXRhc2V0LmlkLFxyXG4gICAgLy8gICAgIHRlcm1Gb3JtID0gbmV3IFRlcm1FZGl0KHttb2RlbDogdGhpcy50ZXJtcy5nZXQodGVybUlkKX0pO1xyXG5cclxuICAgIC8vIHZhciBtb2RhbCA9IG5ldyBCYWNrYm9uZS5Cb290c3RyYXBNb2RhbCh7IGNvbnRlbnQ6IHRlcm1Gb3JtLCBhbmltYXRlOiB0cnVlIH0pLm9wZW4oKTtcclxuICB9LFxyXG4gIF9ydW5JbXBvcnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGRhdGEgPSAkKCcuaW1wb3J0LWRhdGEnKS52YWwoKSxcclxuICAgICAgICBsaW5lcyA9IGRhdGEuc3BsaXQoJ1xcbicpLFxyXG4gICAgICAgIG1hcCA9IFtdO1xyXG5cclxuICAgIF8uZWFjaChsaW5lcywgZnVuY3Rpb24obGluZSwgaSkge1xyXG4gICAgICB2YXIgaW5kZW50YXRpb24gPSAwO1xyXG4gICAgICB3aGlsZSAobGluZVtpbmRlbnRhdGlvbl0gPT0gJ1xcdCcpIHtcclxuICAgICAgICAgIGluZGVudGF0aW9uKys7XHJcbiAgICAgIH1cclxuICAgICAgaWYoIW1hcFtpbmRlbnRhdGlvbl0pIG1hcFtpbmRlbnRhdGlvbl0gPSBbXTtcclxuICAgICAgdmFyIG5hbWUgPSBsaW5lLnNwbGl0KCdcXHQnKS5qb2luKCcnKSxcclxuICAgICAgICAgIGlkID0gbmV3IE9iamVjdElkKCkudG9TdHJpbmcoKSxcclxuICAgICAgICAgIHBhcmVudCA9IGluZGVudGF0aW9uID4gMCA/IG1hcFtpbmRlbnRhdGlvbiAtIDFdW21hcFtpbmRlbnRhdGlvbiAtIDFdLmxlbmd0aCAtIDFdIDogJyc7XHJcblxyXG4gICAgICBtYXBbaW5kZW50YXRpb25dLnB1c2goaWQpO1xyXG5cclxuICAgICAgc2VsZi5jb2xsZWN0aW9uLmFkZCh7IF9pZDogaWQsIG5hbWU6IG5hbWUsIHBhcmVudDogcGFyZW50IH0pO1xyXG4gICAgfSk7XHJcbiAgICBzZWxmLiRlbC5maW5kKCcuc2lkZWJhcicpLmVtcHR5KCk7XHJcbiAgfSxcclxuICBfY2FuY2VsSW1wb3J0OiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuJGVsLmZpbmQoJy5zaWRlYmFyJykuZW1wdHkoKTtcclxuICB9LFxyXG4gIF9zYXZlOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMuY29sbGVjdGlvbi5zYXZlQ2hhbmdlZCgpO1xyXG4gIH0sXHJcbiAgX2FkZDogZnVuY3Rpb24ocGFyZW50SWQpIHtcclxuICAgIHZhciBpZCA9IG5ldyBPYmplY3RJZCgpLnRvU3RyaW5nKCksXHJcbiAgICAgICAgcGFyZW50ID0gcGFyZW50SWQgPyBwYXJlbnRJZCA6ICcnO1xyXG4gICAgdGhpcy5jb2xsZWN0aW9uLmFkZCh7IF9pZDogaWQsIG5hbWU6IFwiVW50aXRsZWRcIiwgcGFyZW50OiBwYXJlbnQgfSk7XHJcbiAgfSxcclxuICBfaW1wb3J0OiBmdW5jdGlvbigpIHtcclxuICAgICQoJ2Rpdi5saXN0IGxpLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcclxuICAgIHZhciBzaWRlYmFyID0gdGhpcy4kZWwuZmluZCgnLnNpZGViYXInKTtcclxuICAgIHNpZGViYXIuZW1wdHkoKTtcclxuXHJcbiAgICB2YXIgZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICBkaWFsb2cuaW5uZXJIVE1MID0gJzx0ZXh0YXJlYSBjbGFzcz1cImltcG9ydC1kYXRhXCIgc3R5bGU9XCJ3aWR0aDogMTAwJTtcIj48L3RleHRhcmVhPjxidXR0b24gY2xhc3M9XCJpbXBvcnQgYnRuXCI+SW1wb3J0PC9idXR0b24+PGJ1dHRvbiBjbGFzcz1cImNhbmNlbCBidG5cIj5DYW5jZWw8L2J1dHRvbj4nO1xyXG4gICAgc2lkZWJhci5hcHBlbmQoZGlhbG9nKTtcclxuICB9LFxyXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcclxuICAgICQoJyMnICsgdGhpcy5pY29uKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XHJcbiAgICB0aGlzLnJlbW92ZSgpO1xyXG4gICAgdGhpcy51bmJpbmQoKTtcclxuICB9LFxyXG4gIHBhbmVsOiBbXHJcbiAgICB7XHJcbiAgICAgIG5hbWU6IFwic2F2ZVwiLFxyXG4gICAgICBpY29uOiBcInNhdmVcIixcclxuICAgICAgZm46IFwiX3NhdmVcIlxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbmFtZTogXCJBZGQgbmV3IHN1YmplY3RcIixcclxuICAgICAgaWNvbjogXCJwbHVzXCIsXHJcbiAgICAgIGZuOiBcIl9hZGRcIlxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgbmFtZTogXCJpbXBvcnRcIixcclxuICAgICAgaWNvbjogXCJmaWxlLXRleHQtb1wiLFxyXG4gICAgICBmbjogXCJfaW1wb3J0XCJcclxuICAgIH1cclxuICBdXHJcbn0pXHJcbmV4cG9ydHMuc3ViamVjdHNWaWV3ID0gU3ViamVjdHNWaWV3XHJcblxyXG52YXIgU3ViamVjdHNUcmVlVmlldyA9IEJhY2tib25lLkxheW91dC5leHRlbmQoe1xyXG4gIGljb246ICdzdWJqZWN0cycsXHJcbiAgY2xhc3NOYW1lOiAnc3ViamVjdHMnLFxyXG4gIHRlbXBsYXRlOiAnI3N1YmplY3RzVHJlZUxheW91dCcsXHJcblxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG4gICAgJC5qc3RyZWUuY3VycmVudFN0YXRlID0ge1xyXG4gICAgICBub2RlVG9NZXJnZTogbnVsbFxyXG4gICAgfTtcclxuICB9LFxyXG4gIGJlZm9yZVJlbmRlcjogZnVuY3Rpb24oKSB7XHJcblxyXG4gIH0sXHJcbiAgYWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgJCgnIycgKyB0aGlzLmljb24pLmFkZENsYXNzKCdhY3RpdmUnKTtcclxuICAgIHRoaXMuY29udGV4dE1lbnUucmVzZXQodGhpcy5wYW5lbCk7XHJcbiAgICAkKCcudHJlZScpXHJcbiAgICAgIC5vbihcIm1vdmVfbm9kZS5qc3RyZWVcIiwgZnVuY3Rpb24oZSwgZGF0YSkge1xyXG4gICAgICAgIHNlbGYuX29uTW92ZU5vZGUoZSwgZGF0YSwgc2VsZik7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5vbihcInJlbmFtZV9ub2RlLmpzdHJlZVwiLCBmdW5jdGlvbihlLCBkYXRhKSB7XHJcbiAgICAgICAgc2VsZi5fb25SZW5hbWVOb2RlKGUsIGRhdGEsIHNlbGYpO1xyXG4gICAgICB9KVxyXG4gICAgICAuanN0cmVlKHtcclxuICAgICAgICBcImNvcmVcIiA6IHtcclxuICAgICAgICAgIFwiYW5pbWF0aW9uXCIgOiAwLFxyXG4gICAgICAgICAgXCJjaGVja19jYWxsYmFja1wiIDogdHJ1ZSxcclxuICAgICAgICAgIFwidGhlbWVzXCIgOiB7IFwic3RyaXBlc1wiIDogdHJ1ZSB9LFxyXG4gICAgICAgICAgXCJkYXRhXCI6IHNlbGYuY29sbGVjdGlvbi5idWlsZFN1YmplY3RzVHJlZSgpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBcImNvbnRleHRtZW51XCI6IHtcclxuICAgICAgICAgIFwiaXRlbXNcIjogZnVuY3Rpb24obywgY2IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlbGYuaXRlbXNGdW5jKG8sIGNiLCBzZWxmKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwidHlwZXNcIjoge1xyXG4gICAgICAgICAgXCJkZWZhdWx0XCI6IHtcImljb25cIjogXCJnbHlwaGljb24gaGlkZGVuLWljb25cIn1cclxuICAgICAgICB9LFxyXG4gICAgICAgIFwicGx1Z2luc1wiIDogWyBcImNvbnRleHRtZW51XCIsIFwiZG5kXCIsIFwic2VhcmNoXCIsIFwic3RhdGVcIiwgXCJ0eXBlc1wiLCBcIndob2xlcm93XCIsIFwic29ydFwiXVxyXG4gICAgICB9KTtcclxuICB9LFxyXG4gIGl0ZW1zRnVuYzogZnVuY3Rpb24obywgY2IsIGNvbnRleHQpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuXHJcbiAgICBvLm1vZGVsID0gY29udGV4dC5jb2xsZWN0aW9uLmdldChvLmlkKTtcclxuICAgIG8uY29sbGVjdGlvbiA9IGNvbnRleHQuY29sbGVjdGlvbjtcclxuXHJcbiAgICB2YXIgcmVzID0gJC5qc3RyZWUuZGVmYXVsdHMuY29udGV4dG1lbnUuaXRlbXMobywgY2IpO1xyXG5cclxuICAgIC8vIEVkaXQgbm9kZVxyXG4gICAgLy8gLS0tLS0tLS0tLS1cclxuXHJcbiAgICByZXMuZWRpdCA9IHtcclxuICAgICAgXCJzZXBhcmF0b3JfYmVmb3JlXCIgIDogZmFsc2UsXHJcbiAgICAgIFwic2VwYXJhdG9yX2FmdGVyXCIgOiB0cnVlLFxyXG4gICAgICBcIl9kaXNhYmxlZFwiICAgICA6IGZhbHNlLFxyXG4gICAgICBcImxhYmVsXCIgICAgICAgOiBcIkRlc2NyaXB0aW9uXCIsXHJcbiAgICAgIFwiYWN0aW9uXCIgICAgICA6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxyXG4gICAgICAgICAgICBvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKSxcclxuICAgICAgICAgICAgc3ViamVjdCA9IG9iai5tb2RlbDtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ2VkaXRpbmcgc3ViamVjdC4uLicpO1xyXG5cclxuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XHJcbiAgICAgICAgaW5wdXQuaWQgPSBcImRlc2NyaXB0aW9uXCI7XHJcbiAgICAgICAgaW5wdXQucGxhY2Vob2xkZXIgPSBcIkRlc2NyaWJlIHN1YmplY3QgaGVyZS4uLlwiO1xyXG4gICAgICAgIGlucHV0LmlubmVySFRNTCA9IHN1YmplY3QuZ2V0KCdkZXNjcmlwdGlvbicpO1xyXG5cclxuICAgICAgICB2YXIgY29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcclxuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cclxuICAgICAgICB2YXIgbW9kYWwgPSBuZXcgQmFja2JvbmUuQm9vdHN0cmFwTW9kYWwoeyBjb250ZW50OiBjb250YWluZXIuaW5uZXJIVE1MLCBhbmltYXRlOiB0cnVlIH0pLm9wZW4oZnVuY3Rpb24oKXtcclxuICAgICAgICAgIHZhciBkZXNjcmlwdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVzY3JpcHRpb25cIikudmFsdWU7XHJcblxyXG4gICAgICAgICAgc3ViamVjdC5zYXZlKCdkZXNjcmlwdGlvbicsIGRlc2NyaXB0aW9uLCB7XHJcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKG1vZGVsLCByZXNwKSB7IFxyXG4gICAgICAgICAgICAgIE5vdGlmeS5zcGlubmVyKCdoaWRlJyk7XHJcbiAgICAgICAgICAgICAgdmFyIG5vdGljZSA9IE5vdGlmeS5pbmZvKCdTdWJqZWN0ICcgKyBzdWJqZWN0LmdldCgnbmFtZScpICsgJyBoYXMgYmVlbiB1cGRhdGVkJyk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgZXJyKSB7IFxyXG4gICAgICAgICAgICAgIE5vdGlmeS5zcGlubmVyKCdoaWRlJyk7XHJcbiAgICAgICAgICAgICAgdmFyIG5vdGljZSA9IE5vdGlmeS5pbmZvKCdTb3JyeSwgdGhlIGVycm9yIG9jY3VyZWQhIFBsZWFzZSByZWxvYWQgdGhlIHBhZ2UgYW5kIHRyeSBhZ2Fpbi4nKTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBDcmVhdGUgYSBuZXcgbm9kZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIHJlcy5jcmVhdGUgPSB7XHJcbiAgICAgIFwic2VwYXJhdG9yX2JlZm9yZVwiICA6IGZhbHNlLFxyXG4gICAgICBcInNlcGFyYXRvcl9hZnRlclwiIDogdHJ1ZSxcclxuICAgICAgXCJfZGlzYWJsZWRcIiAgICAgOiBmYWxzZSxcclxuICAgICAgXCJsYWJlbFwiICAgICAgIDogXCJDcmVhdGVcIixcclxuICAgICAgXCJhY3Rpb25cIiAgICAgIDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXHJcbiAgICAgICAgICBvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coJ2NyZWF0aW5nIGEgbmV3IHN1YmplY3QuLi4nKTtcclxuXHJcbiAgICAgICAgdmFyIGlkID0gbmV3IE9iamVjdElkKCkudG9TdHJpbmcoKTtcclxuXHJcbiAgICAgICAgaW5zdC5jcmVhdGVfbm9kZShvYmosIHtpZDogaWR9LCBcImxhc3RcIiwgZnVuY3Rpb24gKG5ld19ub2RlKSB7XHJcbiAgICAgICAgICAvL3NldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBpbnN0LmVkaXQobmV3X25vZGUpOyB9LDApO1xyXG4gICAgICAgICAgby5jb2xsZWN0aW9uLmNyZWF0ZSh7IF9pZDogbmV3X25vZGUuaWQsIG5hbWU6IG5ld19ub2RlLnRleHQsIHBhcmVudDogbmV3X25vZGUucGFyZW50IH0sIHtcclxuICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24obW9kZWwscmVzcCkge1xyXG4gICAgICAgICAgICAgIE5vdGlmeS5zcGlubmVyKCdoaWRlJyk7XHJcbiAgICAgICAgICAgICAgTm90aWZ5LmluZm8oJ1N1YmplY3QgJyArIG9iai5tb2RlbC5nZXQoJ25hbWUnKSArICcgaGFzIGJlZW4gY3JlYXRlZCEnKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1vZGVsLGVycikgeyBcclxuICAgICAgICAgICAgICBOb3RpZnkuc3Bpbm5lcignaGlkZScpO1xyXG4gICAgICAgICAgICAgIE5vdGlmeS5pbmZvKCdTb3JyeSwgdGhlIGVycm9yIG9jY3VyZWQhIFBsZWFzZSByZWxvYWQgdGhlIHBhZ2UgYW5kIHRyeSBhZ2Fpbi4nKTtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBObyBjdXQgYW5kIHBhc3RlIGZvciB0aGUgbW9tZW50XHJcbiAgICBkZWxldGUgcmVzLmNjcC5zdWJtZW51LmNvcHk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIGEgbm9kZVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuICAgIHJlcy5yZW1vdmUgPSB7XHJcbiAgICAgIFwic2VwYXJhdG9yX2JlZm9yZVwiICA6IGZhbHNlLFxyXG4gICAgICBcImljb25cIiAgICAgICAgOiBmYWxzZSxcclxuICAgICAgXCJzZXBhcmF0b3JfYWZ0ZXJcIiA6IGZhbHNlLFxyXG4gICAgICBcIl9kaXNhYmxlZFwiICAgOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHZhciBpbnN0ID0gJC5qc3RyZWUucmVmZXJlbmNlKGRhdGEucmVmZXJlbmNlKSxcclxuICAgICAgICAgICAgb2JqID0gaW5zdC5nZXRfbm9kZShkYXRhLnJlZmVyZW5jZSk7XHJcbiAgICAgICAgICAgIGhhc0NoaWxkcmVuID0gb2JqLmNoaWxkcmVuLmxlbmd0aCA+IDA7XHJcbiAgICAgICAgcmV0dXJuIGhhc0NoaWxkcmVuOyAvLyBPbmx5IGxlYWYgbm9kZXMgY2FuIGJlIGRlbGV0ZWRcclxuICAgICAgfSxcclxuICAgICAgXCJsYWJlbFwiICAgICAgIDogXCJEZWxldGVcIixcclxuICAgICAgXCJhY3Rpb25cIiAgICAgIDogZnVuY3Rpb24gKGRhdGEsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXHJcbiAgICAgICAgICBvYmogPSBpbnN0LmdldF9ub2RlKGRhdGEucmVmZXJlbmNlKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZygnZGVsZXRpbmcuLi4nLCBvYmouaWQpO1xyXG5cclxuICAgICAgICBvYmoubW9kZWwuZGVzdHJveSh7XHJcbiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihtb2RlbCxyZXNwKSB7XHJcbiAgICAgICAgICAgIE5vdGlmeS5zcGlubmVyKCdoaWRlJyk7XHJcbiAgICAgICAgICAgIE5vdGlmeS5pbmZvKCdTdWJqZWN0ICcgKyBvYmoubW9kZWwuZ2V0KCduYW1lJykgKyAnIGhhcyBiZWVuIHJlbW92ZWQhJyk7XHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1vZGVsLGVycikgeyBcclxuICAgICAgICAgICAgTm90aWZ5LnNwaW5uZXIoJ2hpZGUnKTtcclxuICAgICAgICAgICAgTm90aWZ5LmluZm8oJ1NvcnJ5LCB0aGUgZXJyb3Igb2NjdXJlZCEgUGxlYXNlIHJlbG9hZCB0aGUgcGFnZSBhbmQgdHJ5IGFnYWluLicpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgLy8gVE9ETyBEQU5JRUw6XHJcbiAgICAgICAgLy8gQ2FsbCBzZXJ2ZXIgZnVuY3Rpb24gZGVsZXRlU3ViamVjdFxyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAgIGlmKGluc3QuaXNfc2VsZWN0ZWQob2JqKSkge1xyXG4gICAgICAgICAgaW5zdC5kZWxldGVfbm9kZShpbnN0LmdldF9zZWxlY3RlZCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICBpbnN0LmRlbGV0ZV9ub2RlKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFN0YXJ0IGEgbWVyZ2VcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICByZXMubWVyZ2UgPSB7XHJcbiAgICAgIFwic2VwYXJhdG9yX2JlZm9yZVwiICA6IHRydWUsXHJcbiAgICAgIFwiX2Rpc2FibGVkXCIgICAgIDogZmFsc2UsXHJcbiAgICAgIFwibGFiZWxcIiAgICAgICA6IFwiTWVyZ2VcIixcclxuICAgICAgXCJfZGlzYWJsZWRcIiAgIDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXHJcbiAgICAgICAgICAgIG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xyXG4gICAgICAgICAgICBoYXNDaGlsZHJlbiA9IG9iai5jaGlsZHJlbi5sZW5ndGggPiAwO1xyXG4gICAgICAgIHJldHVybiBoYXNDaGlsZHJlbjsgLy8gT25seSBsZWFmIG5vZGVzIGNhbiBiZSBtZXJnZWRcclxuICAgICAgfSxcclxuICAgICAgXCJhY3Rpb25cIiAgICAgIDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICB2YXIgaW5zdCA9ICQuanN0cmVlLnJlZmVyZW5jZShkYXRhLnJlZmVyZW5jZSksXHJcbiAgICAgICAgICAgIG9iaiA9IGluc3QuZ2V0X25vZGUoZGF0YS5yZWZlcmVuY2UpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZygnb2JqIG5vZGUgdG8gbWVyZ2UnLCBkYXRhLnJlZmVyZW5jZSk7XHJcbiAgICAgICAgJC5qc3RyZWUuY3VycmVudFN0YXRlLm5vZGVUb01lcmdlID0gb2JqLmlkO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIENvbXBsZXRlIGEgbWVyZ2VcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICByZXMubWVyZ2VJbnRvID0ge1xyXG4gICAgICBcInNlcGFyYXRvcl9iZWZvcmVcIiAgOiBmYWxzZSxcclxuICAgICAgXCJzZXBhcmF0b3JfYWZ0ZXJcIiA6IHRydWUsXHJcbiAgICAgIFwiX2Rpc2FibGVkXCIgICAgIDogZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gISQuanN0cmVlLmN1cnJlbnRTdGF0ZS5ub2RlVG9NZXJnZTtcclxuICAgICAgfSxcclxuICAgICAgXCJsYWJlbFwiICAgICAgIDogXCJNZXJnZSBpbnRvXCIsXHJcbiAgICAgIFwiYWN0aW9uXCIgICAgICA6IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgdmFyIGluc3QgPSAkLmpzdHJlZS5yZWZlcmVuY2UoZGF0YS5yZWZlcmVuY2UpLFxyXG4gICAgICAgICAgICB0YXJnZXROb2RlID0gaW5zdC5nZXRfbm9kZShkYXRhLnJlZmVyZW5jZSksXHJcbiAgICAgICAgICAgIG5vZGVUb01lcmdlID0gaW5zdC5nZXRfbm9kZSgkLmpzdHJlZS5jdXJyZW50U3RhdGUubm9kZVRvTWVyZ2UpO1xyXG5cclxuICAgICAgICBpZiAoIW5vZGVUb01lcmdlKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnc2VlbXMgbGlrZSBzdGF0ZS5ub2RlVG9NZXJnZSBpcyBubyBsb25nZXIgaW4gdGhlIHRyZWUuIERvaW5nIG5vdGhpbmcuLi4nKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChub2RlVG9NZXJnZSA9PT0gdGFyZ2V0Tm9kZSkge1xyXG4gICAgICAgICAgTm90aWZ5LnNwaW5uZXIoJ2hpZGUnKTtcclxuICAgICAgICAgIHZhciBub3RpY2UgPSBOb3RpZnkuaW5mbygnQ2FuIG5vdCBtZXJnZSB3aXRoIGl0c2VsZiEnKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coJ2NvbXBsZXRpbmcgbWVyZ2Ugb2YgJywgbm9kZVRvTWVyZ2UuaWQsICdpbnRvICcsIHRhcmdldE5vZGUuaWQpO1xyXG5cclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgLy8gVE9ETyBEQU5JRUw6XHJcbiAgICAgICAgLy8gQ2FsbCBzZXJ2ZXIgZnVuY3Rpb24gbWVyZ2VTdWJqZWN0c1xyXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbiAgICAgICAgcmVxdWVzdFxyXG4gICAgICAgICAgLmdldCgnL2FwaS9zdWJqZWN0cy9tZXJnZScpXHJcbiAgICAgICAgICAucXVlcnkoeyBvbmU6IG5vZGVUb01lcmdlLmlkLCBpbnRvOiB0YXJnZXROb2RlLmlkIH0pXHJcbiAgICAgICAgICAuZW5kKGZ1bmN0aW9uKHJlcyl7XHJcbiAgICAgICAgICAgIGlmKHJlcy5vaykge1xyXG4gICAgICAgICAgICAgIE5vdGlmeS5zcGlubmVyKCdoaWRlJyk7XHJcbiAgICAgICAgICAgICAgTm90aWZ5LmluZm8oJ01lcmdlIGhhcyBiZWVuIGNvbXBsZXRlZCEnKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBOb3RpZnkuc3Bpbm5lcignaGlkZScpO1xyXG4gICAgICAgICAgICAgIHZhciBub3RpY2UgPSBOb3RpZnkuaW5mbygnU29ycnksIHRoZSBlcnJvciBvY2N1cmVkISBQbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpbnN0LmRlbGV0ZV9ub2RlKG5vZGVUb01lcmdlKTtcclxuICAgICAgICAkLmpzdHJlZS5jdXJyZW50U3RhdGUubm9kZVRvTWVyZ2UgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiByZXM7XHJcbiAgfSxcclxuICBjbG9zZTogZnVuY3Rpb24oKSB7XHJcbiAgICAkKCcjJyArIHRoaXMuaWNvbikucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xyXG4gICAgdGhpcy5yZW1vdmUoKTtcclxuICAgIHRoaXMudW5iaW5kKCk7XHJcbiAgfSxcclxuICBfb25Nb3ZlTm9kZTogZnVuY3Rpb24oZSwgZGF0YSwgY29udGV4dCkge1xyXG4gICAgY29uc29sZS5sb2coJ25vZGUgbW92ZWQgeWF5JywgZSwgZGF0YSk7XHJcbiAgICAgIFxyXG4gICAgdmFyIG1vdmVkTm9kZSA9IGRhdGEubm9kZTtcclxuICAgIHZhciBuZXdQYXJlbnQgPSBkYXRhLnBhcmVudDtcclxuICAgIHZhciBvbGRQYXJlbnQgPSBkYXRhLm9sZF9wYXJlbnQ7XHJcblxyXG4gICAgY29uc29sZS5sb2coJ2NoYW5naW5nIHBhcmVudCBmcm9tIG5vZGUnLCBtb3ZlZE5vZGUuaWQsICdmcm9tJywgb2xkUGFyZW50LCAndG8nLCBuZXdQYXJlbnQpO1xyXG5cclxuICAgIC8vIFVzZSBiYWNrYm9uZSBzdHVmZiB0byByZXRyaWV2ZSB0aGUgbW9kZWwgd2l0aCB0aGF0IGlkXHJcbiAgICB2YXIgc3ViamVjdCA9IGNvbnRleHQuY29sbGVjdGlvbi5nZXQobW92ZWROb2RlLmlkKTtcclxuXHJcbiAgICBpZihuZXdQYXJlbnQgPT0gJyMnKSBuZXdQYXJlbnQgPSAnJztcclxuXHJcbiAgICBzdWJqZWN0LnNhdmUoJ3BhcmVudCcsIG5ld1BhcmVudCwge1xyXG4gICAgICBzdWNjZXNzOiBmdW5jdGlvbihtb2RlbCwgcmVzcCkgeyBcclxuICAgICAgICBOb3RpZnkuc3Bpbm5lcignaGlkZScpO1xyXG4gICAgICAgIHZhciBub3RpY2UgPSBOb3RpZnkuaW5mbygnU3ViamVjdCAnICsgc3ViamVjdC5nZXQoJ25hbWUnKSArICcgaGFzIGJlZW4gY2hhbmdlZCcpO1xyXG4gICAgICB9LFxyXG4gICAgICBlcnJvcjogZnVuY3Rpb24obW9kZWwsIGVycikgeyBcclxuICAgICAgICBOb3RpZnkuc3Bpbm5lcignaGlkZScpO1xyXG4gICAgICAgIHZhciBub3RpY2UgPSBOb3RpZnkuaW5mbygnU29ycnksIHRoZSBlcnJvciBvY2N1cmVkISBQbGVhc2UgcmVsb2FkIHRoZSBwYWdlIGFuZCB0cnkgYWdhaW4uJyk7XHJcbiAgICAgICAgY29uc29sZS5sb2coZXJyKTtcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9LFxyXG4gIF9vblJlbmFtZU5vZGU6IGZ1bmN0aW9uKGUsIGRhdGEsIGNvbnRleHQpIHtcclxuICAgIGNvbnNvbGUubG9nKCdyZW5hbWVkIG5vZGUgbW92ZWQgeWF5JywgZSwgZGF0YSk7XHJcbiAgICAgIFxyXG4gICAgdmFyIHVwZGF0ZWROb2RlID0gZGF0YS5ub2RlO1xyXG4gICAgdmFyIG5ld05hbWUgPSBkYXRhLnRleHQ7XHJcbiAgICB2YXIgb2xkTmFtZSA9IGRhdGEub2xkO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKCdjaGFuZ2luZyBuYW1lIG9mIG5vZGUnLCB1cGRhdGVkTm9kZS5pZCwgJ2Zyb20nLCBvbGROYW1lLCAndG8nLCBuZXdOYW1lKTtcclxuXHJcbiAgICAvLyBVc2UgYmFja2JvbmUgc3R1ZmYgdG8gcmV0cmlldmUgdGhlIG1vZGVsIHdpdGggdGhhdCBpZFxyXG4gICAgdmFyIHN1YmplY3QgPSBjb250ZXh0LmNvbGxlY3Rpb24uZ2V0KHVwZGF0ZWROb2RlLmlkKTtcclxuXHJcbiAgICBzdWJqZWN0LnNhdmUoJ25hbWUnLCBuZXdOYW1lLCB7XHJcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKG1vZGVsLCByZXNwKSB7IFxyXG4gICAgICAgIE5vdGlmeS5zcGlubmVyKCdoaWRlJyk7XHJcbiAgICAgICAgdmFyIG5vdGljZSA9IE5vdGlmeS5pbmZvKCdTdWJqZWN0ICcgKyBzdWJqZWN0LmdldCgnbmFtZScpICsgJyBoYXMgYmVlbiBjaGFuZ2VkJyk7XHJcbiAgICAgIH0sXHJcbiAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgZXJyKSB7IFxyXG4gICAgICAgIE5vdGlmeS5zcGlubmVyKCdoaWRlJyk7XHJcbiAgICAgICAgdmFyIG5vdGljZSA9IE5vdGlmeS5pbmZvKCdTb3JyeSwgdGhlIGVycm9yIG9jY3VyZWQhIFBsZWFzZSByZWxvYWQgdGhlIHBhZ2UgYW5kIHRyeSBhZ2Fpbi4nKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH0sXHJcbiAgcGFuZWw6IFtcclxuICAgIHtcclxuICAgICAgbmFtZTogXCJzYXZlXCIsXHJcbiAgICAgIGljb246IFwic2F2ZVwiLFxyXG4gICAgICBmbjogXCJfc2F2ZVwiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiBcIkFkZCBuZXcgc3ViamVjdFwiLFxyXG4gICAgICBpY29uOiBcInBsdXNcIixcclxuICAgICAgZm46IFwiX2FkZFwiXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBuYW1lOiBcImltcG9ydFwiLFxyXG4gICAgICBpY29uOiBcImZpbGUtdGV4dC1vXCIsXHJcbiAgICAgIGZuOiBcIl9pbXBvcnRcIlxyXG4gICAgfVxyXG4gIF1cclxufSlcclxuZXhwb3J0cy5zdWJqZWN0c1RyZWVWaWV3ID0gU3ViamVjdHNUcmVlVmlld1xyXG5cclxudmFyIFN1YmplY3RzRWRpdCA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcclxuICBjbGFzc05hbWU6IFwic3ViamVjdC1lZGl0XCIsXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5iaW5kKFwib2tcIiwgdGhpcy5fc2F2ZSk7XHJcbiAgICB0aGlzLmJpbmQoXCJjYW5jZWxcIiwgdGhpcy5jbG9zZSk7XHJcbiAgfSxcclxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgdGhpcy5mb3JtID0gbmV3IEJhY2tib25lLkZvcm0oe1xyXG4gICAgICBtb2RlbDogdGhpcy5tb2RlbFxyXG4gICAgfSkucmVuZGVyKCk7XHJcbiAgICB0aGlzLiRlbC5odG1sKHRoaXMuZm9ybS5lbCk7XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9LFxyXG4gIF9zYXZlOiBmdW5jdGlvbihtb2RhbCkge1xyXG4gICAgbW9kYWwucHJldmVudENsb3NlKCk7XHJcblxyXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxyXG4gICAgICAgIGVycm9ycyA9IHNlbGYuZm9ybS5jb21taXQoKTtcclxuXHJcbiAgICBpZighZXJyb3JzKSB7XHJcbiAgICAgIE5vdGlmeS5zcGlubmVyKCdzaG93Jyk7XHJcbiAgICAgIHNlbGYubW9kZWwuc2F2ZSh7fSwge1xyXG4gICAgICAgIHdhaXQ6IHRydWUsXHJcbiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24obW9kZWwscmVzcCkgeyBcclxuICAgICAgICAgIE5vdGlmeS5zcGlubmVyKCdoaWRlJyk7XHJcbiAgICAgICAgICB2YXIgbm90aWNlID0gTm90aWZ5LmluZm8oJ05ldyBzdWJqZWN0IGhhcyBiZWVuIHNhdmVkJyk7XHJcbiAgICAgICAgICBtb2RhbC5jbG9zZSgpO1xyXG4gICAgICAgICAgc2VsZi5yZW1vdmUoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCxlcnIpIHsgXHJcbiAgICAgICAgICBOb3RpZnkuc3Bpbm5lcignaGlkZScpO1xyXG4gICAgICAgICAgdmFyIG5vdGljZSA9IE5vdGlmeS5pbmZvKCdTb3JyeSwgdGhlIGVycm9yIG9jY3VyZWQhJyk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfSxcclxuICBjbG9zZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLnJlbW92ZSgpO1xyXG4gICAgdGhpcy51bmJpbmQoKTtcclxuICB9XHJcbn0pXHJcbmV4cG9ydHMuc3ViamVjdHNFZGl0ID0gU3ViamVjdHNFZGl0XHJcblxyXG5cclxuLy9NRU5VXHJcblxyXG52YXIgTWFpbk1lbnUgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgbWFuYWdlOiB0cnVlLFxyXG4gIGV2ZW50czoge1xyXG4gICAgJ2NsaWNrIGxpOm5vdCguYWN0aXZlKSc6ICdnb1RvSW50ZXJuYWwnXHJcbiAgfSxcclxuICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcclxuICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgIHNlbGYucmVuZGVyKCk7XHJcbiAgfSxcclxuICB0ZW1wbGF0ZTogJyNtYWlubWVudScsXHJcbiAgZ29Ub0ludGVybmFsOiBmdW5jdGlvbihlKSB7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KClcclxuICAgIEJhY2tib25lLm1pZGRsZS50cmlnZ2VyKFwiZ29Ub1wiLCBlLmN1cnJlbnRUYXJnZXQuZGF0YXNldC51cmwpXHJcbiAgfSxcclxuICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHsgaXRlbXM6IHRoaXMuY29sbGVjdGlvbiB9O1xyXG4gIH1cclxufSk7XHJcbmV4cG9ydHMubWFpbk1lbnUgPSBNYWluTWVudVxyXG5cclxuLy8gQ09OVEVYVCBNRU5VXHJcblxyXG52YXIgQ29udGV4dE1lbnUgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XHJcbiAgbWFuYWdlOiB0cnVlLFxyXG4gIGNsYXNzTmFtZTogXCJjb250ZXh0LXRvb2xiYXIgYW5pbWF0ZVwiLFxyXG4gIGV2ZW50czoge1xyXG4gICAgJ2NsaWNrIC5idG4nOiAnX3J1bidcclxuICB9LFxyXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xyXG4gICAgc2VsZi5yZW5kZXIoKTtcclxuICAgIHNlbGYuY29sbGVjdGlvbi5vbihcInJlc2V0XCIsIGZ1bmN0aW9uKGNvbCwgcHJldil7XHJcbiAgICAgIHNlbGYucHJldiA9IHByZXYucHJldmlvdXNNb2RlbHM7XHJcbiAgICAgIHNlbGYucmVuZGVyKCk7XHJcbiAgICB9KTtcclxuICAgIHNlbGYuY29sbGVjdGlvbi5vbihcInJlc3RvcmVcIiwgc2VsZi5yZXN0b3JlLCBzZWxmKTtcclxuICB9LFxyXG4gIHRlbXBsYXRlOiAnI2NvbnRleHRtZW51JyxcclxuICBzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xyXG4gICAgcmV0dXJuIHsgaXRlbXM6IHRoaXMuY29sbGVjdGlvbiB9O1xyXG4gIH0sXHJcbiAgcmVzdG9yZTogZnVuY3Rpb24oKSB7XHJcbiAgICB0aGlzLmNvbGxlY3Rpb24ucmVzZXQodGhpcy5wcmV2KTtcclxuICB9LFxyXG4gIF9ydW46IGZ1bmN0aW9uKGUpIHtcclxuICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgIHZhciB2aWV3ID0gdGhpcy5sYXlvdXQuZ2V0Um9vdCgpLFxyXG4gICAgICAgIGZuID0gZS5jdXJyZW50VGFyZ2V0LmRhdGFzZXQuZm47XHJcblxyXG4gICAgdmlld1tmbl0oKTtcclxuICB9LFxyXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcclxuICAgIHRoaXMucmVtb3ZlKCk7XHJcbiAgICB0aGlzLnVuYmluZCgpO1xyXG4gIH1cclxufSk7XHJcbmV4cG9ydHMuY29udGV4dE1lbnUgPSBDb250ZXh0TWVudTtcclxuXHJcbi8vIFVUSUxTXHJcblxyXG52YXIgQ2xpY2thYmxlUm93ID0gQmFja2dyaWQuUm93LmV4dGVuZCh7XHJcbiAgZXZlbnRzOiB7XHJcbiAgICBcImNsaWNrXCI6IFwib25DbGlja1wiXHJcbiAgfSxcclxuICBvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICBpZihlLnRhcmdldC5jbGFzc05hbWUuaW5kZXhPZignc3RyaW5nLWNlbGwnKSAhPSAtMSB8fCBlLnRhcmdldC5jbGFzc05hbWUuaW5kZXhPZignbW9tZW50LWNlbGwnKSAhPSAtMSkge1xyXG4gICAgICB2YXIgdXJsID0gdGhpcy5tb2RlbC51cmxSb290LnNwbGl0KCcvJylcclxuICAgICAgQmFja2JvbmUubWlkZGxlLnRyaWdnZXIoXCJnb1RvXCIsICcvJyArIHVybFsyXSArICcvJyArIHRoaXMubW9kZWwuaWQpXHJcbiAgICB9XHJcbiAgfVxyXG59KTtcclxuZXhwb3J0cy5jbGlja2FibGVSb3cgPSBDbGlja2FibGVSb3dcclxuXHJcbnZhciBEb2N1bWVudFJvdyA9IEJhY2tncmlkLlJvdy5leHRlbmQoe1xyXG4gIGV2ZW50czoge1xyXG4gICAgXCJjbGlja1wiOiBcIm9uQ2xpY2tcIixcclxuICAgIFwiY2xpY2sgLmRlbGV0ZS1kb2N1bWVudFwiOiBcIm9uUmVtb3ZlXCJcclxuICB9LFxyXG4gIG9uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBCYWNrYm9uZS5taWRkbGUudHJpZ2dlcihcImdvVG9FeHRcIiwgJy9hcmNoaXZpc3QuaHRtbCNzdGF0ZT1jb21wb3Nlci5tYWluOzAucGF0aD0nK3RoaXMubW9kZWwuZ2V0KCdpZCcpKyc7MS5jb250ZXh0SWQ9dG9jJyk7XHJcbiAgfSxcclxuICBvblJlbW92ZTogZnVuY3Rpb24oZSkge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIHZhciBjb25maXJtID0gd2luZG93LmNvbmZpcm0oXCJBcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZG8gdGhpcz9cXG5UaGlzIGFjdGlvbiBjYW4ndCBiZSB1bmRvbmUuIFRoaW5rIHR3aWNlIVwiKTtcclxuICAgIGlmKGNvbmZpcm0pIHtcclxuICAgICAgdGhpcy5tb2RlbC5kZXN0cm95KCk7XHJcbiAgICB9XHJcbiAgfVxyXG59KTtcclxuZXhwb3J0cy5kb2N1bWVudFJvdyA9IERvY3VtZW50Um93XHJcblxyXG52YXIgRG9jdW1lbnRDZWxsID0gQmFja2dyaWQuT2JqZWN0Q2VsbCA9IEJhY2tncmlkLkNlbGwuZXh0ZW5kKHtcclxuICBjbGFzc05hbWU6IFwic3RyaW5nLWNlbGwgZG9jdW1lbnQtY2VsbCBhbmltYXRlXCIsXHJcbiAgcmVuZGVyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLiRlbC5lbXB0eSgpO1xyXG4gICAgdmFyIGZvcm1hdHRlZFZhbHVlID0gdGhpcy5mb3JtYXR0ZXIuZnJvbVJhdyh0aGlzLm1vZGVsLmdldCgnbm9kZXMnKSk7XHJcbiAgICBpZihfLmlzTnVsbChmb3JtYXR0ZWRWYWx1ZSkgfHwgXy5pc0VtcHR5KGZvcm1hdHRlZFZhbHVlKSl7XHJcbiAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgdmFyIG1ldGFkYXRhID0gZm9ybWF0dGVkVmFsdWUuZG9jdW1lbnQ7XHJcblxyXG4gICAgICB2YXIgbWFya3VwID0gJzxkaXYgY2xhc3M9XCJ0aXRsZVwiPicgKyBtZXRhZGF0YS50aXRsZSArICc8L2Rpdj4gXFxcclxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImRlbGV0ZS1kb2N1bWVudFwiPkRlbGV0ZTwvc3Bhbj4gXFxcclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwidXBkYXRlZC1hdFwiPnVwZGF0ZWQgYXQgJyArIG1vbWVudChtZXRhZGF0YS51cGRhdGVkX2F0KS5mcm9tTm93KCkgKyAnPC9kaXY+JztcclxuXHJcbiAgICAgIHRoaXMuJGVsLmFwcGVuZChtYXJrdXApXHJcbiAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKVxyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICB9XHJcbn0pO1xyXG5leHBvcnRzLmRvY3VtZW50Q2VsbCA9IERvY3VtZW50Q2VsbFxyXG5cclxudmFyIEZpbHRlciA9IEJhY2tncmlkLkV4dGVuc2lvbi5TZXJ2ZXJTaWRlRmlsdGVyLmV4dGVuZCh7XHJcbiAgY2xhc3NOYW1lOiBcImJhY2tncmlkLWZpbHRlciBmb3JtLXNlYXJjaCBhbmltYXRlXCIsXHJcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgQmFja2dyaWQuRXh0ZW5zaW9uLlNlcnZlclNpZGVGaWx0ZXIuX19zdXBlcl9fLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8IHRoaXMubmFtZTtcclxuICAgICAgdGhpcy5wbGFjZWhvbGRlciA9IG9wdGlvbnMucGxhY2Vob2xkZXIgfHwgdGhpcy5wbGFjZWhvbGRlcjtcclxuICAgICAgdGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGUgfHwgdGhpcy50ZW1wbGF0ZTtcclxuXHJcbiAgICAgIC8vIFBlcnNpc3QgdGhlIHF1ZXJ5IG9uIHBhZ2luYXRpb25cclxuICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmNvbGxlY3Rpb24sIHNlbGYgPSB0aGlzO1xyXG4gICAgICBpZiAoQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uICYmXHJcbiAgICAgICAgICBjb2xsZWN0aW9uIGluc3RhbmNlb2YgQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uICYmXHJcbiAgICAgICAgICBjb2xsZWN0aW9uLm1vZGUgPT0gXCJzZXJ2ZXJcIikge1xyXG4gICAgICAgICAgaWYoXy5pc1VuZGVmaW5lZChjb2xsZWN0aW9uLnF1ZXJ5UGFyYW1zLnF1ZXJ5KSkge1xyXG4gICAgICAgICAgY29sbGVjdGlvbi5xdWVyeVBhcmFtcy5xdWVyeSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICAgIGNvbGxlY3Rpb24ucXVlcnlQYXJhbXMucXVlcnlbdGhpcy5uYW1lXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VsZi5zZWFyY2hCb3goKS52YWwoKTtcclxuICAgICAgICAgICAgaWYoIV8uaXNFbXB0eSh2YWx1ZSkpe1xyXG4gICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7ICRyZWdleDogdmFsdWUsICRvcHRpb25zOiAnaScgfSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICBzZWFyY2g6IGZ1bmN0aW9uIChlKSB7XHJcbiAgICBpZiAoZSkgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgIHZhciBkYXRhID0geyBxdWVyeToge30gfTtcclxuICAgIGRhdGEucXVlcnkgPSBKU09OLnN0cmluZ2lmeSh7ICRyZWdleDogdGhpcy5zZWFyY2hCb3goKS52YWwoKSwgJG9wdGlvbnM6ICdpJyB9KTtcclxuXHJcbiAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXMuY29sbGVjdGlvbjtcclxuICAgIC8vIGdvIGJhY2sgdG8gdGhlIGZpcnN0IHBhZ2Ugb24gc2VhcmNoXHJcbiAgICBpZiAoQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uICYmXHJcbiAgICAgICAgICBjb2xsZWN0aW9uIGluc3RhbmNlb2YgQmFja2JvbmUuUGFnZWFibGVDb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgICBjb2xsZWN0aW9uLmdldEZpcnN0UGFnZSh7ZGF0YTogZGF0YSwgcmVzZXQ6IHRydWUsIGZldGNoOiB0cnVlfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGNvbGxlY3Rpb24uZmV0Y2goe2RhdGE6IGRhdGEsIHJlc2V0OiB0cnVlfSk7XHJcbiAgICB9LFxyXG59KTtcclxuZXhwb3J0cy5maWx0ZXIgPSBGaWx0ZXIiXX0=
